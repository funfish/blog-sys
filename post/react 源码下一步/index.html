<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">react 源码下一步</title><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.587c5e31.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___2dTZ9 "><a class="logo___346dE" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___13XXt" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___29Pln"><h1 class="postTitle___1_m4g">react 源码下一步</h1><span class="postTime___1x0_i">March 24, 2021</span></header><article class="postWrapper___3jnNg post-article"><div><h2>前言</h2>
<p>前文提到了一个简单的 react 例子，结构如下所示</p>
<pre class="hljs"><code>ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>,
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'container'</span>)
);
</code></pre>
<p>只是实在简单呀，缺少 state，缺少状态的变化，于是用另外一个例子来继续研究：</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">hasWorld</span>: <span class="hljs-literal">true</span>,
  }

  changeWorld = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'isChanging：'</span>, <span class="hljs-keyword">this</span>.state.hasWorld)
    <span class="hljs-keyword">this</span>.setState({<span class="hljs-attr">hasWorld</span>: !<span class="hljs-keyword">this</span>.state.hasWorld});
  }

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.changeWorld}</span>&gt;</span>
        {this.state.hasWorld ? 'Hello World!' : 'Hello'}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}
ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Hello</span> /&gt;</span></span>,
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'container'</span>)
);
</code></pre>
<p>本文将围绕这个简单的 class 展开研究。</p>
<h2>Hello 的初始化</h2>
<p>这里先介绍 Hello 组件的初始化过程，包括前面提到的 render/reconcilation 阶段，以及 commit 阶段。</p>
<h3>render/reconcilation 阶段</h3>
<p>这个阶段前面部分和之前博客介绍的很类似，创建 root，创建 current，创建 workInProgress 的 root。只是到了 beginWork 就开始不一样了。这个阶段可以看看下面的图片。</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/workInProgress-component.png" alt=""></p>
<p>可以看到在 Step 11 也就是 updateHostRoot 之前都是一样的，只是在该函数的时候，由于 element 的 type 为函数，不是前一篇博客中的 'h1'，所以会在 reconcileChildFibers 函数阶段创建 tag 为 ClassComponent 的 fiber。可以从上图中看到，其 type 为 element 的 hello 函数。</p>
<p>第二轮 beginWordk 的时候，对象为上面生成的 child，执行的 case 对应的函数如下：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateClassComponent</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
  <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">if</span> (workInProgress.stateNode === <span class="hljs-literal">null</span>) {
      <span class="hljs-comment">// 构建实例</span>
      constructClassInstance(
        workInProgress,
        workInProgress.pendingProps,
        renderExpirationTime,
      );
      mountClassInstance(workInProgress, renderExpirationTime);

      shouldUpdate = <span class="hljs-literal">true</span>;
    }
  }
  <span class="hljs-keyword">return</span> finishClassComponent(
    current,
    workInProgress,
    shouldUpdate,
    hasContext,
    renderExpirationTime,
  );
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">constructClassInstance</span>(<span class="hljs-params">workInProgress, props, renderExpirationTime</span>)</span>{
  <span class="hljs-keyword">const</span> ctor = workInProgress.type;
  <span class="hljs-keyword">const</span> context = emptyObject;
  <span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> ctor(props, context);
  <span class="hljs-keyword">const</span> state = workInProgress.memoizedState = instance.state || <span class="hljs-literal">null</span>;
  instance.updater = classComponentUpdater;
  workInProgress.stateNode = instance;
  instance._reactInternalFiber = workInProgress;
  <span class="hljs-keyword">return</span> instance;
}
</code></pre>
<p>在 constructClassInstance 时候会 new 一个 Hello class，将 child.stateNode 指向该实例。这里有三个特别操作</p>
<ol>
<li>同时给实例的 <code>instance.updater = classComponentUpdater</code>。这个方法在 setState 里面会用到。</li>
<li>给 child.memoizedState 添加上 instance 的 state，也就是 { hasWorld: true }。为以后更新提供前值。</li>
<li>给 instance 添加对应的 fiber</li>
</ol>
<p>这上面的三条都在 setState 里面起到非常关键的作用。updateClassComponent 里面还有 shouldComponentUpdate 的判断，但是这里是首次加载，必然是 true 了。</p>
<p>mountClassInstance 里面则是从 child 里面往 instance 添加 props，ref，context 等属性，同时判断 instance 有无 componentDidMount 函数，有的话 <code>child.effectTag |= Update;</code>。从而在后面阶段可以执行 componentDidMount。</p>
<p>后面的 finishClassComponent，如下</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">finishClassComponent</span>(<span class="hljs-params">current, workInProgress, shouldUpdate, hasContext, renderExpirationTime</span>) </span>{
  <span class="hljs-keyword">const</span> ctor = workInProgress.type;
  <span class="hljs-keyword">const</span> instance = workInProgress.stateNode;
  <span class="hljs-keyword">const</span> nextChildren = instance.render();
  workInProgress.effectTag |= PerformedWork;
  reconcileChildren(current, workInProgress, nextChildren);
  <span class="hljs-keyword">return</span> workInProgress.child;
}
</code></pre>
<p>reconcileChildren 的功能在前一篇博客里面已经提到过，就是如果存在 nextChildren，会生成一个新的 fiber。给到按当前 workInProgress.child。如上图所示。这里我们称其为 render fiber.</p>
<p>第三轮 beginWordk 的时候，对于 render fiber 执行的 case 为 HostComponent，和上篇博客介绍的类似。最后其会结束 beginWork 的工作，开始 completeUnitOfWork。</p>
<p>由于有三个父子关系的 fiber。所以这里也会有三轮 completeUnitOfWork 循环。首先是底层的 render fiber。对于该 fiber，和前一篇博客类似，进入 completeWork，通过 createInstance 创建 DOM。第二轮 completeUnitOfWork 里面 tag 为 ClassComponent，主要修改 root fiber 的 firstEffect/lastEffect。</p>
<p>第三轮同样也是，至此进入 commit 阶段。</p>
<h3>commit 阶段</h3>
<p>commit 阶段也简单，如同前一篇博客提到的。同样也有三大循环，同样的在 commitPlacement 里面插入元素到真实 DOM 里面，只是都了一次循环查找的过程。</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/commit-component.png" alt=""></p>
<p>可以发现对于 Component 组件的渲染和上一篇博客的介绍到的有大同小异，无非就是 Component 形成一个 tag 为 ClassComponent 的 fiber，而且本身的 render 结果又会是一个 fiber。EffectTag 以及 firstEffect 和 lastEffect 的关系还是一样的。</p>
<h2>setState 之后的变化</h2>
<p>本例子的对 setState 的触发，是通过定时器来实现的，而不是上文中的例子，这也是为了减少分析复杂度。</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">hasWorld</span>: <span class="hljs-literal">true</span>,
  }
  
  componentDidMount() {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>{
      <span class="hljs-keyword">this</span>.setState({<span class="hljs-attr">hasWorld</span>: <span class="hljs-literal">false</span>})
    }, <span class="hljs-number">5000</span>)
  }

  changeWorld = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">333</span>, <span class="hljs-keyword">this</span>.state.hasWorld)
    <span class="hljs-keyword">this</span>.setState({<span class="hljs-attr">hasWorld</span>: !<span class="hljs-keyword">this</span>.state.hasWorld});
  }

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.changeWorld}</span>&gt;</span>
        {this.state.hasWorld ? 'Hello World!' : 'Hello'}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}
ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Hello</span> /&gt;</span></span>,
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'container'</span>)
)
</code></pre>
<p>先看看 setState</p>
<pre class="hljs"><code>Component.prototype.setState = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">partialState, callback</span>) </span>{
  <span class="hljs-keyword">this</span>.updater.enqueueSetState(<span class="hljs-keyword">this</span>, partialState, callback, <span class="hljs-string">'setState'</span>);
};
enqueueSetState: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">inst, payload, callback</span>) </span>{
  <span class="hljs-comment">// 获取对应的 fiber</span>
  <span class="hljs-keyword">const</span> fiber = inst._reactInternalFiber;
  <span class="hljs-comment">// 依旧还是 Sync 也就是 1；</span>
  <span class="hljs-keyword">const</span> expirationTime = computeExpirationForFiber(currentTime, fiber);
  <span class="hljs-keyword">const</span> update = createUpdate(expirationTime);
  update.payload = payload;
  enqueueUpdate(fiber, update, expirationTime);
  scheduleWork(fiber, expirationTime);
}
</code></pre>
<p>可以看出来正是调用了实例的 updater 属性，也就是上文中提到的创建实例时候添加上的属性。而 enqueueSetState 里面获取到的 fiber，其实也就是生成 instance 的fibier，下图中的 oldChild。</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/component-setState-2.png" alt=""></p>
<p>在 enqueueSetState 中和我们前文提到的 scheduleRootUpdate 是很像的，都会创建新的队列，并且都会用到 enqueueUpdate 与 scheduleWork。于是后面看到的过程很多都是之前提到过的。只是由于这一次是更新所以有了很多不同。</p>
<p>比如在构建新的 workInProgress tree 的时候，并不会创建新的 newWorkInProgresRoot，而是修改之前的 oldWorkInProgresRoot.alternate 也就是最上面的 current 这个 fiber。当然同时也会将 newWorkInProgresRoot 的部分属性改为 oldWorkInProgresRoot，或者是清为 null，可以在上图看到，为了方便其见，<strong>新画了一个 workInProgress tree，而不是沿用之前的 current，当然这两个是一个 fiber 哦</strong>。</p>
<p>这里简述一下后面的过程，在第一轮 performSyncWork 里面会通过 cloneChildFibers 方式给 newWorkInProgresRoot 创建 newChild fiber，tag 同样为 ClassComponent，child 也是一样的。</p>
<p>在第二轮 performSyncWork 的时候，会在 beginWork 进入 updateClassComponent，需要 updateClassInstance，</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateClassComponent</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
  <span class="hljs-keyword">const</span> shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);
  <span class="hljs-keyword">return</span> finishClassComponent(current, workInProgress, shouldUpdate, hasContext, renderExpirationTime);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateClassInstance</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
  <span class="hljs-keyword">const</span> ctor = workInProgress.type;
  <span class="hljs-keyword">const</span> instance = workInProgress.stateNode;
  <span class="hljs-keyword">const</span> oldProps = workInProgress.memoizedProps;
  <span class="hljs-keyword">const</span> newProps = workInProgress.pendingProps;
  <span class="hljs-keyword">const</span> oldState = workInProgress.memoizedState;
  <span class="hljs-keyword">let</span> updateQueue = workInProgress.updateQueue;
  <span class="hljs-keyword">if</span> (updateQueue !== <span class="hljs-literal">null</span>) {
    processUpdateQueue(
      workInProgress,
      updateQueue,
      newProps,
      instance,
      renderExpirationTime,
    );
    newState = workInProgress.memoizedState;
  }
  <span class="hljs-keyword">const</span> shouldUpdate =
    checkHasForceUpdateAfterProcessing() ||
    checkShouldComponentUpdate(
      workInProgress,
      oldProps,
      newProps,
      oldState,
      newState,
      newContext,
    );
  <span class="hljs-keyword">if</span>(shouldUpdate) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentWillUpdate === <span class="hljs-string">'function'</span>) {
      instance.componentWillUpdate(newProps, newState, newContext);
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.UNSAFE_componentWillUpdate === <span class="hljs-string">'function'</span>) {
      instance.UNSAFE_componentWillUpdate(newProps, newState, newContext);
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentDidUpdate === <span class="hljs-string">'function'</span>) {
      workInProgress.effectTag |= Update;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.getSnapshotBeforeUpdate === <span class="hljs-string">'function'</span>) {
      workInProgress.effectTag |= Snapshot;
    }
  }
  workInProgress.memoizedProps = newProps;
  workInProgress.memoizedState = newState;
}
</code></pre>
<p><strong>updateClassInstance 函数中可以明显的看到 fiber 的新老 state 和 props 的更新，当然也包括 instance 的 state/props 更新。以及 component 独有的生命钩子的执行，包括 ShouldComponentUpdate/ComponentWillUpdate/UNSAFE_componentWillUpdate，甚至通过修改 effectTag 为以后 commit 阶段执行其他生命钩子做好铺垫</strong>。
由于 newChild 的 upDateQueue 在 enqueueSetState 时候被添加更新了，有了更新 updateQueue 的过程，同时 newChild 的 memoizedState 也会被更新为最新的 state；</p>
<p>updateClassComponent 后面的 finishClassComponent，先是通过 <code>instance.render()</code> 生成 children 也就是虚拟 DOM，再通过 reconcileChildren 同样的创建新的 newRender 这个fiber。只是这一次不再是简单的生成新的 fiber。这里存在一个新老对比的过程。</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileSingleElement</span>(<span class="hljs-params">returnFiber, currentFirstChild, element, expirationTime</span>) </span>{
  <span class="hljs-keyword">const</span> key = element.key;
  <span class="hljs-keyword">let</span> child = currentFirstChild;
  <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">if</span> (child.key === key) {
      deleteRemainingChildren(returnFiber, child.sibling);
      <span class="hljs-keyword">const</span> existing = useFiber(
        child,
        element.type === REACT_FRAGMENT_TYPE
        ? element.props.children
        : element.props,
        expirationTime,
      );
      existing.return = returnFiber;
      <span class="hljs-keyword">return</span> existing；
    }
  }
}
</code></pre>
<p>因为 oldChild 存在 oldRender，所以就会在给 newChild 生成 newRender 这个 fiber 的时候有一个对比 key 的过程。以前 reconcileChildren 时候由于 oldChild 并不存在 alternate，所以不进入上面比较的过程。如果 key 相同则通过 useFiber 生成新的 fiber。</p>
<p>后一轮的 beginWork 和初始化的时候差不多，这里就不提了。</p>
<h3>diff 属性</h3>
<p>在结束 beginWork 之后，进入 completeWork 过程。这里同样的由于 newRender 存在 alternate，所以存在一个比较过程。这里也是 diff 的重点。</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">completeWork</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
  <span class="hljs-keyword">const</span> newProps = workInProgress.pendingProps;
  <span class="hljs-keyword">const</span> type = workInProgress.type;
  <span class="hljs-keyword">switch</span> (workInProgress.tag) {
    <span class="hljs-keyword">case</span> HostComponent: {
      <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; workInProgress.stateNode != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">const</span> oldProps = current.memoizedProps;
        <span class="hljs-keyword">const</span> instance = workInProgress.stateNode;
        <span class="hljs-keyword">const</span> updatePayload = diffProperties(
          instance,
          type,
          oldProps,
          newProps,
          rootContainerInstance,
        );
        workInProgress.updateQueue = updatePayload;
        workInProgress.effectTag |= Update;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
}
</code></pre>
<p>存在 alternate，就意味着这是个更新，而 <strong>这里的 diffProperties 就是对比新老 DOM 的不同</strong>。其做法很是粗暴，通过 for in 的形式对比出两个新老 Props 的不同，当然我们这里重点是 children 这个属性。最后会得出一个 updatePayload 数组，其奇数为 key，偶数为新的值。最后再将其赋予给到 <code>workInProgress.updateQueue</code>，更重要的是修改 effectTag，这样可以在 commit 阶段被识别到这是一个更新。同时也修改 newChild 的 firstEffect/lastEffect 为 child。第二轮 completeWork 里面，会把 newWorkInProgresRoot 的 firstEffect/lastEffect 指向 newRender 这个 fiber。<strong>子 fiber 的 effects 会通过链表的形式被添加到父 fiber 的 effects 上面</strong>。如果有原先的存在的则通过 fiber 的 nextEffct 来传递，实现链表。</p>
<h3>commit 阶段</h3>
<p>在 commitRoot 里面由于 finishedWork.effectTag 为 0，所以三大循环前的 <code>nextEffect = finishedWork.firstEffect</code>。也就是前面的提到的 newRender。这样下来在 commitPlacement 里面，由于 effectTag 为 4，即 Update case，会进入 commitWork 更新元素。</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitWork</span>(<span class="hljs-params">current, finishedWork</span>) </span>{
  <span class="hljs-keyword">switch</span> (finishedWork.tag) {
    <span class="hljs-keyword">case</span> HostComponent:
      <span class="hljs-keyword">const</span> instance = finishedWork.stateNode;
      <span class="hljs-keyword">const</span> newProps = finishedWork.memoizedProps;
      <span class="hljs-keyword">const</span> oldProps = current !== <span class="hljs-literal">null</span> ? current.memoizedProps : newProps;
      <span class="hljs-keyword">const</span> type = finishedWork.type;
      <span class="hljs-keyword">const</span> updatePayload = finishedWork.updateQueue;
      updateFiberProps(instance, newProps);
      updateProperties(instance, updatePayload, type, oldProps, newProps);
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateProperties</span>(<span class="hljs-params">domElement, updatePayload</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; updatePayload.length; i += <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">const</span> propKey = updatePayload[i];
    <span class="hljs-keyword">const</span> propValue = updatePayload[i + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">if</span> (propKey === CHILDREN) {
      setTextContent(domElement, propValue);
    }
  }
}
</code></pre>
<p>commitWork 里面的 updateFiberProps 是负责更新该 dom 指向的 props，改为 newProps；后面则是直接修改 nodeValue，实现 DOM 的更新。</p>
<h3>setState 与 初始化的不同</h3>
<p>从 setState 开始就不一样了。</p>
<ol>
<li>先是给老的 oldChild 添加 updateQueue，里面维护着一个 update，包含了新状态。</li>
<li>由于创建的 newChild 存在 alternate，在 beginWork 时候会更新队列以及相关的生命钩子。</li>
<li>newRender 的创建充分考虑到 key 的复用性，key 相同则根据老的 fiber 来创建新的 fiber 就可以了。</li>
<li>completeWork 阶段对于 updatePayload 数组的收集，为后面的 commit 阶段做了很好的铺垫。</li>
<li>commit 阶段 commitAllHostEffects 函数里面由于 effectTag 为 Update，会进入 commitWork 导致直接的更新操作。</li>
</ol>
<p>上面只是介绍了通过 componentDidMount 定时器方式触发 setState 的，实际上常用的是通过点击的方式触发 interactiveUpdates 更新，也就是文中开头的方式，在 click 事件之后发生，click 的时候会触发监听的事件 dispatchInteractiveEvent，最后触发 setState 函数来更新队列，但是最后并没有在 setState 阶段执行 beginWork。而是在监听函数里面触发另外执行的。</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"March 24, 2021","title":"react 源码下一步","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e前文提到了一个简单的 react 例子，结构如下所示\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eReactDOM.render(\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003eHello World!\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e,\n  \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.getElementById(\u003cspan class=\"hljs-string\"\u003e'container'\u003c/span\u003e)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e只是实在简单呀，缺少 state，缺少状态的变化，于是用另外一个例子来继续研究：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eHello\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title\"\u003eComponent\u003c/span\u003e \u003c/span\u003e{\n  state = {\n    \u003cspan class=\"hljs-attr\"\u003ehasWorld\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  }\n\n  changeWorld = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'isChanging：'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state.hasWorld)\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.setState({\u003cspan class=\"hljs-attr\"\u003ehasWorld\u003c/span\u003e: !\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state.hasWorld});\n  }\n\n  render() {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n      \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{this.changeWorld}\u003c/span\u003e\u0026gt;\u003c/span\u003e\n        {this.state.hasWorld ? 'Hello World!' : 'Hello'}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n    )\n  }\n}\nReactDOM.render(\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eHello\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e,\n  \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.getElementById(\u003cspan class=\"hljs-string\"\u003e'container'\u003c/span\u003e)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e本文将围绕这个简单的 class 展开研究。\u003c/p\u003e\n\u003ch2\u003eHello 的初始化\u003c/h2\u003e\n\u003cp\u003e这里先介绍 Hello 组件的初始化过程，包括前面提到的 render/reconcilation 阶段，以及 commit 阶段。\u003c/p\u003e\n\u003ch3\u003erender/reconcilation 阶段\u003c/h3\u003e\n\u003cp\u003e这个阶段前面部分和之前博客介绍的很类似，创建 root，创建 current，创建 workInProgress 的 root。只是到了 beginWork 就开始不一样了。这个阶段可以看看下面的图片。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/workInProgress-component.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e可以看到在 Step 11 也就是 updateHostRoot 之前都是一样的，只是在该函数的时候，由于 element 的 type 为函数，不是前一篇博客中的 'h1'，所以会在 reconcileChildFibers 函数阶段创建 tag 为 ClassComponent 的 fiber。可以从上图中看到，其 type 为 element 的 hello 函数。\u003c/p\u003e\n\u003cp\u003e第二轮 beginWordk 的时候，对象为上面生成的 child，执行的 case 对应的函数如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eupdateClassComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, workInProgress, renderExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (current === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (workInProgress.stateNode === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n      \u003cspan class=\"hljs-comment\"\u003e// 构建实例\u003c/span\u003e\n      constructClassInstance(\n        workInProgress,\n        workInProgress.pendingProps,\n        renderExpirationTime,\n      );\n      mountClassInstance(workInProgress, renderExpirationTime);\n\n      shouldUpdate = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e finishClassComponent(\n    current,\n    workInProgress,\n    shouldUpdate,\n    hasContext,\n    renderExpirationTime,\n  );\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003econstructClassInstance\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eworkInProgress, props, renderExpirationTime\u003c/span\u003e)\u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ctor = workInProgress.type;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e context = emptyObject;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instance = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e ctor(props, context);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e state = workInProgress.memoizedState = instance.state || \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  instance.updater = classComponentUpdater;\n  workInProgress.stateNode = instance;\n  instance._reactInternalFiber = workInProgress;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e instance;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 constructClassInstance 时候会 new 一个 Hello class，将 child.stateNode 指向该实例。这里有三个特别操作\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e同时给实例的 \u003ccode\u003einstance.updater = classComponentUpdater\u003c/code\u003e。这个方法在 setState 里面会用到。\u003c/li\u003e\n\u003cli\u003e给 child.memoizedState 添加上 instance 的 state，也就是 { hasWorld: true }。为以后更新提供前值。\u003c/li\u003e\n\u003cli\u003e给 instance 添加对应的 fiber\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这上面的三条都在 setState 里面起到非常关键的作用。updateClassComponent 里面还有 shouldComponentUpdate 的判断，但是这里是首次加载，必然是 true 了。\u003c/p\u003e\n\u003cp\u003emountClassInstance 里面则是从 child 里面往 instance 添加 props，ref，context 等属性，同时判断 instance 有无 componentDidMount 函数，有的话 \u003ccode\u003echild.effectTag |= Update;\u003c/code\u003e。从而在后面阶段可以执行 componentDidMount。\u003c/p\u003e\n\u003cp\u003e后面的 finishClassComponent，如下\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efinishClassComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, workInProgress, shouldUpdate, hasContext, renderExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ctor = workInProgress.type;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instance = workInProgress.stateNode;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e nextChildren = instance.render();\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e workInProgress.child;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ereconcileChildren 的功能在前一篇博客里面已经提到过，就是如果存在 nextChildren，会生成一个新的 fiber。给到按当前 workInProgress.child。如上图所示。这里我们称其为 render fiber.\u003c/p\u003e\n\u003cp\u003e第三轮 beginWordk 的时候，对于 render fiber 执行的 case 为 HostComponent，和上篇博客介绍的类似。最后其会结束 beginWork 的工作，开始 completeUnitOfWork。\u003c/p\u003e\n\u003cp\u003e由于有三个父子关系的 fiber。所以这里也会有三轮 completeUnitOfWork 循环。首先是底层的 render fiber。对于该 fiber，和前一篇博客类似，进入 completeWork，通过 createInstance 创建 DOM。第二轮 completeUnitOfWork 里面 tag 为 ClassComponent，主要修改 root fiber 的 firstEffect/lastEffect。\u003c/p\u003e\n\u003cp\u003e第三轮同样也是，至此进入 commit 阶段。\u003c/p\u003e\n\u003ch3\u003ecommit 阶段\u003c/h3\u003e\n\u003cp\u003ecommit 阶段也简单，如同前一篇博客提到的。同样也有三大循环，同样的在 commitPlacement 里面插入元素到真实 DOM 里面，只是都了一次循环查找的过程。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/commit-component.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e可以发现对于 Component 组件的渲染和上一篇博客的介绍到的有大同小异，无非就是 Component 形成一个 tag 为 ClassComponent 的 fiber，而且本身的 render 结果又会是一个 fiber。EffectTag 以及 firstEffect 和 lastEffect 的关系还是一样的。\u003c/p\u003e\n\u003ch2\u003esetState 之后的变化\u003c/h2\u003e\n\u003cp\u003e本例子的对 setState 的触发，是通过定时器来实现的，而不是上文中的例子，这也是为了减少分析复杂度。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eHello\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title\"\u003eComponent\u003c/span\u003e \u003c/span\u003e{\n  state = {\n    \u003cspan class=\"hljs-attr\"\u003ehasWorld\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  }\n  \n  componentDidMount() {\n    setTimeout(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e{\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.setState({\u003cspan class=\"hljs-attr\"\u003ehasWorld\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e})\n    }, \u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e)\n  }\n\n  changeWorld = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-number\"\u003e333\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state.hasWorld)\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.setState({\u003cspan class=\"hljs-attr\"\u003ehasWorld\u003c/span\u003e: !\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state.hasWorld});\n  }\n\n  render() {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n      \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{this.changeWorld}\u003c/span\u003e\u0026gt;\u003c/span\u003e\n        {this.state.hasWorld ? 'Hello World!' : 'Hello'}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n    )\n  }\n}\nReactDOM.render(\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eHello\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e,\n  \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.getElementById(\u003cspan class=\"hljs-string\"\u003e'container'\u003c/span\u003e)\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e先看看 setState\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eComponent.prototype.setState = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003epartialState, callback\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.updater.enqueueSetState(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, partialState, callback, \u003cspan class=\"hljs-string\"\u003e'setState'\u003c/span\u003e);\n};\nenqueueSetState: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003einst, payload, callback\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 获取对应的 fiber\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fiber = inst._reactInternalFiber;\n  \u003cspan class=\"hljs-comment\"\u003e// 依旧还是 Sync 也就是 1；\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e expirationTime = computeExpirationForFiber(currentTime, fiber);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e update = createUpdate(expirationTime);\n  update.payload = payload;\n  enqueueUpdate(fiber, update, expirationTime);\n  scheduleWork(fiber, expirationTime);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看出来正是调用了实例的 updater 属性，也就是上文中提到的创建实例时候添加上的属性。而 enqueueSetState 里面获取到的 fiber，其实也就是生成 instance 的fibier，下图中的 oldChild。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/component-setState-2.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e在 enqueueSetState 中和我们前文提到的 scheduleRootUpdate 是很像的，都会创建新的队列，并且都会用到 enqueueUpdate 与 scheduleWork。于是后面看到的过程很多都是之前提到过的。只是由于这一次是更新所以有了很多不同。\u003c/p\u003e\n\u003cp\u003e比如在构建新的 workInProgress tree 的时候，并不会创建新的 newWorkInProgresRoot，而是修改之前的 oldWorkInProgresRoot.alternate 也就是最上面的 current 这个 fiber。当然同时也会将 newWorkInProgresRoot 的部分属性改为 oldWorkInProgresRoot，或者是清为 null，可以在上图看到，为了方便其见，\u003cstrong\u003e新画了一个 workInProgress tree，而不是沿用之前的 current，当然这两个是一个 fiber 哦\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e这里简述一下后面的过程，在第一轮 performSyncWork 里面会通过 cloneChildFibers 方式给 newWorkInProgresRoot 创建 newChild fiber，tag 同样为 ClassComponent，child 也是一样的。\u003c/p\u003e\n\u003cp\u003e在第二轮 performSyncWork 的时候，会在 beginWork 进入 updateClassComponent，需要 updateClassInstance，\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eupdateClassComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, workInProgress, renderExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e finishClassComponent(current, workInProgress, shouldUpdate, hasContext, renderExpirationTime);\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eupdateClassInstance\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, workInProgress, renderExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ctor = workInProgress.type;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instance = workInProgress.stateNode;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e oldProps = workInProgress.memoizedProps;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newProps = workInProgress.pendingProps;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e oldState = workInProgress.memoizedState;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e updateQueue = workInProgress.updateQueue;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (updateQueue !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    processUpdateQueue(\n      workInProgress,\n      updateQueue,\n      newProps,\n      instance,\n      renderExpirationTime,\n    );\n    newState = workInProgress.memoizedState;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e shouldUpdate =\n    checkHasForceUpdateAfterProcessing() ||\n    checkShouldComponentUpdate(\n      workInProgress,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      newContext,\n    );\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(shouldUpdate) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e instance.componentWillUpdate === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n      instance.componentWillUpdate(newProps, newState, newContext);\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e instance.UNSAFE_componentWillUpdate === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n      instance.UNSAFE_componentWillUpdate(newProps, newState, newContext);\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e instance.componentDidUpdate === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n      workInProgress.effectTag |= Update;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e instance.getSnapshotBeforeUpdate === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n      workInProgress.effectTag |= Snapshot;\n    }\n  }\n  workInProgress.memoizedProps = newProps;\n  workInProgress.memoizedState = newState;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eupdateClassInstance 函数中可以明显的看到 fiber 的新老 state 和 props 的更新，当然也包括 instance 的 state/props 更新。以及 component 独有的生命钩子的执行，包括 ShouldComponentUpdate/ComponentWillUpdate/UNSAFE_componentWillUpdate，甚至通过修改 effectTag 为以后 commit 阶段执行其他生命钩子做好铺垫\u003c/strong\u003e。\n由于 newChild 的 upDateQueue 在 enqueueSetState 时候被添加更新了，有了更新 updateQueue 的过程，同时 newChild 的 memoizedState 也会被更新为最新的 state；\u003c/p\u003e\n\u003cp\u003eupdateClassComponent 后面的 finishClassComponent，先是通过 \u003ccode\u003einstance.render()\u003c/code\u003e 生成 children 也就是虚拟 DOM，再通过 reconcileChildren 同样的创建新的 newRender 这个fiber。只是这一次不再是简单的生成新的 fiber。这里存在一个新老对比的过程。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ereconcileSingleElement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ereturnFiber, currentFirstChild, element, expirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e key = element.key;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e child = currentFirstChild;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (child !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (child.key === key) {\n      deleteRemainingChildren(returnFiber, child.sibling);\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e existing = useFiber(\n        child,\n        element.type === REACT_FRAGMENT_TYPE\n        ? element.props.children\n        : element.props,\n        expirationTime,\n      );\n      existing.return = returnFiber;\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e existing；\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e因为 oldChild 存在 oldRender，所以就会在给 newChild 生成 newRender 这个 fiber 的时候有一个对比 key 的过程。以前 reconcileChildren 时候由于 oldChild 并不存在 alternate，所以不进入上面比较的过程。如果 key 相同则通过 useFiber 生成新的 fiber。\u003c/p\u003e\n\u003cp\u003e后一轮的 beginWork 和初始化的时候差不多，这里就不提了。\u003c/p\u003e\n\u003ch3\u003ediff 属性\u003c/h3\u003e\n\u003cp\u003e在结束 beginWork 之后，进入 completeWork 过程。这里同样的由于 newRender 存在 alternate，所以存在一个比较过程。这里也是 diff 的重点。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecompleteWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, workInProgress, renderExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newProps = workInProgress.pendingProps;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e type = workInProgress.type;\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (workInProgress.tag) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e HostComponent: {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (current !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026amp;\u0026amp; workInProgress.stateNode != \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e oldProps = current.memoizedProps;\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instance = workInProgress.stateNode;\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e updatePayload = diffProperties(\n          instance,\n          type,\n          oldProps,\n          newProps,\n          rootContainerInstance,\n        );\n        workInProgress.updateQueue = updatePayload;\n        workInProgress.effectTag |= Update;\n      }\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e存在 alternate，就意味着这是个更新，而 \u003cstrong\u003e这里的 diffProperties 就是对比新老 DOM 的不同\u003c/strong\u003e。其做法很是粗暴，通过 for in 的形式对比出两个新老 Props 的不同，当然我们这里重点是 children 这个属性。最后会得出一个 updatePayload 数组，其奇数为 key，偶数为新的值。最后再将其赋予给到 \u003ccode\u003eworkInProgress.updateQueue\u003c/code\u003e，更重要的是修改 effectTag，这样可以在 commit 阶段被识别到这是一个更新。同时也修改 newChild 的 firstEffect/lastEffect 为 child。第二轮 completeWork 里面，会把 newWorkInProgresRoot 的 firstEffect/lastEffect 指向 newRender 这个 fiber。\u003cstrong\u003e子 fiber 的 effects 会通过链表的形式被添加到父 fiber 的 effects 上面\u003c/strong\u003e。如果有原先的存在的则通过 fiber 的 nextEffct 来传递，实现链表。\u003c/p\u003e\n\u003ch3\u003ecommit 阶段\u003c/h3\u003e\n\u003cp\u003e在 commitRoot 里面由于 finishedWork.effectTag 为 0，所以三大循环前的 \u003ccode\u003enextEffect = finishedWork.firstEffect\u003c/code\u003e。也就是前面的提到的 newRender。这样下来在 commitPlacement 里面，由于 effectTag 为 4，即 Update case，会进入 commitWork 更新元素。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecommitWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, finishedWork\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (finishedWork.tag) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e HostComponent:\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instance = finishedWork.stateNode;\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newProps = finishedWork.memoizedProps;\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e oldProps = current !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e ? current.memoizedProps : newProps;\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e type = finishedWork.type;\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e updatePayload = finishedWork.updateQueue;\n      updateFiberProps(instance, newProps);\n      updateProperties(instance, updatePayload, type, oldProps, newProps);\n  }\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eupdateProperties\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edomElement, updatePayload\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; updatePayload.length; i += \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e propKey = updatePayload[i];\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e propValue = updatePayload[i + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (propKey === CHILDREN) {\n      setTextContent(domElement, propValue);\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecommitWork 里面的 updateFiberProps 是负责更新该 dom 指向的 props，改为 newProps；后面则是直接修改 nodeValue，实现 DOM 的更新。\u003c/p\u003e\n\u003ch3\u003esetState 与 初始化的不同\u003c/h3\u003e\n\u003cp\u003e从 setState 开始就不一样了。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e先是给老的 oldChild 添加 updateQueue，里面维护着一个 update，包含了新状态。\u003c/li\u003e\n\u003cli\u003e由于创建的 newChild 存在 alternate，在 beginWork 时候会更新队列以及相关的生命钩子。\u003c/li\u003e\n\u003cli\u003enewRender 的创建充分考虑到 key 的复用性，key 相同则根据老的 fiber 来创建新的 fiber 就可以了。\u003c/li\u003e\n\u003cli\u003ecompleteWork 阶段对于 updatePayload 数组的收集，为后面的 commit 阶段做了很好的铺垫。\u003c/li\u003e\n\u003cli\u003ecommit 阶段 commitAllHostEffects 函数里面由于 effectTag 为 Update，会进入 commitWork 导致直接的更新操作。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e上面只是介绍了通过 componentDidMount 定时器方式触发 setState 的，实际上常用的是通过点击的方式触发 interactiveUpdates 更新，也就是文中开头的方式，在 click 事件之后发生，click 的时候会触发监听的事件 dispatchInteractiveEvent，最后触发 setState 函数来更新队列，但是最后并没有在 setState 阶段执行 beginWork。而是在监听函数里面触发另外执行的。\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"March 24, 2021","title":"react 源码下一步","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e前文提到了一个简单的 react 例子，结构如下所示\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eReactDOM.render(\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003eHello World!\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e,\n  \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.getElementById(\u003cspan class=\"hljs-string\"\u003e'container'\u003c/span\u003e)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e只是实在简单呀，缺少 state，缺少状态的变化，于是用另外一个例子来继续研究：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eHello\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title\"\u003eComponent\u003c/span\u003e \u003c/span\u003e{\n  state = {\n    \u003cspan class=\"hljs-attr\"\u003ehasWorld\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  }\n\n  changeWorld = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'isChanging：'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state.hasWorld)\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.setState({\u003cspan class=\"hljs-attr\"\u003ehasWorld\u003c/span\u003e: !\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state.hasWorld});\n  }\n\n  render() {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n      \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{this.changeWorld}\u003c/span\u003e\u0026gt;\u003c/span\u003e\n        {this.state.hasWorld ? 'Hello World!' : 'Hello'}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n    )\n  }\n}\nReactDOM.render(\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eHello\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e,\n  \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.getElementById(\u003cspan class=\"hljs-string\"\u003e'container'\u003c/span\u003e)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e本文将围绕这个简单的 class 展开研究。\u003c/p\u003e\n\u003ch2\u003eHello 的初始化\u003c/h2\u003e\n\u003cp\u003e这里先介绍 Hello 组件的初始化过程，包括前面提到的 render/reconcilation 阶段，以及 commit 阶段。\u003c/p\u003e\n\u003ch3\u003erender/reconcilation 阶段\u003c/h3\u003e\n\u003cp\u003e这个阶段前面部分和之前博客介绍的很类似，创建 root，创建 current，创建 workInProgress 的 root。只是到了 beginWork 就开始不一样了。这个阶段可以看看下面的图片。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/workInProgress-component.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e可以看到在 Step 11 也就是 updateHostRoot 之前都是一样的，只是在该函数的时候，由于 element 的 type 为函数，不是前一篇博客中的 'h1'，所以会在 reconcileChildFibers 函数阶段创建 tag 为 ClassComponent 的 fiber。可以从上图中看到，其 type 为 element 的 hello 函数。\u003c/p\u003e\n\u003cp\u003e第二轮 beginWordk 的时候，对象为上面生成的 child，执行的 case 对应的函数如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eupdateClassComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, workInProgress, renderExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (current === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (workInProgress.stateNode === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n      \u003cspan class=\"hljs-comment\"\u003e// 构建实例\u003c/span\u003e\n      constructClassInstance(\n        workInProgress,\n        workInProgress.pendingProps,\n        renderExpirationTime,\n      );\n      mountClassInstance(workInProgress, renderExpirationTime);\n\n      shouldUpdate = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e finishClassComponent(\n    current,\n    workInProgress,\n    shouldUpdate,\n    hasContext,\n    renderExpirationTime,\n  );\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003econstructClassInstance\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eworkInProgress, props, renderExpirationTime\u003c/span\u003e)\u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ctor = workInProgress.type;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e context = emptyObject;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instance = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e ctor(props, context);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e state = workInProgress.memoizedState = instance.state || \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  instance.updater = classComponentUpdater;\n  workInProgress.stateNode = instance;\n  instance._reactInternalFiber = workInProgress;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e instance;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 constructClassInstance 时候会 new 一个 Hello class，将 child.stateNode 指向该实例。这里有三个特别操作\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e同时给实例的 \u003ccode\u003einstance.updater = classComponentUpdater\u003c/code\u003e。这个方法在 setState 里面会用到。\u003c/li\u003e\n\u003cli\u003e给 child.memoizedState 添加上 instance 的 state，也就是 { hasWorld: true }。为以后更新提供前值。\u003c/li\u003e\n\u003cli\u003e给 instance 添加对应的 fiber\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这上面的三条都在 setState 里面起到非常关键的作用。updateClassComponent 里面还有 shouldComponentUpdate 的判断，但是这里是首次加载，必然是 true 了。\u003c/p\u003e\n\u003cp\u003emountClassInstance 里面则是从 child 里面往 instance 添加 props，ref，context 等属性，同时判断 instance 有无 componentDidMount 函数，有的话 \u003ccode\u003echild.effectTag |= Update;\u003c/code\u003e。从而在后面阶段可以执行 componentDidMount。\u003c/p\u003e\n\u003cp\u003e后面的 finishClassComponent，如下\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efinishClassComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, workInProgress, shouldUpdate, hasContext, renderExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ctor = workInProgress.type;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instance = workInProgress.stateNode;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e nextChildren = instance.render();\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e workInProgress.child;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ereconcileChildren 的功能在前一篇博客里面已经提到过，就是如果存在 nextChildren，会生成一个新的 fiber。给到按当前 workInProgress.child。如上图所示。这里我们称其为 render fiber.\u003c/p\u003e\n\u003cp\u003e第三轮 beginWordk 的时候，对于 render fiber 执行的 case 为 HostComponent，和上篇博客介绍的类似。最后其会结束 beginWork 的工作，开始 completeUnitOfWork。\u003c/p\u003e\n\u003cp\u003e由于有三个父子关系的 fiber。所以这里也会有三轮 completeUnitOfWork 循环。首先是底层的 render fiber。对于该 fiber，和前一篇博客类似，进入 completeWork，通过 createInstance 创建 DOM。第二轮 completeUnitOfWork 里面 tag 为 ClassComponent，主要修改 root fiber 的 firstEffect/lastEffect。\u003c/p\u003e\n\u003cp\u003e第三轮同样也是，至此进入 commit 阶段。\u003c/p\u003e\n\u003ch3\u003ecommit 阶段\u003c/h3\u003e\n\u003cp\u003ecommit 阶段也简单，如同前一篇博客提到的。同样也有三大循环，同样的在 commitPlacement 里面插入元素到真实 DOM 里面，只是都了一次循环查找的过程。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/commit-component.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e可以发现对于 Component 组件的渲染和上一篇博客的介绍到的有大同小异，无非就是 Component 形成一个 tag 为 ClassComponent 的 fiber，而且本身的 render 结果又会是一个 fiber。EffectTag 以及 firstEffect 和 lastEffect 的关系还是一样的。\u003c/p\u003e\n\u003ch2\u003esetState 之后的变化\u003c/h2\u003e\n\u003cp\u003e本例子的对 setState 的触发，是通过定时器来实现的，而不是上文中的例子，这也是为了减少分析复杂度。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eHello\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title\"\u003eComponent\u003c/span\u003e \u003c/span\u003e{\n  state = {\n    \u003cspan class=\"hljs-attr\"\u003ehasWorld\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  }\n  \n  componentDidMount() {\n    setTimeout(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e{\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.setState({\u003cspan class=\"hljs-attr\"\u003ehasWorld\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e})\n    }, \u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e)\n  }\n\n  changeWorld = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-number\"\u003e333\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state.hasWorld)\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.setState({\u003cspan class=\"hljs-attr\"\u003ehasWorld\u003c/span\u003e: !\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state.hasWorld});\n  }\n\n  render() {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n      \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{this.changeWorld}\u003c/span\u003e\u0026gt;\u003c/span\u003e\n        {this.state.hasWorld ? 'Hello World!' : 'Hello'}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n    )\n  }\n}\nReactDOM.render(\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eHello\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e,\n  \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.getElementById(\u003cspan class=\"hljs-string\"\u003e'container'\u003c/span\u003e)\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e先看看 setState\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eComponent.prototype.setState = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003epartialState, callback\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.updater.enqueueSetState(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, partialState, callback, \u003cspan class=\"hljs-string\"\u003e'setState'\u003c/span\u003e);\n};\nenqueueSetState: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003einst, payload, callback\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 获取对应的 fiber\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fiber = inst._reactInternalFiber;\n  \u003cspan class=\"hljs-comment\"\u003e// 依旧还是 Sync 也就是 1；\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e expirationTime = computeExpirationForFiber(currentTime, fiber);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e update = createUpdate(expirationTime);\n  update.payload = payload;\n  enqueueUpdate(fiber, update, expirationTime);\n  scheduleWork(fiber, expirationTime);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看出来正是调用了实例的 updater 属性，也就是上文中提到的创建实例时候添加上的属性。而 enqueueSetState 里面获取到的 fiber，其实也就是生成 instance 的fibier，下图中的 oldChild。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/component-setState-2.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e在 enqueueSetState 中和我们前文提到的 scheduleRootUpdate 是很像的，都会创建新的队列，并且都会用到 enqueueUpdate 与 scheduleWork。于是后面看到的过程很多都是之前提到过的。只是由于这一次是更新所以有了很多不同。\u003c/p\u003e\n\u003cp\u003e比如在构建新的 workInProgress tree 的时候，并不会创建新的 newWorkInProgresRoot，而是修改之前的 oldWorkInProgresRoot.alternate 也就是最上面的 current 这个 fiber。当然同时也会将 newWorkInProgresRoot 的部分属性改为 oldWorkInProgresRoot，或者是清为 null，可以在上图看到，为了方便其见，\u003cstrong\u003e新画了一个 workInProgress tree，而不是沿用之前的 current，当然这两个是一个 fiber 哦\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e这里简述一下后面的过程，在第一轮 performSyncWork 里面会通过 cloneChildFibers 方式给 newWorkInProgresRoot 创建 newChild fiber，tag 同样为 ClassComponent，child 也是一样的。\u003c/p\u003e\n\u003cp\u003e在第二轮 performSyncWork 的时候，会在 beginWork 进入 updateClassComponent，需要 updateClassInstance，\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eupdateClassComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, workInProgress, renderExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e finishClassComponent(current, workInProgress, shouldUpdate, hasContext, renderExpirationTime);\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eupdateClassInstance\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, workInProgress, renderExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ctor = workInProgress.type;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instance = workInProgress.stateNode;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e oldProps = workInProgress.memoizedProps;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newProps = workInProgress.pendingProps;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e oldState = workInProgress.memoizedState;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e updateQueue = workInProgress.updateQueue;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (updateQueue !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    processUpdateQueue(\n      workInProgress,\n      updateQueue,\n      newProps,\n      instance,\n      renderExpirationTime,\n    );\n    newState = workInProgress.memoizedState;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e shouldUpdate =\n    checkHasForceUpdateAfterProcessing() ||\n    checkShouldComponentUpdate(\n      workInProgress,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      newContext,\n    );\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(shouldUpdate) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e instance.componentWillUpdate === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n      instance.componentWillUpdate(newProps, newState, newContext);\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e instance.UNSAFE_componentWillUpdate === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n      instance.UNSAFE_componentWillUpdate(newProps, newState, newContext);\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e instance.componentDidUpdate === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n      workInProgress.effectTag |= Update;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e instance.getSnapshotBeforeUpdate === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n      workInProgress.effectTag |= Snapshot;\n    }\n  }\n  workInProgress.memoizedProps = newProps;\n  workInProgress.memoizedState = newState;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eupdateClassInstance 函数中可以明显的看到 fiber 的新老 state 和 props 的更新，当然也包括 instance 的 state/props 更新。以及 component 独有的生命钩子的执行，包括 ShouldComponentUpdate/ComponentWillUpdate/UNSAFE_componentWillUpdate，甚至通过修改 effectTag 为以后 commit 阶段执行其他生命钩子做好铺垫\u003c/strong\u003e。\n由于 newChild 的 upDateQueue 在 enqueueSetState 时候被添加更新了，有了更新 updateQueue 的过程，同时 newChild 的 memoizedState 也会被更新为最新的 state；\u003c/p\u003e\n\u003cp\u003eupdateClassComponent 后面的 finishClassComponent，先是通过 \u003ccode\u003einstance.render()\u003c/code\u003e 生成 children 也就是虚拟 DOM，再通过 reconcileChildren 同样的创建新的 newRender 这个fiber。只是这一次不再是简单的生成新的 fiber。这里存在一个新老对比的过程。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ereconcileSingleElement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ereturnFiber, currentFirstChild, element, expirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e key = element.key;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e child = currentFirstChild;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (child !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (child.key === key) {\n      deleteRemainingChildren(returnFiber, child.sibling);\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e existing = useFiber(\n        child,\n        element.type === REACT_FRAGMENT_TYPE\n        ? element.props.children\n        : element.props,\n        expirationTime,\n      );\n      existing.return = returnFiber;\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e existing；\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e因为 oldChild 存在 oldRender，所以就会在给 newChild 生成 newRender 这个 fiber 的时候有一个对比 key 的过程。以前 reconcileChildren 时候由于 oldChild 并不存在 alternate，所以不进入上面比较的过程。如果 key 相同则通过 useFiber 生成新的 fiber。\u003c/p\u003e\n\u003cp\u003e后一轮的 beginWork 和初始化的时候差不多，这里就不提了。\u003c/p\u003e\n\u003ch3\u003ediff 属性\u003c/h3\u003e\n\u003cp\u003e在结束 beginWork 之后，进入 completeWork 过程。这里同样的由于 newRender 存在 alternate，所以存在一个比较过程。这里也是 diff 的重点。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecompleteWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, workInProgress, renderExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newProps = workInProgress.pendingProps;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e type = workInProgress.type;\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (workInProgress.tag) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e HostComponent: {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (current !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026amp;\u0026amp; workInProgress.stateNode != \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e oldProps = current.memoizedProps;\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instance = workInProgress.stateNode;\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e updatePayload = diffProperties(\n          instance,\n          type,\n          oldProps,\n          newProps,\n          rootContainerInstance,\n        );\n        workInProgress.updateQueue = updatePayload;\n        workInProgress.effectTag |= Update;\n      }\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e存在 alternate，就意味着这是个更新，而 \u003cstrong\u003e这里的 diffProperties 就是对比新老 DOM 的不同\u003c/strong\u003e。其做法很是粗暴，通过 for in 的形式对比出两个新老 Props 的不同，当然我们这里重点是 children 这个属性。最后会得出一个 updatePayload 数组，其奇数为 key，偶数为新的值。最后再将其赋予给到 \u003ccode\u003eworkInProgress.updateQueue\u003c/code\u003e，更重要的是修改 effectTag，这样可以在 commit 阶段被识别到这是一个更新。同时也修改 newChild 的 firstEffect/lastEffect 为 child。第二轮 completeWork 里面，会把 newWorkInProgresRoot 的 firstEffect/lastEffect 指向 newRender 这个 fiber。\u003cstrong\u003e子 fiber 的 effects 会通过链表的形式被添加到父 fiber 的 effects 上面\u003c/strong\u003e。如果有原先的存在的则通过 fiber 的 nextEffct 来传递，实现链表。\u003c/p\u003e\n\u003ch3\u003ecommit 阶段\u003c/h3\u003e\n\u003cp\u003e在 commitRoot 里面由于 finishedWork.effectTag 为 0，所以三大循环前的 \u003ccode\u003enextEffect = finishedWork.firstEffect\u003c/code\u003e。也就是前面的提到的 newRender。这样下来在 commitPlacement 里面，由于 effectTag 为 4，即 Update case，会进入 commitWork 更新元素。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecommitWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, finishedWork\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (finishedWork.tag) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e HostComponent:\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instance = finishedWork.stateNode;\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newProps = finishedWork.memoizedProps;\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e oldProps = current !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e ? current.memoizedProps : newProps;\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e type = finishedWork.type;\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e updatePayload = finishedWork.updateQueue;\n      updateFiberProps(instance, newProps);\n      updateProperties(instance, updatePayload, type, oldProps, newProps);\n  }\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eupdateProperties\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edomElement, updatePayload\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; updatePayload.length; i += \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e propKey = updatePayload[i];\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e propValue = updatePayload[i + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (propKey === CHILDREN) {\n      setTextContent(domElement, propValue);\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecommitWork 里面的 updateFiberProps 是负责更新该 dom 指向的 props，改为 newProps；后面则是直接修改 nodeValue，实现 DOM 的更新。\u003c/p\u003e\n\u003ch3\u003esetState 与 初始化的不同\u003c/h3\u003e\n\u003cp\u003e从 setState 开始就不一样了。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e先是给老的 oldChild 添加 updateQueue，里面维护着一个 update，包含了新状态。\u003c/li\u003e\n\u003cli\u003e由于创建的 newChild 存在 alternate，在 beginWork 时候会更新队列以及相关的生命钩子。\u003c/li\u003e\n\u003cli\u003enewRender 的创建充分考虑到 key 的复用性，key 相同则根据老的 fiber 来创建新的 fiber 就可以了。\u003c/li\u003e\n\u003cli\u003ecompleteWork 阶段对于 updatePayload 数组的收集，为后面的 commit 阶段做了很好的铺垫。\u003c/li\u003e\n\u003cli\u003ecommit 阶段 commitAllHostEffects 函数里面由于 effectTag 为 Update，会进入 commitWork 导致直接的更新操作。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e上面只是介绍了通过 componentDidMount 定时器方式触发 setState 的，实际上常用的是通过点击的方式触发 interactiveUpdates 更新，也就是文中开头的方式，在 click 事件之后发生，click 的时候会触发监听的事件 dispatchInteractiveEvent，最后触发 setState 函数来更新队列，但是最后并没有在 setState 阶段执行 beginWork。而是在监听函数里面触发另外执行的。\u003c/p\u003e\n"}},"buildId":"r4Ww0YLm8YL5~6SwciWHH","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" async=""></script></body></html>