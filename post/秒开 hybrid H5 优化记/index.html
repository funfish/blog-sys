<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">秒开 hybrid H5 优化记</title><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.587c5e31.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___2dTZ9 "><a class="logo___346dE" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___13XXt" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___29Pln"><h1 class="postTitle___1_m4g">秒开 hybrid H5 优化记</h1><span class="postTime___1x0_i">March 24, 2021</span></header><article class="postWrapper___3jnNg post-article"><div><p>记得刚做前端，接手移动端 H5 的时候，特别想要将应用优化到极致，想要达到秒开，流畅接近原生的效果，只是业务需求下一直没有时间去做这样或者那样的优化。这次自己接手一个 hybrid H5 项目，做完业务之后，一直想要优化，刚好又是我一个人负责前端，于是将平时的想法收集起来，周六加班做了个深入的优化（可惜才过了四天，就被通知项目要移交到其他团队）。避免涉密，后面的数据，都做了稍微修改。</p>
<h2>初始问题</h2>
<p>这个项目是基于百度地图做了一个应用，开始存在两个问题，一个是首屏白屏问题；从点击进入到开始到有内容的阶段，有个明显白屏的时间，这个时间是包含 webview 初始化，以及首屏渲染的时间。该首屏渲染的时间，FP 的时间在 Fast 3G 下，大概为 9000+ ms。原本的系统，其实已经做了路由的懒加载了。另外一个百度地图渲染漂移问题。</p>
<p>对于上面的问题，一共做了七层优化，尤其是首屏加载问题。</p>
<h2>百度地图</h2>
<p>用 vue-baidu-map 来作为 Vue 项目的百度地图组件。只是在移动端存在严重的问题，其覆盖物在移动端渲染性能差，稍微用手拖动一下百度地图，其上面的文字或者自定义的图形都会出现颤抖，而在 pc 端是没有这样的问题，官网的示例也是如此，只是采用覆盖物-点的方式，却能很好的避免颤抖的情况。</p>
<p>若是直接采用百度地图的方式，而不是用 vue-baidu-map，其效果会好很多，不会有颤抖问题。只是想要试试新的 vue-baidu-map，而不是一直用老的方式。由于百度地图的代码没有开源出来，查看 vue-baidu-map 中的实现方式，也无特别收获， vue-baidu-map 只是做了一个 Vue 和百度地图的数据驱动的绑定而已，这给调试代码带来了很大的阻挠。后面为了方便调试， <strong>采用 chrome 的 rendering 来调试代码，发现自定义覆盖物在拖动地图的时候，会反复变深绿色，而使用点覆盖物，只会时不时变深绿色</strong>。点覆盖物性能确实要比自定义以及其他覆盖物要很多。后面改为点覆盖物，效果真的提高了不少。</p>
<p>另外经过多次调试后发现高德地图真的要比百度地图好，有三维模式，而且 webview 支持好一些，只是定位没有百度地图准。</p>
<h2>首屏优化</h2>
<p>由于项目需要适配多语言，而之前的语言包，加起来有 1M+ 的大小，只是里面的冗余数据比较多，需要用到信息并没有那么多，于是采用 nodejs，对每个语言文件进行解析，输出对应的简化版本的 json 文件。nodejs 采用 walkdir 模块遍历所有语言包，并输出为简化版本文件。可以将包的体积减少到 3/5 的水平，并采用按需加载。</p>
<h3>lottie 优化</h3>
<p>为了更好的还原动画采用的是 lottie + json 数据的方式，实现动效。只是设计最后给出来的一个动效 html 都要接近 300kb，这个是无法接受的，而且其实动画尺寸非常小，就是个简单 icon，采用 30 帧的序列帧体积也要 170kb，很大，而且设计为了统一管理，统一规范，推荐的还是采用 lottie 方案。后面在一篇腾讯 alloyteam 的文章里面有介绍到 lottie-web 仓库的 lottie_light.min.js 只用 140+kb，完整版的要 240+ kb，虽然只支持 svg，但是已经很够用了。</p>
<p>再加上异步组件和懒加载 lottie_light.min.js 和对应的 json 数据，可以大大的减少首屏渲染压力</p>
<pre class="hljs"><code><span class="hljs-comment">// 异步组件方式</span>
<span class="hljs-attr">components</span>: {
  <span class="hljs-attr">LottieComponent</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"./LottieComponent"</span>);
}
<span class="hljs-comment">// 懒加载Lottie文件</span>
<span class="hljs-keyword">const</span> [lottie, lottieAnimationData] = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([
  <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: "lottieLightMin" */</span> <span class="hljs-string">"./lottie_light.min"</span>),
  <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: "lottieComponent" */</span> <span class="hljs-string">"./lottieComponentData"</span>)
]);
</code></pre>
<p>使得 lottie + json 数据文件大小在接近 200kb 的水平，并达到了按需加载的目的。</p>
<p>最后还想采用将 lottie 文件内置到客户端里面，请求的时候，拦截返回 lottie 文件给到前端就可以了，可惜客户端做的是小白。。。。</p>
<h3>图形压缩</h3>
<p>之前介绍过图像优化，该项目使用的图像有不是很多，通过有效压缩，可以减少 30% 的体积，只是需要注意的是有些首页的图像，在低于 10 kb 的时候，会被 Vue-cli3 打包进首页的 js 文件里面，导致文件臃肿，于是需要观察图片大小，以及配置对应的 vue.config 来达到最优解，本项目刚好是 10 kb， 附近有几个图像被打包进去了，修改 loader 对应的配置值就可以了。</p>
<h3>prefetch 的问题</h3>
<p>通过 chrome 的 performance 调试的时候发现，首页加载的时候会同时记载其他文件，包括所有的语言包都加载进来了。只是不是做了按需加载的处理了吗？其实，vue-cli 3 对项目的默认处理是将需要加载的文件都加载上，另外按需加载的文件，会用 link 链接的方式，并设置为 prefetch 来获得，初衷是好的，prefetch 的资源优先级最低，不会和当前需要的 js 文件抢优先级。只是这样有个严重问题，由于浏览器在 http 1.1 下允许同时发送 6 ~ 8 个网络请求，于是当首页的 js 文件下载的同时，存在空闲连接，其他的 prefetch 请求也会被发送出去。导致了和首页 js 文件抢夺有限带宽的情况。</p>
<p>根据这个情况需要修改 vue.config.js 中的配置，就可以了。</p>
<pre class="hljs"><code>config.plugins.delete(<span class="hljs-string">"prefetch"</span>);
</code></pre>
<p>经过上面几步下来，首屏渲染时间 FP 时间已经缩短到 4000+ms 了。</p>
<h3>百度地图优化</h3>
<p>通过 performance 再次分析发现，在首页初始化的时候，会把百度地图也加载上去，只是初始过程并不会直接渲染百度地图，而是有个和服务端交互的过程，这个过程会消耗几秒钟，之后才会显示出百度地图，这样的话，其实百度地图是不用打包进入首页的 chunk 文件的，可以异步加载。只是按照官网的介绍，vue-baidu-map 需要作为插件在 Vue 里面使用。如下方式:</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>;
<span class="hljs-keyword">import</span> BaiduMap <span class="hljs-keyword">from</span> <span class="hljs-string">"vue-baidu-map"</span>;

Vue.use(BaiduMap, {
  <span class="hljs-attr">ak</span>: <span class="hljs-string">"YOUR_APP_KEY"</span>
});
</code></pre>
<p>这种方式 100%会将 vue-baidu-map 打包进首页的包里面。那如何避免呢？这个就要分析 Vue.use 里面的源码了。</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initUse</span>(<span class="hljs-params">Vue: GlobalAPI</span>) </span>{
  Vue.use = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">plugin: Function | Object</span>) </span>{
    <span class="hljs-keyword">const</span> installedPlugins =
      <span class="hljs-keyword">this</span>._installedPlugins || (<span class="hljs-keyword">this</span>._installedPlugins = []);
    <span class="hljs-keyword">if</span> (installedPlugins.indexOf(plugin) &gt; <span class="hljs-number">-1</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

    <span class="hljs-comment">// additional parameters</span>
    <span class="hljs-keyword">const</span> args = toArray(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
    args.unshift(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin.install === <span class="hljs-string">"function"</span>) {
      plugin.install.apply(plugin, args);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin === <span class="hljs-string">"function"</span>) {
      plugin.apply(<span class="hljs-literal">null</span>, args);
    }
    installedPlugins.push(plugin);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
}
</code></pre>
<p>不难发现 <code>Vue.use</code> 最后执行的是 <code>vue-baidu-map</code> 的 install 方法，并传入 Vue 以及后面的参数对象。于是回头看 install 方法</p>
<pre class="hljs"><code>install (Vue, options) {
  <span class="hljs-keyword">const</span> {ak} = options
  Vue.prototype._BMap = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({ak})

  Vue.component(<span class="hljs-string">'baidu-map'</span>, BaiduMap)
  Vue.component(<span class="hljs-string">'bm-view'</span>, BmView)
  <span class="hljs-comment">// 省略其他的组件注释</span>
}

<span class="hljs-comment">// _BMap 使用方法</span>
<span class="hljs-keyword">const</span> ak = <span class="hljs-keyword">this</span>.ak || <span class="hljs-keyword">this</span>._BMap().ak;
</code></pre>
<p>install 里面的主要功能一个是给 Vue 构造函数的原型传入 <code>_BMap</code> 方法，<code>_BMap</code> 会在 Map 组件初始化的时候使用。于是摆在面前的就有两个问题</p>
<ol>
<li>能不能在组件里面使用 Vue.use 方法动态注册组件</li>
<li>isntall 里面 Vue 构造函数问题：包括了 _BMap 方法挂载，以及组件注册问题问题</li>
</ol>
<p>如果在组件里面引用 <code>Vue.use</code> 会发现此 Vue 非彼 Vue，即是引入的 Vue 和初始实例化的 Vue 的作用是有差别的，若使用同一个 Vue 函数，控制台又会提示其他问题。所以直接使用 <code>Vue.use</code> 在组件里面注册插件是不行的。那如果换成组件本身，用 <code>this.use</code> 呢，很可惜没有这个方法。这个时候可以看看 Vue 关于组件的源码：</p>
<pre class="hljs"><code><span class="hljs-comment">// _createElement 函数里面</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> tag === <span class="hljs-string">"string"</span>) {
  <span class="hljs-comment">// 省略部分代码</span>
  <span class="hljs-keyword">if</span> (
    (!data || !data.pre) &amp;&amp;
    isDef((Ctor = resolveAsset(context.$options, <span class="hljs-string">"components"</span>, tag)))
  ) {
    <span class="hljs-comment">// component</span>
    vnode = createComponent(Ctor, data, context, children, tag);
  }
}
<span class="hljs-comment">// createComponent 里面</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createComponent</span>(<span class="hljs-params">Ctor, data, context, children, tag</span>) </span>{
  <span class="hljs-comment">// 省略部分代码</span>
  <span class="hljs-keyword">if</span> (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }
}
<span class="hljs-comment">// extend 方法</span>
Vue.extend = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">extendOptions</span>) </span>{
  <span class="hljs-comment">// 省略部分代码</span>
  <span class="hljs-keyword">const</span> Super = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">const</span> Sub = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">VueComponent</span>(<span class="hljs-params">options</span>) </span>{
    <span class="hljs-keyword">this</span>._init(options);
  };
  Sub.prototype = <span class="hljs-built_in">Object</span>.create(Super.prototype);
  Sub.prototype.constructor = Sub;
  <span class="hljs-comment">// allow further extension/mixin/plugin usage</span>
  Sub.extend = Super.extend;
  Sub.mixin = Super.mixin;
  Sub.use = Super.use;
};
</code></pre>
<p>可以发现 <strong>组件的创建其实也是 Vue 的继承关系</strong> ，所以如果想在组件里面用 use 方法的话，就是 <code>this.constructor.use</code> 了，只是方法是可以用了，但是传入 vue-baidu-map 的不是 Vue 构造函数本身，而是组件的构造函数，这个构
造函数可以满足 <code>install</code> 方法里面的组件注册，调试一下，发现可以用~~只是其构造函数的 <code>prototype._BMap</code> 并不是 Vue 构造函数，完全不搭边，好在可以 vue-baidu-map 可以通过传递 <code>this.ak</code> 来解决问题；
最后的动态插件实现如下：</p>
<pre class="hljs"><code>created() {
  <span class="hljs-keyword">import</span>(<span class="hljs-string">'vue-baidu-map'</span>).then(<span class="hljs-function"><span class="hljs-params">BaiduMap</span> =&gt;</span> {
    BaiduMap.install = BaiduMap.default.install;
    <span class="hljs-keyword">this</span>.constructor.use(BaiduMap);
    <span class="hljs-keyword">this</span>.baiduLoading = <span class="hljs-literal">false</span>;
  })
}
</code></pre>
<p>上面的方式就可以将百度地图三方库从首页中拆分来，最后首页必须加载文件大小总减少 108 kb 。将首屏 FP 时间压缩到 3000+ms，首屏文件 js 加载大小为 200+ kb 的样子。基本上在 4G 网络或者 wife 的情况下，就可以 1s 内刷新出来了。</p>
<p>做到这一步差不多也就可以了，只是精益求精，还是想要提前 FP 时间。</p>
<h3>包体积优化再分析</h3>
<p>再回头看剩余的包体积，主要包含了 vue 的运行时，vue-router 、vue-i18n 和 core.js。这几个模块都是无法分离出来的，整体大小已经有 150kb 了。还有另外一个大的模块，主要包含业务代码、 axios 相关的模块和被转成 base64 的图片。这些模块也是分离不开来的呀。后面要如何优化好？</p>
<h3>暴力的 index.html</h3>
<p>想起之前看到的一篇文章，<a href="https://juejin.im/post/5b79a2786fb9a01a18267362" target="_blank">Vue 项目骨架屏注入实践</a> 想要学着同样处理一下，但是并没有相应的数据可以用到。</p>
<p>这个时候开始分析手头上的业务，初始记载后，会有一个请求服务器的过程，而服务需要多次轮询之后才有结果（服务端的性能太差了），等获取结果之后才会进入百度地图的页面，这就给了之前分离出百度地图包的契机了，反正百度地图不用立马加载。</p>
<p>那要如何解决中间的白屏问题呢？4G 下也要接近 1s。<strong>白屏时间为 webview 初始化，首页资源下载，vue 实例化，后面两者能不能都干掉呢？</strong> 仔细盯着首页初始化的过程，从白屏到初始化，到服务端多次轮询拿到结果，这个过程中，前端页面是没有什么大的变化的，只有一个 <code>loading</code> 的图案。webview 初始化后，加载的是打包生成的 <code>index.html</code>，然后再去加载其他 js 资源后，再运行 vue，<code>index.html</code> 只是一个充满连接的 html。于是一个想法就起来了，在 index.html 里面直接渲染出 loading 的界面，等 vue 实例化结束了之后，再隐藏掉，不就可以完美过度了吗？压根就不用等待其他 js 资源下载和 Vue 实例化。</p>
<p>于是很简单的，在根目录下，创建 <code>public/index.html</code>，并简单的用原生代码显示出 loading 界面，再调试一下，就完美了。</p>
<p>堪称完美，只要加载一个 <code>index.html</code> 就够了，怕 2G 下也是秒开吧~~~</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"March 24, 2021","title":"秒开 hybrid H5 优化记","content":"\u003cp\u003e记得刚做前端，接手移动端 H5 的时候，特别想要将应用优化到极致，想要达到秒开，流畅接近原生的效果，只是业务需求下一直没有时间去做这样或者那样的优化。这次自己接手一个 hybrid H5 项目，做完业务之后，一直想要优化，刚好又是我一个人负责前端，于是将平时的想法收集起来，周六加班做了个深入的优化（可惜才过了四天，就被通知项目要移交到其他团队）。避免涉密，后面的数据，都做了稍微修改。\u003c/p\u003e\n\u003ch2\u003e初始问题\u003c/h2\u003e\n\u003cp\u003e这个项目是基于百度地图做了一个应用，开始存在两个问题，一个是首屏白屏问题；从点击进入到开始到有内容的阶段，有个明显白屏的时间，这个时间是包含 webview 初始化，以及首屏渲染的时间。该首屏渲染的时间，FP 的时间在 Fast 3G 下，大概为 9000+ ms。原本的系统，其实已经做了路由的懒加载了。另外一个百度地图渲染漂移问题。\u003c/p\u003e\n\u003cp\u003e对于上面的问题，一共做了七层优化，尤其是首屏加载问题。\u003c/p\u003e\n\u003ch2\u003e百度地图\u003c/h2\u003e\n\u003cp\u003e用 vue-baidu-map 来作为 Vue 项目的百度地图组件。只是在移动端存在严重的问题，其覆盖物在移动端渲染性能差，稍微用手拖动一下百度地图，其上面的文字或者自定义的图形都会出现颤抖，而在 pc 端是没有这样的问题，官网的示例也是如此，只是采用覆盖物-点的方式，却能很好的避免颤抖的情况。\u003c/p\u003e\n\u003cp\u003e若是直接采用百度地图的方式，而不是用 vue-baidu-map，其效果会好很多，不会有颤抖问题。只是想要试试新的 vue-baidu-map，而不是一直用老的方式。由于百度地图的代码没有开源出来，查看 vue-baidu-map 中的实现方式，也无特别收获， vue-baidu-map 只是做了一个 Vue 和百度地图的数据驱动的绑定而已，这给调试代码带来了很大的阻挠。后面为了方便调试， \u003cstrong\u003e采用 chrome 的 rendering 来调试代码，发现自定义覆盖物在拖动地图的时候，会反复变深绿色，而使用点覆盖物，只会时不时变深绿色\u003c/strong\u003e。点覆盖物性能确实要比自定义以及其他覆盖物要很多。后面改为点覆盖物，效果真的提高了不少。\u003c/p\u003e\n\u003cp\u003e另外经过多次调试后发现高德地图真的要比百度地图好，有三维模式，而且 webview 支持好一些，只是定位没有百度地图准。\u003c/p\u003e\n\u003ch2\u003e首屏优化\u003c/h2\u003e\n\u003cp\u003e由于项目需要适配多语言，而之前的语言包，加起来有 1M+ 的大小，只是里面的冗余数据比较多，需要用到信息并没有那么多，于是采用 nodejs，对每个语言文件进行解析，输出对应的简化版本的 json 文件。nodejs 采用 walkdir 模块遍历所有语言包，并输出为简化版本文件。可以将包的体积减少到 3/5 的水平，并采用按需加载。\u003c/p\u003e\n\u003ch3\u003elottie 优化\u003c/h3\u003e\n\u003cp\u003e为了更好的还原动画采用的是 lottie + json 数据的方式，实现动效。只是设计最后给出来的一个动效 html 都要接近 300kb，这个是无法接受的，而且其实动画尺寸非常小，就是个简单 icon，采用 30 帧的序列帧体积也要 170kb，很大，而且设计为了统一管理，统一规范，推荐的还是采用 lottie 方案。后面在一篇腾讯 alloyteam 的文章里面有介绍到 lottie-web 仓库的 lottie_light.min.js 只用 140+kb，完整版的要 240+ kb，虽然只支持 svg，但是已经很够用了。\u003c/p\u003e\n\u003cp\u003e再加上异步组件和懒加载 lottie_light.min.js 和对应的 json 数据，可以大大的减少首屏渲染压力\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 异步组件方式\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003ecomponents\u003c/span\u003e: {\n  \u003cspan class=\"hljs-attr\"\u003eLottieComponent\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"./LottieComponent\"\u003c/span\u003e);\n}\n\u003cspan class=\"hljs-comment\"\u003e// 懒加载Lottie文件\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [lottie, lottieAnimationData] = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.all([\n  \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-comment\"\u003e/* webpackChunkName: \"lottieLightMin\" */\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./lottie_light.min\"\u003c/span\u003e),\n  \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-comment\"\u003e/* webpackChunkName: \"lottieComponent\" */\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./lottieComponentData\"\u003c/span\u003e)\n]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e使得 lottie + json 数据文件大小在接近 200kb 的水平，并达到了按需加载的目的。\u003c/p\u003e\n\u003cp\u003e最后还想采用将 lottie 文件内置到客户端里面，请求的时候，拦截返回 lottie 文件给到前端就可以了，可惜客户端做的是小白。。。。\u003c/p\u003e\n\u003ch3\u003e图形压缩\u003c/h3\u003e\n\u003cp\u003e之前介绍过图像优化，该项目使用的图像有不是很多，通过有效压缩，可以减少 30% 的体积，只是需要注意的是有些首页的图像，在低于 10 kb 的时候，会被 Vue-cli3 打包进首页的 js 文件里面，导致文件臃肿，于是需要观察图片大小，以及配置对应的 vue.config 来达到最优解，本项目刚好是 10 kb， 附近有几个图像被打包进去了，修改 loader 对应的配置值就可以了。\u003c/p\u003e\n\u003ch3\u003eprefetch 的问题\u003c/h3\u003e\n\u003cp\u003e通过 chrome 的 performance 调试的时候发现，首页加载的时候会同时记载其他文件，包括所有的语言包都加载进来了。只是不是做了按需加载的处理了吗？其实，vue-cli 3 对项目的默认处理是将需要加载的文件都加载上，另外按需加载的文件，会用 link 链接的方式，并设置为 prefetch 来获得，初衷是好的，prefetch 的资源优先级最低，不会和当前需要的 js 文件抢优先级。只是这样有个严重问题，由于浏览器在 http 1.1 下允许同时发送 6 ~ 8 个网络请求，于是当首页的 js 文件下载的同时，存在空闲连接，其他的 prefetch 请求也会被发送出去。导致了和首页 js 文件抢夺有限带宽的情况。\u003c/p\u003e\n\u003cp\u003e根据这个情况需要修改 vue.config.js 中的配置，就可以了。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003econfig.plugins.delete(\u003cspan class=\"hljs-string\"\u003e\"prefetch\"\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e经过上面几步下来，首屏渲染时间 FP 时间已经缩短到 4000+ms 了。\u003c/p\u003e\n\u003ch3\u003e百度地图优化\u003c/h3\u003e\n\u003cp\u003e通过 performance 再次分析发现，在首页初始化的时候，会把百度地图也加载上去，只是初始过程并不会直接渲染百度地图，而是有个和服务端交互的过程，这个过程会消耗几秒钟，之后才会显示出百度地图，这样的话，其实百度地图是不用打包进入首页的 chunk 文件的，可以异步加载。只是按照官网的介绍，vue-baidu-map 需要作为插件在 Vue 里面使用。如下方式:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Vue \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"vue\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e BaiduMap \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"vue-baidu-map\"\u003c/span\u003e;\n\nVue.use(BaiduMap, {\n  \u003cspan class=\"hljs-attr\"\u003eak\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"YOUR_APP_KEY\"\u003c/span\u003e\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这种方式 100%会将 vue-baidu-map 打包进首页的包里面。那如何避免呢？这个就要分析 Vue.use 里面的源码了。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003einitUse\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eVue: GlobalAPI\u003c/span\u003e) \u003c/span\u003e{\n  Vue.use = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eplugin: Function | Object\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e installedPlugins =\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._installedPlugins || (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._installedPlugins = []);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (installedPlugins.indexOf(plugin) \u0026gt; \u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// additional parameters\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e args = toArray(\u003cspan class=\"hljs-built_in\"\u003earguments\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n    args.unshift(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e plugin.install === \u003cspan class=\"hljs-string\"\u003e\"function\"\u003c/span\u003e) {\n      plugin.install.apply(plugin, args);\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e plugin === \u003cspan class=\"hljs-string\"\u003e\"function\"\u003c/span\u003e) {\n      plugin.apply(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, args);\n    }\n    installedPlugins.push(plugin);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e不难发现 \u003ccode\u003eVue.use\u003c/code\u003e 最后执行的是 \u003ccode\u003evue-baidu-map\u003c/code\u003e 的 install 方法，并传入 Vue 以及后面的参数对象。于是回头看 install 方法\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003einstall (Vue, options) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e {ak} = options\n  Vue.prototype._BMap = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e ({ak})\n\n  Vue.component(\u003cspan class=\"hljs-string\"\u003e'baidu-map'\u003c/span\u003e, BaiduMap)\n  Vue.component(\u003cspan class=\"hljs-string\"\u003e'bm-view'\u003c/span\u003e, BmView)\n  \u003cspan class=\"hljs-comment\"\u003e// 省略其他的组件注释\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// _BMap 使用方法\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ak = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.ak || \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._BMap().ak;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003einstall 里面的主要功能一个是给 Vue 构造函数的原型传入 \u003ccode\u003e_BMap\u003c/code\u003e 方法，\u003ccode\u003e_BMap\u003c/code\u003e 会在 Map 组件初始化的时候使用。于是摆在面前的就有两个问题\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e能不能在组件里面使用 Vue.use 方法动态注册组件\u003c/li\u003e\n\u003cli\u003eisntall 里面 Vue 构造函数问题：包括了 _BMap 方法挂载，以及组件注册问题问题\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e如果在组件里面引用 \u003ccode\u003eVue.use\u003c/code\u003e 会发现此 Vue 非彼 Vue，即是引入的 Vue 和初始实例化的 Vue 的作用是有差别的，若使用同一个 Vue 函数，控制台又会提示其他问题。所以直接使用 \u003ccode\u003eVue.use\u003c/code\u003e 在组件里面注册插件是不行的。那如果换成组件本身，用 \u003ccode\u003ethis.use\u003c/code\u003e 呢，很可惜没有这个方法。这个时候可以看看 Vue 关于组件的源码：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// _createElement 函数里面\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e tag === \u003cspan class=\"hljs-string\"\u003e\"string\"\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n    (!data || !data.pre) \u0026amp;\u0026amp;\n    isDef((Ctor = resolveAsset(context.$options, \u003cspan class=\"hljs-string\"\u003e\"components\"\u003c/span\u003e, tag)))\n  ) {\n    \u003cspan class=\"hljs-comment\"\u003e// component\u003c/span\u003e\n    vnode = createComponent(Ctor, data, context, children, tag);\n  }\n}\n\u003cspan class=\"hljs-comment\"\u003e// createComponent 里面\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecreateComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eCtor, data, context, children, tag\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n}\n\u003cspan class=\"hljs-comment\"\u003e// extend 方法\u003c/span\u003e\nVue.extend = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eextendOptions\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Super = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Sub = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eVueComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eoptions\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._init(options);\n  };\n  Sub.prototype = \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.create(Super.prototype);\n  Sub.prototype.constructor = Sub;\n  \u003cspan class=\"hljs-comment\"\u003e// allow further extension/mixin/plugin usage\u003c/span\u003e\n  Sub.extend = Super.extend;\n  Sub.mixin = Super.mixin;\n  Sub.use = Super.use;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以发现 \u003cstrong\u003e组件的创建其实也是 Vue 的继承关系\u003c/strong\u003e ，所以如果想在组件里面用 use 方法的话，就是 \u003ccode\u003ethis.constructor.use\u003c/code\u003e 了，只是方法是可以用了，但是传入 vue-baidu-map 的不是 Vue 构造函数本身，而是组件的构造函数，这个构\n造函数可以满足 \u003ccode\u003einstall\u003c/code\u003e 方法里面的组件注册，调试一下，发现可以用~~只是其构造函数的 \u003ccode\u003eprototype._BMap\u003c/code\u003e 并不是 Vue 构造函数，完全不搭边，好在可以 vue-baidu-map 可以通过传递 \u003ccode\u003ethis.ak\u003c/code\u003e 来解决问题；\n最后的动态插件实现如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003ecreated() {\n  \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'vue-baidu-map'\u003c/span\u003e).then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eBaiduMap\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    BaiduMap.install = BaiduMap.default.install;\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.constructor.use(BaiduMap);\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.baiduLoading = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面的方式就可以将百度地图三方库从首页中拆分来，最后首页必须加载文件大小总减少 108 kb 。将首屏 FP 时间压缩到 3000+ms，首屏文件 js 加载大小为 200+ kb 的样子。基本上在 4G 网络或者 wife 的情况下，就可以 1s 内刷新出来了。\u003c/p\u003e\n\u003cp\u003e做到这一步差不多也就可以了，只是精益求精，还是想要提前 FP 时间。\u003c/p\u003e\n\u003ch3\u003e包体积优化再分析\u003c/h3\u003e\n\u003cp\u003e再回头看剩余的包体积，主要包含了 vue 的运行时，vue-router 、vue-i18n 和 core.js。这几个模块都是无法分离出来的，整体大小已经有 150kb 了。还有另外一个大的模块，主要包含业务代码、 axios 相关的模块和被转成 base64 的图片。这些模块也是分离不开来的呀。后面要如何优化好？\u003c/p\u003e\n\u003ch3\u003e暴力的 index.html\u003c/h3\u003e\n\u003cp\u003e想起之前看到的一篇文章，\u003ca href=\"https://juejin.im/post/5b79a2786fb9a01a18267362\" target=\"_blank\"\u003eVue 项目骨架屏注入实践\u003c/a\u003e 想要学着同样处理一下，但是并没有相应的数据可以用到。\u003c/p\u003e\n\u003cp\u003e这个时候开始分析手头上的业务，初始记载后，会有一个请求服务器的过程，而服务需要多次轮询之后才有结果（服务端的性能太差了），等获取结果之后才会进入百度地图的页面，这就给了之前分离出百度地图包的契机了，反正百度地图不用立马加载。\u003c/p\u003e\n\u003cp\u003e那要如何解决中间的白屏问题呢？4G 下也要接近 1s。\u003cstrong\u003e白屏时间为 webview 初始化，首页资源下载，vue 实例化，后面两者能不能都干掉呢？\u003c/strong\u003e 仔细盯着首页初始化的过程，从白屏到初始化，到服务端多次轮询拿到结果，这个过程中，前端页面是没有什么大的变化的，只有一个 \u003ccode\u003eloading\u003c/code\u003e 的图案。webview 初始化后，加载的是打包生成的 \u003ccode\u003eindex.html\u003c/code\u003e，然后再去加载其他 js 资源后，再运行 vue，\u003ccode\u003eindex.html\u003c/code\u003e 只是一个充满连接的 html。于是一个想法就起来了，在 index.html 里面直接渲染出 loading 的界面，等 vue 实例化结束了之后，再隐藏掉，不就可以完美过度了吗？压根就不用等待其他 js 资源下载和 Vue 实例化。\u003c/p\u003e\n\u003cp\u003e于是很简单的，在根目录下，创建 \u003ccode\u003epublic/index.html\u003c/code\u003e，并简单的用原生代码显示出 loading 界面，再调试一下，就完美了。\u003c/p\u003e\n\u003cp\u003e堪称完美，只要加载一个 \u003ccode\u003eindex.html\u003c/code\u003e 就够了，怕 2G 下也是秒开吧~~~\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"March 24, 2021","title":"秒开 hybrid H5 优化记","content":"\u003cp\u003e记得刚做前端，接手移动端 H5 的时候，特别想要将应用优化到极致，想要达到秒开，流畅接近原生的效果，只是业务需求下一直没有时间去做这样或者那样的优化。这次自己接手一个 hybrid H5 项目，做完业务之后，一直想要优化，刚好又是我一个人负责前端，于是将平时的想法收集起来，周六加班做了个深入的优化（可惜才过了四天，就被通知项目要移交到其他团队）。避免涉密，后面的数据，都做了稍微修改。\u003c/p\u003e\n\u003ch2\u003e初始问题\u003c/h2\u003e\n\u003cp\u003e这个项目是基于百度地图做了一个应用，开始存在两个问题，一个是首屏白屏问题；从点击进入到开始到有内容的阶段，有个明显白屏的时间，这个时间是包含 webview 初始化，以及首屏渲染的时间。该首屏渲染的时间，FP 的时间在 Fast 3G 下，大概为 9000+ ms。原本的系统，其实已经做了路由的懒加载了。另外一个百度地图渲染漂移问题。\u003c/p\u003e\n\u003cp\u003e对于上面的问题，一共做了七层优化，尤其是首屏加载问题。\u003c/p\u003e\n\u003ch2\u003e百度地图\u003c/h2\u003e\n\u003cp\u003e用 vue-baidu-map 来作为 Vue 项目的百度地图组件。只是在移动端存在严重的问题，其覆盖物在移动端渲染性能差，稍微用手拖动一下百度地图，其上面的文字或者自定义的图形都会出现颤抖，而在 pc 端是没有这样的问题，官网的示例也是如此，只是采用覆盖物-点的方式，却能很好的避免颤抖的情况。\u003c/p\u003e\n\u003cp\u003e若是直接采用百度地图的方式，而不是用 vue-baidu-map，其效果会好很多，不会有颤抖问题。只是想要试试新的 vue-baidu-map，而不是一直用老的方式。由于百度地图的代码没有开源出来，查看 vue-baidu-map 中的实现方式，也无特别收获， vue-baidu-map 只是做了一个 Vue 和百度地图的数据驱动的绑定而已，这给调试代码带来了很大的阻挠。后面为了方便调试， \u003cstrong\u003e采用 chrome 的 rendering 来调试代码，发现自定义覆盖物在拖动地图的时候，会反复变深绿色，而使用点覆盖物，只会时不时变深绿色\u003c/strong\u003e。点覆盖物性能确实要比自定义以及其他覆盖物要很多。后面改为点覆盖物，效果真的提高了不少。\u003c/p\u003e\n\u003cp\u003e另外经过多次调试后发现高德地图真的要比百度地图好，有三维模式，而且 webview 支持好一些，只是定位没有百度地图准。\u003c/p\u003e\n\u003ch2\u003e首屏优化\u003c/h2\u003e\n\u003cp\u003e由于项目需要适配多语言，而之前的语言包，加起来有 1M+ 的大小，只是里面的冗余数据比较多，需要用到信息并没有那么多，于是采用 nodejs，对每个语言文件进行解析，输出对应的简化版本的 json 文件。nodejs 采用 walkdir 模块遍历所有语言包，并输出为简化版本文件。可以将包的体积减少到 3/5 的水平，并采用按需加载。\u003c/p\u003e\n\u003ch3\u003elottie 优化\u003c/h3\u003e\n\u003cp\u003e为了更好的还原动画采用的是 lottie + json 数据的方式，实现动效。只是设计最后给出来的一个动效 html 都要接近 300kb，这个是无法接受的，而且其实动画尺寸非常小，就是个简单 icon，采用 30 帧的序列帧体积也要 170kb，很大，而且设计为了统一管理，统一规范，推荐的还是采用 lottie 方案。后面在一篇腾讯 alloyteam 的文章里面有介绍到 lottie-web 仓库的 lottie_light.min.js 只用 140+kb，完整版的要 240+ kb，虽然只支持 svg，但是已经很够用了。\u003c/p\u003e\n\u003cp\u003e再加上异步组件和懒加载 lottie_light.min.js 和对应的 json 数据，可以大大的减少首屏渲染压力\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 异步组件方式\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003ecomponents\u003c/span\u003e: {\n  \u003cspan class=\"hljs-attr\"\u003eLottieComponent\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"./LottieComponent\"\u003c/span\u003e);\n}\n\u003cspan class=\"hljs-comment\"\u003e// 懒加载Lottie文件\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [lottie, lottieAnimationData] = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.all([\n  \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-comment\"\u003e/* webpackChunkName: \"lottieLightMin\" */\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./lottie_light.min\"\u003c/span\u003e),\n  \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-comment\"\u003e/* webpackChunkName: \"lottieComponent\" */\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./lottieComponentData\"\u003c/span\u003e)\n]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e使得 lottie + json 数据文件大小在接近 200kb 的水平，并达到了按需加载的目的。\u003c/p\u003e\n\u003cp\u003e最后还想采用将 lottie 文件内置到客户端里面，请求的时候，拦截返回 lottie 文件给到前端就可以了，可惜客户端做的是小白。。。。\u003c/p\u003e\n\u003ch3\u003e图形压缩\u003c/h3\u003e\n\u003cp\u003e之前介绍过图像优化，该项目使用的图像有不是很多，通过有效压缩，可以减少 30% 的体积，只是需要注意的是有些首页的图像，在低于 10 kb 的时候，会被 Vue-cli3 打包进首页的 js 文件里面，导致文件臃肿，于是需要观察图片大小，以及配置对应的 vue.config 来达到最优解，本项目刚好是 10 kb， 附近有几个图像被打包进去了，修改 loader 对应的配置值就可以了。\u003c/p\u003e\n\u003ch3\u003eprefetch 的问题\u003c/h3\u003e\n\u003cp\u003e通过 chrome 的 performance 调试的时候发现，首页加载的时候会同时记载其他文件，包括所有的语言包都加载进来了。只是不是做了按需加载的处理了吗？其实，vue-cli 3 对项目的默认处理是将需要加载的文件都加载上，另外按需加载的文件，会用 link 链接的方式，并设置为 prefetch 来获得，初衷是好的，prefetch 的资源优先级最低，不会和当前需要的 js 文件抢优先级。只是这样有个严重问题，由于浏览器在 http 1.1 下允许同时发送 6 ~ 8 个网络请求，于是当首页的 js 文件下载的同时，存在空闲连接，其他的 prefetch 请求也会被发送出去。导致了和首页 js 文件抢夺有限带宽的情况。\u003c/p\u003e\n\u003cp\u003e根据这个情况需要修改 vue.config.js 中的配置，就可以了。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003econfig.plugins.delete(\u003cspan class=\"hljs-string\"\u003e\"prefetch\"\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e经过上面几步下来，首屏渲染时间 FP 时间已经缩短到 4000+ms 了。\u003c/p\u003e\n\u003ch3\u003e百度地图优化\u003c/h3\u003e\n\u003cp\u003e通过 performance 再次分析发现，在首页初始化的时候，会把百度地图也加载上去，只是初始过程并不会直接渲染百度地图，而是有个和服务端交互的过程，这个过程会消耗几秒钟，之后才会显示出百度地图，这样的话，其实百度地图是不用打包进入首页的 chunk 文件的，可以异步加载。只是按照官网的介绍，vue-baidu-map 需要作为插件在 Vue 里面使用。如下方式:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Vue \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"vue\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e BaiduMap \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"vue-baidu-map\"\u003c/span\u003e;\n\nVue.use(BaiduMap, {\n  \u003cspan class=\"hljs-attr\"\u003eak\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"YOUR_APP_KEY\"\u003c/span\u003e\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这种方式 100%会将 vue-baidu-map 打包进首页的包里面。那如何避免呢？这个就要分析 Vue.use 里面的源码了。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003einitUse\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eVue: GlobalAPI\u003c/span\u003e) \u003c/span\u003e{\n  Vue.use = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eplugin: Function | Object\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e installedPlugins =\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._installedPlugins || (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._installedPlugins = []);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (installedPlugins.indexOf(plugin) \u0026gt; \u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// additional parameters\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e args = toArray(\u003cspan class=\"hljs-built_in\"\u003earguments\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n    args.unshift(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e plugin.install === \u003cspan class=\"hljs-string\"\u003e\"function\"\u003c/span\u003e) {\n      plugin.install.apply(plugin, args);\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e plugin === \u003cspan class=\"hljs-string\"\u003e\"function\"\u003c/span\u003e) {\n      plugin.apply(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, args);\n    }\n    installedPlugins.push(plugin);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e不难发现 \u003ccode\u003eVue.use\u003c/code\u003e 最后执行的是 \u003ccode\u003evue-baidu-map\u003c/code\u003e 的 install 方法，并传入 Vue 以及后面的参数对象。于是回头看 install 方法\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003einstall (Vue, options) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e {ak} = options\n  Vue.prototype._BMap = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e ({ak})\n\n  Vue.component(\u003cspan class=\"hljs-string\"\u003e'baidu-map'\u003c/span\u003e, BaiduMap)\n  Vue.component(\u003cspan class=\"hljs-string\"\u003e'bm-view'\u003c/span\u003e, BmView)\n  \u003cspan class=\"hljs-comment\"\u003e// 省略其他的组件注释\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// _BMap 使用方法\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ak = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.ak || \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._BMap().ak;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003einstall 里面的主要功能一个是给 Vue 构造函数的原型传入 \u003ccode\u003e_BMap\u003c/code\u003e 方法，\u003ccode\u003e_BMap\u003c/code\u003e 会在 Map 组件初始化的时候使用。于是摆在面前的就有两个问题\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e能不能在组件里面使用 Vue.use 方法动态注册组件\u003c/li\u003e\n\u003cli\u003eisntall 里面 Vue 构造函数问题：包括了 _BMap 方法挂载，以及组件注册问题问题\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e如果在组件里面引用 \u003ccode\u003eVue.use\u003c/code\u003e 会发现此 Vue 非彼 Vue，即是引入的 Vue 和初始实例化的 Vue 的作用是有差别的，若使用同一个 Vue 函数，控制台又会提示其他问题。所以直接使用 \u003ccode\u003eVue.use\u003c/code\u003e 在组件里面注册插件是不行的。那如果换成组件本身，用 \u003ccode\u003ethis.use\u003c/code\u003e 呢，很可惜没有这个方法。这个时候可以看看 Vue 关于组件的源码：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// _createElement 函数里面\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e tag === \u003cspan class=\"hljs-string\"\u003e\"string\"\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n    (!data || !data.pre) \u0026amp;\u0026amp;\n    isDef((Ctor = resolveAsset(context.$options, \u003cspan class=\"hljs-string\"\u003e\"components\"\u003c/span\u003e, tag)))\n  ) {\n    \u003cspan class=\"hljs-comment\"\u003e// component\u003c/span\u003e\n    vnode = createComponent(Ctor, data, context, children, tag);\n  }\n}\n\u003cspan class=\"hljs-comment\"\u003e// createComponent 里面\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecreateComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eCtor, data, context, children, tag\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n}\n\u003cspan class=\"hljs-comment\"\u003e// extend 方法\u003c/span\u003e\nVue.extend = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eextendOptions\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Super = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Sub = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eVueComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eoptions\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._init(options);\n  };\n  Sub.prototype = \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.create(Super.prototype);\n  Sub.prototype.constructor = Sub;\n  \u003cspan class=\"hljs-comment\"\u003e// allow further extension/mixin/plugin usage\u003c/span\u003e\n  Sub.extend = Super.extend;\n  Sub.mixin = Super.mixin;\n  Sub.use = Super.use;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以发现 \u003cstrong\u003e组件的创建其实也是 Vue 的继承关系\u003c/strong\u003e ，所以如果想在组件里面用 use 方法的话，就是 \u003ccode\u003ethis.constructor.use\u003c/code\u003e 了，只是方法是可以用了，但是传入 vue-baidu-map 的不是 Vue 构造函数本身，而是组件的构造函数，这个构\n造函数可以满足 \u003ccode\u003einstall\u003c/code\u003e 方法里面的组件注册，调试一下，发现可以用~~只是其构造函数的 \u003ccode\u003eprototype._BMap\u003c/code\u003e 并不是 Vue 构造函数，完全不搭边，好在可以 vue-baidu-map 可以通过传递 \u003ccode\u003ethis.ak\u003c/code\u003e 来解决问题；\n最后的动态插件实现如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003ecreated() {\n  \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'vue-baidu-map'\u003c/span\u003e).then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eBaiduMap\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    BaiduMap.install = BaiduMap.default.install;\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.constructor.use(BaiduMap);\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.baiduLoading = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面的方式就可以将百度地图三方库从首页中拆分来，最后首页必须加载文件大小总减少 108 kb 。将首屏 FP 时间压缩到 3000+ms，首屏文件 js 加载大小为 200+ kb 的样子。基本上在 4G 网络或者 wife 的情况下，就可以 1s 内刷新出来了。\u003c/p\u003e\n\u003cp\u003e做到这一步差不多也就可以了，只是精益求精，还是想要提前 FP 时间。\u003c/p\u003e\n\u003ch3\u003e包体积优化再分析\u003c/h3\u003e\n\u003cp\u003e再回头看剩余的包体积，主要包含了 vue 的运行时，vue-router 、vue-i18n 和 core.js。这几个模块都是无法分离出来的，整体大小已经有 150kb 了。还有另外一个大的模块，主要包含业务代码、 axios 相关的模块和被转成 base64 的图片。这些模块也是分离不开来的呀。后面要如何优化好？\u003c/p\u003e\n\u003ch3\u003e暴力的 index.html\u003c/h3\u003e\n\u003cp\u003e想起之前看到的一篇文章，\u003ca href=\"https://juejin.im/post/5b79a2786fb9a01a18267362\" target=\"_blank\"\u003eVue 项目骨架屏注入实践\u003c/a\u003e 想要学着同样处理一下，但是并没有相应的数据可以用到。\u003c/p\u003e\n\u003cp\u003e这个时候开始分析手头上的业务，初始记载后，会有一个请求服务器的过程，而服务需要多次轮询之后才有结果（服务端的性能太差了），等获取结果之后才会进入百度地图的页面，这就给了之前分离出百度地图包的契机了，反正百度地图不用立马加载。\u003c/p\u003e\n\u003cp\u003e那要如何解决中间的白屏问题呢？4G 下也要接近 1s。\u003cstrong\u003e白屏时间为 webview 初始化，首页资源下载，vue 实例化，后面两者能不能都干掉呢？\u003c/strong\u003e 仔细盯着首页初始化的过程，从白屏到初始化，到服务端多次轮询拿到结果，这个过程中，前端页面是没有什么大的变化的，只有一个 \u003ccode\u003eloading\u003c/code\u003e 的图案。webview 初始化后，加载的是打包生成的 \u003ccode\u003eindex.html\u003c/code\u003e，然后再去加载其他 js 资源后，再运行 vue，\u003ccode\u003eindex.html\u003c/code\u003e 只是一个充满连接的 html。于是一个想法就起来了，在 index.html 里面直接渲染出 loading 的界面，等 vue 实例化结束了之后，再隐藏掉，不就可以完美过度了吗？压根就不用等待其他 js 资源下载和 Vue 实例化。\u003c/p\u003e\n\u003cp\u003e于是很简单的，在根目录下，创建 \u003ccode\u003epublic/index.html\u003c/code\u003e，并简单的用原生代码显示出 loading 界面，再调试一下，就完美了。\u003c/p\u003e\n\u003cp\u003e堪称完美，只要加载一个 \u003ccode\u003eindex.html\u003c/code\u003e 就够了，怕 2G 下也是秒开吧~~~\u003c/p\u003e\n"}},"buildId":"r4Ww0YLm8YL5~6SwciWHH","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" async=""></script></body></html>