<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">Vue3 的hoist与diff</title><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.587c5e31.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___2dTZ9 "><a class="logo___346dE" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___13XXt" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___29Pln"><h1 class="postTitle___1_m4g">Vue3 的hoist与diff</h1><span class="postTime___1x0_i">March 24, 2021</span></header><article class="postWrapper___3jnNg post-article"><div><p>5 月天空最蓝的时候就想要学习 Vue3 的内容，只是耐心被炎热的夏天打散，代码久久都没有看一行。在工作和发呆中，深圳的秋天好像也来，官网落幕后的国庆，大家都回去团聚的时候，提笔回顾一下 Vue3 的内容，也顺便更新一下博客，算是除除草？今年其实更想的去其他深水区探索一下，只是从去年探索到今年，最后，还是回来看 Vue3 了，也是一种无奈吧。</p>
<h2>Vue3</h2>
<p>以前的 Vue 像一个黑匣子的，对于开发者而言只是用 sfc 写 template 就足够了，最多偶尔写写 render 函数，灵活度是远远没有 React 方便的。（惭愧，刚没有写几行，国庆又出去玩了，再次提笔已经是 7 号了。。。惭愧）。这次的 Vue3 可以说做的非常彻底，基本把所有 api 都提供出来了，你甚至可以自己写 compile 好的函数。</p>
<h2>hosit 优化</h2>
<p>在 Compile 阶段三部曲，transform 中会有一个编译优化的过程，可以看下面两段生成代码的差异:</p>
<pre class="hljs"><code><span class="hljs-comment">// 原代码</span>
createApp({
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;div&gt;
      &lt;a data-name="1"&gt;
        &lt;li&gt;123&lt;/li&gt;
      &lt;/a&gt;
    &lt;/div&gt;
  `</span>,
}).mount(<span class="hljs-string">"#app"</span>);

<span class="hljs-comment">// compile 生成的代码 没有 hoist 的代码</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">_ctx, _cache</span>) </span>{
  <span class="hljs-keyword">return</span> (
    _openBlock(),
    _createBlock(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, [
      _createVNode(<span class="hljs-string">"a"</span>, { <span class="hljs-string">"data-name"</span>: <span class="hljs-string">"1"</span> }, [
        _createVNode(<span class="hljs-string">"li"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"123"</span>),
      ]),
    ])
  );
}

<span class="hljs-comment">// 设置 hoistStatic 为 true 时</span>
<span class="hljs-keyword">const</span> _hoisted_1 = <span class="hljs-comment">/*#__PURE__*/</span> _createVNode(
  <span class="hljs-string">"a"</span>,
  { <span class="hljs-string">"data-name"</span>: <span class="hljs-string">"1"</span> },
  [<span class="hljs-comment">/*#__PURE__*/</span> _createVNode(<span class="hljs-string">"li"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"123"</span>)],
  <span class="hljs-number">-1</span> <span class="hljs-comment">/* HOISTED */</span>
);
<span class="hljs-comment">// compile 生成的代码</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">_ctx, _cache</span>) </span>{
  <span class="hljs-keyword">return</span> _openBlock(), _createBlock(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, [_hoisted_1]);
}
</code></pre>
<p>可以看到开启 <code>hoistStatic</code>，会对静态代码部分，也就是 <code>&lt;a data-name=&quot;1&quot;&gt;&lt;li&gt;123&lt;/li&gt;&lt;/a&gt;</code> 进行提升的处理，声明提升到 return 函数前面。只有在第一次编译，才会生成 <code>_hoisted_1</code>，这样当局部更新的时候不用在生成 <code>_hoisted_1</code>， 直接引用就好了。可以减少 vnode 的更新计算。</p>
<p>当 <code>compile</code> 函数里面传入的 <code>hoistStatic = true</code>，则会开启 <code>hoist</code> 节点的静态处理。对于 sfc 文件模式，会采用 <code>doCompileTemplate</code>， 其 <code>hoistStatic</code> 默认是 <code>true</code>，如果非 sfc 方式，并且直接调用 compile，则默认为 false。</p>
<h3>生成 hoist</h3>
<p>这里就有一个问题，什么节点才是静态节点？为什么不默认生成？
这个判断比较复杂，需要遍历树的所有节点。下面有几个规则：</p>
<ol>
<li>
<p>根节点不做 <code>hosit</code> 处理，比如上面的 div 标签，避免父节点 props 透传使得其可能变成非静态节点。</p>
</li>
<li>
<p>对于 element 节点，需要节点树下的节点点没有 <strong>key、ref、绑定的 props、指令等以及变量文字</strong> （还有很多种情况要讨论的，比如常量资源等）。判断子节点是否静态的时候会采用缓存方式，避免后续的重复判断子节点。</p>
</li>
<li>
<p>props 也可以是 <code>hoist</code> 节点部分，当然不能是动态的部分，并且元素本身没有被 <code>hoist</code> 处理。</p>
</li>
<li>
<p>文本节点，本身为文本，如 <code>&lt;div /&gt;123</code> 里面的 <code>123</code> 也会被静态化。</p>
</li>
</ol>
<p>如果没有将节点静态化，会有进一步迭代子节点的情况。这里可以看到 <strong>将节点静态化，需要判断其所有子节点是否是静态。</strong></p>
<p>如果 DOM 里面存在其他的比如 <code>{{ state.count }}</code> 这些内容，对应的部分则不会被提升，但是其他的可以，比如</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">data-name</span>=<span class="hljs-string">"1"</span>&gt;</span>
    {{ state.count }}
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>这个时候 <code>a</code> 标签不会被 <code>hoist</code>，但是里面的 <code>li</code> 标签不受其影响，还会被静态化。</p>
<p><code>hoist</code> 生成时会被 <code>push</code> 到上下文的 hoists 上，生成 code 的时候会被提前处理，最后如上面所示，会先声明 <code>_hoisted_1</code>，并在返回的渲染函数里面，将 <code>_hoisted_1</code> 作为 child 传入。</p>
<p>这里有个问题，为什么普通的非 sfc 文件的编译，没有默认开启 <code>hoistStatic</code> 功能？可能是执行时间问题，原本的 <code>ast</code> 生成和 <code>transform</code> 过程都会遍历一次树，若开启 <code>hoistStatic</code>，最坏情况下还会遍历一次树，并且没有起到任何作用，只是这个解释有点牵强，可能是给开发者更多的选择吧？毕竟 <code>compile</code> 方法需要注册才能使用，而注册的过程需要开发者自己配置。</p>
<h3>stringifyStatic</h3>
<p>在 <code>hoist</code> 时，可能会将节点字符串化，比如下面:</p>
<pre class="hljs"><code><span class="hljs-comment">&lt;!-- 内容： --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"1"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"1"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"1"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"1"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"1"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<pre class="hljs"><code><span class="hljs-comment">// 生成如下</span>
<span class="hljs-keyword">const</span> _hoisted_1 = <span class="hljs-comment">/*#__PURE__*/</span> _createStaticVNode(
  <span class="hljs-string">'&lt;a href="1"&gt;&lt;/a&gt;&lt;a href="1"&gt;&lt;/a&gt;&lt;a href="1"&gt;&lt;/a&gt;&lt;a href="1"&gt;&lt;/a&gt;&lt;a href="1"&gt;&lt;/a&gt;'</span>,
  <span class="hljs-number">5</span>
);
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">_ctx, _cache</span>) </span>{
  <span class="hljs-keyword">return</span> _openBlock(), _createBlock(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, [_hoisted_1]);
}
</code></pre>
<p>可以看到原本会被 hoist 提升的静态节点，也就是 5 个会通过 <code>createVnode</code> 创建 vnode，现在进一步直接变成了字符串。自然是减少了 vnode 的生成，原本要生成 5 个 hoist 以及其 props 的，现在只要一个字符串。当然字符串节点最大的好处，还是渲染挂载 DOM 的时，可以让 <code>parent.innerHTML = 字符串</code>，简单直接效率高，不用一步步遍历子节点。这可以说是比上面的变量提升要彻底很多。完全静态的代码，直接设置 <code>innerHTML</code>，其他什么的都不需要。</p>
<p><strong>当然这个功能只有编译阶段为非浏览器环境才会开启，也就是 nodejs 环境</strong>，为什么呢？因为静态节点字符串化的生成判断是比较耗性能的。</p>
<p>生成字符串节点，首先必须是 <code>hoist</code> 静态的节点。其次若子节点连续大于等于 20 个静态节点或者节点中有大于等于 5 个节点有 props，则会进入字符串化。</p>
<p>对于大于等于 20 个节点或者有大于等于 5 个节点有 props 的判断大致如下：</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> nc = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前节点数量</span>
<span class="hljs-keyword">let</span> ec = <span class="hljs-number">0</span>; <span class="hljs-comment">// 存在 props 的节点数量</span>
<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (; i &lt; children.length; i++) {
  <span class="hljs-keyword">const</span> hoisted = getHoistedNode(child)
  <span class="hljs-keyword">if</span> (hoisted) {
    <span class="hljs-keyword">const</span> node = child <span class="hljs-keyword">as</span> StringifiableNode
    <span class="hljs-keyword">const</span> result = analyzeNode(node)
    <span class="hljs-keyword">if</span> (result) {
      nc += result[<span class="hljs-number">0</span>]
      ec += result[<span class="hljs-number">1</span>]
      <span class="hljs-comment">// 节点 push 到 currentChunk 里面为后面 stringifyCurrentChunk 做准备</span>
      currentChunk.push(node)
      <span class="hljs-keyword">continue</span>
    }
  }
  i -= stringifyCurrentChunk(i)
  nc = <span class="hljs-number">0</span>
  ec = <span class="hljs-number">0</span>
  currentChunk.length = <span class="hljs-number">0</span>
}
stringifyCurrentChunk(i);
</code></pre>
<p>会对 parent 下所有的一级子节点遍历，如果遍历的时候发现节点可以静态化，就一直 <code>continue</code>，若不能，则对之前的可以静态化的节点进行 <code>stringifyCurrentChunk</code> 处理，并且重置 <code>nc</code> <code>ec</code> <code>currentChunk</code>。</p>
<p>上面是总体的流程，重点是 <code>analyzeNode</code> 和 <code>stringifyCurrentChunk</code>。</p>
<p>前者 <code>analyzeNode</code> 会不断的遍历所有嵌套的子节点，比如如下结构，会被认为存在 3 个静态节点。</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
</code></pre>
<p><code>analyzeNode</code> 里面还会对 props 判断，如果 props 不是常见的静态类型，则最后有 <code>result = false</code>，分为以下情况：</p>
<ol>
<li>如果已知的 attr，则可以静态化，因为 alt、src 这些，是 dom 本身就有的。</li>
<li>或者是已知的静态 binding，如 :src=&quot;1&quot;，这个可以静态化的，反之 :abc=&quot;1&quot;，就不可以。</li>
</ol>
<p>对于子节点，如果存在孙节点，则会继续遍历，若节点存在 props，则 <code>ec++</code>。</p>
<p><code>stringifyCurrentChunk</code> 会对收集到的可以静态字符串化的节点进行处理，但是这里的静态化，也是一个遍历的过程：</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> staticCall = createCallExpression(context.helper(CREATE_STATIC), [
  <span class="hljs-built_in">JSON</span>.stringify(
    currentChunk.map(<span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> stringifyNode(node, context)).join(<span class="hljs-string">""</span>)
  ),
  <span class="hljs-built_in">String</span>(currentChunk.length),
]);
</code></pre>
<p>每个节点，都会经过 <code>stringifyNode</code> 处理，最后 JSON 化。<code>stringifyNode</code> 里面会根据不同的节点类型来处理，并遍历树的所有节点，对于 class/style 还会特别处理。这里就不继续阐述里面的规则了。</p>
<p><strong>可以看出来，静态节点字符串化，效果虽然很好，但是其会对节点树进行两次遍历，一次是判断是否可以字符串化，一次是将节点转为字符串</strong> 过程比较耗时。至于能否两次合为一次，自然是不能的。</p>
<p>只是有个问题，为什么会是 20 个节点以上或者是 5 个含有 props 的节点就判断可以字符串化呢？如果定义 20 个节点为阈值，是为了避免过渡字符串化，那 5 个含有 props 的节点，又是什么考虑呢？这不是明明小于 20 个节点吗，还是认为存在 props 的节点，一般都有 4 个属性？</p>
<h2>diff</h2>
<p><code>diff</code> 的过程，在 Vue 和 React 里面，已经从原始的整个树更新对比，算法复杂度 O(n3) 转换成 O(n) 了。</p>
<blockquote>
<p>However, the state of the art algorithms have a complexity in the order of O(n3) where n is the number of elements in the tree.</p>
</blockquote>
<p>而这里的 O(n) 也不是最终的目标，比如 react，会将所有需要更新的串在一起，只处理有更新的节点（有点久了，应该是这样的吧），而 Vue3 的思路思路则是维护一个动态数组，<code>dynamicChildren</code>，应该说不是一个，而是每个 <code>block</code> 都存在 <code>dynamicChildren</code>，这个 <code>dynamicChildren</code> 是更新的主角，毕竟，静态节点就不用考虑更新了。</p>
<h3>dynamicChildren 生成</h3>
<p><code>dynamicChildren</code> 的生成是与 <code>createBlock</code> 函数绑定的，只有在 <code>createBlock</code> 里面才有可能生成 <code>dynamicChildren</code>。</p>
<p>比如下面代码</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">data-name</span>=<span class="hljs-string">"1"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>{{stat.count}}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>最后生成下面的 vnode：</p>
<pre class="hljs"><code><span class="hljs-comment">// vnode</span>
{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'div'</span>,
  <span class="hljs-attr">children</span>: [
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'a'</span>,
      <span class="hljs-attr">props</span>: [<span class="hljs-string">'data-name'</span>: <span class="hljs-number">1</span>],
      <span class="hljs-attr">children</span>: [
        { <span class="hljs-attr">type</span>: <span class="hljs-string">'li'</span>, <span class="hljs-attr">children</span>: <span class="hljs-string">'2'</span>, <span class="hljs-attr">patchFlag</span>: <span class="hljs-number">1</span> }
      ]
    }
  ],
  <span class="hljs-attr">dynamicChildren</span>: [
    { <span class="hljs-attr">type</span>: <span class="hljs-string">'li'</span>, <span class="hljs-attr">children</span>: <span class="hljs-string">'2'</span>, <span class="hljs-attr">patchFlag</span>: <span class="hljs-number">1</span> }
  ]
}
<span class="hljs-comment">// 对应的 compile函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">_ctx, _cache</span>) </span>{
  <span class="hljs-keyword">return</span> (_openBlock(), _createBlock(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, [
    _createVNode(<span class="hljs-string">"a"</span>, _hoisted_1, [
      _createVNode(<span class="hljs-string">"li"</span>, <span class="hljs-literal">null</span>, _toDisplayString(stat.count), <span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span>)
    ])
  ]))
}
</code></pre>
<p>可以看到最后生成的 <code>dynamicChildren</code> 部分只包含了动态内容，在后面的 <code>diff</code> 过程则完全可以将 a 标签忽略掉。同时也可以看到 <code>openBlock</code> 和 <code>createBlock</code>，前者需要在每次调用 <code>createBlock</code> 时触发，用来重置全局变量 <code>currentBlock</code> 数组，后者 <code>createBlock</code> 则会在子节点的 vnode 构建完成后，将这里的 div 标签生成 vnode，并将 <code>currentBlock</code> 赋予该 vnode 的 <code>dynamicChildren</code> 字段。</p>
<p><code>currentBlock</code> 数组会在生成 vnode 的时候收集节点，具体如下：</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (
  (shouldTrack &gt; <span class="hljs-number">0</span> || isRenderingTemplateSlot) &amp;&amp;
  !isBlockNode &amp;&amp;
  currentBlock &amp;&amp;
  (patchFlag &gt; <span class="hljs-number">0</span> || shapeFlag &amp; ShapeFlags.COMPONENT) &amp;&amp;
  patchFlag !== PatchFlags.HYDRATE_EVENTS
) {
  currentBlock.push(vnode);
}
</code></pre>
<p>这里的条件蛮多的，<code>shouldTrack</code> 表示目前处于实例生成更新阶段，也就是不是 <code>compile</code> 阶段，<code>isBlockNode</code> 是目前的 vnode 为 <code>block</code> 节点，也就是可以生成 <code>dynamicChildren</code>， <code>patchFlag</code> 这个是重点，大于 0 表示其为动态内容（当然事件监听 <code>PatchFlags.HYDRATE_EVENTS</code>，不在这里面）。后面会重点介绍 <code>patchFlag</code>。</p>
<h3>dynamicChildren 对比</h3>
<p>在更新的时候，会对比前一个 vnode 生成 <code>dynamicChildren</code>，与现在生成的 <code>dynamicChildren</code>，处理如下：</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> patchBlockChildren: PatchBlockChildrenFn = (
  oldChildren,
  newChildren,
  fallbackContainer,
  parentComponent,
  parentSuspense,
  isSVG
) =&gt; {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newChildren.length; i++) {
    <span class="hljs-keyword">const</span> oldVNode = oldChildren[i]
    <span class="hljs-keyword">const</span> newVNode = newChildren[i]
    <span class="hljs-keyword">const</span> container =
      oldVNode.type === Fragment ||
      !isSameVNodeType(oldVNode, newVNode) ||
      oldVNode.shapeFlag &amp; ShapeFlags.COMPONENT ||
      oldVNode.shapeFlag &amp; ShapeFlags.TELEPORT
        ? hostParentNode(oldVNode.el!)!
        : fallbackContainer
    patch(
      oldVNode,
      newVNode,
      container,
      <span class="hljs-literal">null</span>,
      parentComponent,
      parentSuspense,
      isSVG,
      <span class="hljs-literal">true</span>
    )
  }
}
</code></pre>
<p>在 <code>patchBlockChildren</code> 里面会对每一个新老的 <code>child</code> 一一对比，再通过 <code>patch</code> 来更新。只是看到这里就有一个问题了，在 <code>for</code> 语句里面可以看到是严格要求新老 <code>dynamicChildren</code> 数组的长度是一致的，只是真的会一样吗？</p>
<p>比如 <code>v-for</code>，都不知道最后有多少个遍历的节点，如何确定长度呢？抱着这样的想法，试试 <code>v-for</code> 编译生成的代码：</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">data-name</span>=<span class="hljs-string">"1"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"i in 2"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">_ctx, _cache</span>) </span>{
  <span class="hljs-keyword">return</span> (
    _openBlock(),
    _createBlock(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, [
      _createVNode(<span class="hljs-string">"a"</span>, _hoisted_1, [
        (_openBlock(<span class="hljs-literal">true</span>),
        _createBlock(
          _Fragment,
          <span class="hljs-literal">null</span>,
          _renderList(<span class="hljs-number">2</span>, (i) =&gt; {
            <span class="hljs-keyword">return</span> _openBlock(), _createBlock(<span class="hljs-string">"li"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"1"</span>);
          }),
          <span class="hljs-number">256</span> <span class="hljs-comment">/* UNKEYED_FRAGMENT */</span>
        )),
      ]),
    ])
  );
}
</code></pre>
<p>可以看到上面为了 <code>v-for</code> 新增加了 <code>createBlock</code>，也就是对 <code>fragment</code> 这个 vnode 也赋予了 <code>dynamicChildren</code>，这样就不管有几个循环节点，外部看到的只有一个 <code>fragment</code> 片段，这样就能一一对应上了，只是虽然套多了一层 <code>fragment</code>，外面是稳定了，但是里面呢？ <code>for</code> 的数量还是不是固定的。</p>
<p>其实执行 <code>_openBlock(true)</code> 的时候，已经将 <code>currentBlock</code> 数组置为 <code>false</code>，所以 <code>dynamicChildren</code> 也无法生成，自然 <code>v-for</code> 生成的节点无法进入 <code>patchBlockChildren</code> 函数里面。<code>v-for</code> 的 <code>diff</code>，是所有子节点都要一一 <code>diff</code>，也就是全量对比。</p>
<p>当然也有例外，当 vnode 的 <code>PatchFlag</code> 是 <code>PatchFlags.STABLE_FRAGMENT</code> 时，表示其是一个不变的 <code>fragment</code>，最后也会通过 <code>patchBlockChildren</code> 对比子节点，而不是普通全量对比，什么是稳定的不变的片段呢？比如 <code>&lt;li v-for=&quot;i in 2&quot;&gt;1&lt;/li&gt;</code> 这个片段是不可能有动态改变，是稳定的。只是为什么 <code>compile</code> 的代码没有生成 <code>PatchFlags.STABLE_FRAGMENT</code> 呢？因为这部分 <code>PatchFlags.STABLE_FRAGMENT</code> 的判断，不能在浏览器侧 compile，需要在 nodejs 端。具体判断如下</p>
<ol>
<li>需要在非浏览器端 compile。</li>
<li>如果 <code>v-for</code> 的右侧是个变量，则不是稳定节点，除非是 this/NaN/Infinity 这样的骚操作。</li>
<li>其他的情况会通过 Babel 的 <code>parse</code> 方法来解析 <code>v-for</code> 的右侧生成 <code>ast</code> 树，可能存在 <code>v-for=&quot;i in () =&gt; 1 + 1&quot;</code> 这样的骚操作，当然常量 <code>v-for=i in 2</code> 也在这个范畴里面。需要遍历 <code>ast</code> 树，来确定静态的部分。</li>
</ol>
<p>确定了 <code>dynamicChildren</code> 结构之后，就是进行 <code>diff</code> 操作。</p>
<h3>patchFlag 与 diff</h3>
<p><code>patchFlag</code> 是优化模式 <code>optimized mode</code> 里用到的优化标识，通过位操作来判断当前 vnode 的需要执行的 <code>diff</code> 操作。常见的 <code>patchFlag</code> 有</p>
<ol>
<li><code>TEXT: 1</code>，存在动态文本内容，比如 <code>{{ state.count }}</code>。</li>
<li><code>CLASS: 1&lt;&lt;1</code>，存在动态的 class。</li>
<li><code>STYLE: 1&lt;&lt;2</code>，存在 style，如果是静态的字符串 <code>&lt;div style=&quot;color: red&quot;/&gt;</code> 也会被解析成动态的 style。</li>
<li><code>PROPS: 1&lt;&lt;3</code>，存在除了 class/style 以外的动态 props 的情况。</li>
<li><code>FULL_PROPS: 1&lt;&lt;4</code>，表示 props 存在动态字段名，如 <code>&lt;div :[foo]=&quot;bar&quot;&gt;</code>，与上面的 <code>CLASS/STYLE/PROPS</code> 互斥。</li>
</ol>
<p>以及前面提到的 <code>STABLE_FRAGMENT</code>，当然还有更多没有来得及了解的位运算情况，另外还有特殊情况如非位操作的 <code>HOISTED: -1</code> 这些。</p>
<p>生成的 <code>patchFlag</code> 会传入 vnode 里面，当进行 <code>patch</code> 来 <code>diff</code> 的时候就会用到，比如以下常见结构</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (patchFlag &gt; <span class="hljs-number">0</span>) {
  <span class="hljs-keyword">if</span> (patchFlag &amp; PatchFlags.FULL_PROPS) {
    <span class="hljs-comment">// patchProps 对每一个props 都重新对比，遍历新的props更新/新增，在遍历老的props，若不存在则删掉</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (patchFlag &amp; PatchFlags.CLASS) {
      <span class="hljs-comment">// 更新 class</span>
    }
    <span class="hljs-keyword">if</span> (patchFlag &amp; PatchFlags.STYLE) {
      <span class="hljs-comment">// 更新 style</span>
    }
    <span class="hljs-keyword">if</span> (patchFlag &amp; PatchFlags.PROPS) {
      <span class="hljs-comment">// 对动态props进行遍历</span>
    }
    <span class="hljs-keyword">if</span> (patchFlag &amp; PatchFlags.TEXT) {
      <span class="hljs-comment">// 更新动态文案</span>
    }
  }
}
</code></pre>
<p>通过 <code>patchFlag</code> 可以精准的更新 props、class、style 和动态文案这些。这些基本就是日常操作了， <code>dynamicChildren</code> 直接更新到 vnode。现在看看复杂的情况，全量对比，比如在 <code>v-for</code> 的非稳定节点的 <code>diff</code> 操作，其中分为有 <code>key</code> 的 <code>children，和无</code> key 的。</p>
<p>先介绍一下 <code>patchUnkeyedChildren</code>，如果没有在 <code>&lt;li v-for=&quot;i in state.count&quot;/&gt;</code> 里面找到 <code>key</code> 字段，则会进入。首先会取到新老 <code>children</code> 的公共最小长度，对该范围里面的节点，进行 <code>patch</code> 处理。超出长度的节点，若是老的 children 多，则卸载，若新的 children 多则进行挂载。</p>
<p>若是有 key，<strong>则会执行 <code>patchKeyedChildren</code></strong>，（由于懒得做图，这里就简述一下）具体算法步骤：</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> patchKeyedChildren = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> l2 = c2.length;
  <span class="hljs-keyword">let</span> e1 = c1.length - <span class="hljs-number">1</span>; <span class="hljs-comment">// 老 vnode.children 最后的索引</span>
  <span class="hljs-keyword">let</span> e2 = l2 - <span class="hljs-number">1</span>; <span class="hljs-comment">// 新 vnode.children 最后的索引</span>

  <span class="hljs-comment">// 1. 从前往后，比如老： (a b)  新：(a b) c 的情况</span>
  <span class="hljs-keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) {
    <span class="hljs-comment">// 如果是同样类型的 vnode，即 type 和 key 是一样的，则 patch 对比，并且 i++</span>
  }
  <span class="hljs-comment">// 2. 从后往前，比如老： a (b c)  新：e (b c) 的情况</span>
  <span class="hljs-keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) {
    <span class="hljs-comment">// 如果是同样类型的 vnode，即 type 和 key 是一样的，则 patch 对比，并且 e1-- 以及 e2--</span>
  }

  <span class="hljs-comment">// 3. 如果新的包含老的，而新的比老的内容多，如 老的 (a b)，新的 (a b) c</span>
  <span class="hljs-keyword">if</span> (i &gt; e1) {
    <span class="hljs-keyword">while</span> (i &lt;= e2) {
      <span class="hljs-comment">// 新增新增加的 child，同时 i++</span>
    }
  }

  <span class="hljs-comment">// 4. 如果老的包含新的，而新的比老的内容少，如 老的 (a b) c，新的 (a b)</span>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; e2) {
    <span class="hljs-keyword">while</span> (i &lt;= e1) {
      <span class="hljs-comment">// 卸载老的多余的 child，同时 i++</span>
    }
  }

  <span class="hljs-comment">// 还有步骤 5.1/5.2/5.3 复杂情况看下面</span>
};
</code></pre>
<p>上面的都是比较理想的情况，然而存在混乱的情况，比如
老的： a b c d e f g h
新的： a b f d e c g h</p>
<p>所以对于步骤 5 还有有三部曲：</p>
<p>5.1 为新的 children 生成一个 <code>key:index</code> 的 <code>map</code>，<code>keyToNewIndexMap</code> 表示新 children 中 key 和索引的关系
5.2 设置长度为 <code>e2 - i</code>，每个元素的值为 <code>0</code> 的 <code>newIndexToOldIndexMap</code> 数组。</p>
<ol>
<li>遍历老 children 节点，从 <code>keyToNewIndexMap</code> 获取与老 child 相同 key 的索引，也就是对应新节点的索引，然后通过 <code>patch</code> 函数更新，若老节点没有 key，则寻找相同 type/没有 key 的元素来对比，若还找不到，说明这个老元素在新的里面不存在，可以卸载了。</li>
<li>若新老可以 patch，则会设置 <code>newIndexToOldIndexMap[newIndex - s2] = i + 1</code>，指明新节点在老节点中的索引关系。比如上面的例子 <code>newIndexToOldIndexMap = [6, 4, 5, 3]</code>。
5.3 挂载和移动，遍历需要操作的节点，如果是 <code>newIndexToOldIndexMap</code> 存在 <code>0</code> 的值，则说明是新节点，需要挂载上。另外上面的步骤只是更新了 <code>vnode.el</code>，如果出现步骤 5 中的位置错乱的情况，目前只是更新 dom 的内容，其顺序没有改变。<strong>这里需要根据 <code>newIndexToOldIndexMap</code> 来移动需要调整的节点</strong></li>
</ol>
<p>对于 5.3 里面 dom 位置的移动，Vue3 采用了 <strong>最长递增子序列</strong> 的<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97" target="_blank">概念</a>，有动态规划的思维在里面（反正没有看懂算法），感兴趣的可以去了解一下。<strong>该最长递增子序列是作用是尽量减少 dom 的移动。</strong></p>
<p>如果出现新 children 的节点没有按照老 children 的节点顺序排列，比如例子中的 <code>f d e c</code>，就会以 <code>newIndexToOldIndexMap</code> 为输入，求得最长递增子序列对应的索引，上面的例子则是：<code>increasingNewIndexSequence = [1, 2]</code>。 后面移动的时候从后往前遍历，节点从 <code>c d e f</code> 到 <code>f d e c</code>，具体过程如下：</p>
<p>这里 <code>index</code> 值是 5.3 步骤遍历中的索引，递减，<code>j</code>初始值为 <code>increasingNewIndexSequence.length - 1</code>。</p>
<ol>
<li><code>index = 3</code> 先 <code>c.el</code> 移动到 <code>g</code> 前面, index--；</li>
<li><code>index = 2</code>，遇到 <code>e</code> 的时候由于 <code>index === increasingNewIndexSequence[j]</code>，均为 <code>2</code>，则不进行移动，<code>increasingNewIndexSequence</code> 的索引 j--。同理轮到 <code>d</code> 也是类似操作。</li>
<li><code>index = 0</code>，<code>f.el</code> 需要移动到 <code>d</code> 前面。到这里移动结束。</li>
</ol>
<p>可以看到原本是四个节点的，通过最长递增子序列的对比，可以明确哪些节点需要移动的，最后只要执行两次移动就完成了，可以说是 dom 移动的最优解吧。</p>
<p>到这里 <code>diff</code> 的过程差不多告一段落了~~~</p>
<h2>总结</h2>
<p>这次 Vue3 的代码，看着很舒服，可能是 ts 的问题，哪里不懂点哪里。</p>
<p>虽然 Vue3 还有很多内容没有研究透彻，甚至上面的部分内容，还有不少疑惑，比如 <code>hoist</code> 为什么只能在 nodejs 端开启？<code>dynamicChildren</code> 这种方式是最优解吗？好像 react 的方式更好吧？生成 <code>STABLE_FRAGMENT</code> 的所有情况？以及其他没有学习到的，比如事件处理，插槽，比如 <code>v-if</code> <code>v-model</code> 这些。只是还是想要去别的领域走走，去深水区走走。所以 Vue/React 的学习应该会告一段落了。</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"March 24, 2021","title":"Vue3 的hoist与diff","content":"\u003cp\u003e5 月天空最蓝的时候就想要学习 Vue3 的内容，只是耐心被炎热的夏天打散，代码久久都没有看一行。在工作和发呆中，深圳的秋天好像也来，官网落幕后的国庆，大家都回去团聚的时候，提笔回顾一下 Vue3 的内容，也顺便更新一下博客，算是除除草？今年其实更想的去其他深水区探索一下，只是从去年探索到今年，最后，还是回来看 Vue3 了，也是一种无奈吧。\u003c/p\u003e\n\u003ch2\u003eVue3\u003c/h2\u003e\n\u003cp\u003e以前的 Vue 像一个黑匣子的，对于开发者而言只是用 sfc 写 template 就足够了，最多偶尔写写 render 函数，灵活度是远远没有 React 方便的。（惭愧，刚没有写几行，国庆又出去玩了，再次提笔已经是 7 号了。。。惭愧）。这次的 Vue3 可以说做的非常彻底，基本把所有 api 都提供出来了，你甚至可以自己写 compile 好的函数。\u003c/p\u003e\n\u003ch2\u003ehosit 优化\u003c/h2\u003e\n\u003cp\u003e在 Compile 阶段三部曲，transform 中会有一个编译优化的过程，可以看下面两段生成代码的差异:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 原代码\u003c/span\u003e\ncreateApp({\n  \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\n    \u0026lt;div\u0026gt;\n      \u0026lt;a data-name=\"1\"\u0026gt;\n        \u0026lt;li\u0026gt;123\u0026lt;/li\u0026gt;\n      \u0026lt;/a\u0026gt;\n    \u0026lt;/div\u0026gt;\n  `\u003c/span\u003e,\n}).mount(\u003cspan class=\"hljs-string\"\u003e\"#app\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// compile 生成的代码 没有 hoist 的代码\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ctx, _cache\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    _openBlock(),\n    _createBlock(\u003cspan class=\"hljs-string\"\u003e\"div\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, [\n      _createVNode(\u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e, { \u003cspan class=\"hljs-string\"\u003e\"data-name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e }, [\n        _createVNode(\u003cspan class=\"hljs-string\"\u003e\"li\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"123\"\u003c/span\u003e),\n      ]),\n    ])\n  );\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 设置 hoistStatic 为 true 时\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e _hoisted_1 = \u003cspan class=\"hljs-comment\"\u003e/*#__PURE__*/\u003c/span\u003e _createVNode(\n  \u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e,\n  { \u003cspan class=\"hljs-string\"\u003e\"data-name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e },\n  [\u003cspan class=\"hljs-comment\"\u003e/*#__PURE__*/\u003c/span\u003e _createVNode(\u003cspan class=\"hljs-string\"\u003e\"li\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"123\"\u003c/span\u003e)],\n  \u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e/* HOISTED */\u003c/span\u003e\n);\n\u003cspan class=\"hljs-comment\"\u003e// compile 生成的代码\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ctx, _cache\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _openBlock(), _createBlock(\u003cspan class=\"hljs-string\"\u003e\"div\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, [_hoisted_1]);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到开启 \u003ccode\u003ehoistStatic\u003c/code\u003e，会对静态代码部分，也就是 \u003ccode\u003e\u0026lt;a data-name=\u0026quot;1\u0026quot;\u0026gt;\u0026lt;li\u0026gt;123\u0026lt;/li\u0026gt;\u0026lt;/a\u0026gt;\u003c/code\u003e 进行提升的处理，声明提升到 return 函数前面。只有在第一次编译，才会生成 \u003ccode\u003e_hoisted_1\u003c/code\u003e，这样当局部更新的时候不用在生成 \u003ccode\u003e_hoisted_1\u003c/code\u003e， 直接引用就好了。可以减少 vnode 的更新计算。\u003c/p\u003e\n\u003cp\u003e当 \u003ccode\u003ecompile\u003c/code\u003e 函数里面传入的 \u003ccode\u003ehoistStatic = true\u003c/code\u003e，则会开启 \u003ccode\u003ehoist\u003c/code\u003e 节点的静态处理。对于 sfc 文件模式，会采用 \u003ccode\u003edoCompileTemplate\u003c/code\u003e， 其 \u003ccode\u003ehoistStatic\u003c/code\u003e 默认是 \u003ccode\u003etrue\u003c/code\u003e，如果非 sfc 方式，并且直接调用 compile，则默认为 false。\u003c/p\u003e\n\u003ch3\u003e生成 hoist\u003c/h3\u003e\n\u003cp\u003e这里就有一个问题，什么节点才是静态节点？为什么不默认生成？\n这个判断比较复杂，需要遍历树的所有节点。下面有几个规则：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e根节点不做 \u003ccode\u003ehosit\u003c/code\u003e 处理，比如上面的 div 标签，避免父节点 props 透传使得其可能变成非静态节点。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e对于 element 节点，需要节点树下的节点点没有 \u003cstrong\u003ekey、ref、绑定的 props、指令等以及变量文字\u003c/strong\u003e （还有很多种情况要讨论的，比如常量资源等）。判断子节点是否静态的时候会采用缓存方式，避免后续的重复判断子节点。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eprops 也可以是 \u003ccode\u003ehoist\u003c/code\u003e 节点部分，当然不能是动态的部分，并且元素本身没有被 \u003ccode\u003ehoist\u003c/code\u003e 处理。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e文本节点，本身为文本，如 \u003ccode\u003e\u0026lt;div /\u0026gt;123\u003c/code\u003e 里面的 \u003ccode\u003e123\u003c/code\u003e 也会被静态化。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e如果没有将节点静态化，会有进一步迭代子节点的情况。这里可以看到 \u003cstrong\u003e将节点静态化，需要判断其所有子节点是否是静态。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e如果 DOM 里面存在其他的比如 \u003ccode\u003e{{ state.count }}\u003c/code\u003e 这些内容，对应的部分则不会被提升，但是其他的可以，比如\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata-name\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    {{ state.count }}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u0026gt;\u003c/span\u003e123\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个时候 \u003ccode\u003ea\u003c/code\u003e 标签不会被 \u003ccode\u003ehoist\u003c/code\u003e，但是里面的 \u003ccode\u003eli\u003c/code\u003e 标签不受其影响，还会被静态化。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehoist\u003c/code\u003e 生成时会被 \u003ccode\u003epush\u003c/code\u003e 到上下文的 hoists 上，生成 code 的时候会被提前处理，最后如上面所示，会先声明 \u003ccode\u003e_hoisted_1\u003c/code\u003e，并在返回的渲染函数里面，将 \u003ccode\u003e_hoisted_1\u003c/code\u003e 作为 child 传入。\u003c/p\u003e\n\u003cp\u003e这里有个问题，为什么普通的非 sfc 文件的编译，没有默认开启 \u003ccode\u003ehoistStatic\u003c/code\u003e 功能？可能是执行时间问题，原本的 \u003ccode\u003east\u003c/code\u003e 生成和 \u003ccode\u003etransform\u003c/code\u003e 过程都会遍历一次树，若开启 \u003ccode\u003ehoistStatic\u003c/code\u003e，最坏情况下还会遍历一次树，并且没有起到任何作用，只是这个解释有点牵强，可能是给开发者更多的选择吧？毕竟 \u003ccode\u003ecompile\u003c/code\u003e 方法需要注册才能使用，而注册的过程需要开发者自己配置。\u003c/p\u003e\n\u003ch3\u003estringifyStatic\u003c/h3\u003e\n\u003cp\u003e在 \u003ccode\u003ehoist\u003c/code\u003e 时，可能会将节点字符串化，比如下面:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- 内容： --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 生成如下\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e _hoisted_1 = \u003cspan class=\"hljs-comment\"\u003e/*#__PURE__*/\u003c/span\u003e _createStaticVNode(\n  \u003cspan class=\"hljs-string\"\u003e'\u0026lt;a href=\"1\"\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;a href=\"1\"\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;a href=\"1\"\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;a href=\"1\"\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;a href=\"1\"\u0026gt;\u0026lt;/a\u0026gt;'\u003c/span\u003e,\n  \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\n);\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ctx, _cache\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _openBlock(), _createBlock(\u003cspan class=\"hljs-string\"\u003e\"div\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, [_hoisted_1]);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到原本会被 hoist 提升的静态节点，也就是 5 个会通过 \u003ccode\u003ecreateVnode\u003c/code\u003e 创建 vnode，现在进一步直接变成了字符串。自然是减少了 vnode 的生成，原本要生成 5 个 hoist 以及其 props 的，现在只要一个字符串。当然字符串节点最大的好处，还是渲染挂载 DOM 的时，可以让 \u003ccode\u003eparent.innerHTML = 字符串\u003c/code\u003e，简单直接效率高，不用一步步遍历子节点。这可以说是比上面的变量提升要彻底很多。完全静态的代码，直接设置 \u003ccode\u003einnerHTML\u003c/code\u003e，其他什么的都不需要。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e当然这个功能只有编译阶段为非浏览器环境才会开启，也就是 nodejs 环境\u003c/strong\u003e，为什么呢？因为静态节点字符串化的生成判断是比较耗性能的。\u003c/p\u003e\n\u003cp\u003e生成字符串节点，首先必须是 \u003ccode\u003ehoist\u003c/code\u003e 静态的节点。其次若子节点连续大于等于 20 个静态节点或者节点中有大于等于 5 个节点有 props，则会进入字符串化。\u003c/p\u003e\n\u003cp\u003e对于大于等于 20 个节点或者有大于等于 5 个节点有 props 的判断大致如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e nc = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 当前节点数量\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e ec = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 存在 props 的节点数量\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (; i \u0026lt; children.length; i++) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hoisted = getHoistedNode(child)\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (hoisted) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e node = child \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e StringifiableNode\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = analyzeNode(node)\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (result) {\n      nc += result[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n      ec += result[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n      \u003cspan class=\"hljs-comment\"\u003e// 节点 push 到 currentChunk 里面为后面 stringifyCurrentChunk 做准备\u003c/span\u003e\n      currentChunk.push(node)\n      \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e\n    }\n  }\n  i -= stringifyCurrentChunk(i)\n  nc = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n  ec = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n  currentChunk.length = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n}\nstringifyCurrentChunk(i);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e会对 parent 下所有的一级子节点遍历，如果遍历的时候发现节点可以静态化，就一直 \u003ccode\u003econtinue\u003c/code\u003e，若不能，则对之前的可以静态化的节点进行 \u003ccode\u003estringifyCurrentChunk\u003c/code\u003e 处理，并且重置 \u003ccode\u003enc\u003c/code\u003e \u003ccode\u003eec\u003c/code\u003e \u003ccode\u003ecurrentChunk\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e上面是总体的流程，重点是 \u003ccode\u003eanalyzeNode\u003c/code\u003e 和 \u003ccode\u003estringifyCurrentChunk\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e前者 \u003ccode\u003eanalyzeNode\u003c/code\u003e 会不断的遍历所有嵌套的子节点，比如如下结构，会被认为存在 3 个静态节点。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eanalyzeNode\u003c/code\u003e 里面还会对 props 判断，如果 props 不是常见的静态类型，则最后有 \u003ccode\u003eresult = false\u003c/code\u003e，分为以下情况：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e如果已知的 attr，则可以静态化，因为 alt、src 这些，是 dom 本身就有的。\u003c/li\u003e\n\u003cli\u003e或者是已知的静态 binding，如 :src=\u0026quot;1\u0026quot;，这个可以静态化的，反之 :abc=\u0026quot;1\u0026quot;，就不可以。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e对于子节点，如果存在孙节点，则会继续遍历，若节点存在 props，则 \u003ccode\u003eec++\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estringifyCurrentChunk\u003c/code\u003e 会对收集到的可以静态字符串化的节点进行处理，但是这里的静态化，也是一个遍历的过程：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e staticCall = createCallExpression(context.helper(CREATE_STATIC), [\n  \u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.stringify(\n    currentChunk.map(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003enode\u003c/span\u003e) =\u0026gt;\u003c/span\u003e stringifyNode(node, context)).join(\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\n  ),\n  \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e(currentChunk.length),\n]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e每个节点，都会经过 \u003ccode\u003estringifyNode\u003c/code\u003e 处理，最后 JSON 化。\u003ccode\u003estringifyNode\u003c/code\u003e 里面会根据不同的节点类型来处理，并遍历树的所有节点，对于 class/style 还会特别处理。这里就不继续阐述里面的规则了。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e可以看出来，静态节点字符串化，效果虽然很好，但是其会对节点树进行两次遍历，一次是判断是否可以字符串化，一次是将节点转为字符串\u003c/strong\u003e 过程比较耗时。至于能否两次合为一次，自然是不能的。\u003c/p\u003e\n\u003cp\u003e只是有个问题，为什么会是 20 个节点以上或者是 5 个含有 props 的节点就判断可以字符串化呢？如果定义 20 个节点为阈值，是为了避免过渡字符串化，那 5 个含有 props 的节点，又是什么考虑呢？这不是明明小于 20 个节点吗，还是认为存在 props 的节点，一般都有 4 个属性？\u003c/p\u003e\n\u003ch2\u003ediff\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ediff\u003c/code\u003e 的过程，在 Vue 和 React 里面，已经从原始的整个树更新对比，算法复杂度 O(n3) 转换成 O(n) 了。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHowever, the state of the art algorithms have a complexity in the order of O(n3) where n is the number of elements in the tree.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e而这里的 O(n) 也不是最终的目标，比如 react，会将所有需要更新的串在一起，只处理有更新的节点（有点久了，应该是这样的吧），而 Vue3 的思路思路则是维护一个动态数组，\u003ccode\u003edynamicChildren\u003c/code\u003e，应该说不是一个，而是每个 \u003ccode\u003eblock\u003c/code\u003e 都存在 \u003ccode\u003edynamicChildren\u003c/code\u003e，这个 \u003ccode\u003edynamicChildren\u003c/code\u003e 是更新的主角，毕竟，静态节点就不用考虑更新了。\u003c/p\u003e\n\u003ch3\u003edynamicChildren 生成\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003edynamicChildren\u003c/code\u003e 的生成是与 \u003ccode\u003ecreateBlock\u003c/code\u003e 函数绑定的，只有在 \u003ccode\u003ecreateBlock\u003c/code\u003e 里面才有可能生成 \u003ccode\u003edynamicChildren\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e比如下面代码\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata-name\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u0026gt;\u003c/span\u003e{{stat.count}}\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e最后生成下面的 vnode：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// vnode\u003c/span\u003e\n{\n  \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'div'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: [\n    {\n      \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'data-name'\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e],\n      \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: [\n        { \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'li'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'2'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003epatchFlag\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e }\n      ]\n    }\n  ],\n  \u003cspan class=\"hljs-attr\"\u003edynamicChildren\u003c/span\u003e: [\n    { \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'li'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'2'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003epatchFlag\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e }\n  ]\n}\n\u003cspan class=\"hljs-comment\"\u003e// 对应的 compile函数\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ctx, _cache\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (_openBlock(), _createBlock(\u003cspan class=\"hljs-string\"\u003e\"div\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, [\n    _createVNode(\u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e, _hoisted_1, [\n      _createVNode(\u003cspan class=\"hljs-string\"\u003e\"li\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, _toDisplayString(stat.count), \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e/* TEXT */\u003c/span\u003e)\n    ])\n  ]))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到最后生成的 \u003ccode\u003edynamicChildren\u003c/code\u003e 部分只包含了动态内容，在后面的 \u003ccode\u003ediff\u003c/code\u003e 过程则完全可以将 a 标签忽略掉。同时也可以看到 \u003ccode\u003eopenBlock\u003c/code\u003e 和 \u003ccode\u003ecreateBlock\u003c/code\u003e，前者需要在每次调用 \u003ccode\u003ecreateBlock\u003c/code\u003e 时触发，用来重置全局变量 \u003ccode\u003ecurrentBlock\u003c/code\u003e 数组，后者 \u003ccode\u003ecreateBlock\u003c/code\u003e 则会在子节点的 vnode 构建完成后，将这里的 div 标签生成 vnode，并将 \u003ccode\u003ecurrentBlock\u003c/code\u003e 赋予该 vnode 的 \u003ccode\u003edynamicChildren\u003c/code\u003e 字段。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ecurrentBlock\u003c/code\u003e 数组会在生成 vnode 的时候收集节点，具体如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n  (shouldTrack \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e || isRenderingTemplateSlot) \u0026amp;\u0026amp;\n  !isBlockNode \u0026amp;\u0026amp;\n  currentBlock \u0026amp;\u0026amp;\n  (patchFlag \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e || shapeFlag \u0026amp; ShapeFlags.COMPONENT) \u0026amp;\u0026amp;\n  patchFlag !== PatchFlags.HYDRATE_EVENTS\n) {\n  currentBlock.push(vnode);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里的条件蛮多的，\u003ccode\u003eshouldTrack\u003c/code\u003e 表示目前处于实例生成更新阶段，也就是不是 \u003ccode\u003ecompile\u003c/code\u003e 阶段，\u003ccode\u003eisBlockNode\u003c/code\u003e 是目前的 vnode 为 \u003ccode\u003eblock\u003c/code\u003e 节点，也就是可以生成 \u003ccode\u003edynamicChildren\u003c/code\u003e， \u003ccode\u003epatchFlag\u003c/code\u003e 这个是重点，大于 0 表示其为动态内容（当然事件监听 \u003ccode\u003ePatchFlags.HYDRATE_EVENTS\u003c/code\u003e，不在这里面）。后面会重点介绍 \u003ccode\u003epatchFlag\u003c/code\u003e。\u003c/p\u003e\n\u003ch3\u003edynamicChildren 对比\u003c/h3\u003e\n\u003cp\u003e在更新的时候，会对比前一个 vnode 生成 \u003ccode\u003edynamicChildren\u003c/code\u003e，与现在生成的 \u003ccode\u003edynamicChildren\u003c/code\u003e，处理如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e patchBlockChildren: PatchBlockChildrenFn = (\n  oldChildren,\n  newChildren,\n  fallbackContainer,\n  parentComponent,\n  parentSuspense,\n  isSVG\n) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; newChildren.length; i++) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e oldVNode = oldChildren[i]\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newVNode = newChildren[i]\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container =\n      oldVNode.type === Fragment ||\n      !isSameVNodeType(oldVNode, newVNode) ||\n      oldVNode.shapeFlag \u0026amp; ShapeFlags.COMPONENT ||\n      oldVNode.shapeFlag \u0026amp; ShapeFlags.TELEPORT\n        ? hostParentNode(oldVNode.el!)!\n        : fallbackContainer\n    patch(\n      oldVNode,\n      newVNode,\n      container,\n      \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n      parentComponent,\n      parentSuspense,\n      isSVG,\n      \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n    )\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 \u003ccode\u003epatchBlockChildren\u003c/code\u003e 里面会对每一个新老的 \u003ccode\u003echild\u003c/code\u003e 一一对比，再通过 \u003ccode\u003epatch\u003c/code\u003e 来更新。只是看到这里就有一个问题了，在 \u003ccode\u003efor\u003c/code\u003e 语句里面可以看到是严格要求新老 \u003ccode\u003edynamicChildren\u003c/code\u003e 数组的长度是一致的，只是真的会一样吗？\u003c/p\u003e\n\u003cp\u003e比如 \u003ccode\u003ev-for\u003c/code\u003e，都不知道最后有多少个遍历的节点，如何确定长度呢？抱着这样的想法，试试 \u003ccode\u003ev-for\u003c/code\u003e 编译生成的代码：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata-name\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ev-for\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"i in 2\"\u003c/span\u003e\u0026gt;\u003c/span\u003e1\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ctx, _cache\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    _openBlock(),\n    _createBlock(\u003cspan class=\"hljs-string\"\u003e\"div\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, [\n      _createVNode(\u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e, _hoisted_1, [\n        (_openBlock(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e),\n        _createBlock(\n          _Fragment,\n          \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n          _renderList(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, (i) =\u0026gt; {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _openBlock(), _createBlock(\u003cspan class=\"hljs-string\"\u003e\"li\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e);\n          }),\n          \u003cspan class=\"hljs-number\"\u003e256\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e/* UNKEYED_FRAGMENT */\u003c/span\u003e\n        )),\n      ]),\n    ])\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到上面为了 \u003ccode\u003ev-for\u003c/code\u003e 新增加了 \u003ccode\u003ecreateBlock\u003c/code\u003e，也就是对 \u003ccode\u003efragment\u003c/code\u003e 这个 vnode 也赋予了 \u003ccode\u003edynamicChildren\u003c/code\u003e，这样就不管有几个循环节点，外部看到的只有一个 \u003ccode\u003efragment\u003c/code\u003e 片段，这样就能一一对应上了，只是虽然套多了一层 \u003ccode\u003efragment\u003c/code\u003e，外面是稳定了，但是里面呢？ \u003ccode\u003efor\u003c/code\u003e 的数量还是不是固定的。\u003c/p\u003e\n\u003cp\u003e其实执行 \u003ccode\u003e_openBlock(true)\u003c/code\u003e 的时候，已经将 \u003ccode\u003ecurrentBlock\u003c/code\u003e 数组置为 \u003ccode\u003efalse\u003c/code\u003e，所以 \u003ccode\u003edynamicChildren\u003c/code\u003e 也无法生成，自然 \u003ccode\u003ev-for\u003c/code\u003e 生成的节点无法进入 \u003ccode\u003epatchBlockChildren\u003c/code\u003e 函数里面。\u003ccode\u003ev-for\u003c/code\u003e 的 \u003ccode\u003ediff\u003c/code\u003e，是所有子节点都要一一 \u003ccode\u003ediff\u003c/code\u003e，也就是全量对比。\u003c/p\u003e\n\u003cp\u003e当然也有例外，当 vnode 的 \u003ccode\u003ePatchFlag\u003c/code\u003e 是 \u003ccode\u003ePatchFlags.STABLE_FRAGMENT\u003c/code\u003e 时，表示其是一个不变的 \u003ccode\u003efragment\u003c/code\u003e，最后也会通过 \u003ccode\u003epatchBlockChildren\u003c/code\u003e 对比子节点，而不是普通全量对比，什么是稳定的不变的片段呢？比如 \u003ccode\u003e\u0026lt;li v-for=\u0026quot;i in 2\u0026quot;\u0026gt;1\u0026lt;/li\u0026gt;\u003c/code\u003e 这个片段是不可能有动态改变，是稳定的。只是为什么 \u003ccode\u003ecompile\u003c/code\u003e 的代码没有生成 \u003ccode\u003ePatchFlags.STABLE_FRAGMENT\u003c/code\u003e 呢？因为这部分 \u003ccode\u003ePatchFlags.STABLE_FRAGMENT\u003c/code\u003e 的判断，不能在浏览器侧 compile，需要在 nodejs 端。具体判断如下\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e需要在非浏览器端 compile。\u003c/li\u003e\n\u003cli\u003e如果 \u003ccode\u003ev-for\u003c/code\u003e 的右侧是个变量，则不是稳定节点，除非是 this/NaN/Infinity 这样的骚操作。\u003c/li\u003e\n\u003cli\u003e其他的情况会通过 Babel 的 \u003ccode\u003eparse\u003c/code\u003e 方法来解析 \u003ccode\u003ev-for\u003c/code\u003e 的右侧生成 \u003ccode\u003east\u003c/code\u003e 树，可能存在 \u003ccode\u003ev-for=\u0026quot;i in () =\u0026gt; 1 + 1\u0026quot;\u003c/code\u003e 这样的骚操作，当然常量 \u003ccode\u003ev-for=i in 2\u003c/code\u003e 也在这个范畴里面。需要遍历 \u003ccode\u003east\u003c/code\u003e 树，来确定静态的部分。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e确定了 \u003ccode\u003edynamicChildren\u003c/code\u003e 结构之后，就是进行 \u003ccode\u003ediff\u003c/code\u003e 操作。\u003c/p\u003e\n\u003ch3\u003epatchFlag 与 diff\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003epatchFlag\u003c/code\u003e 是优化模式 \u003ccode\u003eoptimized mode\u003c/code\u003e 里用到的优化标识，通过位操作来判断当前 vnode 的需要执行的 \u003ccode\u003ediff\u003c/code\u003e 操作。常见的 \u003ccode\u003epatchFlag\u003c/code\u003e 有\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eTEXT: 1\u003c/code\u003e，存在动态文本内容，比如 \u003ccode\u003e{{ state.count }}\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCLASS: 1\u0026lt;\u0026lt;1\u003c/code\u003e，存在动态的 class。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSTYLE: 1\u0026lt;\u0026lt;2\u003c/code\u003e，存在 style，如果是静态的字符串 \u003ccode\u003e\u0026lt;div style=\u0026quot;color: red\u0026quot;/\u0026gt;\u003c/code\u003e 也会被解析成动态的 style。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePROPS: 1\u0026lt;\u0026lt;3\u003c/code\u003e，存在除了 class/style 以外的动态 props 的情况。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eFULL_PROPS: 1\u0026lt;\u0026lt;4\u003c/code\u003e，表示 props 存在动态字段名，如 \u003ccode\u003e\u0026lt;div :[foo]=\u0026quot;bar\u0026quot;\u0026gt;\u003c/code\u003e，与上面的 \u003ccode\u003eCLASS/STYLE/PROPS\u003c/code\u003e 互斥。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e以及前面提到的 \u003ccode\u003eSTABLE_FRAGMENT\u003c/code\u003e，当然还有更多没有来得及了解的位运算情况，另外还有特殊情况如非位操作的 \u003ccode\u003eHOISTED: -1\u003c/code\u003e 这些。\u003c/p\u003e\n\u003cp\u003e生成的 \u003ccode\u003epatchFlag\u003c/code\u003e 会传入 vnode 里面，当进行 \u003ccode\u003epatch\u003c/code\u003e 来 \u003ccode\u003ediff\u003c/code\u003e 的时候就会用到，比如以下常见结构\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (patchFlag \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (patchFlag \u0026amp; PatchFlags.FULL_PROPS) {\n    \u003cspan class=\"hljs-comment\"\u003e// patchProps 对每一个props 都重新对比，遍历新的props更新/新增，在遍历老的props，若不存在则删掉\u003c/span\u003e\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (patchFlag \u0026amp; PatchFlags.CLASS) {\n      \u003cspan class=\"hljs-comment\"\u003e// 更新 class\u003c/span\u003e\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (patchFlag \u0026amp; PatchFlags.STYLE) {\n      \u003cspan class=\"hljs-comment\"\u003e// 更新 style\u003c/span\u003e\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (patchFlag \u0026amp; PatchFlags.PROPS) {\n      \u003cspan class=\"hljs-comment\"\u003e// 对动态props进行遍历\u003c/span\u003e\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (patchFlag \u0026amp; PatchFlags.TEXT) {\n      \u003cspan class=\"hljs-comment\"\u003e// 更新动态文案\u003c/span\u003e\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过 \u003ccode\u003epatchFlag\u003c/code\u003e 可以精准的更新 props、class、style 和动态文案这些。这些基本就是日常操作了， \u003ccode\u003edynamicChildren\u003c/code\u003e 直接更新到 vnode。现在看看复杂的情况，全量对比，比如在 \u003ccode\u003ev-for\u003c/code\u003e 的非稳定节点的 \u003ccode\u003ediff\u003c/code\u003e 操作，其中分为有 \u003ccode\u003ekey\u003c/code\u003e 的 \u003ccode\u003echildren，和无\u003c/code\u003e key 的。\u003c/p\u003e\n\u003cp\u003e先介绍一下 \u003ccode\u003epatchUnkeyedChildren\u003c/code\u003e，如果没有在 \u003ccode\u003e\u0026lt;li v-for=\u0026quot;i in state.count\u0026quot;/\u0026gt;\u003c/code\u003e 里面找到 \u003ccode\u003ekey\u003c/code\u003e 字段，则会进入。首先会取到新老 \u003ccode\u003echildren\u003c/code\u003e 的公共最小长度，对该范围里面的节点，进行 \u003ccode\u003epatch\u003c/code\u003e 处理。超出长度的节点，若是老的 children 多，则卸载，若新的 children 多则进行挂载。\u003c/p\u003e\n\u003cp\u003e若是有 key，\u003cstrong\u003e则会执行 \u003ccode\u003epatchKeyedChildren\u003c/code\u003e\u003c/strong\u003e，（由于懒得做图，这里就简述一下）具体算法步骤：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e patchKeyedChildren = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e l2 = c2.length;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e e1 = c1.length - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 老 vnode.children 最后的索引\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e e2 = l2 - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 新 vnode.children 最后的索引\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// 1. 从前往后，比如老： (a b)  新：(a b) c 的情况\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (i \u0026lt;= e1 \u0026amp;\u0026amp; i \u0026lt;= e2) {\n    \u003cspan class=\"hljs-comment\"\u003e// 如果是同样类型的 vnode，即 type 和 key 是一样的，则 patch 对比，并且 i++\u003c/span\u003e\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 2. 从后往前，比如老： a (b c)  新：e (b c) 的情况\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (i \u0026lt;= e1 \u0026amp;\u0026amp; i \u0026lt;= e2) {\n    \u003cspan class=\"hljs-comment\"\u003e// 如果是同样类型的 vnode，即 type 和 key 是一样的，则 patch 对比，并且 e1-- 以及 e2--\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// 3. 如果新的包含老的，而新的比老的内容多，如 老的 (a b)，新的 (a b) c\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (i \u0026gt; e1) {\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (i \u0026lt;= e2) {\n      \u003cspan class=\"hljs-comment\"\u003e// 新增新增加的 child，同时 i++\u003c/span\u003e\n    }\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// 4. 如果老的包含新的，而新的比老的内容少，如 老的 (a b) c，新的 (a b)\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (i \u0026gt; e2) {\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (i \u0026lt;= e1) {\n      \u003cspan class=\"hljs-comment\"\u003e// 卸载老的多余的 child，同时 i++\u003c/span\u003e\n    }\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// 还有步骤 5.1/5.2/5.3 复杂情况看下面\u003c/span\u003e\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面的都是比较理想的情况，然而存在混乱的情况，比如\n老的： a b c d e f g h\n新的： a b f d e c g h\u003c/p\u003e\n\u003cp\u003e所以对于步骤 5 还有有三部曲：\u003c/p\u003e\n\u003cp\u003e5.1 为新的 children 生成一个 \u003ccode\u003ekey:index\u003c/code\u003e 的 \u003ccode\u003emap\u003c/code\u003e，\u003ccode\u003ekeyToNewIndexMap\u003c/code\u003e 表示新 children 中 key 和索引的关系\n5.2 设置长度为 \u003ccode\u003ee2 - i\u003c/code\u003e，每个元素的值为 \u003ccode\u003e0\u003c/code\u003e 的 \u003ccode\u003enewIndexToOldIndexMap\u003c/code\u003e 数组。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e遍历老 children 节点，从 \u003ccode\u003ekeyToNewIndexMap\u003c/code\u003e 获取与老 child 相同 key 的索引，也就是对应新节点的索引，然后通过 \u003ccode\u003epatch\u003c/code\u003e 函数更新，若老节点没有 key，则寻找相同 type/没有 key 的元素来对比，若还找不到，说明这个老元素在新的里面不存在，可以卸载了。\u003c/li\u003e\n\u003cli\u003e若新老可以 patch，则会设置 \u003ccode\u003enewIndexToOldIndexMap[newIndex - s2] = i + 1\u003c/code\u003e，指明新节点在老节点中的索引关系。比如上面的例子 \u003ccode\u003enewIndexToOldIndexMap = [6, 4, 5, 3]\u003c/code\u003e。\n5.3 挂载和移动，遍历需要操作的节点，如果是 \u003ccode\u003enewIndexToOldIndexMap\u003c/code\u003e 存在 \u003ccode\u003e0\u003c/code\u003e 的值，则说明是新节点，需要挂载上。另外上面的步骤只是更新了 \u003ccode\u003evnode.el\u003c/code\u003e，如果出现步骤 5 中的位置错乱的情况，目前只是更新 dom 的内容，其顺序没有改变。\u003cstrong\u003e这里需要根据 \u003ccode\u003enewIndexToOldIndexMap\u003c/code\u003e 来移动需要调整的节点\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e对于 5.3 里面 dom 位置的移动，Vue3 采用了 \u003cstrong\u003e最长递增子序列\u003c/strong\u003e 的\u003ca href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97\" target=\"_blank\"\u003e概念\u003c/a\u003e，有动态规划的思维在里面（反正没有看懂算法），感兴趣的可以去了解一下。\u003cstrong\u003e该最长递增子序列是作用是尽量减少 dom 的移动。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e如果出现新 children 的节点没有按照老 children 的节点顺序排列，比如例子中的 \u003ccode\u003ef d e c\u003c/code\u003e，就会以 \u003ccode\u003enewIndexToOldIndexMap\u003c/code\u003e 为输入，求得最长递增子序列对应的索引，上面的例子则是：\u003ccode\u003eincreasingNewIndexSequence = [1, 2]\u003c/code\u003e。 后面移动的时候从后往前遍历，节点从 \u003ccode\u003ec d e f\u003c/code\u003e 到 \u003ccode\u003ef d e c\u003c/code\u003e，具体过程如下：\u003c/p\u003e\n\u003cp\u003e这里 \u003ccode\u003eindex\u003c/code\u003e 值是 5.3 步骤遍历中的索引，递减，\u003ccode\u003ej\u003c/code\u003e初始值为 \u003ccode\u003eincreasingNewIndexSequence.length - 1\u003c/code\u003e。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eindex = 3\u003c/code\u003e 先 \u003ccode\u003ec.el\u003c/code\u003e 移动到 \u003ccode\u003eg\u003c/code\u003e 前面, index--；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eindex = 2\u003c/code\u003e，遇到 \u003ccode\u003ee\u003c/code\u003e 的时候由于 \u003ccode\u003eindex === increasingNewIndexSequence[j]\u003c/code\u003e，均为 \u003ccode\u003e2\u003c/code\u003e，则不进行移动，\u003ccode\u003eincreasingNewIndexSequence\u003c/code\u003e 的索引 j--。同理轮到 \u003ccode\u003ed\u003c/code\u003e 也是类似操作。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eindex = 0\u003c/code\u003e，\u003ccode\u003ef.el\u003c/code\u003e 需要移动到 \u003ccode\u003ed\u003c/code\u003e 前面。到这里移动结束。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e可以看到原本是四个节点的，通过最长递增子序列的对比，可以明确哪些节点需要移动的，最后只要执行两次移动就完成了，可以说是 dom 移动的最优解吧。\u003c/p\u003e\n\u003cp\u003e到这里 \u003ccode\u003ediff\u003c/code\u003e 的过程差不多告一段落了~~~\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e这次 Vue3 的代码，看着很舒服，可能是 ts 的问题，哪里不懂点哪里。\u003c/p\u003e\n\u003cp\u003e虽然 Vue3 还有很多内容没有研究透彻，甚至上面的部分内容，还有不少疑惑，比如 \u003ccode\u003ehoist\u003c/code\u003e 为什么只能在 nodejs 端开启？\u003ccode\u003edynamicChildren\u003c/code\u003e 这种方式是最优解吗？好像 react 的方式更好吧？生成 \u003ccode\u003eSTABLE_FRAGMENT\u003c/code\u003e 的所有情况？以及其他没有学习到的，比如事件处理，插槽，比如 \u003ccode\u003ev-if\u003c/code\u003e \u003ccode\u003ev-model\u003c/code\u003e 这些。只是还是想要去别的领域走走，去深水区走走。所以 Vue/React 的学习应该会告一段落了。\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"March 24, 2021","title":"Vue3 的hoist与diff","content":"\u003cp\u003e5 月天空最蓝的时候就想要学习 Vue3 的内容，只是耐心被炎热的夏天打散，代码久久都没有看一行。在工作和发呆中，深圳的秋天好像也来，官网落幕后的国庆，大家都回去团聚的时候，提笔回顾一下 Vue3 的内容，也顺便更新一下博客，算是除除草？今年其实更想的去其他深水区探索一下，只是从去年探索到今年，最后，还是回来看 Vue3 了，也是一种无奈吧。\u003c/p\u003e\n\u003ch2\u003eVue3\u003c/h2\u003e\n\u003cp\u003e以前的 Vue 像一个黑匣子的，对于开发者而言只是用 sfc 写 template 就足够了，最多偶尔写写 render 函数，灵活度是远远没有 React 方便的。（惭愧，刚没有写几行，国庆又出去玩了，再次提笔已经是 7 号了。。。惭愧）。这次的 Vue3 可以说做的非常彻底，基本把所有 api 都提供出来了，你甚至可以自己写 compile 好的函数。\u003c/p\u003e\n\u003ch2\u003ehosit 优化\u003c/h2\u003e\n\u003cp\u003e在 Compile 阶段三部曲，transform 中会有一个编译优化的过程，可以看下面两段生成代码的差异:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 原代码\u003c/span\u003e\ncreateApp({\n  \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\n    \u0026lt;div\u0026gt;\n      \u0026lt;a data-name=\"1\"\u0026gt;\n        \u0026lt;li\u0026gt;123\u0026lt;/li\u0026gt;\n      \u0026lt;/a\u0026gt;\n    \u0026lt;/div\u0026gt;\n  `\u003c/span\u003e,\n}).mount(\u003cspan class=\"hljs-string\"\u003e\"#app\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// compile 生成的代码 没有 hoist 的代码\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ctx, _cache\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    _openBlock(),\n    _createBlock(\u003cspan class=\"hljs-string\"\u003e\"div\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, [\n      _createVNode(\u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e, { \u003cspan class=\"hljs-string\"\u003e\"data-name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e }, [\n        _createVNode(\u003cspan class=\"hljs-string\"\u003e\"li\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"123\"\u003c/span\u003e),\n      ]),\n    ])\n  );\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 设置 hoistStatic 为 true 时\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e _hoisted_1 = \u003cspan class=\"hljs-comment\"\u003e/*#__PURE__*/\u003c/span\u003e _createVNode(\n  \u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e,\n  { \u003cspan class=\"hljs-string\"\u003e\"data-name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e },\n  [\u003cspan class=\"hljs-comment\"\u003e/*#__PURE__*/\u003c/span\u003e _createVNode(\u003cspan class=\"hljs-string\"\u003e\"li\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"123\"\u003c/span\u003e)],\n  \u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e/* HOISTED */\u003c/span\u003e\n);\n\u003cspan class=\"hljs-comment\"\u003e// compile 生成的代码\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ctx, _cache\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _openBlock(), _createBlock(\u003cspan class=\"hljs-string\"\u003e\"div\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, [_hoisted_1]);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到开启 \u003ccode\u003ehoistStatic\u003c/code\u003e，会对静态代码部分，也就是 \u003ccode\u003e\u0026lt;a data-name=\u0026quot;1\u0026quot;\u0026gt;\u0026lt;li\u0026gt;123\u0026lt;/li\u0026gt;\u0026lt;/a\u0026gt;\u003c/code\u003e 进行提升的处理，声明提升到 return 函数前面。只有在第一次编译，才会生成 \u003ccode\u003e_hoisted_1\u003c/code\u003e，这样当局部更新的时候不用在生成 \u003ccode\u003e_hoisted_1\u003c/code\u003e， 直接引用就好了。可以减少 vnode 的更新计算。\u003c/p\u003e\n\u003cp\u003e当 \u003ccode\u003ecompile\u003c/code\u003e 函数里面传入的 \u003ccode\u003ehoistStatic = true\u003c/code\u003e，则会开启 \u003ccode\u003ehoist\u003c/code\u003e 节点的静态处理。对于 sfc 文件模式，会采用 \u003ccode\u003edoCompileTemplate\u003c/code\u003e， 其 \u003ccode\u003ehoistStatic\u003c/code\u003e 默认是 \u003ccode\u003etrue\u003c/code\u003e，如果非 sfc 方式，并且直接调用 compile，则默认为 false。\u003c/p\u003e\n\u003ch3\u003e生成 hoist\u003c/h3\u003e\n\u003cp\u003e这里就有一个问题，什么节点才是静态节点？为什么不默认生成？\n这个判断比较复杂，需要遍历树的所有节点。下面有几个规则：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e根节点不做 \u003ccode\u003ehosit\u003c/code\u003e 处理，比如上面的 div 标签，避免父节点 props 透传使得其可能变成非静态节点。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e对于 element 节点，需要节点树下的节点点没有 \u003cstrong\u003ekey、ref、绑定的 props、指令等以及变量文字\u003c/strong\u003e （还有很多种情况要讨论的，比如常量资源等）。判断子节点是否静态的时候会采用缓存方式，避免后续的重复判断子节点。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eprops 也可以是 \u003ccode\u003ehoist\u003c/code\u003e 节点部分，当然不能是动态的部分，并且元素本身没有被 \u003ccode\u003ehoist\u003c/code\u003e 处理。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e文本节点，本身为文本，如 \u003ccode\u003e\u0026lt;div /\u0026gt;123\u003c/code\u003e 里面的 \u003ccode\u003e123\u003c/code\u003e 也会被静态化。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e如果没有将节点静态化，会有进一步迭代子节点的情况。这里可以看到 \u003cstrong\u003e将节点静态化，需要判断其所有子节点是否是静态。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e如果 DOM 里面存在其他的比如 \u003ccode\u003e{{ state.count }}\u003c/code\u003e 这些内容，对应的部分则不会被提升，但是其他的可以，比如\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata-name\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    {{ state.count }}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u0026gt;\u003c/span\u003e123\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个时候 \u003ccode\u003ea\u003c/code\u003e 标签不会被 \u003ccode\u003ehoist\u003c/code\u003e，但是里面的 \u003ccode\u003eli\u003c/code\u003e 标签不受其影响，还会被静态化。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehoist\u003c/code\u003e 生成时会被 \u003ccode\u003epush\u003c/code\u003e 到上下文的 hoists 上，生成 code 的时候会被提前处理，最后如上面所示，会先声明 \u003ccode\u003e_hoisted_1\u003c/code\u003e，并在返回的渲染函数里面，将 \u003ccode\u003e_hoisted_1\u003c/code\u003e 作为 child 传入。\u003c/p\u003e\n\u003cp\u003e这里有个问题，为什么普通的非 sfc 文件的编译，没有默认开启 \u003ccode\u003ehoistStatic\u003c/code\u003e 功能？可能是执行时间问题，原本的 \u003ccode\u003east\u003c/code\u003e 生成和 \u003ccode\u003etransform\u003c/code\u003e 过程都会遍历一次树，若开启 \u003ccode\u003ehoistStatic\u003c/code\u003e，最坏情况下还会遍历一次树，并且没有起到任何作用，只是这个解释有点牵强，可能是给开发者更多的选择吧？毕竟 \u003ccode\u003ecompile\u003c/code\u003e 方法需要注册才能使用，而注册的过程需要开发者自己配置。\u003c/p\u003e\n\u003ch3\u003estringifyStatic\u003c/h3\u003e\n\u003cp\u003e在 \u003ccode\u003ehoist\u003c/code\u003e 时，可能会将节点字符串化，比如下面:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- 内容： --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 生成如下\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e _hoisted_1 = \u003cspan class=\"hljs-comment\"\u003e/*#__PURE__*/\u003c/span\u003e _createStaticVNode(\n  \u003cspan class=\"hljs-string\"\u003e'\u0026lt;a href=\"1\"\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;a href=\"1\"\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;a href=\"1\"\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;a href=\"1\"\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;a href=\"1\"\u0026gt;\u0026lt;/a\u0026gt;'\u003c/span\u003e,\n  \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\n);\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ctx, _cache\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _openBlock(), _createBlock(\u003cspan class=\"hljs-string\"\u003e\"div\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, [_hoisted_1]);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到原本会被 hoist 提升的静态节点，也就是 5 个会通过 \u003ccode\u003ecreateVnode\u003c/code\u003e 创建 vnode，现在进一步直接变成了字符串。自然是减少了 vnode 的生成，原本要生成 5 个 hoist 以及其 props 的，现在只要一个字符串。当然字符串节点最大的好处，还是渲染挂载 DOM 的时，可以让 \u003ccode\u003eparent.innerHTML = 字符串\u003c/code\u003e，简单直接效率高，不用一步步遍历子节点。这可以说是比上面的变量提升要彻底很多。完全静态的代码，直接设置 \u003ccode\u003einnerHTML\u003c/code\u003e，其他什么的都不需要。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e当然这个功能只有编译阶段为非浏览器环境才会开启，也就是 nodejs 环境\u003c/strong\u003e，为什么呢？因为静态节点字符串化的生成判断是比较耗性能的。\u003c/p\u003e\n\u003cp\u003e生成字符串节点，首先必须是 \u003ccode\u003ehoist\u003c/code\u003e 静态的节点。其次若子节点连续大于等于 20 个静态节点或者节点中有大于等于 5 个节点有 props，则会进入字符串化。\u003c/p\u003e\n\u003cp\u003e对于大于等于 20 个节点或者有大于等于 5 个节点有 props 的判断大致如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e nc = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 当前节点数量\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e ec = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 存在 props 的节点数量\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (; i \u0026lt; children.length; i++) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hoisted = getHoistedNode(child)\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (hoisted) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e node = child \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e StringifiableNode\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = analyzeNode(node)\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (result) {\n      nc += result[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n      ec += result[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n      \u003cspan class=\"hljs-comment\"\u003e// 节点 push 到 currentChunk 里面为后面 stringifyCurrentChunk 做准备\u003c/span\u003e\n      currentChunk.push(node)\n      \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e\n    }\n  }\n  i -= stringifyCurrentChunk(i)\n  nc = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n  ec = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n  currentChunk.length = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n}\nstringifyCurrentChunk(i);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e会对 parent 下所有的一级子节点遍历，如果遍历的时候发现节点可以静态化，就一直 \u003ccode\u003econtinue\u003c/code\u003e，若不能，则对之前的可以静态化的节点进行 \u003ccode\u003estringifyCurrentChunk\u003c/code\u003e 处理，并且重置 \u003ccode\u003enc\u003c/code\u003e \u003ccode\u003eec\u003c/code\u003e \u003ccode\u003ecurrentChunk\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e上面是总体的流程，重点是 \u003ccode\u003eanalyzeNode\u003c/code\u003e 和 \u003ccode\u003estringifyCurrentChunk\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e前者 \u003ccode\u003eanalyzeNode\u003c/code\u003e 会不断的遍历所有嵌套的子节点，比如如下结构，会被认为存在 3 个静态节点。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eanalyzeNode\u003c/code\u003e 里面还会对 props 判断，如果 props 不是常见的静态类型，则最后有 \u003ccode\u003eresult = false\u003c/code\u003e，分为以下情况：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e如果已知的 attr，则可以静态化，因为 alt、src 这些，是 dom 本身就有的。\u003c/li\u003e\n\u003cli\u003e或者是已知的静态 binding，如 :src=\u0026quot;1\u0026quot;，这个可以静态化的，反之 :abc=\u0026quot;1\u0026quot;，就不可以。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e对于子节点，如果存在孙节点，则会继续遍历，若节点存在 props，则 \u003ccode\u003eec++\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estringifyCurrentChunk\u003c/code\u003e 会对收集到的可以静态字符串化的节点进行处理，但是这里的静态化，也是一个遍历的过程：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e staticCall = createCallExpression(context.helper(CREATE_STATIC), [\n  \u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.stringify(\n    currentChunk.map(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003enode\u003c/span\u003e) =\u0026gt;\u003c/span\u003e stringifyNode(node, context)).join(\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\n  ),\n  \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e(currentChunk.length),\n]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e每个节点，都会经过 \u003ccode\u003estringifyNode\u003c/code\u003e 处理，最后 JSON 化。\u003ccode\u003estringifyNode\u003c/code\u003e 里面会根据不同的节点类型来处理，并遍历树的所有节点，对于 class/style 还会特别处理。这里就不继续阐述里面的规则了。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e可以看出来，静态节点字符串化，效果虽然很好，但是其会对节点树进行两次遍历，一次是判断是否可以字符串化，一次是将节点转为字符串\u003c/strong\u003e 过程比较耗时。至于能否两次合为一次，自然是不能的。\u003c/p\u003e\n\u003cp\u003e只是有个问题，为什么会是 20 个节点以上或者是 5 个含有 props 的节点就判断可以字符串化呢？如果定义 20 个节点为阈值，是为了避免过渡字符串化，那 5 个含有 props 的节点，又是什么考虑呢？这不是明明小于 20 个节点吗，还是认为存在 props 的节点，一般都有 4 个属性？\u003c/p\u003e\n\u003ch2\u003ediff\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ediff\u003c/code\u003e 的过程，在 Vue 和 React 里面，已经从原始的整个树更新对比，算法复杂度 O(n3) 转换成 O(n) 了。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHowever, the state of the art algorithms have a complexity in the order of O(n3) where n is the number of elements in the tree.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e而这里的 O(n) 也不是最终的目标，比如 react，会将所有需要更新的串在一起，只处理有更新的节点（有点久了，应该是这样的吧），而 Vue3 的思路思路则是维护一个动态数组，\u003ccode\u003edynamicChildren\u003c/code\u003e，应该说不是一个，而是每个 \u003ccode\u003eblock\u003c/code\u003e 都存在 \u003ccode\u003edynamicChildren\u003c/code\u003e，这个 \u003ccode\u003edynamicChildren\u003c/code\u003e 是更新的主角，毕竟，静态节点就不用考虑更新了。\u003c/p\u003e\n\u003ch3\u003edynamicChildren 生成\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003edynamicChildren\u003c/code\u003e 的生成是与 \u003ccode\u003ecreateBlock\u003c/code\u003e 函数绑定的，只有在 \u003ccode\u003ecreateBlock\u003c/code\u003e 里面才有可能生成 \u003ccode\u003edynamicChildren\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e比如下面代码\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata-name\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u0026gt;\u003c/span\u003e{{stat.count}}\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e最后生成下面的 vnode：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// vnode\u003c/span\u003e\n{\n  \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'div'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: [\n    {\n      \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'data-name'\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e],\n      \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: [\n        { \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'li'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'2'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003epatchFlag\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e }\n      ]\n    }\n  ],\n  \u003cspan class=\"hljs-attr\"\u003edynamicChildren\u003c/span\u003e: [\n    { \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'li'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'2'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003epatchFlag\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e }\n  ]\n}\n\u003cspan class=\"hljs-comment\"\u003e// 对应的 compile函数\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ctx, _cache\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (_openBlock(), _createBlock(\u003cspan class=\"hljs-string\"\u003e\"div\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, [\n    _createVNode(\u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e, _hoisted_1, [\n      _createVNode(\u003cspan class=\"hljs-string\"\u003e\"li\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, _toDisplayString(stat.count), \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e/* TEXT */\u003c/span\u003e)\n    ])\n  ]))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到最后生成的 \u003ccode\u003edynamicChildren\u003c/code\u003e 部分只包含了动态内容，在后面的 \u003ccode\u003ediff\u003c/code\u003e 过程则完全可以将 a 标签忽略掉。同时也可以看到 \u003ccode\u003eopenBlock\u003c/code\u003e 和 \u003ccode\u003ecreateBlock\u003c/code\u003e，前者需要在每次调用 \u003ccode\u003ecreateBlock\u003c/code\u003e 时触发，用来重置全局变量 \u003ccode\u003ecurrentBlock\u003c/code\u003e 数组，后者 \u003ccode\u003ecreateBlock\u003c/code\u003e 则会在子节点的 vnode 构建完成后，将这里的 div 标签生成 vnode，并将 \u003ccode\u003ecurrentBlock\u003c/code\u003e 赋予该 vnode 的 \u003ccode\u003edynamicChildren\u003c/code\u003e 字段。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ecurrentBlock\u003c/code\u003e 数组会在生成 vnode 的时候收集节点，具体如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n  (shouldTrack \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e || isRenderingTemplateSlot) \u0026amp;\u0026amp;\n  !isBlockNode \u0026amp;\u0026amp;\n  currentBlock \u0026amp;\u0026amp;\n  (patchFlag \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e || shapeFlag \u0026amp; ShapeFlags.COMPONENT) \u0026amp;\u0026amp;\n  patchFlag !== PatchFlags.HYDRATE_EVENTS\n) {\n  currentBlock.push(vnode);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里的条件蛮多的，\u003ccode\u003eshouldTrack\u003c/code\u003e 表示目前处于实例生成更新阶段，也就是不是 \u003ccode\u003ecompile\u003c/code\u003e 阶段，\u003ccode\u003eisBlockNode\u003c/code\u003e 是目前的 vnode 为 \u003ccode\u003eblock\u003c/code\u003e 节点，也就是可以生成 \u003ccode\u003edynamicChildren\u003c/code\u003e， \u003ccode\u003epatchFlag\u003c/code\u003e 这个是重点，大于 0 表示其为动态内容（当然事件监听 \u003ccode\u003ePatchFlags.HYDRATE_EVENTS\u003c/code\u003e，不在这里面）。后面会重点介绍 \u003ccode\u003epatchFlag\u003c/code\u003e。\u003c/p\u003e\n\u003ch3\u003edynamicChildren 对比\u003c/h3\u003e\n\u003cp\u003e在更新的时候，会对比前一个 vnode 生成 \u003ccode\u003edynamicChildren\u003c/code\u003e，与现在生成的 \u003ccode\u003edynamicChildren\u003c/code\u003e，处理如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e patchBlockChildren: PatchBlockChildrenFn = (\n  oldChildren,\n  newChildren,\n  fallbackContainer,\n  parentComponent,\n  parentSuspense,\n  isSVG\n) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; newChildren.length; i++) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e oldVNode = oldChildren[i]\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newVNode = newChildren[i]\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container =\n      oldVNode.type === Fragment ||\n      !isSameVNodeType(oldVNode, newVNode) ||\n      oldVNode.shapeFlag \u0026amp; ShapeFlags.COMPONENT ||\n      oldVNode.shapeFlag \u0026amp; ShapeFlags.TELEPORT\n        ? hostParentNode(oldVNode.el!)!\n        : fallbackContainer\n    patch(\n      oldVNode,\n      newVNode,\n      container,\n      \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n      parentComponent,\n      parentSuspense,\n      isSVG,\n      \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n    )\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 \u003ccode\u003epatchBlockChildren\u003c/code\u003e 里面会对每一个新老的 \u003ccode\u003echild\u003c/code\u003e 一一对比，再通过 \u003ccode\u003epatch\u003c/code\u003e 来更新。只是看到这里就有一个问题了，在 \u003ccode\u003efor\u003c/code\u003e 语句里面可以看到是严格要求新老 \u003ccode\u003edynamicChildren\u003c/code\u003e 数组的长度是一致的，只是真的会一样吗？\u003c/p\u003e\n\u003cp\u003e比如 \u003ccode\u003ev-for\u003c/code\u003e，都不知道最后有多少个遍历的节点，如何确定长度呢？抱着这样的想法，试试 \u003ccode\u003ev-for\u003c/code\u003e 编译生成的代码：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata-name\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ev-for\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"i in 2\"\u003c/span\u003e\u0026gt;\u003c/span\u003e1\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ctx, _cache\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    _openBlock(),\n    _createBlock(\u003cspan class=\"hljs-string\"\u003e\"div\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, [\n      _createVNode(\u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e, _hoisted_1, [\n        (_openBlock(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e),\n        _createBlock(\n          _Fragment,\n          \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n          _renderList(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, (i) =\u0026gt; {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _openBlock(), _createBlock(\u003cspan class=\"hljs-string\"\u003e\"li\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e);\n          }),\n          \u003cspan class=\"hljs-number\"\u003e256\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e/* UNKEYED_FRAGMENT */\u003c/span\u003e\n        )),\n      ]),\n    ])\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到上面为了 \u003ccode\u003ev-for\u003c/code\u003e 新增加了 \u003ccode\u003ecreateBlock\u003c/code\u003e，也就是对 \u003ccode\u003efragment\u003c/code\u003e 这个 vnode 也赋予了 \u003ccode\u003edynamicChildren\u003c/code\u003e，这样就不管有几个循环节点，外部看到的只有一个 \u003ccode\u003efragment\u003c/code\u003e 片段，这样就能一一对应上了，只是虽然套多了一层 \u003ccode\u003efragment\u003c/code\u003e，外面是稳定了，但是里面呢？ \u003ccode\u003efor\u003c/code\u003e 的数量还是不是固定的。\u003c/p\u003e\n\u003cp\u003e其实执行 \u003ccode\u003e_openBlock(true)\u003c/code\u003e 的时候，已经将 \u003ccode\u003ecurrentBlock\u003c/code\u003e 数组置为 \u003ccode\u003efalse\u003c/code\u003e，所以 \u003ccode\u003edynamicChildren\u003c/code\u003e 也无法生成，自然 \u003ccode\u003ev-for\u003c/code\u003e 生成的节点无法进入 \u003ccode\u003epatchBlockChildren\u003c/code\u003e 函数里面。\u003ccode\u003ev-for\u003c/code\u003e 的 \u003ccode\u003ediff\u003c/code\u003e，是所有子节点都要一一 \u003ccode\u003ediff\u003c/code\u003e，也就是全量对比。\u003c/p\u003e\n\u003cp\u003e当然也有例外，当 vnode 的 \u003ccode\u003ePatchFlag\u003c/code\u003e 是 \u003ccode\u003ePatchFlags.STABLE_FRAGMENT\u003c/code\u003e 时，表示其是一个不变的 \u003ccode\u003efragment\u003c/code\u003e，最后也会通过 \u003ccode\u003epatchBlockChildren\u003c/code\u003e 对比子节点，而不是普通全量对比，什么是稳定的不变的片段呢？比如 \u003ccode\u003e\u0026lt;li v-for=\u0026quot;i in 2\u0026quot;\u0026gt;1\u0026lt;/li\u0026gt;\u003c/code\u003e 这个片段是不可能有动态改变，是稳定的。只是为什么 \u003ccode\u003ecompile\u003c/code\u003e 的代码没有生成 \u003ccode\u003ePatchFlags.STABLE_FRAGMENT\u003c/code\u003e 呢？因为这部分 \u003ccode\u003ePatchFlags.STABLE_FRAGMENT\u003c/code\u003e 的判断，不能在浏览器侧 compile，需要在 nodejs 端。具体判断如下\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e需要在非浏览器端 compile。\u003c/li\u003e\n\u003cli\u003e如果 \u003ccode\u003ev-for\u003c/code\u003e 的右侧是个变量，则不是稳定节点，除非是 this/NaN/Infinity 这样的骚操作。\u003c/li\u003e\n\u003cli\u003e其他的情况会通过 Babel 的 \u003ccode\u003eparse\u003c/code\u003e 方法来解析 \u003ccode\u003ev-for\u003c/code\u003e 的右侧生成 \u003ccode\u003east\u003c/code\u003e 树，可能存在 \u003ccode\u003ev-for=\u0026quot;i in () =\u0026gt; 1 + 1\u0026quot;\u003c/code\u003e 这样的骚操作，当然常量 \u003ccode\u003ev-for=i in 2\u003c/code\u003e 也在这个范畴里面。需要遍历 \u003ccode\u003east\u003c/code\u003e 树，来确定静态的部分。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e确定了 \u003ccode\u003edynamicChildren\u003c/code\u003e 结构之后，就是进行 \u003ccode\u003ediff\u003c/code\u003e 操作。\u003c/p\u003e\n\u003ch3\u003epatchFlag 与 diff\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003epatchFlag\u003c/code\u003e 是优化模式 \u003ccode\u003eoptimized mode\u003c/code\u003e 里用到的优化标识，通过位操作来判断当前 vnode 的需要执行的 \u003ccode\u003ediff\u003c/code\u003e 操作。常见的 \u003ccode\u003epatchFlag\u003c/code\u003e 有\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eTEXT: 1\u003c/code\u003e，存在动态文本内容，比如 \u003ccode\u003e{{ state.count }}\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCLASS: 1\u0026lt;\u0026lt;1\u003c/code\u003e，存在动态的 class。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSTYLE: 1\u0026lt;\u0026lt;2\u003c/code\u003e，存在 style，如果是静态的字符串 \u003ccode\u003e\u0026lt;div style=\u0026quot;color: red\u0026quot;/\u0026gt;\u003c/code\u003e 也会被解析成动态的 style。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePROPS: 1\u0026lt;\u0026lt;3\u003c/code\u003e，存在除了 class/style 以外的动态 props 的情况。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eFULL_PROPS: 1\u0026lt;\u0026lt;4\u003c/code\u003e，表示 props 存在动态字段名，如 \u003ccode\u003e\u0026lt;div :[foo]=\u0026quot;bar\u0026quot;\u0026gt;\u003c/code\u003e，与上面的 \u003ccode\u003eCLASS/STYLE/PROPS\u003c/code\u003e 互斥。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e以及前面提到的 \u003ccode\u003eSTABLE_FRAGMENT\u003c/code\u003e，当然还有更多没有来得及了解的位运算情况，另外还有特殊情况如非位操作的 \u003ccode\u003eHOISTED: -1\u003c/code\u003e 这些。\u003c/p\u003e\n\u003cp\u003e生成的 \u003ccode\u003epatchFlag\u003c/code\u003e 会传入 vnode 里面，当进行 \u003ccode\u003epatch\u003c/code\u003e 来 \u003ccode\u003ediff\u003c/code\u003e 的时候就会用到，比如以下常见结构\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (patchFlag \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (patchFlag \u0026amp; PatchFlags.FULL_PROPS) {\n    \u003cspan class=\"hljs-comment\"\u003e// patchProps 对每一个props 都重新对比，遍历新的props更新/新增，在遍历老的props，若不存在则删掉\u003c/span\u003e\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (patchFlag \u0026amp; PatchFlags.CLASS) {\n      \u003cspan class=\"hljs-comment\"\u003e// 更新 class\u003c/span\u003e\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (patchFlag \u0026amp; PatchFlags.STYLE) {\n      \u003cspan class=\"hljs-comment\"\u003e// 更新 style\u003c/span\u003e\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (patchFlag \u0026amp; PatchFlags.PROPS) {\n      \u003cspan class=\"hljs-comment\"\u003e// 对动态props进行遍历\u003c/span\u003e\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (patchFlag \u0026amp; PatchFlags.TEXT) {\n      \u003cspan class=\"hljs-comment\"\u003e// 更新动态文案\u003c/span\u003e\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过 \u003ccode\u003epatchFlag\u003c/code\u003e 可以精准的更新 props、class、style 和动态文案这些。这些基本就是日常操作了， \u003ccode\u003edynamicChildren\u003c/code\u003e 直接更新到 vnode。现在看看复杂的情况，全量对比，比如在 \u003ccode\u003ev-for\u003c/code\u003e 的非稳定节点的 \u003ccode\u003ediff\u003c/code\u003e 操作，其中分为有 \u003ccode\u003ekey\u003c/code\u003e 的 \u003ccode\u003echildren，和无\u003c/code\u003e key 的。\u003c/p\u003e\n\u003cp\u003e先介绍一下 \u003ccode\u003epatchUnkeyedChildren\u003c/code\u003e，如果没有在 \u003ccode\u003e\u0026lt;li v-for=\u0026quot;i in state.count\u0026quot;/\u0026gt;\u003c/code\u003e 里面找到 \u003ccode\u003ekey\u003c/code\u003e 字段，则会进入。首先会取到新老 \u003ccode\u003echildren\u003c/code\u003e 的公共最小长度，对该范围里面的节点，进行 \u003ccode\u003epatch\u003c/code\u003e 处理。超出长度的节点，若是老的 children 多，则卸载，若新的 children 多则进行挂载。\u003c/p\u003e\n\u003cp\u003e若是有 key，\u003cstrong\u003e则会执行 \u003ccode\u003epatchKeyedChildren\u003c/code\u003e\u003c/strong\u003e，（由于懒得做图，这里就简述一下）具体算法步骤：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e patchKeyedChildren = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e l2 = c2.length;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e e1 = c1.length - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 老 vnode.children 最后的索引\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e e2 = l2 - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 新 vnode.children 最后的索引\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// 1. 从前往后，比如老： (a b)  新：(a b) c 的情况\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (i \u0026lt;= e1 \u0026amp;\u0026amp; i \u0026lt;= e2) {\n    \u003cspan class=\"hljs-comment\"\u003e// 如果是同样类型的 vnode，即 type 和 key 是一样的，则 patch 对比，并且 i++\u003c/span\u003e\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 2. 从后往前，比如老： a (b c)  新：e (b c) 的情况\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (i \u0026lt;= e1 \u0026amp;\u0026amp; i \u0026lt;= e2) {\n    \u003cspan class=\"hljs-comment\"\u003e// 如果是同样类型的 vnode，即 type 和 key 是一样的，则 patch 对比，并且 e1-- 以及 e2--\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// 3. 如果新的包含老的，而新的比老的内容多，如 老的 (a b)，新的 (a b) c\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (i \u0026gt; e1) {\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (i \u0026lt;= e2) {\n      \u003cspan class=\"hljs-comment\"\u003e// 新增新增加的 child，同时 i++\u003c/span\u003e\n    }\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// 4. 如果老的包含新的，而新的比老的内容少，如 老的 (a b) c，新的 (a b)\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (i \u0026gt; e2) {\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (i \u0026lt;= e1) {\n      \u003cspan class=\"hljs-comment\"\u003e// 卸载老的多余的 child，同时 i++\u003c/span\u003e\n    }\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// 还有步骤 5.1/5.2/5.3 复杂情况看下面\u003c/span\u003e\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面的都是比较理想的情况，然而存在混乱的情况，比如\n老的： a b c d e f g h\n新的： a b f d e c g h\u003c/p\u003e\n\u003cp\u003e所以对于步骤 5 还有有三部曲：\u003c/p\u003e\n\u003cp\u003e5.1 为新的 children 生成一个 \u003ccode\u003ekey:index\u003c/code\u003e 的 \u003ccode\u003emap\u003c/code\u003e，\u003ccode\u003ekeyToNewIndexMap\u003c/code\u003e 表示新 children 中 key 和索引的关系\n5.2 设置长度为 \u003ccode\u003ee2 - i\u003c/code\u003e，每个元素的值为 \u003ccode\u003e0\u003c/code\u003e 的 \u003ccode\u003enewIndexToOldIndexMap\u003c/code\u003e 数组。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e遍历老 children 节点，从 \u003ccode\u003ekeyToNewIndexMap\u003c/code\u003e 获取与老 child 相同 key 的索引，也就是对应新节点的索引，然后通过 \u003ccode\u003epatch\u003c/code\u003e 函数更新，若老节点没有 key，则寻找相同 type/没有 key 的元素来对比，若还找不到，说明这个老元素在新的里面不存在，可以卸载了。\u003c/li\u003e\n\u003cli\u003e若新老可以 patch，则会设置 \u003ccode\u003enewIndexToOldIndexMap[newIndex - s2] = i + 1\u003c/code\u003e，指明新节点在老节点中的索引关系。比如上面的例子 \u003ccode\u003enewIndexToOldIndexMap = [6, 4, 5, 3]\u003c/code\u003e。\n5.3 挂载和移动，遍历需要操作的节点，如果是 \u003ccode\u003enewIndexToOldIndexMap\u003c/code\u003e 存在 \u003ccode\u003e0\u003c/code\u003e 的值，则说明是新节点，需要挂载上。另外上面的步骤只是更新了 \u003ccode\u003evnode.el\u003c/code\u003e，如果出现步骤 5 中的位置错乱的情况，目前只是更新 dom 的内容，其顺序没有改变。\u003cstrong\u003e这里需要根据 \u003ccode\u003enewIndexToOldIndexMap\u003c/code\u003e 来移动需要调整的节点\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e对于 5.3 里面 dom 位置的移动，Vue3 采用了 \u003cstrong\u003e最长递增子序列\u003c/strong\u003e 的\u003ca href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97\" target=\"_blank\"\u003e概念\u003c/a\u003e，有动态规划的思维在里面（反正没有看懂算法），感兴趣的可以去了解一下。\u003cstrong\u003e该最长递增子序列是作用是尽量减少 dom 的移动。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e如果出现新 children 的节点没有按照老 children 的节点顺序排列，比如例子中的 \u003ccode\u003ef d e c\u003c/code\u003e，就会以 \u003ccode\u003enewIndexToOldIndexMap\u003c/code\u003e 为输入，求得最长递增子序列对应的索引，上面的例子则是：\u003ccode\u003eincreasingNewIndexSequence = [1, 2]\u003c/code\u003e。 后面移动的时候从后往前遍历，节点从 \u003ccode\u003ec d e f\u003c/code\u003e 到 \u003ccode\u003ef d e c\u003c/code\u003e，具体过程如下：\u003c/p\u003e\n\u003cp\u003e这里 \u003ccode\u003eindex\u003c/code\u003e 值是 5.3 步骤遍历中的索引，递减，\u003ccode\u003ej\u003c/code\u003e初始值为 \u003ccode\u003eincreasingNewIndexSequence.length - 1\u003c/code\u003e。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eindex = 3\u003c/code\u003e 先 \u003ccode\u003ec.el\u003c/code\u003e 移动到 \u003ccode\u003eg\u003c/code\u003e 前面, index--；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eindex = 2\u003c/code\u003e，遇到 \u003ccode\u003ee\u003c/code\u003e 的时候由于 \u003ccode\u003eindex === increasingNewIndexSequence[j]\u003c/code\u003e，均为 \u003ccode\u003e2\u003c/code\u003e，则不进行移动，\u003ccode\u003eincreasingNewIndexSequence\u003c/code\u003e 的索引 j--。同理轮到 \u003ccode\u003ed\u003c/code\u003e 也是类似操作。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eindex = 0\u003c/code\u003e，\u003ccode\u003ef.el\u003c/code\u003e 需要移动到 \u003ccode\u003ed\u003c/code\u003e 前面。到这里移动结束。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e可以看到原本是四个节点的，通过最长递增子序列的对比，可以明确哪些节点需要移动的，最后只要执行两次移动就完成了，可以说是 dom 移动的最优解吧。\u003c/p\u003e\n\u003cp\u003e到这里 \u003ccode\u003ediff\u003c/code\u003e 的过程差不多告一段落了~~~\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e这次 Vue3 的代码，看着很舒服，可能是 ts 的问题，哪里不懂点哪里。\u003c/p\u003e\n\u003cp\u003e虽然 Vue3 还有很多内容没有研究透彻，甚至上面的部分内容，还有不少疑惑，比如 \u003ccode\u003ehoist\u003c/code\u003e 为什么只能在 nodejs 端开启？\u003ccode\u003edynamicChildren\u003c/code\u003e 这种方式是最优解吗？好像 react 的方式更好吧？生成 \u003ccode\u003eSTABLE_FRAGMENT\u003c/code\u003e 的所有情况？以及其他没有学习到的，比如事件处理，插槽，比如 \u003ccode\u003ev-if\u003c/code\u003e \u003ccode\u003ev-model\u003c/code\u003e 这些。只是还是想要去别的领域走走，去深水区走走。所以 Vue/React 的学习应该会告一段落了。\u003c/p\u003e\n"}},"buildId":"r4Ww0YLm8YL5~6SwciWHH","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" async=""></script></body></html>