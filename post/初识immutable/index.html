<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">初识immutable</title><link rel="preload" href="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.491f56ba.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___3Hk0c "><a class="logo___1KD30" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___1qXLb" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___3VKNp"><h1 class="postTitle___26vXM">初识immutable</h1><span class="postTime___16Ish">July 7, 2018</span></header><article class="postWrapper___3NXol post-article"><div><h3>前言</h3>
<p>Immutable.js 出来已经有很长一段时间了，只是日常项目中一直用不上。一个是平时没有怎么接触，不了解，另外一个是团队的开发节奏和习惯已经稳定下来了，要改变也不容易。当然了解一下也不差。</p>
<p>不可变的数据一旦生成，就无法被改变，这就要求数据可持久化。可是日常中的引用类型的数据，一旦改变了，就改变了，谈什么持久化数据结构呢？</p>
<h3>接触immutable</h3>
<p>感受一下immutable的不同：</p>
<pre class="hljs"><code><span class="hljs-comment">// 原本写法：</span>
<span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
<span class="hljs-keyword">let</span> b = a;
b[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
<span class="hljs-built_in">console</span>.log(a[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 0</span>
<span class="hljs-built_in">console</span>.log(a === b); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// immutable 里面的写法</span>
<span class="hljs-keyword">import</span> { List } <span class="hljs-keyword">from</span> <span class="hljs-string">'immutable'</span>;
<span class="hljs-keyword">let</span> a = List([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);
<span class="hljs-keyword">let</span> b = a.set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-built_in">console</span>.log(a.get(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">console</span>.log(b.equals(a)) <span class="hljs-comment">// false</span>
</code></pre>
<p>可以直观的看到在没有使用 immutable 之前， a 与 b 都是同一引用，一旦其中的数据修改了，另一个也会跟着变化，毕竟 a 是等于 b 的。而到了 immutable，就不一样了，当你设置 <code>a.set(0, 0)</code> 的时候，并不会修改 a ，而是返回一个新的数组赋予到 b，所以 a 还是原来的 a。</p>
<p>**这就是 immutable 致力解决的疼点：持久化数据解构。**平时使用数据的时候，可能一不小心就会把引用类型数据修改了，导致一些隐藏比较深的问题。尤其是对后来的开发者/维护者而言，意义就更重大了。</p>
<p>在 immutable 里面常见的数据类型有：</p>
<ol>
<li>List： 有序可重复列表，类似于 Javascript 的 Arry；</li>
<li>Map：键值对，类似于 Javascript 的 Object；</li>
</ol>
<p>其 API 还是很亲民的，基本上字如其名，大致接触一下就能够了解了。常用的用法这里就不做介绍了，需要了解，请移步<a href="http://facebook.github.io/immutable-js/" target="_blank">官方文档</a>。</p>
<h3>List 类型</h3>
<p>Liit 类型可以说是常用的了，尤其是和 Javascript 里面的 Arry 类似。看一下 List 里面的主要部分：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeList</span>(<span class="hljs-params">origin, capacity, level, root, tail, ownerID, hash</span>) </span>{
  <span class="hljs-keyword">const</span> list = <span class="hljs-built_in">Object</span>.create(ListPrototype);
  list.size = capacity - origin;
  list._origin = origin;
  list._capacity = capacity;
  list._level = level;
  list._root = root;
  list._tail = tail;
  list.__ownerID = ownerID;
  list.__hash = hash;
  list.__altered = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">return</span> list;
}
</code></pre>
<p>一个空内容的 List，也就是 <code>List()</code>，是 <code>makeList(0, 0, SHIFT))</code> 生成的，而 SHIFT 的值为 5。传入 List 括号里面的值会被存储在 _root 和 _tail 里面，只是 _root 和 _tail 里面的数据又有以下结构：</p>
<pre class="hljs"><code><span class="hljs-comment">// @VNode class</span>
<span class="hljs-keyword">constructor</span>(array, ownerID) {
  <span class="hljs-keyword">this</span>.array = array;
  <span class="hljs-keyword">this</span>.ownerID = ownerID;
}
</code></pre>
<p>在 List 列表的生成里，就可以看到，持久化数据的形成，比如看看为何将数据分别保持在 _tail 和 _root 里面，以及又是用何种方式保存；</p>
<p>以设置一个数据为例子，如： List([1]).set(0, 0):</p>
<pre class="hljs"><code>set(index, value) {
  <span class="hljs-keyword">return</span> updateList(<span class="hljs-keyword">this</span>, index, value);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateList</span>(<span class="hljs-params">list, index, value</span>) </span>{
  ...
  let newTail = list._tail;
  <span class="hljs-keyword">let</span> newRoot = list._root;
  <span class="hljs-keyword">const</span> didAlter = MakeRef(DID_ALTER);
  <span class="hljs-keyword">if</span> (index &gt;= getTailOffset(list._capacity)) {
    newTail = updateVNode(newTail, list.__ownerID, <span class="hljs-number">0</span>, index, value, didAlter);
  } <span class="hljs-keyword">else</span> {
    newRoot = updateVNode(
      newRoot,
      list.__ownerID,
      list._level,
      index,
      value,
      didAlter
    );
  }
  ...
  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
}
<span class="hljs-comment">// SIZE = 1 &lt;&lt; SHIFT，而 SHIFT = 5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTailOffset</span>(<span class="hljs-params">size</span>) </span>{
  <span class="hljs-keyword">return</span> size &lt; SIZE ? <span class="hljs-number">0</span> : ((size - <span class="hljs-number">1</span>) &gt;&gt;&gt; SHIFT) &lt;&lt; SHIFT;
}
</code></pre>
<p>可以看出在 updateList 里面，通过 _capacity 来判断，以 32位 为尺度将 _capacity 切分开来，当 index 大于 <code>((size - 1) &gt;&gt;&gt; SHIFT) &lt;&lt; SHIFT</code> 时候，更新 _trail, 否则更新 _root。例如： 当 _capacity 为 33，index 为 32 及其以下的时候，修改的都是 _root，否之则修改 _tail。这个是很好理解的，当数据量达到一定程度的时候，针对靠后的数据单独存储，而靠前的数据放在 _tail，分类处理。只是特别之处在与 _tail 的设计。</p>
<h4>List 里面的 32 阶 RRB-Tree</h4>
<p>_tail 里面采用的是 RRB-Tree 的形式存储数据。这个什么树的先不介绍，先看看看怎么形成，形成的是什么，继续看上面的 updateList 方法，里面用到了 updateVNode 方法来生成 _tail:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateVNode</span>(<span class="hljs-params">node, ownerID, level, index, value, didAlter</span>) </span>{
  <span class="hljs-comment">// MASK = 31;</span>
  <span class="hljs-keyword">const</span> idx = (index &gt;&gt;&gt; level) &amp; MASK;
  ...
  let newNode;
  <span class="hljs-keyword">if</span> (level &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">const</span> lowerNode = node &amp;&amp; node.array[idx];
    <span class="hljs-keyword">const</span> newLowerNode = updateVNode(
      lowerNode,
      ownerID,
      level - SHIFT,
      index,
      value,
      didAlter
    );
    <span class="hljs-keyword">if</span> (newLowerNode === lowerNode) {
      <span class="hljs-keyword">return</span> node;
    }
    newNode = editableVNode(node, ownerID);
    newNode.array[idx] = newLowerNode;
    <span class="hljs-keyword">return</span> newNode;
  }
  ...
  newNode = editableVNode(node, ownerID);
  <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">undefined</span> &amp;&amp; idx === newNode.array.length - <span class="hljs-number">1</span>) {
    newNode.array.pop();
  } <span class="hljs-keyword">else</span> {
    newNode.array[idx] = value;
  }
  <span class="hljs-keyword">return</span> newNode;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">editableVNode</span>(<span class="hljs-params">node, ownerID</span>) </span>{
  <span class="hljs-keyword">if</span> (ownerID &amp;&amp; node &amp;&amp; ownerID === node.ownerID) {
    <span class="hljs-keyword">return</span> node;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> VNode(node ? node.array.slice() : [], ownerID);
}
<span class="hljs-comment">// @VNode class</span>
<span class="hljs-keyword">constructor</span>(array, ownerID) {
  <span class="hljs-keyword">this</span>.array = array;
  <span class="hljs-keyword">this</span>.ownerID = ownerID;
}
</code></pre>
<p>在这里可以看到 value/newLowerNode 是赋值给 <code>newNode.array[idx]</code>， 而 idx 并不是等于 index。以 _capacity 为 65 的 List 为例子，其 _level 为 5。当 index 为 60 的时候，有以下行为：</p>
<ol>
<li>第一次进入 idx = 1，level = 5，将会有 _tail.array[1] = newLowerNode;</li>
<li>计算 1 里面的 newLowerNode，第二次进入，此时 level = 0，idx = 28，于是有 newLowerNode.array[28] = value；
可以看出这里生成个<strong>二维的数组，其中每个子节点的长度最大为 32，于是这就构成了一个 32阶的树结构</strong>。至于为什么阶长是 32，在代码中是这么解释的：</li>
</ol>
<blockquote>
<p>Resulted in best performance after ______?</p>
</blockquote>
<p>这不是逗我嘛。。。什么都没有写好吧，而且 github 里面最早的版本也是这么写的。。。。最后还好找到是有测试实验数据证明 32 也就是 SHIFT 为 5 是最佳实践。至于为什么要采用这种结构，不是本文要考虑的，将在下篇中给出来。</p>
<p>最后数据生成的结构如下如所示：
<img src="https://github.com/funfish/blog/raw/master/images/immutableTree.PNG" alt=""></p>
<p>get 方法里面也是差不多的，通过 _capacity 来判断。</p>
<h2>Map 类型结构</h2>
<p>同样的先看看一个空的 Map() 的结构：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeMap</span>(<span class="hljs-params">size, root, ownerID, hash</span>) </span>{
  <span class="hljs-keyword">const</span> map = <span class="hljs-built_in">Object</span>.create(MapPrototype);
  map.size = size;
  map._root = root;
  map.__ownerID = ownerID;
  map.__hash = hash;
  map.__altered = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">return</span> map;
}
</code></pre>
<p>这里就没有 _tail 结构的，所有数据都放在 _root 里面。只是 _root 里面的数据并非总是简单，采用了 Trie Nodes 的方式存储数据。 immutable 里面将对象的键值对转换为数组表示，即 [key, value] 的形式。</p>
<p>存储的数据分为以下级别：</p>
<ol>
<li>ArrayMapNode，最简单方式，当键值对不超过8个的时候(不含嵌套的键值对)，采用这种方式，所有键值对保存在 entries 里面。同时 get/set 方法都较为简单，直接遍历一下获取就好了；</li>
<li>BitmapIndexedNode，当 ArrayMapNode 里面元素超过8个的时候，_root 会转变为 BitmapIndexedNode，BitmapIndexedNode 的子节点是 ValueNode。在 BitmapIndexedNode 里面查/增/改元素，都需要用到 bit-map(位图)算法，BitmapIndexedNode.bitmap 存储的是键名和存储顺序的位图信息。例如 get 方法，通过 BitmapIndexedNode.bitmap，以及 key 名就可以获取该键值对的排列序号，从而获取到相应的 ValueNode；</li>
<li>HashArrayMapNode，ValueNode 个数超过 16 个的时候，_root 会转变为 HashArrayMapNode 对象，其子元素为 ValueNode。而当 ValueNode 个数超过 32 个的情况时，HashArrayMapNode 的亲子元素就会出现 HashArrayMapNode/BitmapIndexedNode，而 BitmapIndexedNode 的亲子元素可以是 BitmapIndexedNode/ValueNode。由此看来巨量的键值对，将有 HashArrayMapNode/BitmapIndexedNode/ValueNode 组合而成，而每个 HashArrayMapNode 最多有32个亲子元素，BitmapIndexedNode 最多有16个亲子元素。 HashArrayMapNode 类对应带的 count，代表其子元素的数量。当需要读取的时候，直接键名的哈希值，就能够实现了。。。。好像有点简单呀；</li>
<li>HashCollisionNode，这种情况相当少，比如当 {null: 1} 和 {undefined: 2} 的键名是完全不同的，但是他们的键名的哈希值却是一样的。这使得后者 {undefined: 2} 创建的时候才会有 HashCollisionNode。HashCollisionNode 包含了这两个相同哈希值的键名下的数据；</li>
</ol>
<blockquote>
<p>// The hash code for a string is computed as
// s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
(多键值的整个读写离不开键名哈希计算，而其关键步骤如上，n为键名从左到右字母的 charCodeAt)。</p>
</blockquote>
<h2>withMutations 操作</h2>
<p>每次对 immutable 的数据类型操作的时候，都会返回一个新的数据，这样就存在一个问题，如果需要像原本一样对一个数据不断0操作，如不断的向Arry 里面 push 新值。对于 List，每次都返回一个新 List 岂不是多了很多中间变量，多了很多蹩脚的操作？于是就有了 withMutations 操作。如：</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> a = List();
<span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, { <span class="hljs-attr">length</span>: <span class="hljs-number">10</span> }).forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> a = a.push(item));
<span class="hljs-comment">// 上面可以用withMutations操作</span>
a = a.withMutations(<span class="hljs-function"><span class="hljs-params">list</span> =&gt;</span> 
  <span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, { <span class="hljs-attr">length</span>: <span class="hljs-number">10</span> }).forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> list.push(item))
)
</code></pre>
<p>上面为原先不使用 withMutations 的方法，每次 push 之后都需要重新对 a 重新赋值，才能保证正确性。而用了 withMutations 方法之后，不再需要创建中间 List，减少了复杂度，基本上运行时间比前一种快上好几倍。当然 withMutations 不会修改 a，所以需要将中间 List 赋值到 a。</p>
<p>为什么 withMutations 会有这样的效果呢？以 A(List) 为例子，当使用 withMutations 时候，其首先，生成的中间变量 B(List)，其属性值就是 A 的属性值，没有任何更改，当然如果 A 没有 __ownerID， B 的 __ownerID 会被设置上。但是对 B 进行 push/pop/set 等等操作的时候，A 其实是没有受到任何影响的。</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">editableVNode</span>(<span class="hljs-params">node, ownerID</span>) </span>{
  <span class="hljs-keyword">if</span> (ownerID &amp;&amp; node &amp;&amp; ownerID === node.ownerID) {
    <span class="hljs-keyword">return</span> node;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> VNode(node ? node.array.slice() : [], ownerID);
}
</code></pre>
<p>如在 withMutations 操作里面 set 数据的时候， 上面 if 语句是无法通过的，因为 A 的数据里面是没后 ownerID 的，相当于给 A 的数据浅拷贝一次到 B 里面，但是在 withMutations 里面再次 set 的时候，这时上面的 if 语句是可以通过的，于是又能节省不少运行时间。类似的 Map 也是相似的，这里就不再提到了。</p>
<h3>其他</h3>
<p>immutable.js 类型的一层层继承关系，刚开始的看的时候会觉得有点乱，不管哪里都有 extends。细细看下来还是挺不错的。Immutable.js 还有个 Seq 类型，其特点就是懒。懒的意思是，直到获取使用了才开始计算。一开始觉得很神奇，居然有用数据的时候才计算的。。。well，后来一看这得益于一系列的 API，主要就是把调用方法函数数据什么的统统用闭包给存起来。。。。。。。好吧。</p>
<p>ps：immutable.js 最神奇的地方还是在于其数据结构，下篇文章将会好好讲数据结构。</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"July 7, 2018","title":"初识immutable","content":"\u003ch3\u003e前言\u003c/h3\u003e\n\u003cp\u003eImmutable.js 出来已经有很长一段时间了，只是日常项目中一直用不上。一个是平时没有怎么接触，不了解，另外一个是团队的开发节奏和习惯已经稳定下来了，要改变也不容易。当然了解一下也不差。\u003c/p\u003e\n\u003cp\u003e不可变的数据一旦生成，就无法被改变，这就要求数据可持久化。可是日常中的引用类型的数据，一旦改变了，就改变了，谈什么持久化数据结构呢？\u003c/p\u003e\n\u003ch3\u003e接触immutable\u003c/h3\u003e\n\u003cp\u003e感受一下immutable的不同：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 原本写法：\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e a = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e b = a;\nb[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(a[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// 0\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(a === b); \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// immutable 里面的写法\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { List } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'immutable'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e a = List([\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]);\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e b = a.set(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(a.get(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(b.equals(a)) \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以直观的看到在没有使用 immutable 之前， a 与 b 都是同一引用，一旦其中的数据修改了，另一个也会跟着变化，毕竟 a 是等于 b 的。而到了 immutable，就不一样了，当你设置 \u003ccode\u003ea.set(0, 0)\u003c/code\u003e 的时候，并不会修改 a ，而是返回一个新的数组赋予到 b，所以 a 还是原来的 a。\u003c/p\u003e\n\u003cp\u003e**这就是 immutable 致力解决的疼点：持久化数据解构。**平时使用数据的时候，可能一不小心就会把引用类型数据修改了，导致一些隐藏比较深的问题。尤其是对后来的开发者/维护者而言，意义就更重大了。\u003c/p\u003e\n\u003cp\u003e在 immutable 里面常见的数据类型有：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eList： 有序可重复列表，类似于 Javascript 的 Arry；\u003c/li\u003e\n\u003cli\u003eMap：键值对，类似于 Javascript 的 Object；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e其 API 还是很亲民的，基本上字如其名，大致接触一下就能够了解了。常用的用法这里就不做介绍了，需要了解，请移步\u003ca href=\"http://facebook.github.io/immutable-js/\" target=\"_blank\"\u003e官方文档\u003c/a\u003e。\u003c/p\u003e\n\u003ch3\u003eList 类型\u003c/h3\u003e\n\u003cp\u003eLiit 类型可以说是常用的了，尤其是和 Javascript 里面的 Arry 类似。看一下 List 里面的主要部分：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emakeList\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eorigin, capacity, level, root, tail, ownerID, hash\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e list = \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.create(ListPrototype);\n  list.size = capacity - origin;\n  list._origin = origin;\n  list._capacity = capacity;\n  list._level = level;\n  list._root = root;\n  list._tail = tail;\n  list.__ownerID = ownerID;\n  list.__hash = hash;\n  list.__altered = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e list;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e一个空内容的 List，也就是 \u003ccode\u003eList()\u003c/code\u003e，是 \u003ccode\u003emakeList(0, 0, SHIFT))\u003c/code\u003e 生成的，而 SHIFT 的值为 5。传入 List 括号里面的值会被存储在 _root 和 _tail 里面，只是 _root 和 _tail 里面的数据又有以下结构：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// @VNode class\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econstructor\u003c/span\u003e(array, ownerID) {\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.array = array;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.ownerID = ownerID;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 List 列表的生成里，就可以看到，持久化数据的形成，比如看看为何将数据分别保持在 _tail 和 _root 里面，以及又是用何种方式保存；\u003c/p\u003e\n\u003cp\u003e以设置一个数据为例子，如： List([1]).set(0, 0):\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eset(index, value) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e updateList(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, index, value);\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eupdateList\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003elist, index, value\u003c/span\u003e) \u003c/span\u003e{\n  ...\n  let newTail = list._tail;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e newRoot = list._root;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e didAlter = MakeRef(DID_ALTER);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (index \u0026gt;= getTailOffset(list._capacity)) {\n    newTail = updateVNode(newTail, list.__ownerID, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, index, value, didAlter);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    newRoot = updateVNode(\n      newRoot,\n      list.__ownerID,\n      list._level,\n      index,\n      value,\n      didAlter\n    );\n  }\n  ...\n  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n}\n\u003cspan class=\"hljs-comment\"\u003e// SIZE = 1 \u0026lt;\u0026lt; SHIFT，而 SHIFT = 5\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003egetTailOffset\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003esize\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e size \u0026lt; SIZE ? \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e : ((size - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) \u0026gt;\u0026gt;\u0026gt; SHIFT) \u0026lt;\u0026lt; SHIFT;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看出在 updateList 里面，通过 _capacity 来判断，以 32位 为尺度将 _capacity 切分开来，当 index 大于 \u003ccode\u003e((size - 1) \u0026gt;\u0026gt;\u0026gt; SHIFT) \u0026lt;\u0026lt; SHIFT\u003c/code\u003e 时候，更新 _trail, 否则更新 _root。例如： 当 _capacity 为 33，index 为 32 及其以下的时候，修改的都是 _root，否之则修改 _tail。这个是很好理解的，当数据量达到一定程度的时候，针对靠后的数据单独存储，而靠前的数据放在 _tail，分类处理。只是特别之处在与 _tail 的设计。\u003c/p\u003e\n\u003ch4\u003eList 里面的 32 阶 RRB-Tree\u003c/h4\u003e\n\u003cp\u003e_tail 里面采用的是 RRB-Tree 的形式存储数据。这个什么树的先不介绍，先看看看怎么形成，形成的是什么，继续看上面的 updateList 方法，里面用到了 updateVNode 方法来生成 _tail:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eupdateVNode\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enode, ownerID, level, index, value, didAlter\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// MASK = 31;\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e idx = (index \u0026gt;\u0026gt;\u0026gt; level) \u0026amp; MASK;\n  ...\n  let newNode;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (level \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e lowerNode = node \u0026amp;\u0026amp; node.array[idx];\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newLowerNode = updateVNode(\n      lowerNode,\n      ownerID,\n      level - SHIFT,\n      index,\n      value,\n      didAlter\n    );\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (newLowerNode === lowerNode) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e node;\n    }\n    newNode = editableVNode(node, ownerID);\n    newNode.array[idx] = newLowerNode;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e newNode;\n  }\n  ...\n  newNode = editableVNode(node, ownerID);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (value === \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e \u0026amp;\u0026amp; idx === newNode.array.length - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n    newNode.array.pop();\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    newNode.array[idx] = value;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e newNode;\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eeditableVNode\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enode, ownerID\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ownerID \u0026amp;\u0026amp; node \u0026amp;\u0026amp; ownerID === node.ownerID) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e node;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e VNode(node ? node.array.slice() : [], ownerID);\n}\n\u003cspan class=\"hljs-comment\"\u003e// @VNode class\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econstructor\u003c/span\u003e(array, ownerID) {\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.array = array;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.ownerID = ownerID;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在这里可以看到 value/newLowerNode 是赋值给 \u003ccode\u003enewNode.array[idx]\u003c/code\u003e， 而 idx 并不是等于 index。以 _capacity 为 65 的 List 为例子，其 _level 为 5。当 index 为 60 的时候，有以下行为：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e第一次进入 idx = 1，level = 5，将会有 _tail.array[1] = newLowerNode;\u003c/li\u003e\n\u003cli\u003e计算 1 里面的 newLowerNode，第二次进入，此时 level = 0，idx = 28，于是有 newLowerNode.array[28] = value；\n可以看出这里生成个\u003cstrong\u003e二维的数组，其中每个子节点的长度最大为 32，于是这就构成了一个 32阶的树结构\u003c/strong\u003e。至于为什么阶长是 32，在代码中是这么解释的：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eResulted in best performance after ______?\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这不是逗我嘛。。。什么都没有写好吧，而且 github 里面最早的版本也是这么写的。。。。最后还好找到是有测试实验数据证明 32 也就是 SHIFT 为 5 是最佳实践。至于为什么要采用这种结构，不是本文要考虑的，将在下篇中给出来。\u003c/p\u003e\n\u003cp\u003e最后数据生成的结构如下如所示：\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/immutableTree.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eget 方法里面也是差不多的，通过 _capacity 来判断。\u003c/p\u003e\n\u003ch2\u003eMap 类型结构\u003c/h2\u003e\n\u003cp\u003e同样的先看看一个空的 Map() 的结构：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emakeMap\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003esize, root, ownerID, hash\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e map = \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.create(MapPrototype);\n  map.size = size;\n  map._root = root;\n  map.__ownerID = ownerID;\n  map.__hash = hash;\n  map.__altered = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e map;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里就没有 _tail 结构的，所有数据都放在 _root 里面。只是 _root 里面的数据并非总是简单，采用了 Trie Nodes 的方式存储数据。 immutable 里面将对象的键值对转换为数组表示，即 [key, value] 的形式。\u003c/p\u003e\n\u003cp\u003e存储的数据分为以下级别：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eArrayMapNode，最简单方式，当键值对不超过8个的时候(不含嵌套的键值对)，采用这种方式，所有键值对保存在 entries 里面。同时 get/set 方法都较为简单，直接遍历一下获取就好了；\u003c/li\u003e\n\u003cli\u003eBitmapIndexedNode，当 ArrayMapNode 里面元素超过8个的时候，_root 会转变为 BitmapIndexedNode，BitmapIndexedNode 的子节点是 ValueNode。在 BitmapIndexedNode 里面查/增/改元素，都需要用到 bit-map(位图)算法，BitmapIndexedNode.bitmap 存储的是键名和存储顺序的位图信息。例如 get 方法，通过 BitmapIndexedNode.bitmap，以及 key 名就可以获取该键值对的排列序号，从而获取到相应的 ValueNode；\u003c/li\u003e\n\u003cli\u003eHashArrayMapNode，ValueNode 个数超过 16 个的时候，_root 会转变为 HashArrayMapNode 对象，其子元素为 ValueNode。而当 ValueNode 个数超过 32 个的情况时，HashArrayMapNode 的亲子元素就会出现 HashArrayMapNode/BitmapIndexedNode，而 BitmapIndexedNode 的亲子元素可以是 BitmapIndexedNode/ValueNode。由此看来巨量的键值对，将有 HashArrayMapNode/BitmapIndexedNode/ValueNode 组合而成，而每个 HashArrayMapNode 最多有32个亲子元素，BitmapIndexedNode 最多有16个亲子元素。 HashArrayMapNode 类对应带的 count，代表其子元素的数量。当需要读取的时候，直接键名的哈希值，就能够实现了。。。。好像有点简单呀；\u003c/li\u003e\n\u003cli\u003eHashCollisionNode，这种情况相当少，比如当 {null: 1} 和 {undefined: 2} 的键名是完全不同的，但是他们的键名的哈希值却是一样的。这使得后者 {undefined: 2} 创建的时候才会有 HashCollisionNode。HashCollisionNode 包含了这两个相同哈希值的键名下的数据；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e// The hash code for a string is computed as\n// s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n(多键值的整个读写离不开键名哈希计算，而其关键步骤如上，n为键名从左到右字母的 charCodeAt)。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ewithMutations 操作\u003c/h2\u003e\n\u003cp\u003e每次对 immutable 的数据类型操作的时候，都会返回一个新的数据，这样就存在一个问题，如果需要像原本一样对一个数据不断0操作，如不断的向Arry 里面 push 新值。对于 List，每次都返回一个新 List 岂不是多了很多中间变量，多了很多蹩脚的操作？于是就有了 withMutations 操作。如：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e a = List();\n\u003cspan class=\"hljs-built_in\"\u003eArray\u003c/span\u003e.apply(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003elength\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e }).forEach(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eitem\u003c/span\u003e =\u0026gt;\u003c/span\u003e a = a.push(item));\n\u003cspan class=\"hljs-comment\"\u003e// 上面可以用withMutations操作\u003c/span\u003e\na = a.withMutations(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003elist\u003c/span\u003e =\u0026gt;\u003c/span\u003e \n  \u003cspan class=\"hljs-built_in\"\u003eArray\u003c/span\u003e.apply(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003elength\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e }).forEach(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eitem\u003c/span\u003e =\u0026gt;\u003c/span\u003e list.push(item))\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面为原先不使用 withMutations 的方法，每次 push 之后都需要重新对 a 重新赋值，才能保证正确性。而用了 withMutations 方法之后，不再需要创建中间 List，减少了复杂度，基本上运行时间比前一种快上好几倍。当然 withMutations 不会修改 a，所以需要将中间 List 赋值到 a。\u003c/p\u003e\n\u003cp\u003e为什么 withMutations 会有这样的效果呢？以 A(List) 为例子，当使用 withMutations 时候，其首先，生成的中间变量 B(List)，其属性值就是 A 的属性值，没有任何更改，当然如果 A 没有 __ownerID， B 的 __ownerID 会被设置上。但是对 B 进行 push/pop/set 等等操作的时候，A 其实是没有受到任何影响的。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eeditableVNode\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enode, ownerID\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ownerID \u0026amp;\u0026amp; node \u0026amp;\u0026amp; ownerID === node.ownerID) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e node;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e VNode(node ? node.array.slice() : [], ownerID);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如在 withMutations 操作里面 set 数据的时候， 上面 if 语句是无法通过的，因为 A 的数据里面是没后 ownerID 的，相当于给 A 的数据浅拷贝一次到 B 里面，但是在 withMutations 里面再次 set 的时候，这时上面的 if 语句是可以通过的，于是又能节省不少运行时间。类似的 Map 也是相似的，这里就不再提到了。\u003c/p\u003e\n\u003ch3\u003e其他\u003c/h3\u003e\n\u003cp\u003eimmutable.js 类型的一层层继承关系，刚开始的看的时候会觉得有点乱，不管哪里都有 extends。细细看下来还是挺不错的。Immutable.js 还有个 Seq 类型，其特点就是懒。懒的意思是，直到获取使用了才开始计算。一开始觉得很神奇，居然有用数据的时候才计算的。。。well，后来一看这得益于一系列的 API，主要就是把调用方法函数数据什么的统统用闭包给存起来。。。。。。。好吧。\u003c/p\u003e\n\u003cp\u003eps：immutable.js 最神奇的地方还是在于其数据结构，下篇文章将会好好讲数据结构。\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"July 7, 2018","title":"初识immutable","content":"\u003ch3\u003e前言\u003c/h3\u003e\n\u003cp\u003eImmutable.js 出来已经有很长一段时间了，只是日常项目中一直用不上。一个是平时没有怎么接触，不了解，另外一个是团队的开发节奏和习惯已经稳定下来了，要改变也不容易。当然了解一下也不差。\u003c/p\u003e\n\u003cp\u003e不可变的数据一旦生成，就无法被改变，这就要求数据可持久化。可是日常中的引用类型的数据，一旦改变了，就改变了，谈什么持久化数据结构呢？\u003c/p\u003e\n\u003ch3\u003e接触immutable\u003c/h3\u003e\n\u003cp\u003e感受一下immutable的不同：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 原本写法：\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e a = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e b = a;\nb[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(a[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// 0\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(a === b); \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// immutable 里面的写法\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { List } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'immutable'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e a = List([\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]);\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e b = a.set(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(a.get(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(b.equals(a)) \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以直观的看到在没有使用 immutable 之前， a 与 b 都是同一引用，一旦其中的数据修改了，另一个也会跟着变化，毕竟 a 是等于 b 的。而到了 immutable，就不一样了，当你设置 \u003ccode\u003ea.set(0, 0)\u003c/code\u003e 的时候，并不会修改 a ，而是返回一个新的数组赋予到 b，所以 a 还是原来的 a。\u003c/p\u003e\n\u003cp\u003e**这就是 immutable 致力解决的疼点：持久化数据解构。**平时使用数据的时候，可能一不小心就会把引用类型数据修改了，导致一些隐藏比较深的问题。尤其是对后来的开发者/维护者而言，意义就更重大了。\u003c/p\u003e\n\u003cp\u003e在 immutable 里面常见的数据类型有：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eList： 有序可重复列表，类似于 Javascript 的 Arry；\u003c/li\u003e\n\u003cli\u003eMap：键值对，类似于 Javascript 的 Object；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e其 API 还是很亲民的，基本上字如其名，大致接触一下就能够了解了。常用的用法这里就不做介绍了，需要了解，请移步\u003ca href=\"http://facebook.github.io/immutable-js/\" target=\"_blank\"\u003e官方文档\u003c/a\u003e。\u003c/p\u003e\n\u003ch3\u003eList 类型\u003c/h3\u003e\n\u003cp\u003eLiit 类型可以说是常用的了，尤其是和 Javascript 里面的 Arry 类似。看一下 List 里面的主要部分：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emakeList\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eorigin, capacity, level, root, tail, ownerID, hash\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e list = \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.create(ListPrototype);\n  list.size = capacity - origin;\n  list._origin = origin;\n  list._capacity = capacity;\n  list._level = level;\n  list._root = root;\n  list._tail = tail;\n  list.__ownerID = ownerID;\n  list.__hash = hash;\n  list.__altered = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e list;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e一个空内容的 List，也就是 \u003ccode\u003eList()\u003c/code\u003e，是 \u003ccode\u003emakeList(0, 0, SHIFT))\u003c/code\u003e 生成的，而 SHIFT 的值为 5。传入 List 括号里面的值会被存储在 _root 和 _tail 里面，只是 _root 和 _tail 里面的数据又有以下结构：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// @VNode class\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econstructor\u003c/span\u003e(array, ownerID) {\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.array = array;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.ownerID = ownerID;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 List 列表的生成里，就可以看到，持久化数据的形成，比如看看为何将数据分别保持在 _tail 和 _root 里面，以及又是用何种方式保存；\u003c/p\u003e\n\u003cp\u003e以设置一个数据为例子，如： List([1]).set(0, 0):\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eset(index, value) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e updateList(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, index, value);\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eupdateList\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003elist, index, value\u003c/span\u003e) \u003c/span\u003e{\n  ...\n  let newTail = list._tail;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e newRoot = list._root;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e didAlter = MakeRef(DID_ALTER);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (index \u0026gt;= getTailOffset(list._capacity)) {\n    newTail = updateVNode(newTail, list.__ownerID, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, index, value, didAlter);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    newRoot = updateVNode(\n      newRoot,\n      list.__ownerID,\n      list._level,\n      index,\n      value,\n      didAlter\n    );\n  }\n  ...\n  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n}\n\u003cspan class=\"hljs-comment\"\u003e// SIZE = 1 \u0026lt;\u0026lt; SHIFT，而 SHIFT = 5\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003egetTailOffset\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003esize\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e size \u0026lt; SIZE ? \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e : ((size - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) \u0026gt;\u0026gt;\u0026gt; SHIFT) \u0026lt;\u0026lt; SHIFT;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看出在 updateList 里面，通过 _capacity 来判断，以 32位 为尺度将 _capacity 切分开来，当 index 大于 \u003ccode\u003e((size - 1) \u0026gt;\u0026gt;\u0026gt; SHIFT) \u0026lt;\u0026lt; SHIFT\u003c/code\u003e 时候，更新 _trail, 否则更新 _root。例如： 当 _capacity 为 33，index 为 32 及其以下的时候，修改的都是 _root，否之则修改 _tail。这个是很好理解的，当数据量达到一定程度的时候，针对靠后的数据单独存储，而靠前的数据放在 _tail，分类处理。只是特别之处在与 _tail 的设计。\u003c/p\u003e\n\u003ch4\u003eList 里面的 32 阶 RRB-Tree\u003c/h4\u003e\n\u003cp\u003e_tail 里面采用的是 RRB-Tree 的形式存储数据。这个什么树的先不介绍，先看看看怎么形成，形成的是什么，继续看上面的 updateList 方法，里面用到了 updateVNode 方法来生成 _tail:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eupdateVNode\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enode, ownerID, level, index, value, didAlter\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// MASK = 31;\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e idx = (index \u0026gt;\u0026gt;\u0026gt; level) \u0026amp; MASK;\n  ...\n  let newNode;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (level \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e lowerNode = node \u0026amp;\u0026amp; node.array[idx];\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newLowerNode = updateVNode(\n      lowerNode,\n      ownerID,\n      level - SHIFT,\n      index,\n      value,\n      didAlter\n    );\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (newLowerNode === lowerNode) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e node;\n    }\n    newNode = editableVNode(node, ownerID);\n    newNode.array[idx] = newLowerNode;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e newNode;\n  }\n  ...\n  newNode = editableVNode(node, ownerID);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (value === \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e \u0026amp;\u0026amp; idx === newNode.array.length - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n    newNode.array.pop();\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    newNode.array[idx] = value;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e newNode;\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eeditableVNode\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enode, ownerID\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ownerID \u0026amp;\u0026amp; node \u0026amp;\u0026amp; ownerID === node.ownerID) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e node;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e VNode(node ? node.array.slice() : [], ownerID);\n}\n\u003cspan class=\"hljs-comment\"\u003e// @VNode class\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econstructor\u003c/span\u003e(array, ownerID) {\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.array = array;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.ownerID = ownerID;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在这里可以看到 value/newLowerNode 是赋值给 \u003ccode\u003enewNode.array[idx]\u003c/code\u003e， 而 idx 并不是等于 index。以 _capacity 为 65 的 List 为例子，其 _level 为 5。当 index 为 60 的时候，有以下行为：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e第一次进入 idx = 1，level = 5，将会有 _tail.array[1] = newLowerNode;\u003c/li\u003e\n\u003cli\u003e计算 1 里面的 newLowerNode，第二次进入，此时 level = 0，idx = 28，于是有 newLowerNode.array[28] = value；\n可以看出这里生成个\u003cstrong\u003e二维的数组，其中每个子节点的长度最大为 32，于是这就构成了一个 32阶的树结构\u003c/strong\u003e。至于为什么阶长是 32，在代码中是这么解释的：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eResulted in best performance after ______?\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这不是逗我嘛。。。什么都没有写好吧，而且 github 里面最早的版本也是这么写的。。。。最后还好找到是有测试实验数据证明 32 也就是 SHIFT 为 5 是最佳实践。至于为什么要采用这种结构，不是本文要考虑的，将在下篇中给出来。\u003c/p\u003e\n\u003cp\u003e最后数据生成的结构如下如所示：\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/immutableTree.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eget 方法里面也是差不多的，通过 _capacity 来判断。\u003c/p\u003e\n\u003ch2\u003eMap 类型结构\u003c/h2\u003e\n\u003cp\u003e同样的先看看一个空的 Map() 的结构：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emakeMap\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003esize, root, ownerID, hash\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e map = \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.create(MapPrototype);\n  map.size = size;\n  map._root = root;\n  map.__ownerID = ownerID;\n  map.__hash = hash;\n  map.__altered = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e map;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里就没有 _tail 结构的，所有数据都放在 _root 里面。只是 _root 里面的数据并非总是简单，采用了 Trie Nodes 的方式存储数据。 immutable 里面将对象的键值对转换为数组表示，即 [key, value] 的形式。\u003c/p\u003e\n\u003cp\u003e存储的数据分为以下级别：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eArrayMapNode，最简单方式，当键值对不超过8个的时候(不含嵌套的键值对)，采用这种方式，所有键值对保存在 entries 里面。同时 get/set 方法都较为简单，直接遍历一下获取就好了；\u003c/li\u003e\n\u003cli\u003eBitmapIndexedNode，当 ArrayMapNode 里面元素超过8个的时候，_root 会转变为 BitmapIndexedNode，BitmapIndexedNode 的子节点是 ValueNode。在 BitmapIndexedNode 里面查/增/改元素，都需要用到 bit-map(位图)算法，BitmapIndexedNode.bitmap 存储的是键名和存储顺序的位图信息。例如 get 方法，通过 BitmapIndexedNode.bitmap，以及 key 名就可以获取该键值对的排列序号，从而获取到相应的 ValueNode；\u003c/li\u003e\n\u003cli\u003eHashArrayMapNode，ValueNode 个数超过 16 个的时候，_root 会转变为 HashArrayMapNode 对象，其子元素为 ValueNode。而当 ValueNode 个数超过 32 个的情况时，HashArrayMapNode 的亲子元素就会出现 HashArrayMapNode/BitmapIndexedNode，而 BitmapIndexedNode 的亲子元素可以是 BitmapIndexedNode/ValueNode。由此看来巨量的键值对，将有 HashArrayMapNode/BitmapIndexedNode/ValueNode 组合而成，而每个 HashArrayMapNode 最多有32个亲子元素，BitmapIndexedNode 最多有16个亲子元素。 HashArrayMapNode 类对应带的 count，代表其子元素的数量。当需要读取的时候，直接键名的哈希值，就能够实现了。。。。好像有点简单呀；\u003c/li\u003e\n\u003cli\u003eHashCollisionNode，这种情况相当少，比如当 {null: 1} 和 {undefined: 2} 的键名是完全不同的，但是他们的键名的哈希值却是一样的。这使得后者 {undefined: 2} 创建的时候才会有 HashCollisionNode。HashCollisionNode 包含了这两个相同哈希值的键名下的数据；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e// The hash code for a string is computed as\n// s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n(多键值的整个读写离不开键名哈希计算，而其关键步骤如上，n为键名从左到右字母的 charCodeAt)。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ewithMutations 操作\u003c/h2\u003e\n\u003cp\u003e每次对 immutable 的数据类型操作的时候，都会返回一个新的数据，这样就存在一个问题，如果需要像原本一样对一个数据不断0操作，如不断的向Arry 里面 push 新值。对于 List，每次都返回一个新 List 岂不是多了很多中间变量，多了很多蹩脚的操作？于是就有了 withMutations 操作。如：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e a = List();\n\u003cspan class=\"hljs-built_in\"\u003eArray\u003c/span\u003e.apply(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003elength\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e }).forEach(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eitem\u003c/span\u003e =\u0026gt;\u003c/span\u003e a = a.push(item));\n\u003cspan class=\"hljs-comment\"\u003e// 上面可以用withMutations操作\u003c/span\u003e\na = a.withMutations(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003elist\u003c/span\u003e =\u0026gt;\u003c/span\u003e \n  \u003cspan class=\"hljs-built_in\"\u003eArray\u003c/span\u003e.apply(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003elength\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e }).forEach(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eitem\u003c/span\u003e =\u0026gt;\u003c/span\u003e list.push(item))\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面为原先不使用 withMutations 的方法，每次 push 之后都需要重新对 a 重新赋值，才能保证正确性。而用了 withMutations 方法之后，不再需要创建中间 List，减少了复杂度，基本上运行时间比前一种快上好几倍。当然 withMutations 不会修改 a，所以需要将中间 List 赋值到 a。\u003c/p\u003e\n\u003cp\u003e为什么 withMutations 会有这样的效果呢？以 A(List) 为例子，当使用 withMutations 时候，其首先，生成的中间变量 B(List)，其属性值就是 A 的属性值，没有任何更改，当然如果 A 没有 __ownerID， B 的 __ownerID 会被设置上。但是对 B 进行 push/pop/set 等等操作的时候，A 其实是没有受到任何影响的。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eeditableVNode\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enode, ownerID\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ownerID \u0026amp;\u0026amp; node \u0026amp;\u0026amp; ownerID === node.ownerID) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e node;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e VNode(node ? node.array.slice() : [], ownerID);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如在 withMutations 操作里面 set 数据的时候， 上面 if 语句是无法通过的，因为 A 的数据里面是没后 ownerID 的，相当于给 A 的数据浅拷贝一次到 B 里面，但是在 withMutations 里面再次 set 的时候，这时上面的 if 语句是可以通过的，于是又能节省不少运行时间。类似的 Map 也是相似的，这里就不再提到了。\u003c/p\u003e\n\u003ch3\u003e其他\u003c/h3\u003e\n\u003cp\u003eimmutable.js 类型的一层层继承关系，刚开始的看的时候会觉得有点乱，不管哪里都有 extends。细细看下来还是挺不错的。Immutable.js 还有个 Seq 类型，其特点就是懒。懒的意思是，直到获取使用了才开始计算。一开始觉得很神奇，居然有用数据的时候才计算的。。。well，后来一看这得益于一系列的 API，主要就是把调用方法函数数据什么的统统用闭包给存起来。。。。。。。好吧。\u003c/p\u003e\n\u003cp\u003eps：immutable.js 最神奇的地方还是在于其数据结构，下篇文章将会好好讲数据结构。\u003c/p\u003e\n"}},"buildId":"IdQI6resUd3YjXidM2HVB","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" async=""></script></body></html>