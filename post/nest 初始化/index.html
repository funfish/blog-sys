<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">nest 初始化</title><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.587c5e31.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___2dTZ9 "><a class="logo___346dE" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___13XXt" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___29Pln"><h1 class="postTitle___1_m4g">nest 初始化</h1><span class="postTime___1x0_i">March 24, 2021</span></header><article class="postWrapper___3jnNg post-article"><div><p>春节呆在家里不能外出，假期又特别长，刚好在学习 nest，于是就看了一遍源码。nest 是用 typescript 写得，用法自然也是基于 typescript，其源码用 vscode 阅读非常方便，基本上是读过里面最流畅的了，只是一个初始化过程，其涉及的操作非常多，逻辑上还是需要捋一捋。直接用 nest 仓库代码阅读调试会发现调试的时候，部分代码引入采用类似下面的方式：</p>
<pre class="hljs"><code><span class="hljs-comment">// 在 core 目录下的 nest-application.ts</span>
<span class="hljs-keyword">import</span> { Logger } <span class="hljs-keyword">from</span> <span class="hljs-string">"@nestjs/common/services/logger.service"</span>;
</code></pre>
<p>其直接引用 <code>node_modules</code> 里面的模块，但是源码里面怎么可能有 <code>node_modules</code> ，不是应该直接用相对路径？</p>
<p>nest 里面采用分包的形式打包，源码是 typescript 实现的，所以会将 packages 下面的模块通过编译生成普通 js 文件，于是为了方便调试，想到一个笨拙的办法，修改源代码的基础配置 <code>tsconfig.base.json</code>，这个配置是项目的基础 tsconfig，如下：</p>
<pre class="hljs"><code>{
  <span class="hljs-comment">// 添加如下配置</span>
  <span class="hljs-string">"paths"</span>: {
    <span class="hljs-string">"@nestjs/*"</span>: [<span class="hljs-string">"../*"</span>]
  }
}
</code></pre>
<p>所有 packages 下面的 tsconfig 都会扩展 <code>tsconfig.base.json</code>, 所以在基础文件里面配置路径别称，将 <code>@nestjs/*</code> 指向相对路径，就可以直接的智能交互引用的代码了，方便定位和阅读。</p>
<p>ps: 修改配置的时候发现一个奇怪的 bug，修改扩展配置文件 tsconfig ，vscode 无法做到实时更新，需要重新初始化一次才可以，比如重启 vscode。</p>
<h2>IOC 控制反转 依赖注入</h2>
<p>在开始源码前，需要了解一下 IOC 控制反转和依赖注入，nest 采用内置的 IOC 容器实现依赖注入的功能；关于控制反转和依赖注入可以看 <a href="https://www.zhihu.com/question/23277575" target="_blank">这里</a></p>
<p>简单的来说，<strong>程序只用负责使用依赖就好了，至于依赖如何被创建不用用户关心，交给第三方 IOC 容器来负责</strong> 。这也是 nest 的特色依赖注入；而初始化的过程，则大部分都在创建这个 IOC 容器。</p>
<p>依赖注入写法的主要部分如下：</p>
<pre class="hljs"><code><span class="hljs-meta">@Controller</span>(<span class="hljs-string">"api"</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppController {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> readonly appService: AppService</span>) {}

  <span class="hljs-meta">@Post</span>(<span class="hljs-string">"login"</span>)
  <span class="hljs-keyword">async</span> login(<span class="hljs-meta">@Request</span>() req) {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">this</span>.appService.findOne(req.name);
    <span class="hljs-keyword">return</span> res;
  }
}
</code></pre>
<p>这里面不需要知道 <code>appService</code> 实例是如何创建的，只是需要直接用就可以了，将变量通过参数的方式传入进来，而不是在 <code>constructor</code> 里面去实例该变量；</p>
<h2>容器初始化之扫描</h2>
<p>按照官方提供的例子，一般业务启动如下:</p>
<pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bootstrap</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> NestFactory.create(ApplicationModule);
  <span class="hljs-keyword">await</span> app.listen(<span class="hljs-number">3000</span>);
}
</code></pre>
<p><code>bootstrap</code> 分为创建应用和监听过程，其中创建应用主要是初始化依赖，而监听则主要是对中间件和路由进行初始化。</p>
<pre class="hljs"><code>public <span class="hljs-keyword">async</span> create&lt;T extends INestApplication = INestApplication&gt;(
  <span class="hljs-built_in">module</span>: any,
  serverOrOptions?: AbstractHttpAdapter | NestApplicationOptions,
  options?: NestApplicationOptions,
): <span class="hljs-built_in">Promise</span>&lt;T&gt; {
  <span class="hljs-comment">// 设置 httpServer，即是 http 平台，默认采用 platform-express</span>
  <span class="hljs-keyword">let</span> [httpServer, appOptions] = <span class="hljs-keyword">this</span>.isHttpServer(serverOrOptions)
    ? [serverOrOptions, options]
    : [<span class="hljs-keyword">this</span>.createHttpAdapter(), serverOrOptions];
  <span class="hljs-comment">// 创建全局应用配置，并根据该配置生成 container，该容器则是 IOC 容器载体；</span>
  <span class="hljs-keyword">const</span> applicationConfig = <span class="hljs-keyword">new</span> ApplicationConfig();
  <span class="hljs-keyword">const</span> container = <span class="hljs-keyword">new</span> NestContainer(applicationConfig);

  <span class="hljs-keyword">this</span>.applyLogger(appOptions);
  <span class="hljs-comment">// this.initialize 初始化容器，赋予容器功能</span>
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.initialize(<span class="hljs-built_in">module</span>, container, applicationConfig, httpServer);

  <span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> NestApplication(
    container,
    httpServer,
    applicationConfig,
    appOptions,
  );
  <span class="hljs-keyword">const</span> target = <span class="hljs-keyword">this</span>.createNestInstance(instance);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.createAdapterProxy&lt;T&gt;(target, httpServer);
}

private <span class="hljs-keyword">async</span> initialize(
  <span class="hljs-built_in">module</span>: any,
  <span class="hljs-attr">container</span>: NestContainer,
  config = <span class="hljs-keyword">new</span> ApplicationConfig(),
  <span class="hljs-attr">httpServer</span>: HttpServer = <span class="hljs-literal">null</span>,
) {
  <span class="hljs-keyword">const</span> instanceLoader = <span class="hljs-keyword">new</span> InstanceLoader(container);
  <span class="hljs-keyword">const</span> dependenciesScanner = <span class="hljs-keyword">new</span> DependenciesScanner(
    container,
    <span class="hljs-keyword">new</span> MetadataScanner(),
    config,
  );
  container.setHttpAdapter(httpServer);
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">this</span>.logger.log(MESSAGES.APPLICATION_START);
    <span class="hljs-keyword">await</span> ExceptionsZone.asyncRun(<span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">await</span> dependenciesScanner.scan(<span class="hljs-built_in">module</span>);
      <span class="hljs-keyword">await</span> instanceLoader.createInstancesOfDependencies();
      dependenciesScanner.applyApplicationProviders();
    });
  } <span class="hljs-keyword">catch</span> (e) {
    process.abort();
  }
}
</code></pre>
<p>创建的配置 <code>applicationConfig</code> 包含全局的 pipes/guards 等等，<code>create</code> 里面最主要是的 <code>init</code> 方法，该方法先生成加载器 <code>loader</code> 和依赖的 <code>Scanner</code>。初始化里面的 <code>dependenciesScanner.scan</code> 会做以下操作</p>
<ol>
<li>注册核心模块 <code>InternalCoreModule</code>，该模块是容器的核心模块，对比提交记录可以发现，之前版本是没有核心模块，后面将 <code>applicationConfig</code> 里面非全局配置的功能集中到了 <code>InternalCoreModule</code>；</li>
<li>将核心模块和用户配置传入的模块进行一次 <code>scanForModules</code>，遍历所有的模块，并根据随机 uuid、名称、scope 以及其他信息创建 token，以该 token 为 key 最后 <code>set</code> 到容器里面；如果是同一模块，若 scope 不一样，其在容器中注册的模块也会不一样；</li>
<li>scan 所有(用户与核心)模块的依赖</li>
</ol>
<pre class="hljs"><code>public <span class="hljs-keyword">async</span> scanModulesForDependencies() {
  <span class="hljs-keyword">const</span> modules = <span class="hljs-keyword">this</span>.container.getModules();

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [token, { metatype }] <span class="hljs-keyword">of</span> modules) {
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.reflectImports(metatype, token, metatype.name);
    <span class="hljs-keyword">this</span>.reflectProviders(metatype, token);
    <span class="hljs-keyword">this</span>.reflectControllers(metatype, token);
    <span class="hljs-keyword">this</span>.reflectExports(metatype, token);
  }
  <span class="hljs-keyword">this</span>.calculateModulesDistance(modules);
}
</code></pre>
<p>前面添加模块后，则立刻对所有模块的依赖进行 scan，对导入模块/输出模块与当前模块进行关联，而 providers/controllers 处理比较特别，所有的依赖注入项会在 providers 里面找，而这些用户的 providers 添加则是在 <code>this.reflectProviders(metatype, token)</code> 里面进行的：</p>
<pre class="hljs"><code>public addProvider(provider: Provider): string {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isCustomProvider(provider)) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.addCustomProvider(provider, <span class="hljs-keyword">this</span>._providers);
  }
  <span class="hljs-keyword">this</span>._providers.set(
    (provider <span class="hljs-keyword">as</span> Type&lt;Injectable&gt;).name,
    <span class="hljs-keyword">new</span> InstanceWrapper({
      <span class="hljs-attr">name</span>: (provider <span class="hljs-keyword">as</span> Type&lt;Injectable&gt;).name,
      <span class="hljs-attr">metatype</span>: provider <span class="hljs-keyword">as</span> Type&lt;Injectable&gt;,
      <span class="hljs-attr">instance</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">isResolved</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">scope</span>: getClassScope(provider),
      <span class="hljs-attr">host</span>: <span class="hljs-keyword">this</span>,
    }),
  );
  <span class="hljs-keyword">return</span> (provider <span class="hljs-keyword">as</span> Type&lt;Injectable&gt;).name;
}
</code></pre>
<p>最终 providers 会生成一个 <code>InstanceWrapper</code> 实例，该实例下面的 <code>metatype</code> 指向原 provider 的类，而 instance 则是类的实例化，后面会提到。</p>
<p>在遍历所有的 providers 和 controlers 的同时 nest 还会收集其添加的 guards/interceptors/exceptionFilters/pipes/routeArguments 这些修饰器到模块的 injectables 里面，给后面使用。（routeArguments 是 nest 提供的专门的路由信息修饰器）</p>
<p><code>this.calculateModulesDistance(modules)</code> 给已添加的模块计算其优先级，越晚加入的模块，优先级越低，比如导入的模块其优先级就要小于当前模块，这个优先级作用目前只在中间件里面看到，按照优先级排序注册中间件。</p>
<h2>容器初始化之实例化</h2>
<p>经过上面的铺垫相关的模块已经添加到 container 里面了，但是具体的依赖注入实现还在实例化，回到初始化里面 <code>await instanceLoader.createInstancesOfDependencies()</code>。</p>
<p>实例化中先是处理原型，将原型上的方法扩展到 InstanceWrapper 实例里面（目前不知道有什么用。。。。。。可能只是单纯的扩展）。</p>
<pre class="hljs"><code>public <span class="hljs-keyword">async</span> loadInstance&lt;T&gt;(
  wrapper: InstanceWrapper&lt;T&gt;, <span class="hljs-attr">collection</span>: <span class="hljs-built_in">Map</span>&lt;string, InstanceWrapper&gt;,
  <span class="hljs-attr">module</span>: Module, contextId = STATIC_CONTEXT, inquirer?: InstanceWrapper,
) {
  <span class="hljs-comment">// 省略前面部分代码</span>
  <span class="hljs-comment">// instanceHost 则是前面InstanceWrapper下value</span>
  <span class="hljs-comment">// 如果该InstanceWrapper已经resolved了，则不需要后面继续遍历寻找参数</span>
  <span class="hljs-keyword">if</span> (instanceHost.isResolved) {
    <span class="hljs-keyword">return</span> done();
  }
  <span class="hljs-keyword">const</span> callback = <span class="hljs-keyword">async</span> (instances: unknown[]) =&gt; {
    <span class="hljs-keyword">const</span> properties = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.resolveProperties(wrapper, <span class="hljs-built_in">module</span>, inject,contextId, wrapper, inquirer);
    <span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.instantiateClass(instances, wrapper, targetWrapper, contextId, inquirer);
    <span class="hljs-keyword">this</span>.applyProperties(instance, properties);
    done();
  };
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.resolveConstructorParams&lt;T&gt;(wrapper, <span class="hljs-built_in">module</span>, inject, callback, contextId, wrapper, inquirer);
}

public <span class="hljs-keyword">async</span> resolveConstructorParams&lt;T&gt;(
  wrapper: InstanceWrapper&lt;T&gt;, <span class="hljs-attr">module</span>: Module, <span class="hljs-attr">inject</span>: InjectorDependency[],
  <span class="hljs-attr">callback</span>: <span class="hljs-function">(<span class="hljs-params">args: unknown[]</span>) =&gt;</span> <span class="hljs-keyword">void</span>, contextId = STATIC_CONTEXT,
  inquirer?: InstanceWrapper, parentInquirer?: InstanceWrapper,
) {
  <span class="hljs-comment">// 省略前面部分代码</span>
  <span class="hljs-keyword">const</span> dependencies = isNil(inject) ? <span class="hljs-keyword">this</span>.reflectConstructorParams(wrapper.metatype <span class="hljs-keyword">as</span> Type&lt;any&gt;) : inject;
  <span class="hljs-keyword">const</span> optionalDependenciesIds = isNil(inject) ? <span class="hljs-keyword">this</span>.reflectOptionalParams(wrapper.metatype <span class="hljs-keyword">as</span> Type&lt;any&gt;) : [];

  <span class="hljs-keyword">let</span> isResolved = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">const</span> resolveParam = <span class="hljs-keyword">async</span> (param: unknown, <span class="hljs-attr">index</span>: number) =&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isInquirer(param, parentInquirer)) {
        <span class="hljs-keyword">return</span> parentInquirer &amp;&amp; parentInquirer.instance;
      }
      <span class="hljs-keyword">const</span> paramWrapper = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.resolveSingleParam&lt;T&gt;(wrapper, param, { index, dependencies }, <span class="hljs-built_in">module</span>,
        contextId, inquirer, index);
      <span class="hljs-keyword">const</span> instanceHost = paramWrapper.getInstanceByContextId(contextId, inquirerId);
      <span class="hljs-keyword">if</span> (!instanceHost.isResolved &amp;&amp; !paramWrapper.forwardRef) {
        isResolved = <span class="hljs-literal">false</span>;
      }
      <span class="hljs-keyword">return</span> instanceHost &amp;&amp; instanceHost.instance;
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-keyword">const</span> isOptional = optionalDependenciesIds.includes(index);
      <span class="hljs-keyword">if</span> (!isOptional) {
        <span class="hljs-keyword">throw</span> err;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
    }
  };
  <span class="hljs-comment">// 最后得到需要注入的实例</span>
  <span class="hljs-keyword">const</span> instances = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(dependencies.map(resolveParam));
  isResolved &amp;&amp; (<span class="hljs-keyword">await</span> callback(instances));
}
</code></pre>
<p>实例过程中会遍历模块下的所有 providers/injectables/controllers，最后依次完成实例化，实例化通用方法为 <code>loadInstance</code>。可以看到通过解析参数的方式来获取依赖 <code>dependencies</code>，然后解析依赖，通过 <code>resolveSingleParam</code> 获得对应 <code>provider</code>，再进入 <code>callback</code> 回调。</p>
<p>只是具体如何解析依赖？在 <code>resolveConstructorParams</code> 方法里面，通过 <code>reflectConstructorParams</code> 可以拿到参数，比如</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppController {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> readonly appService: AppService</span>) {}
}
</code></pre>
<p>这里的 <code>appService</code> 参数，就是通过 <code>reflectConstructorParams</code> 获得的，先知道需要哪些依赖才能注入，只是如何知道有那些参数呢？这里的实现卡了很两天才明白， 因为 <code>reflectConstructorParams</code> 实现很简单：</p>
<pre class="hljs"><code>public reflectConstructorParams&lt;T&gt;(type: Type&lt;T&gt;): any[] {
  <span class="hljs-keyword">const</span> paramtypes = <span class="hljs-built_in">Reflect</span>.getMetadata(PARAMTYPES_METADATA, type) || [];
  <span class="hljs-comment">// 省略部分代码</span>
  <span class="hljs-keyword">return</span> paramtypes;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Injectable</span>(<span class="hljs-params">options?: InjectableOptions</span>): <span class="hljs-title">ClassDecorator</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target: object</span>) =&gt;</span> {
    <span class="hljs-built_in">Reflect</span>.defineMetadata(SCOPE_OPTIONS_METADATA, options, target);
  };
}
</code></pre>
<p>通过获取 <code>'design:paramtypes'</code> 的元数据就可以获得参数了，只是代码里面并没有用相关的修饰器，将参数传进去，官方文档提到：</p>
<blockquote>
<p>A provider is simply a class annotated with an @Injectable() decorator</p>
</blockquote>
<p>只是 <code>Injectable</code> 修饰器的实现明显不是提供 <code>'design:paramtypes'</code> 元数据，甚至 <code>@Injectable()</code> 里面什么数据都没有传递。于是这里就陷入了僵局，按照官方意思是只要用了 <code>@Injectable()</code> 就可以。测试的时候，将 <code>@Injectable()</code> 去掉发现依赖不能注入了，编译后的代码则是：</p>
<pre class="hljs"><code>AppController = __decorate(
  [
    common_1.Controller(<span class="hljs-string">"api"</span>),
    __metadata(<span class="hljs-string">"design:paramtypes"</span>, [app_service_1.AppService])
  ],
  AppController
);
</code></pre>
<p>明明没有用到 <code>'design:paramtypes'</code> 相关的修饰器，结果编译出来的代码就是有的。。。。。。实在很奇怪。直到谷歌 <code>'design:paramtypes'</code> 的时候发现，原来这个 typescript 搞的鬼</p>
<blockquote>
<p>When you enable metadata through the &quot;emitDecoratorMetadata&quot; property, the TypeScript compiler will generate the following metadata properties:
'design:type', 'design:paramtypes' and 'design:returntype'.</p>
</blockquote>
<p>嗯，<strong>依赖注入里面，typescript 已经帮你把参数给拎出来了，直接访问元数据，key 为 <code>'design:paramtypes'</code> 就可以了。</strong></p>
<p>回到之前，获取到参数的类，但是距离可用还差很远，需要获取参数对应的 provider 的 InstanceWrapper，获取到 InstanceWrapper 之后也不能直接用，如果该 InstanceWrapper 没有被 resolved 过，则需要递归继续加载该 provider 的 <code>loadInstance</code> 方法。<code>resolveConstructorParams</code> 方法下最后的 instances 则是需要注入的实例了，而不是 <code>null</code>，因此需要递归，就是将底层的类实例好后传入上级作为参数，直到顶端。</p>
<p>类如何被实例？实例的过程发生在 <code>const instance = await this.instantiateClass(instances, wrapper, targetWrapper, contextId, inquirer)</code> 里面，这里的 instances 参数是需要注入的实例，而这些实例也同样来自于 <code>instantiateClass</code> 方法:</p>
<pre class="hljs"><code>public <span class="hljs-keyword">async</span> instantiateClass&lt;T = any&gt;(
  instances: any[],
  <span class="hljs-attr">wrapper</span>: InstanceWrapper,
  <span class="hljs-attr">targetMetatype</span>: InstanceWrapper,
  contextId = STATIC_CONTEXT,
  inquirer?: InstanceWrapper,
) {
  <span class="hljs-comment">// 省略部分代码</span>
  <span class="hljs-keyword">const</span> instanceHost = targetMetatype.getInstanceByContextId(
    contextId,
    inquirerId,
  );
  <span class="hljs-keyword">if</span> (isNil(inject) &amp;&amp; isInContext) {
    instanceHost.instance = wrapper.forwardRef
      ? <span class="hljs-built_in">Object</span>.assign(
          instanceHost.instance,
          <span class="hljs-keyword">new</span> (metatype <span class="hljs-keyword">as</span> Type&lt;any&gt;)(...instances),
        )
      : <span class="hljs-keyword">new</span> (metatype <span class="hljs-keyword">as</span> Type&lt;any&gt;)(...instances);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isInContext) {
    <span class="hljs-keyword">const</span> factoryReturnValue = ((targetMetatype.metatype <span class="hljs-keyword">as</span> any) <span class="hljs-keyword">as</span> <span class="hljs-built_in">Function</span>)(
      ...instances,
    );
    instanceHost.instance = <span class="hljs-keyword">await</span> factoryReturnValue;
  }
  instanceHost.isResolved = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> instanceHost.instance;
}
</code></pre>
<p>可以看到通过 new 的形式生成新的实例赋值到 <code>InstanceWrapper</code> 的 <code>instance</code>，并将 isResolved 设置为 <code>true</code>，表示后面不再递归该 <code>provider</code> 了。由此可见这个 isResolved 很重要，在添加 <code>providers</code> 的时候，也会根据 <code>provider</code> 类型来修改 isResolved，如果是 Custom providers，则有可能 isResolved 一开始就是 <code>true</code>；</p>
<h2>应用初始化之中间件</h2>
<p>上面的 IOC 控制容器初始化好了之后，会进入业务主程序的下一步 <code>await app.listen(3000)</code>。</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> init() {
  <span class="hljs-keyword">const</span> useBodyParser =
    <span class="hljs-keyword">this</span>.appOptions &amp;&amp; <span class="hljs-keyword">this</span>.appOptions.bodyParser !== <span class="hljs-literal">false</span>;
  <span class="hljs-comment">// 注册 platform-express 的中间件，就是bodyParser.json和bodyParser.urlencoded</span>
  useBodyParser &amp;&amp; <span class="hljs-keyword">this</span>.registerParserMiddleware();
  <span class="hljs-comment">// registerModules 注册websocket模块和微服务模块，</span>
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.registerModules();
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.registerRouter();
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.callInitHook();
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.registerRouterHooks();
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.callBootstrapHook();

  <span class="hljs-keyword">this</span>.isInitialized = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">this</span>.logger.log(MESSAGES.APPLICATION_READY);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}
</code></pre>
<p>先是注册常规的解析中间件，后面的 <code>registerModules</code> 里面会注册上用户自定义的中间件，常见的中间件用法如下</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppModule</span> </span>{
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(LoggerMiddleware).forRoutes(AppController);
  }
}

@Injectable()
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoggerMiddleware</span> <span class="hljs-title">implements</span> <span class="hljs-title">NestMiddleware</span> </span>{
  use(req, res, <span class="hljs-attr">next</span>: <span class="hljs-built_in">Function</span>) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Request..."</span>);
    next();
  }
}
</code></pre>
<p>可以看到应用方需要显式的使用 <code>configure</code> 才能使用该中间件，因为源码里面是采用 <code>await instance.configure(middlewareBuilder)</code> 的方法。而 <code>config</code> 正如字面意思配置中间件，只是起到给入口的作用，更多的是让后面 <code>apply</code> 和 <code>forRoutes</code> 方法，结合起来能够将中间件与路由挂勾上，尤其是 <code>forRoutes</code>，<strong>若不用上 <code>forRoutes</code> 定义路由，则模块下的中间件不会注册上。</strong></p>
<pre class="hljs"><code>public forRoutes(
  ...routes: <span class="hljs-built_in">Array</span>&lt;string | Type&lt;any&gt; | RouteInfo&gt;
): MiddlewareConsumer {
  <span class="hljs-keyword">const</span> { middlewareCollection, routesMapper } = <span class="hljs-keyword">this</span>.builder;

  <span class="hljs-keyword">const</span> forRoutes = <span class="hljs-keyword">this</span>.mapRoutesToFlatList(
    routes.map(<span class="hljs-function"><span class="hljs-params">route</span> =&gt;</span> routesMapper.mapRouteToRouteInfo(route)),
  );
  <span class="hljs-keyword">const</span> configuration = {
    <span class="hljs-attr">middleware</span>: filterMiddleware(<span class="hljs-keyword">this</span>.middleware),
    <span class="hljs-attr">forRoutes</span>: forRoutes.filter(<span class="hljs-function"><span class="hljs-params">route</span> =&gt;</span> !<span class="hljs-keyword">this</span>.isRouteExcluded(route)),
  };
  middlewareCollection.add(configuration);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.builder;
}
</code></pre>
<p>这里传入的路由配置会被 <code>mapRouteToRouteInfo</code> 解析，传入的可以是简单的路由地址字符串，也可以是路由集合，更可以是对应的 <code>controller</code> 类。接着前面配置的 <code>LoggerMiddleware</code> 会和路由信息一起被添加到中间件集合里面，最后存入 <code>middlewareModule</code>， key 则是模块的 token 信息。</p>
<h2>应用初始化之路由</h2>
<p>中间件添加完之后就是添加路由信息，相比较于 express 之类的，nest 采用方式既不是统一的路由配置，也不是约定目录的路由，而是采用和 spring 一样的注解来定义路由。对应源码入口处理部分如下：</p>
<pre class="hljs"><code>public resolve&lt;T extends HttpServer&gt;(applicationRef: T, <span class="hljs-attr">basePath</span>: string) {
  <span class="hljs-keyword">const</span> modules = <span class="hljs-keyword">this</span>.container.getModules();
  modules.forEach(<span class="hljs-function">(<span class="hljs-params">{ controllers, metatype }, moduleName</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> path = metatype
      ? <span class="hljs-built_in">Reflect</span>.getMetadata(MODULE_PATH, metatype)
      : <span class="hljs-literal">undefined</span>;
    path = path ? basePath + path : basePath;
    <span class="hljs-comment">// 遍历模块，注册每个模块下的controllers集合</span>
    <span class="hljs-keyword">this</span>.registerRouters(controllers, moduleName, path, applicationRef);
  });
}
private applyCallbackToRouter&lt;T extends HttpServer&gt;(
  router: T,
  <span class="hljs-attr">pathProperties</span>: RoutePathProperties,
  <span class="hljs-attr">instanceWrapper</span>: InstanceWrapper,
  <span class="hljs-attr">moduleKey</span>: string,
  <span class="hljs-attr">basePath</span>: string,
) {
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">path</span>: paths, requestMethod, targetCallback, methodName } = pathProperties;
  <span class="hljs-keyword">const</span> { instance } = instanceWrapper;
  <span class="hljs-keyword">const</span> routerMethod = <span class="hljs-keyword">this</span>.routerMethodFactory
    .get(router, requestMethod)
    .bind(router);

  <span class="hljs-keyword">const</span> stripSlash = <span class="hljs-function">(<span class="hljs-params">str: string</span>) =&gt;</span>
    str[str.length - <span class="hljs-number">1</span>] === <span class="hljs-string">'/'</span> ? str.slice(<span class="hljs-number">0</span>, str.length - <span class="hljs-number">1</span>) : str;

  <span class="hljs-keyword">const</span> isRequestScoped = !instanceWrapper.isDependencyTreeStatic();
  <span class="hljs-keyword">const</span> proxy = isRequestScoped
    ? <span class="hljs-keyword">this</span>.createRequestScopedHandler(instanceWrapper, requestMethod, <span class="hljs-keyword">this</span>.container.getModuleByKey(moduleKey),
        moduleKey, methodName)
    : <span class="hljs-keyword">this</span>.createCallbackProxy(instance, targetCallback, methodName, moduleKey, requestMethod);

  paths.forEach(<span class="hljs-function"><span class="hljs-params">path</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> fullPath = stripSlash(basePath) + path;
    routerMethod(stripSlash(fullPath) || <span class="hljs-string">'/'</span>, proxy);
  });
}
</code></pre>
<p>第一个 <code>resolve</code> 方法简单的遍历，加上 <code>registerRouters</code> 在对单个 <code>controller</code> 遍历，可以获得所有的路由信息，而第二个 <code>applyCallbackToRouter</code> 则是路由的重点，<code>routerMethod</code> 是 <code>platform-express</code> 请求通用方法，比如：post/get 之类，可以通过它建立路由，相应的第一个参数 <code>stripSlash(fullPath) || '/'</code> 是路由的访问路径，而第二个参数 <code>proxy</code> 则是路由处理回调。<code>proxy</code> 创建则涉及到非常多的内容：</p>
<p>整体的 <code>proxy</code> 会通过 <code>create</code> 创建新的路由实例，该实例会先获取信息 <code>getMetadata</code>。可以直接先看看该方法，再回到 <code>create</code> :</p>
<pre class="hljs"><code>public getMetadata(
  instance: Controller,<span class="hljs-attr">callback</span>: <span class="hljs-function">(<span class="hljs-params">...args: any[]</span>) =&gt;</span> any,
  <span class="hljs-attr">methodName</span>: string, <span class="hljs-attr">module</span>: string, <span class="hljs-attr">requestMethod</span>: RequestMethod,
): HandlerMetadata {
  <span class="hljs-keyword">const</span> cacheMetadata = <span class="hljs-keyword">this</span>.handlerMetadataStorage.get(instance, methodName);
  <span class="hljs-keyword">if</span> (cacheMetadata) {
    <span class="hljs-keyword">return</span> cacheMetadata;
  }
  <span class="hljs-comment">// 路由传参信息</span>
  <span class="hljs-keyword">const</span> metadata =
    <span class="hljs-keyword">this</span>.contextUtils.reflectCallbackMetadata(instance, methodName, ROUTE_ARGS_METADATA) || {};
  <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(metadata);
  <span class="hljs-keyword">const</span> argsLength = <span class="hljs-keyword">this</span>.contextUtils.getArgumentsLength(keys, metadata);
  <span class="hljs-keyword">const</span> paramtypes = <span class="hljs-keyword">this</span>.contextUtils.reflectCallbackParamtypes(instance, methodName);
  <span class="hljs-keyword">const</span> getParamsMetadata = (moduleKey: string, contextId = STATIC_CONTEXT, inquirerId?: string,
  ) =&gt; <span class="hljs-keyword">this</span>.exchangeKeysForValues(keys, metadata, moduleKey, contextId, inquirerId);

  <span class="hljs-keyword">const</span> paramsMetadata = getParamsMetadata(<span class="hljs-built_in">module</span>);
  <span class="hljs-comment">// 路由信息里面，如果是 @Response 或者 @Next 则为 true</span>
  <span class="hljs-keyword">const</span> isResponseHandled = paramsMetadata.some(<span class="hljs-function">(<span class="hljs-params">{ type }</span>) =&gt;</span>
    type === RouteParamtypes.RESPONSE || type === RouteParamtypes.NEXT);
  <span class="hljs-comment">// 有无重定向修饰器 如@Redirect</span>
  <span class="hljs-keyword">const</span> httpRedirectResponse = <span class="hljs-keyword">this</span>.reflectRedirect(callback);
  <span class="hljs-comment">// 有无渲染修饰器 如@Render('index')</span>
  <span class="hljs-keyword">const</span> fnHandleResponse = <span class="hljs-keyword">this</span>.createHandleResponseFn(callback, isResponseHandled, httpRedirectResponse);
  <span class="hljs-comment">// post 响应默认状态码是 201，其他方式都是 200 ，可以通过 @HttpCode 来修改状态码</span>
  <span class="hljs-keyword">const</span> httpCode = <span class="hljs-keyword">this</span>.reflectHttpStatusCode(callback);
  <span class="hljs-keyword">const</span> httpStatusCode = httpCode ? httpCode : <span class="hljs-keyword">this</span>.responseController.getStatusByMethod(requestMethod);
  <span class="hljs-comment">// 如@Header('Cache-Control', 'none') 修改响应头</span>
  <span class="hljs-keyword">const</span> responseHeaders = <span class="hljs-keyword">this</span>.reflectResponseHeaders(callback);
  <span class="hljs-keyword">const</span> hasCustomHeaders = !isEmpty(responseHeaders);
  <span class="hljs-keyword">const</span> handlerMetadata: HandlerMetadata = {
    argsLength, fnHandleResponse, paramtypes, getParamsMetadata,
    httpStatusCode, hasCustomHeaders, responseHeaders,
  };
  <span class="hljs-keyword">this</span>.handlerMetadataStorage.set(instance, methodName, handlerMetadata);
  <span class="hljs-keyword">return</span> handlerMetadata;
}
</code></pre>
<p>对于 <code>Controller</code> 其通常会采用一系列的修饰器，比如在其参数里面，添加 <code>@Request() req</code>。生成路由的时候也需要把这些信息提取出来，这些修饰器配置的元数据 key 是 <code>ROUTE_ARGS_METADATA</code>，value 则是代码中的 <code>metadata</code>。<code>reflectCallbackParamtypes</code> 方法和前文提到的获取依赖方式一样，采用 <code>'design:paramtypes'</code> 获取 <code>controller</code> 方法的形参。其他的基本上都是获取类或方法上修饰器的信息。还有个重要功能，是否响应需要模板渲染，比如渲染 html 页面，这个时候则可以用到 <code>@Render('index')</code>，可以看官方<a href="https://docs.nestjs.com/techniques/mvc#template-rendering" target="_blank">文档</a>，需要注意的是 html 文件需要保存在 views 目录。</p>
<p>再回到创建路由 <code>proxy</code> 的入口 <code>create</code>：</p>
<pre class="hljs"><code>public create(
  instance: Controller, <span class="hljs-attr">callback</span>: <span class="hljs-function">(<span class="hljs-params">...args: any[]</span>) =&gt;</span> any, <span class="hljs-attr">methodName</span>: string,
  <span class="hljs-attr">module</span>: string, <span class="hljs-attr">requestMethod</span>: RequestMethod, contextId = STATIC_CONTEXT, inquirerId?: string,
) {
  <span class="hljs-comment">// 上面提到的获取contorller下路由对应方法的信息，如参数/请求头等等</span>
  <span class="hljs-keyword">const</span> { argsLength, fnHandleResponse, paramtypes,
    getParamsMetadata, httpStatusCode, responseHeaders, hasCustomHeaders,
  } = <span class="hljs-keyword">this</span>.getMetadata(instance, callback, methodName, <span class="hljs-built_in">module</span>, requestMethod);

  <span class="hljs-keyword">const</span> paramsOptions = <span class="hljs-keyword">this</span>.contextUtils.mergeParamsMetatypes(
    getParamsMetadata(<span class="hljs-built_in">module</span>, contextId, inquirerId), paramtypes);
  <span class="hljs-keyword">const</span> contextType: ContextType = <span class="hljs-string">'http'</span>;
  <span class="hljs-comment">// 提取模块中的 pipes/guards/interceptors</span>
  <span class="hljs-keyword">const</span> pipes = <span class="hljs-keyword">this</span>.pipesContextCreator.create(instance, callback, <span class="hljs-built_in">module</span>, contextId, inquirerId);
  <span class="hljs-keyword">const</span> guards = <span class="hljs-keyword">this</span>.guardsContextCreator.create(instance, callback, <span class="hljs-built_in">module</span>, contextId, inquirerId);
  <span class="hljs-keyword">const</span> interceptors = <span class="hljs-keyword">this</span>.interceptorsContextCreator.create(instance, callback, <span class="hljs-built_in">module</span>, contextId, inquirerId);

  <span class="hljs-keyword">const</span> fnCanActivate = <span class="hljs-keyword">this</span>.createGuardsFn(guards, instance, callback, contextType);
  <span class="hljs-keyword">const</span> fnApplyPipes = <span class="hljs-keyword">this</span>.createPipesFn(pipes, paramsOptions);

  <span class="hljs-keyword">const</span> handler = &lt;TRequest, TResponse&gt;(args: any[], req: TRequest, res: TResponse,
    next: Function) =&gt; async () =&gt; {
    fnApplyPipes &amp;&amp; (await fnApplyPipes(args, req, res, next));
    return callback.apply(instance, args);
  };

  return async &lt;TRequest, TResponse&gt;(req: TRequest, res: TResponse, next: Function) =&gt; {
    const args = this.contextUtils.createNullArray(argsLength);
    fnCanActivate &amp;&amp; (await fnCanActivate([req, res, next]));

    this.responseController.setStatus(res, httpStatusCode);
    hasCustomHeaders &amp;&amp;
      this.responseController.setHeaders(res, responseHeaders);

    const result = await this.interceptorsConsumer.intercept(interceptors, [req, res, next],
      instance, callback, handler(args, req, res, next), contextType);
    await fnHandleResponse(result, res);
  };
}
</code></pre>
<p>上面 <code>create</code> 返回则是路由响应的处理方式了。可以看到前面部分的 <code>pipes/guards/interceptors</code>，是根据全局、<code>controller</code>以及其下面的 <code>method</code> 的修饰器获取对应的名称，再从模块的 <code>injectables</code> 获取对应的 <code>InstanceWrapper</code>，从而得到的数组。其后面还有对应的处理方法 <code>fnCanActivate</code> 和 <code>fnApplyPipes</code>，从代码上可以看到，路由响应里面先是执行 <code>fnCanActivate</code> 也就是守卫，后面设置响应，然后是 <code>interceptors</code>，最后是 <code>fnApplyPipes</code>，这里以 <code>fnCanActivate</code> 为例子，看看其实现：</p>
<pre class="hljs"><code>public createGuardsFn(guards: any[], <span class="hljs-attr">instance</span>: Controller, <span class="hljs-attr">callback</span>: <span class="hljs-function">(<span class="hljs-params">...args: any[]</span>) =&gt;</span> any,
  contextType?: TContext): <span class="hljs-function">(<span class="hljs-params">args: any[]</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt; | <span class="hljs-literal">null</span> {
  <span class="hljs-keyword">const</span> canActivateFn = <span class="hljs-keyword">async</span> (args: any[]) =&gt; {
    <span class="hljs-keyword">const</span> canActivate = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.guardsConsumer.tryActivate&lt;TContext&gt;(
      guards, args, instance, callback, contextType,
    );
    <span class="hljs-keyword">if</span> (!canActivate) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ForbiddenException(FORBIDDEN_MESSAGE);
    }
  };
  <span class="hljs-keyword">return</span> guards.length ? canActivateFn : <span class="hljs-literal">null</span>;
}
public <span class="hljs-keyword">async</span> tryActivate(
  guards: CanActivate[], <span class="hljs-attr">args</span>: any[], <span class="hljs-attr">instance</span>: Controller,
  <span class="hljs-attr">callback</span>: <span class="hljs-function">(<span class="hljs-params">...args: any[]</span>) =&gt;</span> any, type?: TContext,
) {
  <span class="hljs-keyword">if</span> (!guards || isEmpty(guards)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">const</span> context = <span class="hljs-keyword">this</span>.createContext(args, instance, callback);
  context.setType&lt;TContext&gt;(type);

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> guard <span class="hljs-keyword">of</span> guards) {
    <span class="hljs-keyword">const</span> result = guard.canActivate(context);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.pickResult(result)) {
      <span class="hljs-keyword">continue</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</code></pre>
<p>上面可以看到，<code>guard</code> 是通过调用 <code>canActivate</code> 来实现，如果没有实现该方法，则会抛出报错 <code>new ForbiddenException(FORBIDDEN_MESSAGE)</code>，后面的代码也就不执行了。最后路由代理具体业务的执行，则是在 <code>create</code> 提到的 <code>handler</code> 里面执行。</p>
<p>这里回过头看一下，前面代码可以发现 <code>getMetadata</code> 里面生成的 <code>getParamsMetadata</code>，会用在 <code>create</code> 的 <code>createPipesFn</code> 方法里面用到：</p>
<pre class="hljs"><code>public createPipesFn(
  pipes: PipeTransform[],
  <span class="hljs-attr">paramsOptions</span>: (ParamProperties &amp; { metatype?: any })[],
) {
  <span class="hljs-keyword">const</span> pipesFn = <span class="hljs-keyword">async</span> &lt;TRequest, TResponse&gt;(args: any[], <span class="hljs-attr">req</span>: TRequest,
    <span class="hljs-attr">res</span>: TResponse, <span class="hljs-attr">next</span>: <span class="hljs-built_in">Function</span>,
  ) =&gt; {
    <span class="hljs-keyword">const</span> resolveParamValue = <span class="hljs-keyword">async</span> (
      param: ParamProperties &amp; { metatype?: any },
    ) =&gt; {
      <span class="hljs-comment">// index 为参数序号，表示第几个参数</span>
      <span class="hljs-comment">// type 为修饰器类型，如 @Request</span>
      <span class="hljs-keyword">const</span> { index, extractValue, type, data, metatype, <span class="hljs-attr">pipes</span>: paramPipes } = param;
      <span class="hljs-keyword">const</span> value = extractValue(req, res, next);

      args[index] = <span class="hljs-keyword">this</span>.isPipeable(type)
        ? <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.getParamValue(
            value,
            { metatype, type, data } <span class="hljs-keyword">as</span> any,
            pipes.concat(paramPipes),
          )
        : value;
    };
    <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(paramsOptions.map(resolveParamValue));
  };
  <span class="hljs-keyword">return</span> paramsOptions.length ? pipesFn : <span class="hljs-literal">null</span>;
}
</code></pre>
<p>可以发现 <code>createPipesFn</code> 方法里面只是返回一个 <code>pipesFn</code>，<strong>这个 <code>pipesFn</code> 作用在于生成参数 <code>args</code>，而这个 <code>args</code> 是从路由处理代理里面传过来，<code>const args = this.contextUtils.createNullArray(argsLength)</code> 是个空数组!</strong>，由于引用对象的特性，该空数组将会在 <code>createPipesFn</code> 实现参数回填，最后再 <code>callback</code> 也就是对应路由执行 method 里面传递 <code>args</code> 作为参数进去。</p>
<p>打比方如 <code>async login(@Request() req) {}</code> 参数 <code>req</code> 会在 <code>createPipesFn</code> 里面根据修饰器类型返回 <code>req</code> 对象，并被赋值到 <code>args</code> 数组的第一个元素里面，最后这个 <code>args</code> 则会成为 <code>login</code> 方法的传参。从而通过 <code>pipe</code> 的方式实现参数的传递。</p>
<p>当然 <code>pipe</code> 的作用不止如此，具体的大家可以探索一下；</p>
<h2>应用初始化之其他</h2>
<p>上面介绍了路由如何通过 <code>platform-express</code> 生成，还有一点其他的内容，回到 <code>init</code> 方法：</p>
<pre class="hljs"><code><span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.callInitHook();
<span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.registerRouterHooks();
<span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.callBootstrapHook();

<span class="hljs-keyword">this</span>.isInitialized = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">this</span>.logger.log(MESSAGES.APPLICATION_READY);
</code></pre>
<p>上面分别调用的是 nest 自定义的生命周期钩子，<code>onModuleInit/onApplicationBootstrap</code> 这两个钩子，而 <code>registerRouterHooks</code> 则是给路由添加无路由处理和异常处理；</p>
<h2>总结</h2>
<p>开始用 nest 写业务的时候，还是懵懵懂懂的，一知半解，好奇这些修饰器是如何用的，为什么 <code>@Request</code> 可以这么用，和使用多年的 Vue/React 甚至 egg 风格截然不同，看了源码之后有种豁然开朗的感觉，而且 typescript 阅读源码很方便，让生锈的脑袋不怎么费力的就读下来了，只是中间的跳转实在有点啰嗦，可能这就是面向对象的特点吧。</p>
<p>关于 nest 还有不少地方没有介绍到，这里主要介绍的是初始化过程，包括容器初始化和应用初始化。<strong>容器的初始化是获取所有的依赖项，形成一个 IOC 容器，并实例化依赖，也包含 <code>controller</code>。应用初始化则是中间件、微服务模块、websoket 模块的注册和路由的生成，而这些的前提也是 IOC 容器。</strong></p>
<p>希望 2020，疫情好转，国运昌盛；</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"March 24, 2021","title":"nest 初始化","content":"\u003cp\u003e春节呆在家里不能外出，假期又特别长，刚好在学习 nest，于是就看了一遍源码。nest 是用 typescript 写得，用法自然也是基于 typescript，其源码用 vscode 阅读非常方便，基本上是读过里面最流畅的了，只是一个初始化过程，其涉及的操作非常多，逻辑上还是需要捋一捋。直接用 nest 仓库代码阅读调试会发现调试的时候，部分代码引入采用类似下面的方式：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 在 core 目录下的 nest-application.ts\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { Logger } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@nestjs/common/services/logger.service\"\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其直接引用 \u003ccode\u003enode_modules\u003c/code\u003e 里面的模块，但是源码里面怎么可能有 \u003ccode\u003enode_modules\u003c/code\u003e ，不是应该直接用相对路径？\u003c/p\u003e\n\u003cp\u003enest 里面采用分包的形式打包，源码是 typescript 实现的，所以会将 packages 下面的模块通过编译生成普通 js 文件，于是为了方便调试，想到一个笨拙的办法，修改源代码的基础配置 \u003ccode\u003etsconfig.base.json\u003c/code\u003e，这个配置是项目的基础 tsconfig，如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 添加如下配置\u003c/span\u003e\n  \u003cspan class=\"hljs-string\"\u003e\"paths\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"@nestjs/*\"\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"../*\"\u003c/span\u003e]\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e所有 packages 下面的 tsconfig 都会扩展 \u003ccode\u003etsconfig.base.json\u003c/code\u003e, 所以在基础文件里面配置路径别称，将 \u003ccode\u003e@nestjs/*\u003c/code\u003e 指向相对路径，就可以直接的智能交互引用的代码了，方便定位和阅读。\u003c/p\u003e\n\u003cp\u003eps: 修改配置的时候发现一个奇怪的 bug，修改扩展配置文件 tsconfig ，vscode 无法做到实时更新，需要重新初始化一次才可以，比如重启 vscode。\u003c/p\u003e\n\u003ch2\u003eIOC 控制反转 依赖注入\u003c/h2\u003e\n\u003cp\u003e在开始源码前，需要了解一下 IOC 控制反转和依赖注入，nest 采用内置的 IOC 容器实现依赖注入的功能；关于控制反转和依赖注入可以看 \u003ca href=\"https://www.zhihu.com/question/23277575\" target=\"_blank\"\u003e这里\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e简单的来说，\u003cstrong\u003e程序只用负责使用依赖就好了，至于依赖如何被创建不用用户关心，交给第三方 IOC 容器来负责\u003c/strong\u003e 。这也是 nest 的特色依赖注入；而初始化的过程，则大部分都在创建这个 IOC 容器。\u003c/p\u003e\n\u003cp\u003e依赖注入写法的主要部分如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-meta\"\u003e@Controller\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"api\"\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e AppController {\n  \u003cspan class=\"hljs-keyword\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e readonly appService: AppService\u003c/span\u003e) {}\n\n  \u003cspan class=\"hljs-meta\"\u003e@Post\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"login\"\u003c/span\u003e)\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e login(\u003cspan class=\"hljs-meta\"\u003e@Request\u003c/span\u003e() req) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e res = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.appService.findOne(req.name);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里面不需要知道 \u003ccode\u003eappService\u003c/code\u003e 实例是如何创建的，只是需要直接用就可以了，将变量通过参数的方式传入进来，而不是在 \u003ccode\u003econstructor\u003c/code\u003e 里面去实例该变量；\u003c/p\u003e\n\u003ch2\u003e容器初始化之扫描\u003c/h2\u003e\n\u003cp\u003e按照官方提供的例子，一般业务启动如下:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ebootstrap\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e NestFactory.create(ApplicationModule);\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e app.listen(\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ebootstrap\u003c/code\u003e 分为创建应用和监听过程，其中创建应用主要是初始化依赖，而监听则主要是对中间件和路由进行初始化。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e create\u0026lt;T extends INestApplication = INestApplication\u0026gt;(\n  \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e: any,\n  serverOrOptions?: AbstractHttpAdapter | NestApplicationOptions,\n  options?: NestApplicationOptions,\n): \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026lt;T\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// 设置 httpServer，即是 http 平台，默认采用 platform-express\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e [httpServer, appOptions] = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isHttpServer(serverOrOptions)\n    ? [serverOrOptions, options]\n    : [\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createHttpAdapter(), serverOrOptions];\n  \u003cspan class=\"hljs-comment\"\u003e// 创建全局应用配置，并根据该配置生成 container，该容器则是 IOC 容器载体；\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e applicationConfig = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e ApplicationConfig();\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e NestContainer(applicationConfig);\n\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.applyLogger(appOptions);\n  \u003cspan class=\"hljs-comment\"\u003e// this.initialize 初始化容器，赋予容器功能\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.initialize(\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, container, applicationConfig, httpServer);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instance = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e NestApplication(\n    container,\n    httpServer,\n    applicationConfig,\n    appOptions,\n  );\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e target = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createNestInstance(instance);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createAdapterProxy\u0026lt;T\u0026gt;(target, httpServer);\n}\n\nprivate \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e initialize(\n  \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e: any,\n  \u003cspan class=\"hljs-attr\"\u003econtainer\u003c/span\u003e: NestContainer,\n  config = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e ApplicationConfig(),\n  \u003cspan class=\"hljs-attr\"\u003ehttpServer\u003c/span\u003e: HttpServer = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instanceLoader = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e InstanceLoader(container);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dependenciesScanner = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e DependenciesScanner(\n    container,\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e MetadataScanner(),\n    config,\n  );\n  container.setHttpAdapter(httpServer);\n  \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.logger.log(MESSAGES.APPLICATION_START);\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e ExceptionsZone.asyncRun(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u0026gt; {\n      \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e dependenciesScanner.scan(\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e instanceLoader.createInstancesOfDependencies();\n      dependenciesScanner.applyApplicationProviders();\n    });\n  } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n    process.abort();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e创建的配置 \u003ccode\u003eapplicationConfig\u003c/code\u003e 包含全局的 pipes/guards 等等，\u003ccode\u003ecreate\u003c/code\u003e 里面最主要是的 \u003ccode\u003einit\u003c/code\u003e 方法，该方法先生成加载器 \u003ccode\u003eloader\u003c/code\u003e 和依赖的 \u003ccode\u003eScanner\u003c/code\u003e。初始化里面的 \u003ccode\u003edependenciesScanner.scan\u003c/code\u003e 会做以下操作\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e注册核心模块 \u003ccode\u003eInternalCoreModule\u003c/code\u003e，该模块是容器的核心模块，对比提交记录可以发现，之前版本是没有核心模块，后面将 \u003ccode\u003eapplicationConfig\u003c/code\u003e 里面非全局配置的功能集中到了 \u003ccode\u003eInternalCoreModule\u003c/code\u003e；\u003c/li\u003e\n\u003cli\u003e将核心模块和用户配置传入的模块进行一次 \u003ccode\u003escanForModules\u003c/code\u003e，遍历所有的模块，并根据随机 uuid、名称、scope 以及其他信息创建 token，以该 token 为 key 最后 \u003ccode\u003eset\u003c/code\u003e 到容器里面；如果是同一模块，若 scope 不一样，其在容器中注册的模块也会不一样；\u003c/li\u003e\n\u003cli\u003escan 所有(用户与核心)模块的依赖\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e scanModulesForDependencies() {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e modules = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.container.getModules();\n\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [token, { metatype }] \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e modules) {\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.reflectImports(metatype, token, metatype.name);\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.reflectProviders(metatype, token);\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.reflectControllers(metatype, token);\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.reflectExports(metatype, token);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.calculateModulesDistance(modules);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e前面添加模块后，则立刻对所有模块的依赖进行 scan，对导入模块/输出模块与当前模块进行关联，而 providers/controllers 处理比较特别，所有的依赖注入项会在 providers 里面找，而这些用户的 providers 添加则是在 \u003ccode\u003ethis.reflectProviders(metatype, token)\u003c/code\u003e 里面进行的：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic addProvider(provider: Provider): string {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isCustomProvider(provider)) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.addCustomProvider(provider, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._providers);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._providers.set(\n    (provider \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e Type\u0026lt;Injectable\u0026gt;).name,\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e InstanceWrapper({\n      \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: (provider \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e Type\u0026lt;Injectable\u0026gt;).name,\n      \u003cspan class=\"hljs-attr\"\u003emetatype\u003c/span\u003e: provider \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e Type\u0026lt;Injectable\u0026gt;,\n      \u003cspan class=\"hljs-attr\"\u003einstance\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eisResolved\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003escope\u003c/span\u003e: getClassScope(provider),\n      \u003cspan class=\"hljs-attr\"\u003ehost\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e,\n    }),\n  );\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (provider \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e Type\u0026lt;Injectable\u0026gt;).name;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e最终 providers 会生成一个 \u003ccode\u003eInstanceWrapper\u003c/code\u003e 实例，该实例下面的 \u003ccode\u003emetatype\u003c/code\u003e 指向原 provider 的类，而 instance 则是类的实例化，后面会提到。\u003c/p\u003e\n\u003cp\u003e在遍历所有的 providers 和 controlers 的同时 nest 还会收集其添加的 guards/interceptors/exceptionFilters/pipes/routeArguments 这些修饰器到模块的 injectables 里面，给后面使用。（routeArguments 是 nest 提供的专门的路由信息修饰器）\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ethis.calculateModulesDistance(modules)\u003c/code\u003e 给已添加的模块计算其优先级，越晚加入的模块，优先级越低，比如导入的模块其优先级就要小于当前模块，这个优先级作用目前只在中间件里面看到，按照优先级排序注册中间件。\u003c/p\u003e\n\u003ch2\u003e容器初始化之实例化\u003c/h2\u003e\n\u003cp\u003e经过上面的铺垫相关的模块已经添加到 container 里面了，但是具体的依赖注入实现还在实例化，回到初始化里面 \u003ccode\u003eawait instanceLoader.createInstancesOfDependencies()\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e实例化中先是处理原型，将原型上的方法扩展到 InstanceWrapper 实例里面（目前不知道有什么用。。。。。。可能只是单纯的扩展）。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e loadInstance\u0026lt;T\u0026gt;(\n  wrapper: InstanceWrapper\u0026lt;T\u0026gt;, \u003cspan class=\"hljs-attr\"\u003ecollection\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eMap\u003c/span\u003e\u0026lt;string, InstanceWrapper\u0026gt;,\n  \u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: Module, contextId = STATIC_CONTEXT, inquirer?: InstanceWrapper,\n) {\n  \u003cspan class=\"hljs-comment\"\u003e// 省略前面部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// instanceHost 则是前面InstanceWrapper下value\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 如果该InstanceWrapper已经resolved了，则不需要后面继续遍历寻找参数\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (instanceHost.isResolved) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e done();\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e callback = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (instances: unknown[]) =\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e properties = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.resolveProperties(wrapper, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, inject,contextId, wrapper, inquirer);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instance = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.instantiateClass(instances, wrapper, targetWrapper, contextId, inquirer);\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.applyProperties(instance, properties);\n    done();\n  };\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.resolveConstructorParams\u0026lt;T\u0026gt;(wrapper, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, inject, callback, contextId, wrapper, inquirer);\n}\n\npublic \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e resolveConstructorParams\u0026lt;T\u0026gt;(\n  wrapper: InstanceWrapper\u0026lt;T\u0026gt;, \u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: Module, \u003cspan class=\"hljs-attr\"\u003einject\u003c/span\u003e: InjectorDependency[],\n  \u003cspan class=\"hljs-attr\"\u003ecallback\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eargs: unknown[]\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e, contextId = STATIC_CONTEXT,\n  inquirer?: InstanceWrapper, parentInquirer?: InstanceWrapper,\n) {\n  \u003cspan class=\"hljs-comment\"\u003e// 省略前面部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dependencies = isNil(inject) ? \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.reflectConstructorParams(wrapper.metatype \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e Type\u0026lt;any\u0026gt;) : inject;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e optionalDependenciesIds = isNil(inject) ? \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.reflectOptionalParams(wrapper.metatype \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e Type\u0026lt;any\u0026gt;) : [];\n\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e isResolved = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e resolveParam = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (param: unknown, \u003cspan class=\"hljs-attr\"\u003eindex\u003c/span\u003e: number) =\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isInquirer(param, parentInquirer)) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e parentInquirer \u0026amp;\u0026amp; parentInquirer.instance;\n      }\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e paramWrapper = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.resolveSingleParam\u0026lt;T\u0026gt;(wrapper, param, { index, dependencies }, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e,\n        contextId, inquirer, index);\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instanceHost = paramWrapper.getInstanceByContextId(contextId, inquirerId);\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!instanceHost.isResolved \u0026amp;\u0026amp; !paramWrapper.forwardRef) {\n        isResolved = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n      }\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e instanceHost \u0026amp;\u0026amp; instanceHost.instance;\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (err) {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isOptional = optionalDependenciesIds.includes(index);\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isOptional) {\n        \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e err;\n      }\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n    }\n  };\n  \u003cspan class=\"hljs-comment\"\u003e// 最后得到需要注入的实例\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instances = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.all(dependencies.map(resolveParam));\n  isResolved \u0026amp;\u0026amp; (\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e callback(instances));\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e实例过程中会遍历模块下的所有 providers/injectables/controllers，最后依次完成实例化，实例化通用方法为 \u003ccode\u003eloadInstance\u003c/code\u003e。可以看到通过解析参数的方式来获取依赖 \u003ccode\u003edependencies\u003c/code\u003e，然后解析依赖，通过 \u003ccode\u003eresolveSingleParam\u003c/code\u003e 获得对应 \u003ccode\u003eprovider\u003c/code\u003e，再进入 \u003ccode\u003ecallback\u003c/code\u003e 回调。\u003c/p\u003e\n\u003cp\u003e只是具体如何解析依赖？在 \u003ccode\u003eresolveConstructorParams\u003c/code\u003e 方法里面，通过 \u003ccode\u003ereflectConstructorParams\u003c/code\u003e 可以拿到参数，比如\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e AppController {\n  \u003cspan class=\"hljs-keyword\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e readonly appService: AppService\u003c/span\u003e) {}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里的 \u003ccode\u003eappService\u003c/code\u003e 参数，就是通过 \u003ccode\u003ereflectConstructorParams\u003c/code\u003e 获得的，先知道需要哪些依赖才能注入，只是如何知道有那些参数呢？这里的实现卡了很两天才明白， 因为 \u003ccode\u003ereflectConstructorParams\u003c/code\u003e 实现很简单：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic reflectConstructorParams\u0026lt;T\u0026gt;(type: Type\u0026lt;T\u0026gt;): any[] {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e paramtypes = \u003cspan class=\"hljs-built_in\"\u003eReflect\u003c/span\u003e.getMetadata(PARAMTYPES_METADATA, type) || [];\n  \u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e paramtypes;\n}\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eInjectable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eoptions?: InjectableOptions\u003c/span\u003e): \u003cspan class=\"hljs-title\"\u003eClassDecorator\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003etarget: object\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-built_in\"\u003eReflect\u003c/span\u003e.defineMetadata(SCOPE_OPTIONS_METADATA, options, target);\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过获取 \u003ccode\u003e'design:paramtypes'\u003c/code\u003e 的元数据就可以获得参数了，只是代码里面并没有用相关的修饰器，将参数传进去，官方文档提到：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eA provider is simply a class annotated with an @Injectable() decorator\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e只是 \u003ccode\u003eInjectable\u003c/code\u003e 修饰器的实现明显不是提供 \u003ccode\u003e'design:paramtypes'\u003c/code\u003e 元数据，甚至 \u003ccode\u003e@Injectable()\u003c/code\u003e 里面什么数据都没有传递。于是这里就陷入了僵局，按照官方意思是只要用了 \u003ccode\u003e@Injectable()\u003c/code\u003e 就可以。测试的时候，将 \u003ccode\u003e@Injectable()\u003c/code\u003e 去掉发现依赖不能注入了，编译后的代码则是：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eAppController = __decorate(\n  [\n    common_1.Controller(\u003cspan class=\"hljs-string\"\u003e\"api\"\u003c/span\u003e),\n    __metadata(\u003cspan class=\"hljs-string\"\u003e\"design:paramtypes\"\u003c/span\u003e, [app_service_1.AppService])\n  ],\n  AppController\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e明明没有用到 \u003ccode\u003e'design:paramtypes'\u003c/code\u003e 相关的修饰器，结果编译出来的代码就是有的。。。。。。实在很奇怪。直到谷歌 \u003ccode\u003e'design:paramtypes'\u003c/code\u003e 的时候发现，原来这个 typescript 搞的鬼\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWhen you enable metadata through the \u0026quot;emitDecoratorMetadata\u0026quot; property, the TypeScript compiler will generate the following metadata properties:\n'design:type', 'design:paramtypes' and 'design:returntype'.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e嗯，\u003cstrong\u003e依赖注入里面，typescript 已经帮你把参数给拎出来了，直接访问元数据，key 为 \u003ccode\u003e'design:paramtypes'\u003c/code\u003e 就可以了。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e回到之前，获取到参数的类，但是距离可用还差很远，需要获取参数对应的 provider 的 InstanceWrapper，获取到 InstanceWrapper 之后也不能直接用，如果该 InstanceWrapper 没有被 resolved 过，则需要递归继续加载该 provider 的 \u003ccode\u003eloadInstance\u003c/code\u003e 方法。\u003ccode\u003eresolveConstructorParams\u003c/code\u003e 方法下最后的 instances 则是需要注入的实例了，而不是 \u003ccode\u003enull\u003c/code\u003e，因此需要递归，就是将底层的类实例好后传入上级作为参数，直到顶端。\u003c/p\u003e\n\u003cp\u003e类如何被实例？实例的过程发生在 \u003ccode\u003econst instance = await this.instantiateClass(instances, wrapper, targetWrapper, contextId, inquirer)\u003c/code\u003e 里面，这里的 instances 参数是需要注入的实例，而这些实例也同样来自于 \u003ccode\u003einstantiateClass\u003c/code\u003e 方法:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e instantiateClass\u0026lt;T = any\u0026gt;(\n  instances: any[],\n  \u003cspan class=\"hljs-attr\"\u003ewrapper\u003c/span\u003e: InstanceWrapper,\n  \u003cspan class=\"hljs-attr\"\u003etargetMetatype\u003c/span\u003e: InstanceWrapper,\n  contextId = STATIC_CONTEXT,\n  inquirer?: InstanceWrapper,\n) {\n  \u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instanceHost = targetMetatype.getInstanceByContextId(\n    contextId,\n    inquirerId,\n  );\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isNil(inject) \u0026amp;\u0026amp; isInContext) {\n    instanceHost.instance = wrapper.forwardRef\n      ? \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.assign(\n          instanceHost.instance,\n          \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e (metatype \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e Type\u0026lt;any\u0026gt;)(...instances),\n        )\n      : \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e (metatype \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e Type\u0026lt;any\u0026gt;)(...instances);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isInContext) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e factoryReturnValue = ((targetMetatype.metatype \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e any) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eFunction\u003c/span\u003e)(\n      ...instances,\n    );\n    instanceHost.instance = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e factoryReturnValue;\n  }\n  instanceHost.isResolved = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e instanceHost.instance;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到通过 new 的形式生成新的实例赋值到 \u003ccode\u003eInstanceWrapper\u003c/code\u003e 的 \u003ccode\u003einstance\u003c/code\u003e，并将 isResolved 设置为 \u003ccode\u003etrue\u003c/code\u003e，表示后面不再递归该 \u003ccode\u003eprovider\u003c/code\u003e 了。由此可见这个 isResolved 很重要，在添加 \u003ccode\u003eproviders\u003c/code\u003e 的时候，也会根据 \u003ccode\u003eprovider\u003c/code\u003e 类型来修改 isResolved，如果是 Custom providers，则有可能 isResolved 一开始就是 \u003ccode\u003etrue\u003c/code\u003e；\u003c/p\u003e\n\u003ch2\u003e应用初始化之中间件\u003c/h2\u003e\n\u003cp\u003e上面的 IOC 控制容器初始化好了之后，会进入业务主程序的下一步 \u003ccode\u003eawait app.listen(3000)\u003c/code\u003e。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e init() {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e useBodyParser =\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.appOptions \u0026amp;\u0026amp; \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.appOptions.bodyParser !== \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// 注册 platform-express 的中间件，就是bodyParser.json和bodyParser.urlencoded\u003c/span\u003e\n  useBodyParser \u0026amp;\u0026amp; \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.registerParserMiddleware();\n  \u003cspan class=\"hljs-comment\"\u003e// registerModules 注册websocket模块和微服务模块，\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.registerModules();\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.registerRouter();\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.callInitHook();\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.registerRouterHooks();\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.callBootstrapHook();\n\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isInitialized = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.logger.log(MESSAGES.APPLICATION_READY);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e先是注册常规的解析中间件，后面的 \u003ccode\u003eregisterModules\u003c/code\u003e 里面会注册上用户自定义的中间件，常见的中间件用法如下\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eAppModule\u003c/span\u003e \u003c/span\u003e{\n  configure(consumer: MiddlewareConsumer) {\n    consumer.apply(LoggerMiddleware).forRoutes(AppController);\n  }\n}\n\n@Injectable()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eLoggerMiddleware\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eimplements\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eNestMiddleware\u003c/span\u003e \u003c/span\u003e{\n  use(req, res, \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eFunction\u003c/span\u003e) {\n    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e\"Request...\"\u003c/span\u003e);\n    next();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到应用方需要显式的使用 \u003ccode\u003econfigure\u003c/code\u003e 才能使用该中间件，因为源码里面是采用 \u003ccode\u003eawait instance.configure(middlewareBuilder)\u003c/code\u003e 的方法。而 \u003ccode\u003econfig\u003c/code\u003e 正如字面意思配置中间件，只是起到给入口的作用，更多的是让后面 \u003ccode\u003eapply\u003c/code\u003e 和 \u003ccode\u003eforRoutes\u003c/code\u003e 方法，结合起来能够将中间件与路由挂勾上，尤其是 \u003ccode\u003eforRoutes\u003c/code\u003e，\u003cstrong\u003e若不用上 \u003ccode\u003eforRoutes\u003c/code\u003e 定义路由，则模块下的中间件不会注册上。\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic forRoutes(\n  ...routes: \u003cspan class=\"hljs-built_in\"\u003eArray\u003c/span\u003e\u0026lt;string | Type\u0026lt;any\u0026gt; | RouteInfo\u0026gt;\n): MiddlewareConsumer {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { middlewareCollection, routesMapper } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.builder;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e forRoutes = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.mapRoutesToFlatList(\n    routes.map(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eroute\u003c/span\u003e =\u0026gt;\u003c/span\u003e routesMapper.mapRouteToRouteInfo(route)),\n  );\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e configuration = {\n    \u003cspan class=\"hljs-attr\"\u003emiddleware\u003c/span\u003e: filterMiddleware(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.middleware),\n    \u003cspan class=\"hljs-attr\"\u003eforRoutes\u003c/span\u003e: forRoutes.filter(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eroute\u003c/span\u003e =\u0026gt;\u003c/span\u003e !\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isRouteExcluded(route)),\n  };\n  middlewareCollection.add(configuration);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.builder;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里传入的路由配置会被 \u003ccode\u003emapRouteToRouteInfo\u003c/code\u003e 解析，传入的可以是简单的路由地址字符串，也可以是路由集合，更可以是对应的 \u003ccode\u003econtroller\u003c/code\u003e 类。接着前面配置的 \u003ccode\u003eLoggerMiddleware\u003c/code\u003e 会和路由信息一起被添加到中间件集合里面，最后存入 \u003ccode\u003emiddlewareModule\u003c/code\u003e， key 则是模块的 token 信息。\u003c/p\u003e\n\u003ch2\u003e应用初始化之路由\u003c/h2\u003e\n\u003cp\u003e中间件添加完之后就是添加路由信息，相比较于 express 之类的，nest 采用方式既不是统一的路由配置，也不是约定目录的路由，而是采用和 spring 一样的注解来定义路由。对应源码入口处理部分如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic resolve\u0026lt;T extends HttpServer\u0026gt;(applicationRef: T, \u003cspan class=\"hljs-attr\"\u003ebasePath\u003c/span\u003e: string) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e modules = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.container.getModules();\n  modules.forEach(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ controllers, metatype }, moduleName\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e path = metatype\n      ? \u003cspan class=\"hljs-built_in\"\u003eReflect\u003c/span\u003e.getMetadata(MODULE_PATH, metatype)\n      : \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n    path = path ? basePath + path : basePath;\n    \u003cspan class=\"hljs-comment\"\u003e// 遍历模块，注册每个模块下的controllers集合\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.registerRouters(controllers, moduleName, path, applicationRef);\n  });\n}\nprivate applyCallbackToRouter\u0026lt;T extends HttpServer\u0026gt;(\n  router: T,\n  \u003cspan class=\"hljs-attr\"\u003epathProperties\u003c/span\u003e: RoutePathProperties,\n  \u003cspan class=\"hljs-attr\"\u003einstanceWrapper\u003c/span\u003e: InstanceWrapper,\n  \u003cspan class=\"hljs-attr\"\u003emoduleKey\u003c/span\u003e: string,\n  \u003cspan class=\"hljs-attr\"\u003ebasePath\u003c/span\u003e: string,\n) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: paths, requestMethod, targetCallback, methodName } = pathProperties;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { instance } = instanceWrapper;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e routerMethod = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.routerMethodFactory\n    .get(router, requestMethod)\n    .bind(router);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e stripSlash = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003estr: string\u003c/span\u003e) =\u0026gt;\u003c/span\u003e\n    str[str.length - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] === \u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e ? str.slice(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, str.length - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) : str;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isRequestScoped = !instanceWrapper.isDependencyTreeStatic();\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e proxy = isRequestScoped\n    ? \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createRequestScopedHandler(instanceWrapper, requestMethod, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.container.getModuleByKey(moduleKey),\n        moduleKey, methodName)\n    : \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createCallbackProxy(instance, targetCallback, methodName, moduleKey, requestMethod);\n\n  paths.forEach(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003epath\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fullPath = stripSlash(basePath) + path;\n    routerMethod(stripSlash(fullPath) || \u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e, proxy);\n  });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e第一个 \u003ccode\u003eresolve\u003c/code\u003e 方法简单的遍历，加上 \u003ccode\u003eregisterRouters\u003c/code\u003e 在对单个 \u003ccode\u003econtroller\u003c/code\u003e 遍历，可以获得所有的路由信息，而第二个 \u003ccode\u003eapplyCallbackToRouter\u003c/code\u003e 则是路由的重点，\u003ccode\u003erouterMethod\u003c/code\u003e 是 \u003ccode\u003eplatform-express\u003c/code\u003e 请求通用方法，比如：post/get 之类，可以通过它建立路由，相应的第一个参数 \u003ccode\u003estripSlash(fullPath) || '/'\u003c/code\u003e 是路由的访问路径，而第二个参数 \u003ccode\u003eproxy\u003c/code\u003e 则是路由处理回调。\u003ccode\u003eproxy\u003c/code\u003e 创建则涉及到非常多的内容：\u003c/p\u003e\n\u003cp\u003e整体的 \u003ccode\u003eproxy\u003c/code\u003e 会通过 \u003ccode\u003ecreate\u003c/code\u003e 创建新的路由实例，该实例会先获取信息 \u003ccode\u003egetMetadata\u003c/code\u003e。可以直接先看看该方法，再回到 \u003ccode\u003ecreate\u003c/code\u003e :\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic getMetadata(\n  instance: Controller,\u003cspan class=\"hljs-attr\"\u003ecallback\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e...args: any[]\u003c/span\u003e) =\u0026gt;\u003c/span\u003e any,\n  \u003cspan class=\"hljs-attr\"\u003emethodName\u003c/span\u003e: string, \u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: string, \u003cspan class=\"hljs-attr\"\u003erequestMethod\u003c/span\u003e: RequestMethod,\n): HandlerMetadata {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e cacheMetadata = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.handlerMetadataStorage.get(instance, methodName);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (cacheMetadata) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e cacheMetadata;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 路由传参信息\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e metadata =\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.contextUtils.reflectCallbackMetadata(instance, methodName, ROUTE_ARGS_METADATA) || {};\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e keys = \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.keys(metadata);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e argsLength = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.contextUtils.getArgumentsLength(keys, metadata);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e paramtypes = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.contextUtils.reflectCallbackParamtypes(instance, methodName);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e getParamsMetadata = (moduleKey: string, contextId = STATIC_CONTEXT, inquirerId?: string,\n  ) =\u0026gt; \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.exchangeKeysForValues(keys, metadata, moduleKey, contextId, inquirerId);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e paramsMetadata = getParamsMetadata(\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e);\n  \u003cspan class=\"hljs-comment\"\u003e// 路由信息里面，如果是 @Response 或者 @Next 则为 true\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isResponseHandled = paramsMetadata.some(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ type }\u003c/span\u003e) =\u0026gt;\u003c/span\u003e\n    type === RouteParamtypes.RESPONSE || type === RouteParamtypes.NEXT);\n  \u003cspan class=\"hljs-comment\"\u003e// 有无重定向修饰器 如@Redirect\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e httpRedirectResponse = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.reflectRedirect(callback);\n  \u003cspan class=\"hljs-comment\"\u003e// 有无渲染修饰器 如@Render('index')\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fnHandleResponse = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createHandleResponseFn(callback, isResponseHandled, httpRedirectResponse);\n  \u003cspan class=\"hljs-comment\"\u003e// post 响应默认状态码是 201，其他方式都是 200 ，可以通过 @HttpCode 来修改状态码\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e httpCode = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.reflectHttpStatusCode(callback);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e httpStatusCode = httpCode ? httpCode : \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.responseController.getStatusByMethod(requestMethod);\n  \u003cspan class=\"hljs-comment\"\u003e// 如@Header('Cache-Control', 'none') 修改响应头\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e responseHeaders = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.reflectResponseHeaders(callback);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hasCustomHeaders = !isEmpty(responseHeaders);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e handlerMetadata: HandlerMetadata = {\n    argsLength, fnHandleResponse, paramtypes, getParamsMetadata,\n    httpStatusCode, hasCustomHeaders, responseHeaders,\n  };\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.handlerMetadataStorage.set(instance, methodName, handlerMetadata);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e handlerMetadata;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于 \u003ccode\u003eController\u003c/code\u003e 其通常会采用一系列的修饰器，比如在其参数里面，添加 \u003ccode\u003e@Request() req\u003c/code\u003e。生成路由的时候也需要把这些信息提取出来，这些修饰器配置的元数据 key 是 \u003ccode\u003eROUTE_ARGS_METADATA\u003c/code\u003e，value 则是代码中的 \u003ccode\u003emetadata\u003c/code\u003e。\u003ccode\u003ereflectCallbackParamtypes\u003c/code\u003e 方法和前文提到的获取依赖方式一样，采用 \u003ccode\u003e'design:paramtypes'\u003c/code\u003e 获取 \u003ccode\u003econtroller\u003c/code\u003e 方法的形参。其他的基本上都是获取类或方法上修饰器的信息。还有个重要功能，是否响应需要模板渲染，比如渲染 html 页面，这个时候则可以用到 \u003ccode\u003e@Render('index')\u003c/code\u003e，可以看官方\u003ca href=\"https://docs.nestjs.com/techniques/mvc#template-rendering\" target=\"_blank\"\u003e文档\u003c/a\u003e，需要注意的是 html 文件需要保存在 views 目录。\u003c/p\u003e\n\u003cp\u003e再回到创建路由 \u003ccode\u003eproxy\u003c/code\u003e 的入口 \u003ccode\u003ecreate\u003c/code\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic create(\n  instance: Controller, \u003cspan class=\"hljs-attr\"\u003ecallback\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e...args: any[]\u003c/span\u003e) =\u0026gt;\u003c/span\u003e any, \u003cspan class=\"hljs-attr\"\u003emethodName\u003c/span\u003e: string,\n  \u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: string, \u003cspan class=\"hljs-attr\"\u003erequestMethod\u003c/span\u003e: RequestMethod, contextId = STATIC_CONTEXT, inquirerId?: string,\n) {\n  \u003cspan class=\"hljs-comment\"\u003e// 上面提到的获取contorller下路由对应方法的信息，如参数/请求头等等\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { argsLength, fnHandleResponse, paramtypes,\n    getParamsMetadata, httpStatusCode, responseHeaders, hasCustomHeaders,\n  } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.getMetadata(instance, callback, methodName, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, requestMethod);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e paramsOptions = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.contextUtils.mergeParamsMetatypes(\n    getParamsMetadata(\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, contextId, inquirerId), paramtypes);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e contextType: ContextType = \u003cspan class=\"hljs-string\"\u003e'http'\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// 提取模块中的 pipes/guards/interceptors\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pipes = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.pipesContextCreator.create(instance, callback, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, contextId, inquirerId);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e guards = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.guardsContextCreator.create(instance, callback, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, contextId, inquirerId);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e interceptors = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.interceptorsContextCreator.create(instance, callback, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, contextId, inquirerId);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fnCanActivate = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createGuardsFn(guards, instance, callback, contextType);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fnApplyPipes = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createPipesFn(pipes, paramsOptions);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e handler = \u0026lt;TRequest, TResponse\u0026gt;(args: any[], req: TRequest, res: TResponse,\n    next: Function) =\u0026gt; async () =\u0026gt; {\n    fnApplyPipes \u0026amp;\u0026amp; (await fnApplyPipes(args, req, res, next));\n    return callback.apply(instance, args);\n  };\n\n  return async \u0026lt;TRequest, TResponse\u0026gt;(req: TRequest, res: TResponse, next: Function) =\u0026gt; {\n    const args = this.contextUtils.createNullArray(argsLength);\n    fnCanActivate \u0026amp;\u0026amp; (await fnCanActivate([req, res, next]));\n\n    this.responseController.setStatus(res, httpStatusCode);\n    hasCustomHeaders \u0026amp;\u0026amp;\n      this.responseController.setHeaders(res, responseHeaders);\n\n    const result = await this.interceptorsConsumer.intercept(interceptors, [req, res, next],\n      instance, callback, handler(args, req, res, next), contextType);\n    await fnHandleResponse(result, res);\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面 \u003ccode\u003ecreate\u003c/code\u003e 返回则是路由响应的处理方式了。可以看到前面部分的 \u003ccode\u003epipes/guards/interceptors\u003c/code\u003e，是根据全局、\u003ccode\u003econtroller\u003c/code\u003e以及其下面的 \u003ccode\u003emethod\u003c/code\u003e 的修饰器获取对应的名称，再从模块的 \u003ccode\u003einjectables\u003c/code\u003e 获取对应的 \u003ccode\u003eInstanceWrapper\u003c/code\u003e，从而得到的数组。其后面还有对应的处理方法 \u003ccode\u003efnCanActivate\u003c/code\u003e 和 \u003ccode\u003efnApplyPipes\u003c/code\u003e，从代码上可以看到，路由响应里面先是执行 \u003ccode\u003efnCanActivate\u003c/code\u003e 也就是守卫，后面设置响应，然后是 \u003ccode\u003einterceptors\u003c/code\u003e，最后是 \u003ccode\u003efnApplyPipes\u003c/code\u003e，这里以 \u003ccode\u003efnCanActivate\u003c/code\u003e 为例子，看看其实现：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic createGuardsFn(guards: any[], \u003cspan class=\"hljs-attr\"\u003einstance\u003c/span\u003e: Controller, \u003cspan class=\"hljs-attr\"\u003ecallback\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e...args: any[]\u003c/span\u003e) =\u0026gt;\u003c/span\u003e any,\n  contextType?: TContext): \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eargs: any[]\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u0026gt; | \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e canActivateFn = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (args: any[]) =\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e canActivate = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.guardsConsumer.tryActivate\u0026lt;TContext\u0026gt;(\n      guards, args, instance, callback, contextType,\n    );\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!canActivate) {\n      \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e ForbiddenException(FORBIDDEN_MESSAGE);\n    }\n  };\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e guards.length ? canActivateFn : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n}\npublic \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e tryActivate(\n  guards: CanActivate[], \u003cspan class=\"hljs-attr\"\u003eargs\u003c/span\u003e: any[], \u003cspan class=\"hljs-attr\"\u003einstance\u003c/span\u003e: Controller,\n  \u003cspan class=\"hljs-attr\"\u003ecallback\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e...args: any[]\u003c/span\u003e) =\u0026gt;\u003c/span\u003e any, type?: TContext,\n) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!guards || isEmpty(guards)) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e context = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createContext(args, instance, callback);\n  context.setType\u0026lt;TContext\u0026gt;(type);\n\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e guard \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e guards) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = guard.canActivate(context);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.pickResult(result)) {\n      \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面可以看到，\u003ccode\u003eguard\u003c/code\u003e 是通过调用 \u003ccode\u003ecanActivate\u003c/code\u003e 来实现，如果没有实现该方法，则会抛出报错 \u003ccode\u003enew ForbiddenException(FORBIDDEN_MESSAGE)\u003c/code\u003e，后面的代码也就不执行了。最后路由代理具体业务的执行，则是在 \u003ccode\u003ecreate\u003c/code\u003e 提到的 \u003ccode\u003ehandler\u003c/code\u003e 里面执行。\u003c/p\u003e\n\u003cp\u003e这里回过头看一下，前面代码可以发现 \u003ccode\u003egetMetadata\u003c/code\u003e 里面生成的 \u003ccode\u003egetParamsMetadata\u003c/code\u003e，会用在 \u003ccode\u003ecreate\u003c/code\u003e 的 \u003ccode\u003ecreatePipesFn\u003c/code\u003e 方法里面用到：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic createPipesFn(\n  pipes: PipeTransform[],\n  \u003cspan class=\"hljs-attr\"\u003eparamsOptions\u003c/span\u003e: (ParamProperties \u0026amp; { metatype?: any })[],\n) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pipesFn = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u0026lt;TRequest, TResponse\u0026gt;(args: any[], \u003cspan class=\"hljs-attr\"\u003ereq\u003c/span\u003e: TRequest,\n    \u003cspan class=\"hljs-attr\"\u003eres\u003c/span\u003e: TResponse, \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eFunction\u003c/span\u003e,\n  ) =\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e resolveParamValue = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (\n      param: ParamProperties \u0026amp; { metatype?: any },\n    ) =\u0026gt; {\n      \u003cspan class=\"hljs-comment\"\u003e// index 为参数序号，表示第几个参数\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e// type 为修饰器类型，如 @Request\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { index, extractValue, type, data, metatype, \u003cspan class=\"hljs-attr\"\u003epipes\u003c/span\u003e: paramPipes } = param;\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e value = extractValue(req, res, next);\n\n      args[index] = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isPipeable(type)\n        ? \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.getParamValue(\n            value,\n            { metatype, type, data } \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e any,\n            pipes.concat(paramPipes),\n          )\n        : value;\n    };\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.all(paramsOptions.map(resolveParamValue));\n  };\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e paramsOptions.length ? pipesFn : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以发现 \u003ccode\u003ecreatePipesFn\u003c/code\u003e 方法里面只是返回一个 \u003ccode\u003epipesFn\u003c/code\u003e，\u003cstrong\u003e这个 \u003ccode\u003epipesFn\u003c/code\u003e 作用在于生成参数 \u003ccode\u003eargs\u003c/code\u003e，而这个 \u003ccode\u003eargs\u003c/code\u003e 是从路由处理代理里面传过来，\u003ccode\u003econst args = this.contextUtils.createNullArray(argsLength)\u003c/code\u003e 是个空数组!\u003c/strong\u003e，由于引用对象的特性，该空数组将会在 \u003ccode\u003ecreatePipesFn\u003c/code\u003e 实现参数回填，最后再 \u003ccode\u003ecallback\u003c/code\u003e 也就是对应路由执行 method 里面传递 \u003ccode\u003eargs\u003c/code\u003e 作为参数进去。\u003c/p\u003e\n\u003cp\u003e打比方如 \u003ccode\u003easync login(@Request() req) {}\u003c/code\u003e 参数 \u003ccode\u003ereq\u003c/code\u003e 会在 \u003ccode\u003ecreatePipesFn\u003c/code\u003e 里面根据修饰器类型返回 \u003ccode\u003ereq\u003c/code\u003e 对象，并被赋值到 \u003ccode\u003eargs\u003c/code\u003e 数组的第一个元素里面，最后这个 \u003ccode\u003eargs\u003c/code\u003e 则会成为 \u003ccode\u003elogin\u003c/code\u003e 方法的传参。从而通过 \u003ccode\u003epipe\u003c/code\u003e 的方式实现参数的传递。\u003c/p\u003e\n\u003cp\u003e当然 \u003ccode\u003epipe\u003c/code\u003e 的作用不止如此，具体的大家可以探索一下；\u003c/p\u003e\n\u003ch2\u003e应用初始化之其他\u003c/h2\u003e\n\u003cp\u003e上面介绍了路由如何通过 \u003ccode\u003eplatform-express\u003c/code\u003e 生成，还有一点其他的内容，回到 \u003ccode\u003einit\u003c/code\u003e 方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.callInitHook();\n\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.registerRouterHooks();\n\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.callBootstrapHook();\n\n\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isInitialized = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.logger.log(MESSAGES.APPLICATION_READY);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面分别调用的是 nest 自定义的生命周期钩子，\u003ccode\u003eonModuleInit/onApplicationBootstrap\u003c/code\u003e 这两个钩子，而 \u003ccode\u003eregisterRouterHooks\u003c/code\u003e 则是给路由添加无路由处理和异常处理；\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e开始用 nest 写业务的时候，还是懵懵懂懂的，一知半解，好奇这些修饰器是如何用的，为什么 \u003ccode\u003e@Request\u003c/code\u003e 可以这么用，和使用多年的 Vue/React 甚至 egg 风格截然不同，看了源码之后有种豁然开朗的感觉，而且 typescript 阅读源码很方便，让生锈的脑袋不怎么费力的就读下来了，只是中间的跳转实在有点啰嗦，可能这就是面向对象的特点吧。\u003c/p\u003e\n\u003cp\u003e关于 nest 还有不少地方没有介绍到，这里主要介绍的是初始化过程，包括容器初始化和应用初始化。\u003cstrong\u003e容器的初始化是获取所有的依赖项，形成一个 IOC 容器，并实例化依赖，也包含 \u003ccode\u003econtroller\u003c/code\u003e。应用初始化则是中间件、微服务模块、websoket 模块的注册和路由的生成，而这些的前提也是 IOC 容器。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e希望 2020，疫情好转，国运昌盛；\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"March 24, 2021","title":"nest 初始化","content":"\u003cp\u003e春节呆在家里不能外出，假期又特别长，刚好在学习 nest，于是就看了一遍源码。nest 是用 typescript 写得，用法自然也是基于 typescript，其源码用 vscode 阅读非常方便，基本上是读过里面最流畅的了，只是一个初始化过程，其涉及的操作非常多，逻辑上还是需要捋一捋。直接用 nest 仓库代码阅读调试会发现调试的时候，部分代码引入采用类似下面的方式：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 在 core 目录下的 nest-application.ts\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { Logger } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@nestjs/common/services/logger.service\"\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其直接引用 \u003ccode\u003enode_modules\u003c/code\u003e 里面的模块，但是源码里面怎么可能有 \u003ccode\u003enode_modules\u003c/code\u003e ，不是应该直接用相对路径？\u003c/p\u003e\n\u003cp\u003enest 里面采用分包的形式打包，源码是 typescript 实现的，所以会将 packages 下面的模块通过编译生成普通 js 文件，于是为了方便调试，想到一个笨拙的办法，修改源代码的基础配置 \u003ccode\u003etsconfig.base.json\u003c/code\u003e，这个配置是项目的基础 tsconfig，如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 添加如下配置\u003c/span\u003e\n  \u003cspan class=\"hljs-string\"\u003e\"paths\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"@nestjs/*\"\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"../*\"\u003c/span\u003e]\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e所有 packages 下面的 tsconfig 都会扩展 \u003ccode\u003etsconfig.base.json\u003c/code\u003e, 所以在基础文件里面配置路径别称，将 \u003ccode\u003e@nestjs/*\u003c/code\u003e 指向相对路径，就可以直接的智能交互引用的代码了，方便定位和阅读。\u003c/p\u003e\n\u003cp\u003eps: 修改配置的时候发现一个奇怪的 bug，修改扩展配置文件 tsconfig ，vscode 无法做到实时更新，需要重新初始化一次才可以，比如重启 vscode。\u003c/p\u003e\n\u003ch2\u003eIOC 控制反转 依赖注入\u003c/h2\u003e\n\u003cp\u003e在开始源码前，需要了解一下 IOC 控制反转和依赖注入，nest 采用内置的 IOC 容器实现依赖注入的功能；关于控制反转和依赖注入可以看 \u003ca href=\"https://www.zhihu.com/question/23277575\" target=\"_blank\"\u003e这里\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e简单的来说，\u003cstrong\u003e程序只用负责使用依赖就好了，至于依赖如何被创建不用用户关心，交给第三方 IOC 容器来负责\u003c/strong\u003e 。这也是 nest 的特色依赖注入；而初始化的过程，则大部分都在创建这个 IOC 容器。\u003c/p\u003e\n\u003cp\u003e依赖注入写法的主要部分如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-meta\"\u003e@Controller\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"api\"\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e AppController {\n  \u003cspan class=\"hljs-keyword\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e readonly appService: AppService\u003c/span\u003e) {}\n\n  \u003cspan class=\"hljs-meta\"\u003e@Post\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"login\"\u003c/span\u003e)\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e login(\u003cspan class=\"hljs-meta\"\u003e@Request\u003c/span\u003e() req) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e res = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.appService.findOne(req.name);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里面不需要知道 \u003ccode\u003eappService\u003c/code\u003e 实例是如何创建的，只是需要直接用就可以了，将变量通过参数的方式传入进来，而不是在 \u003ccode\u003econstructor\u003c/code\u003e 里面去实例该变量；\u003c/p\u003e\n\u003ch2\u003e容器初始化之扫描\u003c/h2\u003e\n\u003cp\u003e按照官方提供的例子，一般业务启动如下:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ebootstrap\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e NestFactory.create(ApplicationModule);\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e app.listen(\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ebootstrap\u003c/code\u003e 分为创建应用和监听过程，其中创建应用主要是初始化依赖，而监听则主要是对中间件和路由进行初始化。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e create\u0026lt;T extends INestApplication = INestApplication\u0026gt;(\n  \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e: any,\n  serverOrOptions?: AbstractHttpAdapter | NestApplicationOptions,\n  options?: NestApplicationOptions,\n): \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026lt;T\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// 设置 httpServer，即是 http 平台，默认采用 platform-express\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e [httpServer, appOptions] = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isHttpServer(serverOrOptions)\n    ? [serverOrOptions, options]\n    : [\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createHttpAdapter(), serverOrOptions];\n  \u003cspan class=\"hljs-comment\"\u003e// 创建全局应用配置，并根据该配置生成 container，该容器则是 IOC 容器载体；\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e applicationConfig = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e ApplicationConfig();\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e NestContainer(applicationConfig);\n\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.applyLogger(appOptions);\n  \u003cspan class=\"hljs-comment\"\u003e// this.initialize 初始化容器，赋予容器功能\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.initialize(\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, container, applicationConfig, httpServer);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instance = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e NestApplication(\n    container,\n    httpServer,\n    applicationConfig,\n    appOptions,\n  );\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e target = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createNestInstance(instance);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createAdapterProxy\u0026lt;T\u0026gt;(target, httpServer);\n}\n\nprivate \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e initialize(\n  \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e: any,\n  \u003cspan class=\"hljs-attr\"\u003econtainer\u003c/span\u003e: NestContainer,\n  config = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e ApplicationConfig(),\n  \u003cspan class=\"hljs-attr\"\u003ehttpServer\u003c/span\u003e: HttpServer = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instanceLoader = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e InstanceLoader(container);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dependenciesScanner = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e DependenciesScanner(\n    container,\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e MetadataScanner(),\n    config,\n  );\n  container.setHttpAdapter(httpServer);\n  \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.logger.log(MESSAGES.APPLICATION_START);\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e ExceptionsZone.asyncRun(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u0026gt; {\n      \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e dependenciesScanner.scan(\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e instanceLoader.createInstancesOfDependencies();\n      dependenciesScanner.applyApplicationProviders();\n    });\n  } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n    process.abort();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e创建的配置 \u003ccode\u003eapplicationConfig\u003c/code\u003e 包含全局的 pipes/guards 等等，\u003ccode\u003ecreate\u003c/code\u003e 里面最主要是的 \u003ccode\u003einit\u003c/code\u003e 方法，该方法先生成加载器 \u003ccode\u003eloader\u003c/code\u003e 和依赖的 \u003ccode\u003eScanner\u003c/code\u003e。初始化里面的 \u003ccode\u003edependenciesScanner.scan\u003c/code\u003e 会做以下操作\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e注册核心模块 \u003ccode\u003eInternalCoreModule\u003c/code\u003e，该模块是容器的核心模块，对比提交记录可以发现，之前版本是没有核心模块，后面将 \u003ccode\u003eapplicationConfig\u003c/code\u003e 里面非全局配置的功能集中到了 \u003ccode\u003eInternalCoreModule\u003c/code\u003e；\u003c/li\u003e\n\u003cli\u003e将核心模块和用户配置传入的模块进行一次 \u003ccode\u003escanForModules\u003c/code\u003e，遍历所有的模块，并根据随机 uuid、名称、scope 以及其他信息创建 token，以该 token 为 key 最后 \u003ccode\u003eset\u003c/code\u003e 到容器里面；如果是同一模块，若 scope 不一样，其在容器中注册的模块也会不一样；\u003c/li\u003e\n\u003cli\u003escan 所有(用户与核心)模块的依赖\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e scanModulesForDependencies() {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e modules = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.container.getModules();\n\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [token, { metatype }] \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e modules) {\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.reflectImports(metatype, token, metatype.name);\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.reflectProviders(metatype, token);\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.reflectControllers(metatype, token);\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.reflectExports(metatype, token);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.calculateModulesDistance(modules);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e前面添加模块后，则立刻对所有模块的依赖进行 scan，对导入模块/输出模块与当前模块进行关联，而 providers/controllers 处理比较特别，所有的依赖注入项会在 providers 里面找，而这些用户的 providers 添加则是在 \u003ccode\u003ethis.reflectProviders(metatype, token)\u003c/code\u003e 里面进行的：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic addProvider(provider: Provider): string {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isCustomProvider(provider)) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.addCustomProvider(provider, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._providers);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._providers.set(\n    (provider \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e Type\u0026lt;Injectable\u0026gt;).name,\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e InstanceWrapper({\n      \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: (provider \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e Type\u0026lt;Injectable\u0026gt;).name,\n      \u003cspan class=\"hljs-attr\"\u003emetatype\u003c/span\u003e: provider \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e Type\u0026lt;Injectable\u0026gt;,\n      \u003cspan class=\"hljs-attr\"\u003einstance\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eisResolved\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003escope\u003c/span\u003e: getClassScope(provider),\n      \u003cspan class=\"hljs-attr\"\u003ehost\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e,\n    }),\n  );\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (provider \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e Type\u0026lt;Injectable\u0026gt;).name;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e最终 providers 会生成一个 \u003ccode\u003eInstanceWrapper\u003c/code\u003e 实例，该实例下面的 \u003ccode\u003emetatype\u003c/code\u003e 指向原 provider 的类，而 instance 则是类的实例化，后面会提到。\u003c/p\u003e\n\u003cp\u003e在遍历所有的 providers 和 controlers 的同时 nest 还会收集其添加的 guards/interceptors/exceptionFilters/pipes/routeArguments 这些修饰器到模块的 injectables 里面，给后面使用。（routeArguments 是 nest 提供的专门的路由信息修饰器）\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ethis.calculateModulesDistance(modules)\u003c/code\u003e 给已添加的模块计算其优先级，越晚加入的模块，优先级越低，比如导入的模块其优先级就要小于当前模块，这个优先级作用目前只在中间件里面看到，按照优先级排序注册中间件。\u003c/p\u003e\n\u003ch2\u003e容器初始化之实例化\u003c/h2\u003e\n\u003cp\u003e经过上面的铺垫相关的模块已经添加到 container 里面了，但是具体的依赖注入实现还在实例化，回到初始化里面 \u003ccode\u003eawait instanceLoader.createInstancesOfDependencies()\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e实例化中先是处理原型，将原型上的方法扩展到 InstanceWrapper 实例里面（目前不知道有什么用。。。。。。可能只是单纯的扩展）。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e loadInstance\u0026lt;T\u0026gt;(\n  wrapper: InstanceWrapper\u0026lt;T\u0026gt;, \u003cspan class=\"hljs-attr\"\u003ecollection\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eMap\u003c/span\u003e\u0026lt;string, InstanceWrapper\u0026gt;,\n  \u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: Module, contextId = STATIC_CONTEXT, inquirer?: InstanceWrapper,\n) {\n  \u003cspan class=\"hljs-comment\"\u003e// 省略前面部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// instanceHost 则是前面InstanceWrapper下value\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 如果该InstanceWrapper已经resolved了，则不需要后面继续遍历寻找参数\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (instanceHost.isResolved) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e done();\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e callback = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (instances: unknown[]) =\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e properties = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.resolveProperties(wrapper, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, inject,contextId, wrapper, inquirer);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instance = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.instantiateClass(instances, wrapper, targetWrapper, contextId, inquirer);\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.applyProperties(instance, properties);\n    done();\n  };\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.resolveConstructorParams\u0026lt;T\u0026gt;(wrapper, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, inject, callback, contextId, wrapper, inquirer);\n}\n\npublic \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e resolveConstructorParams\u0026lt;T\u0026gt;(\n  wrapper: InstanceWrapper\u0026lt;T\u0026gt;, \u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: Module, \u003cspan class=\"hljs-attr\"\u003einject\u003c/span\u003e: InjectorDependency[],\n  \u003cspan class=\"hljs-attr\"\u003ecallback\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eargs: unknown[]\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e, contextId = STATIC_CONTEXT,\n  inquirer?: InstanceWrapper, parentInquirer?: InstanceWrapper,\n) {\n  \u003cspan class=\"hljs-comment\"\u003e// 省略前面部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dependencies = isNil(inject) ? \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.reflectConstructorParams(wrapper.metatype \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e Type\u0026lt;any\u0026gt;) : inject;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e optionalDependenciesIds = isNil(inject) ? \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.reflectOptionalParams(wrapper.metatype \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e Type\u0026lt;any\u0026gt;) : [];\n\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e isResolved = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e resolveParam = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (param: unknown, \u003cspan class=\"hljs-attr\"\u003eindex\u003c/span\u003e: number) =\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isInquirer(param, parentInquirer)) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e parentInquirer \u0026amp;\u0026amp; parentInquirer.instance;\n      }\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e paramWrapper = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.resolveSingleParam\u0026lt;T\u0026gt;(wrapper, param, { index, dependencies }, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e,\n        contextId, inquirer, index);\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instanceHost = paramWrapper.getInstanceByContextId(contextId, inquirerId);\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!instanceHost.isResolved \u0026amp;\u0026amp; !paramWrapper.forwardRef) {\n        isResolved = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n      }\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e instanceHost \u0026amp;\u0026amp; instanceHost.instance;\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (err) {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isOptional = optionalDependenciesIds.includes(index);\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isOptional) {\n        \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e err;\n      }\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n    }\n  };\n  \u003cspan class=\"hljs-comment\"\u003e// 最后得到需要注入的实例\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instances = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.all(dependencies.map(resolveParam));\n  isResolved \u0026amp;\u0026amp; (\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e callback(instances));\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e实例过程中会遍历模块下的所有 providers/injectables/controllers，最后依次完成实例化，实例化通用方法为 \u003ccode\u003eloadInstance\u003c/code\u003e。可以看到通过解析参数的方式来获取依赖 \u003ccode\u003edependencies\u003c/code\u003e，然后解析依赖，通过 \u003ccode\u003eresolveSingleParam\u003c/code\u003e 获得对应 \u003ccode\u003eprovider\u003c/code\u003e，再进入 \u003ccode\u003ecallback\u003c/code\u003e 回调。\u003c/p\u003e\n\u003cp\u003e只是具体如何解析依赖？在 \u003ccode\u003eresolveConstructorParams\u003c/code\u003e 方法里面，通过 \u003ccode\u003ereflectConstructorParams\u003c/code\u003e 可以拿到参数，比如\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e AppController {\n  \u003cspan class=\"hljs-keyword\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e readonly appService: AppService\u003c/span\u003e) {}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里的 \u003ccode\u003eappService\u003c/code\u003e 参数，就是通过 \u003ccode\u003ereflectConstructorParams\u003c/code\u003e 获得的，先知道需要哪些依赖才能注入，只是如何知道有那些参数呢？这里的实现卡了很两天才明白， 因为 \u003ccode\u003ereflectConstructorParams\u003c/code\u003e 实现很简单：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic reflectConstructorParams\u0026lt;T\u0026gt;(type: Type\u0026lt;T\u0026gt;): any[] {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e paramtypes = \u003cspan class=\"hljs-built_in\"\u003eReflect\u003c/span\u003e.getMetadata(PARAMTYPES_METADATA, type) || [];\n  \u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e paramtypes;\n}\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eInjectable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eoptions?: InjectableOptions\u003c/span\u003e): \u003cspan class=\"hljs-title\"\u003eClassDecorator\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003etarget: object\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-built_in\"\u003eReflect\u003c/span\u003e.defineMetadata(SCOPE_OPTIONS_METADATA, options, target);\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过获取 \u003ccode\u003e'design:paramtypes'\u003c/code\u003e 的元数据就可以获得参数了，只是代码里面并没有用相关的修饰器，将参数传进去，官方文档提到：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eA provider is simply a class annotated with an @Injectable() decorator\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e只是 \u003ccode\u003eInjectable\u003c/code\u003e 修饰器的实现明显不是提供 \u003ccode\u003e'design:paramtypes'\u003c/code\u003e 元数据，甚至 \u003ccode\u003e@Injectable()\u003c/code\u003e 里面什么数据都没有传递。于是这里就陷入了僵局，按照官方意思是只要用了 \u003ccode\u003e@Injectable()\u003c/code\u003e 就可以。测试的时候，将 \u003ccode\u003e@Injectable()\u003c/code\u003e 去掉发现依赖不能注入了，编译后的代码则是：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eAppController = __decorate(\n  [\n    common_1.Controller(\u003cspan class=\"hljs-string\"\u003e\"api\"\u003c/span\u003e),\n    __metadata(\u003cspan class=\"hljs-string\"\u003e\"design:paramtypes\"\u003c/span\u003e, [app_service_1.AppService])\n  ],\n  AppController\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e明明没有用到 \u003ccode\u003e'design:paramtypes'\u003c/code\u003e 相关的修饰器，结果编译出来的代码就是有的。。。。。。实在很奇怪。直到谷歌 \u003ccode\u003e'design:paramtypes'\u003c/code\u003e 的时候发现，原来这个 typescript 搞的鬼\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWhen you enable metadata through the \u0026quot;emitDecoratorMetadata\u0026quot; property, the TypeScript compiler will generate the following metadata properties:\n'design:type', 'design:paramtypes' and 'design:returntype'.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e嗯，\u003cstrong\u003e依赖注入里面，typescript 已经帮你把参数给拎出来了，直接访问元数据，key 为 \u003ccode\u003e'design:paramtypes'\u003c/code\u003e 就可以了。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e回到之前，获取到参数的类，但是距离可用还差很远，需要获取参数对应的 provider 的 InstanceWrapper，获取到 InstanceWrapper 之后也不能直接用，如果该 InstanceWrapper 没有被 resolved 过，则需要递归继续加载该 provider 的 \u003ccode\u003eloadInstance\u003c/code\u003e 方法。\u003ccode\u003eresolveConstructorParams\u003c/code\u003e 方法下最后的 instances 则是需要注入的实例了，而不是 \u003ccode\u003enull\u003c/code\u003e，因此需要递归，就是将底层的类实例好后传入上级作为参数，直到顶端。\u003c/p\u003e\n\u003cp\u003e类如何被实例？实例的过程发生在 \u003ccode\u003econst instance = await this.instantiateClass(instances, wrapper, targetWrapper, contextId, inquirer)\u003c/code\u003e 里面，这里的 instances 参数是需要注入的实例，而这些实例也同样来自于 \u003ccode\u003einstantiateClass\u003c/code\u003e 方法:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e instantiateClass\u0026lt;T = any\u0026gt;(\n  instances: any[],\n  \u003cspan class=\"hljs-attr\"\u003ewrapper\u003c/span\u003e: InstanceWrapper,\n  \u003cspan class=\"hljs-attr\"\u003etargetMetatype\u003c/span\u003e: InstanceWrapper,\n  contextId = STATIC_CONTEXT,\n  inquirer?: InstanceWrapper,\n) {\n  \u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instanceHost = targetMetatype.getInstanceByContextId(\n    contextId,\n    inquirerId,\n  );\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isNil(inject) \u0026amp;\u0026amp; isInContext) {\n    instanceHost.instance = wrapper.forwardRef\n      ? \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.assign(\n          instanceHost.instance,\n          \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e (metatype \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e Type\u0026lt;any\u0026gt;)(...instances),\n        )\n      : \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e (metatype \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e Type\u0026lt;any\u0026gt;)(...instances);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isInContext) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e factoryReturnValue = ((targetMetatype.metatype \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e any) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eFunction\u003c/span\u003e)(\n      ...instances,\n    );\n    instanceHost.instance = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e factoryReturnValue;\n  }\n  instanceHost.isResolved = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e instanceHost.instance;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到通过 new 的形式生成新的实例赋值到 \u003ccode\u003eInstanceWrapper\u003c/code\u003e 的 \u003ccode\u003einstance\u003c/code\u003e，并将 isResolved 设置为 \u003ccode\u003etrue\u003c/code\u003e，表示后面不再递归该 \u003ccode\u003eprovider\u003c/code\u003e 了。由此可见这个 isResolved 很重要，在添加 \u003ccode\u003eproviders\u003c/code\u003e 的时候，也会根据 \u003ccode\u003eprovider\u003c/code\u003e 类型来修改 isResolved，如果是 Custom providers，则有可能 isResolved 一开始就是 \u003ccode\u003etrue\u003c/code\u003e；\u003c/p\u003e\n\u003ch2\u003e应用初始化之中间件\u003c/h2\u003e\n\u003cp\u003e上面的 IOC 控制容器初始化好了之后，会进入业务主程序的下一步 \u003ccode\u003eawait app.listen(3000)\u003c/code\u003e。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e init() {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e useBodyParser =\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.appOptions \u0026amp;\u0026amp; \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.appOptions.bodyParser !== \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// 注册 platform-express 的中间件，就是bodyParser.json和bodyParser.urlencoded\u003c/span\u003e\n  useBodyParser \u0026amp;\u0026amp; \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.registerParserMiddleware();\n  \u003cspan class=\"hljs-comment\"\u003e// registerModules 注册websocket模块和微服务模块，\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.registerModules();\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.registerRouter();\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.callInitHook();\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.registerRouterHooks();\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.callBootstrapHook();\n\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isInitialized = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.logger.log(MESSAGES.APPLICATION_READY);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e先是注册常规的解析中间件，后面的 \u003ccode\u003eregisterModules\u003c/code\u003e 里面会注册上用户自定义的中间件，常见的中间件用法如下\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eAppModule\u003c/span\u003e \u003c/span\u003e{\n  configure(consumer: MiddlewareConsumer) {\n    consumer.apply(LoggerMiddleware).forRoutes(AppController);\n  }\n}\n\n@Injectable()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eLoggerMiddleware\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eimplements\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eNestMiddleware\u003c/span\u003e \u003c/span\u003e{\n  use(req, res, \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eFunction\u003c/span\u003e) {\n    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e\"Request...\"\u003c/span\u003e);\n    next();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到应用方需要显式的使用 \u003ccode\u003econfigure\u003c/code\u003e 才能使用该中间件，因为源码里面是采用 \u003ccode\u003eawait instance.configure(middlewareBuilder)\u003c/code\u003e 的方法。而 \u003ccode\u003econfig\u003c/code\u003e 正如字面意思配置中间件，只是起到给入口的作用，更多的是让后面 \u003ccode\u003eapply\u003c/code\u003e 和 \u003ccode\u003eforRoutes\u003c/code\u003e 方法，结合起来能够将中间件与路由挂勾上，尤其是 \u003ccode\u003eforRoutes\u003c/code\u003e，\u003cstrong\u003e若不用上 \u003ccode\u003eforRoutes\u003c/code\u003e 定义路由，则模块下的中间件不会注册上。\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic forRoutes(\n  ...routes: \u003cspan class=\"hljs-built_in\"\u003eArray\u003c/span\u003e\u0026lt;string | Type\u0026lt;any\u0026gt; | RouteInfo\u0026gt;\n): MiddlewareConsumer {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { middlewareCollection, routesMapper } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.builder;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e forRoutes = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.mapRoutesToFlatList(\n    routes.map(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eroute\u003c/span\u003e =\u0026gt;\u003c/span\u003e routesMapper.mapRouteToRouteInfo(route)),\n  );\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e configuration = {\n    \u003cspan class=\"hljs-attr\"\u003emiddleware\u003c/span\u003e: filterMiddleware(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.middleware),\n    \u003cspan class=\"hljs-attr\"\u003eforRoutes\u003c/span\u003e: forRoutes.filter(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eroute\u003c/span\u003e =\u0026gt;\u003c/span\u003e !\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isRouteExcluded(route)),\n  };\n  middlewareCollection.add(configuration);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.builder;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里传入的路由配置会被 \u003ccode\u003emapRouteToRouteInfo\u003c/code\u003e 解析，传入的可以是简单的路由地址字符串，也可以是路由集合，更可以是对应的 \u003ccode\u003econtroller\u003c/code\u003e 类。接着前面配置的 \u003ccode\u003eLoggerMiddleware\u003c/code\u003e 会和路由信息一起被添加到中间件集合里面，最后存入 \u003ccode\u003emiddlewareModule\u003c/code\u003e， key 则是模块的 token 信息。\u003c/p\u003e\n\u003ch2\u003e应用初始化之路由\u003c/h2\u003e\n\u003cp\u003e中间件添加完之后就是添加路由信息，相比较于 express 之类的，nest 采用方式既不是统一的路由配置，也不是约定目录的路由，而是采用和 spring 一样的注解来定义路由。对应源码入口处理部分如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic resolve\u0026lt;T extends HttpServer\u0026gt;(applicationRef: T, \u003cspan class=\"hljs-attr\"\u003ebasePath\u003c/span\u003e: string) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e modules = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.container.getModules();\n  modules.forEach(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ controllers, metatype }, moduleName\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e path = metatype\n      ? \u003cspan class=\"hljs-built_in\"\u003eReflect\u003c/span\u003e.getMetadata(MODULE_PATH, metatype)\n      : \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n    path = path ? basePath + path : basePath;\n    \u003cspan class=\"hljs-comment\"\u003e// 遍历模块，注册每个模块下的controllers集合\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.registerRouters(controllers, moduleName, path, applicationRef);\n  });\n}\nprivate applyCallbackToRouter\u0026lt;T extends HttpServer\u0026gt;(\n  router: T,\n  \u003cspan class=\"hljs-attr\"\u003epathProperties\u003c/span\u003e: RoutePathProperties,\n  \u003cspan class=\"hljs-attr\"\u003einstanceWrapper\u003c/span\u003e: InstanceWrapper,\n  \u003cspan class=\"hljs-attr\"\u003emoduleKey\u003c/span\u003e: string,\n  \u003cspan class=\"hljs-attr\"\u003ebasePath\u003c/span\u003e: string,\n) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: paths, requestMethod, targetCallback, methodName } = pathProperties;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { instance } = instanceWrapper;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e routerMethod = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.routerMethodFactory\n    .get(router, requestMethod)\n    .bind(router);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e stripSlash = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003estr: string\u003c/span\u003e) =\u0026gt;\u003c/span\u003e\n    str[str.length - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] === \u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e ? str.slice(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, str.length - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) : str;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isRequestScoped = !instanceWrapper.isDependencyTreeStatic();\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e proxy = isRequestScoped\n    ? \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createRequestScopedHandler(instanceWrapper, requestMethod, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.container.getModuleByKey(moduleKey),\n        moduleKey, methodName)\n    : \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createCallbackProxy(instance, targetCallback, methodName, moduleKey, requestMethod);\n\n  paths.forEach(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003epath\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fullPath = stripSlash(basePath) + path;\n    routerMethod(stripSlash(fullPath) || \u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e, proxy);\n  });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e第一个 \u003ccode\u003eresolve\u003c/code\u003e 方法简单的遍历，加上 \u003ccode\u003eregisterRouters\u003c/code\u003e 在对单个 \u003ccode\u003econtroller\u003c/code\u003e 遍历，可以获得所有的路由信息，而第二个 \u003ccode\u003eapplyCallbackToRouter\u003c/code\u003e 则是路由的重点，\u003ccode\u003erouterMethod\u003c/code\u003e 是 \u003ccode\u003eplatform-express\u003c/code\u003e 请求通用方法，比如：post/get 之类，可以通过它建立路由，相应的第一个参数 \u003ccode\u003estripSlash(fullPath) || '/'\u003c/code\u003e 是路由的访问路径，而第二个参数 \u003ccode\u003eproxy\u003c/code\u003e 则是路由处理回调。\u003ccode\u003eproxy\u003c/code\u003e 创建则涉及到非常多的内容：\u003c/p\u003e\n\u003cp\u003e整体的 \u003ccode\u003eproxy\u003c/code\u003e 会通过 \u003ccode\u003ecreate\u003c/code\u003e 创建新的路由实例，该实例会先获取信息 \u003ccode\u003egetMetadata\u003c/code\u003e。可以直接先看看该方法，再回到 \u003ccode\u003ecreate\u003c/code\u003e :\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic getMetadata(\n  instance: Controller,\u003cspan class=\"hljs-attr\"\u003ecallback\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e...args: any[]\u003c/span\u003e) =\u0026gt;\u003c/span\u003e any,\n  \u003cspan class=\"hljs-attr\"\u003emethodName\u003c/span\u003e: string, \u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: string, \u003cspan class=\"hljs-attr\"\u003erequestMethod\u003c/span\u003e: RequestMethod,\n): HandlerMetadata {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e cacheMetadata = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.handlerMetadataStorage.get(instance, methodName);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (cacheMetadata) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e cacheMetadata;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 路由传参信息\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e metadata =\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.contextUtils.reflectCallbackMetadata(instance, methodName, ROUTE_ARGS_METADATA) || {};\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e keys = \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.keys(metadata);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e argsLength = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.contextUtils.getArgumentsLength(keys, metadata);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e paramtypes = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.contextUtils.reflectCallbackParamtypes(instance, methodName);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e getParamsMetadata = (moduleKey: string, contextId = STATIC_CONTEXT, inquirerId?: string,\n  ) =\u0026gt; \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.exchangeKeysForValues(keys, metadata, moduleKey, contextId, inquirerId);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e paramsMetadata = getParamsMetadata(\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e);\n  \u003cspan class=\"hljs-comment\"\u003e// 路由信息里面，如果是 @Response 或者 @Next 则为 true\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isResponseHandled = paramsMetadata.some(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ type }\u003c/span\u003e) =\u0026gt;\u003c/span\u003e\n    type === RouteParamtypes.RESPONSE || type === RouteParamtypes.NEXT);\n  \u003cspan class=\"hljs-comment\"\u003e// 有无重定向修饰器 如@Redirect\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e httpRedirectResponse = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.reflectRedirect(callback);\n  \u003cspan class=\"hljs-comment\"\u003e// 有无渲染修饰器 如@Render('index')\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fnHandleResponse = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createHandleResponseFn(callback, isResponseHandled, httpRedirectResponse);\n  \u003cspan class=\"hljs-comment\"\u003e// post 响应默认状态码是 201，其他方式都是 200 ，可以通过 @HttpCode 来修改状态码\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e httpCode = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.reflectHttpStatusCode(callback);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e httpStatusCode = httpCode ? httpCode : \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.responseController.getStatusByMethod(requestMethod);\n  \u003cspan class=\"hljs-comment\"\u003e// 如@Header('Cache-Control', 'none') 修改响应头\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e responseHeaders = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.reflectResponseHeaders(callback);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hasCustomHeaders = !isEmpty(responseHeaders);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e handlerMetadata: HandlerMetadata = {\n    argsLength, fnHandleResponse, paramtypes, getParamsMetadata,\n    httpStatusCode, hasCustomHeaders, responseHeaders,\n  };\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.handlerMetadataStorage.set(instance, methodName, handlerMetadata);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e handlerMetadata;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于 \u003ccode\u003eController\u003c/code\u003e 其通常会采用一系列的修饰器，比如在其参数里面，添加 \u003ccode\u003e@Request() req\u003c/code\u003e。生成路由的时候也需要把这些信息提取出来，这些修饰器配置的元数据 key 是 \u003ccode\u003eROUTE_ARGS_METADATA\u003c/code\u003e，value 则是代码中的 \u003ccode\u003emetadata\u003c/code\u003e。\u003ccode\u003ereflectCallbackParamtypes\u003c/code\u003e 方法和前文提到的获取依赖方式一样，采用 \u003ccode\u003e'design:paramtypes'\u003c/code\u003e 获取 \u003ccode\u003econtroller\u003c/code\u003e 方法的形参。其他的基本上都是获取类或方法上修饰器的信息。还有个重要功能，是否响应需要模板渲染，比如渲染 html 页面，这个时候则可以用到 \u003ccode\u003e@Render('index')\u003c/code\u003e，可以看官方\u003ca href=\"https://docs.nestjs.com/techniques/mvc#template-rendering\" target=\"_blank\"\u003e文档\u003c/a\u003e，需要注意的是 html 文件需要保存在 views 目录。\u003c/p\u003e\n\u003cp\u003e再回到创建路由 \u003ccode\u003eproxy\u003c/code\u003e 的入口 \u003ccode\u003ecreate\u003c/code\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic create(\n  instance: Controller, \u003cspan class=\"hljs-attr\"\u003ecallback\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e...args: any[]\u003c/span\u003e) =\u0026gt;\u003c/span\u003e any, \u003cspan class=\"hljs-attr\"\u003emethodName\u003c/span\u003e: string,\n  \u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: string, \u003cspan class=\"hljs-attr\"\u003erequestMethod\u003c/span\u003e: RequestMethod, contextId = STATIC_CONTEXT, inquirerId?: string,\n) {\n  \u003cspan class=\"hljs-comment\"\u003e// 上面提到的获取contorller下路由对应方法的信息，如参数/请求头等等\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { argsLength, fnHandleResponse, paramtypes,\n    getParamsMetadata, httpStatusCode, responseHeaders, hasCustomHeaders,\n  } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.getMetadata(instance, callback, methodName, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, requestMethod);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e paramsOptions = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.contextUtils.mergeParamsMetatypes(\n    getParamsMetadata(\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, contextId, inquirerId), paramtypes);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e contextType: ContextType = \u003cspan class=\"hljs-string\"\u003e'http'\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// 提取模块中的 pipes/guards/interceptors\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pipes = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.pipesContextCreator.create(instance, callback, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, contextId, inquirerId);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e guards = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.guardsContextCreator.create(instance, callback, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, contextId, inquirerId);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e interceptors = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.interceptorsContextCreator.create(instance, callback, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, contextId, inquirerId);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fnCanActivate = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createGuardsFn(guards, instance, callback, contextType);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fnApplyPipes = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createPipesFn(pipes, paramsOptions);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e handler = \u0026lt;TRequest, TResponse\u0026gt;(args: any[], req: TRequest, res: TResponse,\n    next: Function) =\u0026gt; async () =\u0026gt; {\n    fnApplyPipes \u0026amp;\u0026amp; (await fnApplyPipes(args, req, res, next));\n    return callback.apply(instance, args);\n  };\n\n  return async \u0026lt;TRequest, TResponse\u0026gt;(req: TRequest, res: TResponse, next: Function) =\u0026gt; {\n    const args = this.contextUtils.createNullArray(argsLength);\n    fnCanActivate \u0026amp;\u0026amp; (await fnCanActivate([req, res, next]));\n\n    this.responseController.setStatus(res, httpStatusCode);\n    hasCustomHeaders \u0026amp;\u0026amp;\n      this.responseController.setHeaders(res, responseHeaders);\n\n    const result = await this.interceptorsConsumer.intercept(interceptors, [req, res, next],\n      instance, callback, handler(args, req, res, next), contextType);\n    await fnHandleResponse(result, res);\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面 \u003ccode\u003ecreate\u003c/code\u003e 返回则是路由响应的处理方式了。可以看到前面部分的 \u003ccode\u003epipes/guards/interceptors\u003c/code\u003e，是根据全局、\u003ccode\u003econtroller\u003c/code\u003e以及其下面的 \u003ccode\u003emethod\u003c/code\u003e 的修饰器获取对应的名称，再从模块的 \u003ccode\u003einjectables\u003c/code\u003e 获取对应的 \u003ccode\u003eInstanceWrapper\u003c/code\u003e，从而得到的数组。其后面还有对应的处理方法 \u003ccode\u003efnCanActivate\u003c/code\u003e 和 \u003ccode\u003efnApplyPipes\u003c/code\u003e，从代码上可以看到，路由响应里面先是执行 \u003ccode\u003efnCanActivate\u003c/code\u003e 也就是守卫，后面设置响应，然后是 \u003ccode\u003einterceptors\u003c/code\u003e，最后是 \u003ccode\u003efnApplyPipes\u003c/code\u003e，这里以 \u003ccode\u003efnCanActivate\u003c/code\u003e 为例子，看看其实现：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic createGuardsFn(guards: any[], \u003cspan class=\"hljs-attr\"\u003einstance\u003c/span\u003e: Controller, \u003cspan class=\"hljs-attr\"\u003ecallback\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e...args: any[]\u003c/span\u003e) =\u0026gt;\u003c/span\u003e any,\n  contextType?: TContext): \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eargs: any[]\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u0026gt; | \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e canActivateFn = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (args: any[]) =\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e canActivate = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.guardsConsumer.tryActivate\u0026lt;TContext\u0026gt;(\n      guards, args, instance, callback, contextType,\n    );\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!canActivate) {\n      \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e ForbiddenException(FORBIDDEN_MESSAGE);\n    }\n  };\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e guards.length ? canActivateFn : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n}\npublic \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e tryActivate(\n  guards: CanActivate[], \u003cspan class=\"hljs-attr\"\u003eargs\u003c/span\u003e: any[], \u003cspan class=\"hljs-attr\"\u003einstance\u003c/span\u003e: Controller,\n  \u003cspan class=\"hljs-attr\"\u003ecallback\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e...args: any[]\u003c/span\u003e) =\u0026gt;\u003c/span\u003e any, type?: TContext,\n) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!guards || isEmpty(guards)) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e context = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createContext(args, instance, callback);\n  context.setType\u0026lt;TContext\u0026gt;(type);\n\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e guard \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e guards) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = guard.canActivate(context);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.pickResult(result)) {\n      \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面可以看到，\u003ccode\u003eguard\u003c/code\u003e 是通过调用 \u003ccode\u003ecanActivate\u003c/code\u003e 来实现，如果没有实现该方法，则会抛出报错 \u003ccode\u003enew ForbiddenException(FORBIDDEN_MESSAGE)\u003c/code\u003e，后面的代码也就不执行了。最后路由代理具体业务的执行，则是在 \u003ccode\u003ecreate\u003c/code\u003e 提到的 \u003ccode\u003ehandler\u003c/code\u003e 里面执行。\u003c/p\u003e\n\u003cp\u003e这里回过头看一下，前面代码可以发现 \u003ccode\u003egetMetadata\u003c/code\u003e 里面生成的 \u003ccode\u003egetParamsMetadata\u003c/code\u003e，会用在 \u003ccode\u003ecreate\u003c/code\u003e 的 \u003ccode\u003ecreatePipesFn\u003c/code\u003e 方法里面用到：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic createPipesFn(\n  pipes: PipeTransform[],\n  \u003cspan class=\"hljs-attr\"\u003eparamsOptions\u003c/span\u003e: (ParamProperties \u0026amp; { metatype?: any })[],\n) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pipesFn = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u0026lt;TRequest, TResponse\u0026gt;(args: any[], \u003cspan class=\"hljs-attr\"\u003ereq\u003c/span\u003e: TRequest,\n    \u003cspan class=\"hljs-attr\"\u003eres\u003c/span\u003e: TResponse, \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eFunction\u003c/span\u003e,\n  ) =\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e resolveParamValue = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (\n      param: ParamProperties \u0026amp; { metatype?: any },\n    ) =\u0026gt; {\n      \u003cspan class=\"hljs-comment\"\u003e// index 为参数序号，表示第几个参数\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e// type 为修饰器类型，如 @Request\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { index, extractValue, type, data, metatype, \u003cspan class=\"hljs-attr\"\u003epipes\u003c/span\u003e: paramPipes } = param;\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e value = extractValue(req, res, next);\n\n      args[index] = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isPipeable(type)\n        ? \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.getParamValue(\n            value,\n            { metatype, type, data } \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e any,\n            pipes.concat(paramPipes),\n          )\n        : value;\n    };\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.all(paramsOptions.map(resolveParamValue));\n  };\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e paramsOptions.length ? pipesFn : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以发现 \u003ccode\u003ecreatePipesFn\u003c/code\u003e 方法里面只是返回一个 \u003ccode\u003epipesFn\u003c/code\u003e，\u003cstrong\u003e这个 \u003ccode\u003epipesFn\u003c/code\u003e 作用在于生成参数 \u003ccode\u003eargs\u003c/code\u003e，而这个 \u003ccode\u003eargs\u003c/code\u003e 是从路由处理代理里面传过来，\u003ccode\u003econst args = this.contextUtils.createNullArray(argsLength)\u003c/code\u003e 是个空数组!\u003c/strong\u003e，由于引用对象的特性，该空数组将会在 \u003ccode\u003ecreatePipesFn\u003c/code\u003e 实现参数回填，最后再 \u003ccode\u003ecallback\u003c/code\u003e 也就是对应路由执行 method 里面传递 \u003ccode\u003eargs\u003c/code\u003e 作为参数进去。\u003c/p\u003e\n\u003cp\u003e打比方如 \u003ccode\u003easync login(@Request() req) {}\u003c/code\u003e 参数 \u003ccode\u003ereq\u003c/code\u003e 会在 \u003ccode\u003ecreatePipesFn\u003c/code\u003e 里面根据修饰器类型返回 \u003ccode\u003ereq\u003c/code\u003e 对象，并被赋值到 \u003ccode\u003eargs\u003c/code\u003e 数组的第一个元素里面，最后这个 \u003ccode\u003eargs\u003c/code\u003e 则会成为 \u003ccode\u003elogin\u003c/code\u003e 方法的传参。从而通过 \u003ccode\u003epipe\u003c/code\u003e 的方式实现参数的传递。\u003c/p\u003e\n\u003cp\u003e当然 \u003ccode\u003epipe\u003c/code\u003e 的作用不止如此，具体的大家可以探索一下；\u003c/p\u003e\n\u003ch2\u003e应用初始化之其他\u003c/h2\u003e\n\u003cp\u003e上面介绍了路由如何通过 \u003ccode\u003eplatform-express\u003c/code\u003e 生成，还有一点其他的内容，回到 \u003ccode\u003einit\u003c/code\u003e 方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.callInitHook();\n\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.registerRouterHooks();\n\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.callBootstrapHook();\n\n\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isInitialized = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.logger.log(MESSAGES.APPLICATION_READY);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面分别调用的是 nest 自定义的生命周期钩子，\u003ccode\u003eonModuleInit/onApplicationBootstrap\u003c/code\u003e 这两个钩子，而 \u003ccode\u003eregisterRouterHooks\u003c/code\u003e 则是给路由添加无路由处理和异常处理；\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e开始用 nest 写业务的时候，还是懵懵懂懂的，一知半解，好奇这些修饰器是如何用的，为什么 \u003ccode\u003e@Request\u003c/code\u003e 可以这么用，和使用多年的 Vue/React 甚至 egg 风格截然不同，看了源码之后有种豁然开朗的感觉，而且 typescript 阅读源码很方便，让生锈的脑袋不怎么费力的就读下来了，只是中间的跳转实在有点啰嗦，可能这就是面向对象的特点吧。\u003c/p\u003e\n\u003cp\u003e关于 nest 还有不少地方没有介绍到，这里主要介绍的是初始化过程，包括容器初始化和应用初始化。\u003cstrong\u003e容器的初始化是获取所有的依赖项，形成一个 IOC 容器，并实例化依赖，也包含 \u003ccode\u003econtroller\u003c/code\u003e。应用初始化则是中间件、微服务模块、websoket 模块的注册和路由的生成，而这些的前提也是 IOC 容器。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e希望 2020，疫情好转，国运昌盛；\u003c/p\u003e\n"}},"buildId":"r4Ww0YLm8YL5~6SwciWHH","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" async=""></script></body></html>