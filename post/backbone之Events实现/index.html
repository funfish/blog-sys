<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">backbone之Events实现</title><link rel="preload" href="/blog-sys/_next/static/ZS9D2ZWqQsj~9BxQGiyVr/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/ZS9D2ZWqQsj~9BxQGiyVr/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/ZS9D2ZWqQsj~9BxQGiyVr/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.491f56ba.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___3Hk0c "><a class="logo___1KD30" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___1qXLb" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___3VKNp"><h1 class="postTitle___26vXM">backbone之Events实现</h1><span class="postTime___16Ish">July 7, 2018</span></header><article class="postWrapper___3NXol post-article"><div><h1>前言</h1>
<p>记得某次在大神的博客里面讲技术选型，提到团队对Backbone的框架很熟悉，在一次开发的时候选用Backbone源码的一部分，再搭配其他的使用。虽然Backbone现在已经不流行了，但从几年前我就开始听说它的存在了，一直觉得这么神奇的框架肯定很有必要学习，看到大神提到选取Backbone源码的一部分，顿时觉得大神就是大神，对源码运用与此精通。最近有空看Backbone源码，细读时，如啃老牛肉，又硬又难吃，常常看了一部分忘记另外一部分，疼苦不堪，后来结合Backbone的<a href="http://www.css88.com/doc/backbone/" target="_blank">api文档</a>和里面的Todos例子顿时觉得，神清气爽，仿佛任督二脉都打通了，只是看过之后愈发觉得，Backbone框架已经不是前端的弄潮儿，只是接近2000+的源码，里面的MVC思想，值得去研究，而不是天天研究如何运用新框架的api</p>
<h1>目的</h1>
<p>刚开始读Backbone就被开头的Events弄得云里雾里的，应该很多人有这样的经历，于是想介绍Events的实现思路以及其中的疑难；</p>
<h1>思路</h1>
<pre class="hljs"><code><span class="hljs-keyword">var</span> object = {};
_.extend(object, Backbone.Events);
object.on(<span class="hljs-string">'expand'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ alert(<span class="hljs-string">'expanded'</span>); });
object.trigger(<span class="hljs-string">'expand'</span>);
</code></pre>
<p>这是源码在介绍Events用到的例子，Events模块可以被扩展到任意的对象上面，而在其他的Bakbone模块如Model/Collection/View等，同样在其内部扩展了Events模块；
事件模块，无非就是实现注册动作，监听动作，对应的在Events里面主要是on，listenTo，off， stopListening和trigger这几个；
刚开始看的时候比较晕，后来一想从注册事件，到触发事件，看不懂究竟在做什么，那可不可以从后往前看，先看如何触发事件，在看如何注册事件，这么一想就事半功倍了。</p>
<p>从trigger函数开始，落着点在triggerEvents函数，而在传递的events，一层层回溯，正是this._events，于是triggerEvents主体表达式就是</p>
<pre class="hljs"><code><span class="hljs-keyword">this</span>._events[name].callback.call(<span class="hljs-keyword">this</span>._events[name].ctx)
</code></pre>
<p>这就完事了，也就是说on事件负责把事件对应的回调函数/上下文注册到this._events里面，然后需要trigger的时候，直接call就好，如此的简单明了。再看on事件的时候发现却实是如此；
on事件通过onApi将事件需要的回调和上下文写入this.__events[name]里面；形成事件名字和回调映射的关系；这一切都是如此的顺畅，直到回头看on事件，发现写入this._events[name]的混杂着listening: _this.listening。</p>
<h2>奇形怪状的各种listening _listening listeningTo _listeners</h2>
<p>在on下面还有：</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (_listening) {
  <span class="hljs-keyword">var</span> listeners = <span class="hljs-keyword">this</span>._listeners || (<span class="hljs-keyword">this</span>._listeners = {});
  listeners[_listening.id] = _listening;
  _listening.interop = <span class="hljs-literal">false</span>;
}
</code></pre>
<p>更不要提listenTo函数，一开始看直接懵逼了，但是主要流程都懂了还怕这些listenXX干嘛？
于是整理了一下和listenXX有关的所有地方，发现有如下关系：</p>
<pre class="hljs"><code><span class="hljs-keyword">this</span>._listeners[_listening.id] = _listening
_listening = <span class="hljs-keyword">this</span>._listeningTo[id] = <span class="hljs-keyword">new</span> Listening(<span class="hljs-keyword">this</span>, obj)
</code></pre>
<p>理清关系后发现都是纸老虎，就是在this._listeners里面添加个id和new Listening(this, obj)键值嘛，每当有个新的对象要监听的时候，就在this._listener里面添加构造函数Listening(this, obj)，而 _listeners则是个全局变量，用来传递这个构造函数。那细心的观众不难发现，this._listeningTo又是用来干嘛的？this._listeningTo不是和this._listener一摸一样的吗？
开始我也是很疑惑，明明就是两个一样的对象，到后台打印也是一摸一样的呀？那为何作者要写两个呢？直到有一天，看着this._listeningTo和this._listener发呆的时候，发现，咦？前者有个To，后面没有呀，listeningTo不就意味着某个对象监听另外一个对象，而listener更像是监听者监听某个动作，再看看源码，哦，this._listeningTo出现在listenTo事件里面，而this._listener出现在On事件里面，So两个是完全不一样的呀。。。只有在纯粹的listenTo里面才会一样，如果单独监听某个动作，那创建的构造函数Listening不会出现在this._listeningTo里面。。。。。。尽然如此简单。。。。。。</p>
<h2>interop库互相操作理解</h2>
<p>前面提到的on和listenTo，接下来可以看stopListening和off函数，本质上和之前提到的on和listenTo很相似，但是这里面反复提到listening.interop到底是什么东西呢？如果是真的话，则会执行listening.off/on函数，咦？前面不是已经执行了obj.off/on了吗？这又是有何作用，带着疑问翻看了backbone的issue，发现下面这条<a href="https://github.com/jashkenas/backbone/issues/3611" target="_blank">issue</a>原来是当obj本身有on/off函数，而obj又不扩展Events，则会进入listening构造函数中保存的off/on事件。
另外值得一提的是在on事件里面，若<code>listening.interop=true</code>，在进行listening.on之前，已经将全局变量_listening设置为void 0，后面再进行on函数的时候，其option中保存的listening将不是Listening实例而是undefined，所以在off事件中进行listening.off事件，若<code>this.interop=true</code>则会再次进入off事件，而在offApi中，listening.off之前会判断之前存放在this._events[name]中对应的option是否保存Listening实例，而前文提到这个时候listening为undefined，故不会重复循环进入listening.off里面；</p>
<p>还剩下once相关的事件，看过underscore源码的你，或者是没有看过的你，肯定可以理解，这里就不解释了
由于水平有限，若有水平有限，有错误的地方还请提出来</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"July 7, 2018","title":"backbone之Events实现","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e记得某次在大神的博客里面讲技术选型，提到团队对Backbone的框架很熟悉，在一次开发的时候选用Backbone源码的一部分，再搭配其他的使用。虽然Backbone现在已经不流行了，但从几年前我就开始听说它的存在了，一直觉得这么神奇的框架肯定很有必要学习，看到大神提到选取Backbone源码的一部分，顿时觉得大神就是大神，对源码运用与此精通。最近有空看Backbone源码，细读时，如啃老牛肉，又硬又难吃，常常看了一部分忘记另外一部分，疼苦不堪，后来结合Backbone的\u003ca href=\"http://www.css88.com/doc/backbone/\" target=\"_blank\"\u003eapi文档\u003c/a\u003e和里面的Todos例子顿时觉得，神清气爽，仿佛任督二脉都打通了，只是看过之后愈发觉得，Backbone框架已经不是前端的弄潮儿，只是接近2000+的源码，里面的MVC思想，值得去研究，而不是天天研究如何运用新框架的api\u003c/p\u003e\n\u003ch1\u003e目的\u003c/h1\u003e\n\u003cp\u003e刚开始读Backbone就被开头的Events弄得云里雾里的，应该很多人有这样的经历，于是想介绍Events的实现思路以及其中的疑难；\u003c/p\u003e\n\u003ch1\u003e思路\u003c/h1\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e object = {};\n_.extend(object, Backbone.Events);\nobject.on(\u003cspan class=\"hljs-string\"\u003e'expand'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e)\u003c/span\u003e{ alert(\u003cspan class=\"hljs-string\"\u003e'expanded'\u003c/span\u003e); });\nobject.trigger(\u003cspan class=\"hljs-string\"\u003e'expand'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这是源码在介绍Events用到的例子，Events模块可以被扩展到任意的对象上面，而在其他的Bakbone模块如Model/Collection/View等，同样在其内部扩展了Events模块；\n事件模块，无非就是实现注册动作，监听动作，对应的在Events里面主要是on，listenTo，off， stopListening和trigger这几个；\n刚开始看的时候比较晕，后来一想从注册事件，到触发事件，看不懂究竟在做什么，那可不可以从后往前看，先看如何触发事件，在看如何注册事件，这么一想就事半功倍了。\u003c/p\u003e\n\u003cp\u003e从trigger函数开始，落着点在triggerEvents函数，而在传递的events，一层层回溯，正是this._events，于是triggerEvents主体表达式就是\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._events[name].callback.call(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._events[name].ctx)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这就完事了，也就是说on事件负责把事件对应的回调函数/上下文注册到this._events里面，然后需要trigger的时候，直接call就好，如此的简单明了。再看on事件的时候发现却实是如此；\non事件通过onApi将事件需要的回调和上下文写入this.__events[name]里面；形成事件名字和回调映射的关系；这一切都是如此的顺畅，直到回头看on事件，发现写入this._events[name]的混杂着listening: _this.listening。\u003c/p\u003e\n\u003ch2\u003e奇形怪状的各种listening _listening listeningTo _listeners\u003c/h2\u003e\n\u003cp\u003e在on下面还有：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (_listening) {\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e listeners = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._listeners || (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._listeners = {});\n  listeners[_listening.id] = _listening;\n  _listening.interop = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e更不要提listenTo函数，一开始看直接懵逼了，但是主要流程都懂了还怕这些listenXX干嘛？\n于是整理了一下和listenXX有关的所有地方，发现有如下关系：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._listeners[_listening.id] = _listening\n_listening = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._listeningTo[id] = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Listening(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, obj)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e理清关系后发现都是纸老虎，就是在this._listeners里面添加个id和new Listening(this, obj)键值嘛，每当有个新的对象要监听的时候，就在this._listener里面添加构造函数Listening(this, obj)，而 _listeners则是个全局变量，用来传递这个构造函数。那细心的观众不难发现，this._listeningTo又是用来干嘛的？this._listeningTo不是和this._listener一摸一样的吗？\n开始我也是很疑惑，明明就是两个一样的对象，到后台打印也是一摸一样的呀？那为何作者要写两个呢？直到有一天，看着this._listeningTo和this._listener发呆的时候，发现，咦？前者有个To，后面没有呀，listeningTo不就意味着某个对象监听另外一个对象，而listener更像是监听者监听某个动作，再看看源码，哦，this._listeningTo出现在listenTo事件里面，而this._listener出现在On事件里面，So两个是完全不一样的呀。。。只有在纯粹的listenTo里面才会一样，如果单独监听某个动作，那创建的构造函数Listening不会出现在this._listeningTo里面。。。。。。尽然如此简单。。。。。。\u003c/p\u003e\n\u003ch2\u003einterop库互相操作理解\u003c/h2\u003e\n\u003cp\u003e前面提到的on和listenTo，接下来可以看stopListening和off函数，本质上和之前提到的on和listenTo很相似，但是这里面反复提到listening.interop到底是什么东西呢？如果是真的话，则会执行listening.off/on函数，咦？前面不是已经执行了obj.off/on了吗？这又是有何作用，带着疑问翻看了backbone的issue，发现下面这条\u003ca href=\"https://github.com/jashkenas/backbone/issues/3611\" target=\"_blank\"\u003eissue\u003c/a\u003e原来是当obj本身有on/off函数，而obj又不扩展Events，则会进入listening构造函数中保存的off/on事件。\n另外值得一提的是在on事件里面，若\u003ccode\u003elistening.interop=true\u003c/code\u003e，在进行listening.on之前，已经将全局变量_listening设置为void 0，后面再进行on函数的时候，其option中保存的listening将不是Listening实例而是undefined，所以在off事件中进行listening.off事件，若\u003ccode\u003ethis.interop=true\u003c/code\u003e则会再次进入off事件，而在offApi中，listening.off之前会判断之前存放在this._events[name]中对应的option是否保存Listening实例，而前文提到这个时候listening为undefined，故不会重复循环进入listening.off里面；\u003c/p\u003e\n\u003cp\u003e还剩下once相关的事件，看过underscore源码的你，或者是没有看过的你，肯定可以理解，这里就不解释了\n由于水平有限，若有水平有限，有错误的地方还请提出来\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"July 7, 2018","title":"backbone之Events实现","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e记得某次在大神的博客里面讲技术选型，提到团队对Backbone的框架很熟悉，在一次开发的时候选用Backbone源码的一部分，再搭配其他的使用。虽然Backbone现在已经不流行了，但从几年前我就开始听说它的存在了，一直觉得这么神奇的框架肯定很有必要学习，看到大神提到选取Backbone源码的一部分，顿时觉得大神就是大神，对源码运用与此精通。最近有空看Backbone源码，细读时，如啃老牛肉，又硬又难吃，常常看了一部分忘记另外一部分，疼苦不堪，后来结合Backbone的\u003ca href=\"http://www.css88.com/doc/backbone/\" target=\"_blank\"\u003eapi文档\u003c/a\u003e和里面的Todos例子顿时觉得，神清气爽，仿佛任督二脉都打通了，只是看过之后愈发觉得，Backbone框架已经不是前端的弄潮儿，只是接近2000+的源码，里面的MVC思想，值得去研究，而不是天天研究如何运用新框架的api\u003c/p\u003e\n\u003ch1\u003e目的\u003c/h1\u003e\n\u003cp\u003e刚开始读Backbone就被开头的Events弄得云里雾里的，应该很多人有这样的经历，于是想介绍Events的实现思路以及其中的疑难；\u003c/p\u003e\n\u003ch1\u003e思路\u003c/h1\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e object = {};\n_.extend(object, Backbone.Events);\nobject.on(\u003cspan class=\"hljs-string\"\u003e'expand'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e)\u003c/span\u003e{ alert(\u003cspan class=\"hljs-string\"\u003e'expanded'\u003c/span\u003e); });\nobject.trigger(\u003cspan class=\"hljs-string\"\u003e'expand'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这是源码在介绍Events用到的例子，Events模块可以被扩展到任意的对象上面，而在其他的Bakbone模块如Model/Collection/View等，同样在其内部扩展了Events模块；\n事件模块，无非就是实现注册动作，监听动作，对应的在Events里面主要是on，listenTo，off， stopListening和trigger这几个；\n刚开始看的时候比较晕，后来一想从注册事件，到触发事件，看不懂究竟在做什么，那可不可以从后往前看，先看如何触发事件，在看如何注册事件，这么一想就事半功倍了。\u003c/p\u003e\n\u003cp\u003e从trigger函数开始，落着点在triggerEvents函数，而在传递的events，一层层回溯，正是this._events，于是triggerEvents主体表达式就是\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._events[name].callback.call(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._events[name].ctx)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这就完事了，也就是说on事件负责把事件对应的回调函数/上下文注册到this._events里面，然后需要trigger的时候，直接call就好，如此的简单明了。再看on事件的时候发现却实是如此；\non事件通过onApi将事件需要的回调和上下文写入this.__events[name]里面；形成事件名字和回调映射的关系；这一切都是如此的顺畅，直到回头看on事件，发现写入this._events[name]的混杂着listening: _this.listening。\u003c/p\u003e\n\u003ch2\u003e奇形怪状的各种listening _listening listeningTo _listeners\u003c/h2\u003e\n\u003cp\u003e在on下面还有：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (_listening) {\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e listeners = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._listeners || (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._listeners = {});\n  listeners[_listening.id] = _listening;\n  _listening.interop = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e更不要提listenTo函数，一开始看直接懵逼了，但是主要流程都懂了还怕这些listenXX干嘛？\n于是整理了一下和listenXX有关的所有地方，发现有如下关系：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._listeners[_listening.id] = _listening\n_listening = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._listeningTo[id] = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Listening(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, obj)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e理清关系后发现都是纸老虎，就是在this._listeners里面添加个id和new Listening(this, obj)键值嘛，每当有个新的对象要监听的时候，就在this._listener里面添加构造函数Listening(this, obj)，而 _listeners则是个全局变量，用来传递这个构造函数。那细心的观众不难发现，this._listeningTo又是用来干嘛的？this._listeningTo不是和this._listener一摸一样的吗？\n开始我也是很疑惑，明明就是两个一样的对象，到后台打印也是一摸一样的呀？那为何作者要写两个呢？直到有一天，看着this._listeningTo和this._listener发呆的时候，发现，咦？前者有个To，后面没有呀，listeningTo不就意味着某个对象监听另外一个对象，而listener更像是监听者监听某个动作，再看看源码，哦，this._listeningTo出现在listenTo事件里面，而this._listener出现在On事件里面，So两个是完全不一样的呀。。。只有在纯粹的listenTo里面才会一样，如果单独监听某个动作，那创建的构造函数Listening不会出现在this._listeningTo里面。。。。。。尽然如此简单。。。。。。\u003c/p\u003e\n\u003ch2\u003einterop库互相操作理解\u003c/h2\u003e\n\u003cp\u003e前面提到的on和listenTo，接下来可以看stopListening和off函数，本质上和之前提到的on和listenTo很相似，但是这里面反复提到listening.interop到底是什么东西呢？如果是真的话，则会执行listening.off/on函数，咦？前面不是已经执行了obj.off/on了吗？这又是有何作用，带着疑问翻看了backbone的issue，发现下面这条\u003ca href=\"https://github.com/jashkenas/backbone/issues/3611\" target=\"_blank\"\u003eissue\u003c/a\u003e原来是当obj本身有on/off函数，而obj又不扩展Events，则会进入listening构造函数中保存的off/on事件。\n另外值得一提的是在on事件里面，若\u003ccode\u003elistening.interop=true\u003c/code\u003e，在进行listening.on之前，已经将全局变量_listening设置为void 0，后面再进行on函数的时候，其option中保存的listening将不是Listening实例而是undefined，所以在off事件中进行listening.off事件，若\u003ccode\u003ethis.interop=true\u003c/code\u003e则会再次进入off事件，而在offApi中，listening.off之前会判断之前存放在this._events[name]中对应的option是否保存Listening实例，而前文提到这个时候listening为undefined，故不会重复循环进入listening.off里面；\u003c/p\u003e\n\u003cp\u003e还剩下once相关的事件，看过underscore源码的你，或者是没有看过的你，肯定可以理解，这里就不解释了\n由于水平有限，若有水平有限，有错误的地方还请提出来\u003c/p\u003e\n"}},"buildId":"ZS9D2ZWqQsj~9BxQGiyVr","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/ZS9D2ZWqQsj~9BxQGiyVr/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/ZS9D2ZWqQsj~9BxQGiyVr/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/ZS9D2ZWqQsj~9BxQGiyVr/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" async=""></script></body></html>