<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">React Suspense data fetching 探究</title><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.587c5e31.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___2dTZ9 "><a class="logo___346dE" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___13XXt" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___29Pln"><h1 class="postTitle___1_m4g">React Suspense data fetching 探究</h1><span class="postTime___1x0_i">March 24, 2021</span></header><article class="postWrapper___3jnNg post-article"><div><p>最近 React 16.6 中提出了新组件 Suspense 允许 React 挂起组件渲染直到 IO 的数据返回。这个特性在 JSConf Iceland 中 <a href="https://www.youtube.com/watch?v=nLF0n9SACd4" target="_blank">Beyond React 16</a> 里面 Dan 就介绍到了，并在半年后的今天登陆 React 16.6。</p>
<h3>Suspense 简单用法</h3>
<p>在官网教程里面介绍到 Suspense 与 React.lazy 结合做 <a href="https://reactjs.org/docs/code-splitting.html#reactlazy" target="_blank">Code-Spliting</a> ，自然是可以这么用的，只是这更多的是代码分割，除了代码分割以外 IO 的处理，在 Beyond React 16 演讲中还提到了 <strong>data fetching</strong>，Dan 的第二个 demo 主要提到的也是 data fetching。下面先看看 Suspense 的一个简单的非代码分割的 demo：</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> Img = lazy(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> delay(<span class="hljs-number">2000</span>);
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">default</span>: ImageResource
  }
})

<span class="hljs-keyword">const</span> ImageResource = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> {<span class="hljs-attr">...props</span>} /&gt;</span></span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"App"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>}&gt;
          <span class="hljs-tag">&lt;<span class="hljs-name">Img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://www.baidu.com/img/bd_logo1.png?where=super"</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}
</code></pre>
<p>在官网教程提到 React.lazy 要动态的调用 import 方式注入组件，返回一个 Promise。 同时 Promise 返回一个 default 的组件。所以就可以采用上面的方式，而不必用 import 方式，只是如此还是类似于代码分割，没有达到数据获取返回之前挂起组件的思路。</p>
<h3>Dan 的例子</h3>
<p>在 Dan 的演讲里面多处地方有用到 Suspense 的意识，也就是 createFetcher 与 this.deferSetState 方法。deferSetState 通过异步修改组件显示与否，当 createFetcher 传参 Promise 状态结束后才执行异步 deferSetState，显示已经接收到数据的组件。这就是挂起 Suspense 的作用了。在 React 16.6 里面没有提供 deferSetState，可能也是更多的异步操作留到 17.0 大版本上。而 Suspense 组件，已经可以实现 children 的挂起行为了。<strong>所以可以猜测，Suspense 组件作用就是 this.deferSetState</strong> 。</p>
<p>Dan 的 demo 里面，采用的 createFetcher 方法，类似于 <a href="https://www.npmjs.com/package/simple-cache-provider" target="_blank">simple-cache-provider 包</a> ，提供数据缓存控制。由于 Dan 的 demo 里的获取数据函数 Promise 没有写明具体的实现方式，不知道里面有没有什么巧门，还好在 demo 最后里有提到图片更新的 Promise，具体代码如下：</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> imageFecther = createFether(
  <span class="hljs-function">(<span class="hljs-params">src</span>) =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> Image();
    image.onload = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(src);
    image.src = src;
  })
)

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Img</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> 
      {<span class="hljs-attr">...props</span>}
      <span class="hljs-attr">src</span>=<span class="hljs-string">{imageFecher.read(props.src)}</span>
    &gt;</span>
  )
}
</span></code></pre>
<p>这整个组件 Img 还是很简单的，若是平时的直接将 Promise 返回值到 img 标签的 src 将得到的是 <code>[Object Promise]</code>，而不是 url。只是为何凭借一个 resolve，Suspense 组件就知道可以有数据进来，可以解除挂起状态，并让 src 得到想要的 url 嗯？</p>
<p>由于 simple-cache-provider 包已经不再更新而且在 react 项目里面找不到了，所以单独下载 simple-cache-provider 包。这个缓存控制包，代码在300+，主要 api 有 createCache、createResource 和 SimpleCache。上面 demo 中的代码采用 simple-cache-provider 包实现，就要用到 createCache 来创建缓存，createResource 来获取资源。简化一下 simple-cache-provider 包，替换 createCache 以及 createResource，其具体实现如下：</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> cacheResourceSimple = {};

<span class="hljs-keyword">const</span> createResourceSimple = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">miss</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">resource, key</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (!resource[key]) {
      resource[key] = {
        key,
        <span class="hljs-attr">value</span>: <span class="hljs-literal">false</span>,
      }
      <span class="hljs-keyword">const</span> _suspender = miss(key);
      _suspender.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
        resource[key].value = value;
      });
      <span class="hljs-keyword">throw</span> _suspender;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> resource[key].value；
    }
  }
}

<span class="hljs-keyword">const</span> imgFetcher = createResourceSimple(
  <span class="hljs-function"><span class="hljs-params">src</span> =&gt;</span>
    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> Image();
      img.onload = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(src);
      img.src = src;
    })
)

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Img</span> (<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> 
      {<span class="hljs-attr">...props</span>}
      <span class="hljs-attr">src</span>=<span class="hljs-string">{imgFetcher(cacheResourceSimple,</span> <span class="hljs-attr">props.src</span>)} 
    /&gt;</span></span>
  )
}
</code></pre>
<p>图片组件的挂起表现正常，基本上就实现 Dan 的挂起图片的功能了。</p>
<p>只是上面的代码为什么可以实现图片组件的挂起呢？明明 imgFetcher 函数返回的也是一个 Promise，最后 src 将得到的还是 <code>[Object Promise]</code> 呀。抱着这样的疑惑，打断点试了试，发现上面代码神奇之处在于 <code>throw _suspender</code>。在 simple-cache-provider 包里面的就是这样实现的，执行 _suspender 之后抛出错误。</p>
<p>在这里就要回到 react 源码了，当 <code>throw _suspender</code> 的时候，会被 renderRoot 方法捕获 catch ，进入 throwException 抛错函数来处理，而 throwException 里面
会判断 fiber 是否是 <code>Symbol(react.suspense)</code> 类型，并且挂起的组件非空，则会执行下面。</p>
<pre class="hljs"><code>thenable.then(onResolveOrReject, onResolveOrReject);
<span class="hljs-keyword">var</span> nextChildren = <span class="hljs-literal">null</span>;
</code></pre>
<p>简单的就是挂了个 then。<strong>当图片 resolve 之后，会执行 <code>_suspender.then</code>，接下来又会执行 thenable.then</strong> ，从而使得该组件在有数据返回的时候立刻异步渲染。后面的 nextChildren 置空，则是使得组件在数据没有返回前的渲染好像只是渲染 null 一样。具体 react 实现是复杂的，一环接一环的，这里就不做具体分析了。但是 <strong>抛出 createResourceSimple 的传参 Promise 给到 react 捕获到</strong> ，才有了 suspense data fetching 的行为。</p>
<h2>总结</h2>
<p>实现 Suspense 组件的另外一个更大的作用 suspense data fetching 的方法，只需要将 IO 接口请求的异步函数当作错误抛出，就可以了。官网里面没有介绍到这个方式，可能也是考虑到功能还不完善？丑媳妇迟早要见公婆的。</p>
<h2>参考</h2>
<ol>
<li><a href="https://www.youtube.com/watch?v=nLF0n9SACd4" target="_blank">Beyond React 16</a> Dan 的这个视频，看到前面的 CPU time slicing 就兴奋不已了，倒是忘记后面新功能。</li>
</ol>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"March 24, 2021","title":"React Suspense data fetching 探究","content":"\u003cp\u003e最近 React 16.6 中提出了新组件 Suspense 允许 React 挂起组件渲染直到 IO 的数据返回。这个特性在 JSConf Iceland 中 \u003ca href=\"https://www.youtube.com/watch?v=nLF0n9SACd4\" target=\"_blank\"\u003eBeyond React 16\u003c/a\u003e 里面 Dan 就介绍到了，并在半年后的今天登陆 React 16.6。\u003c/p\u003e\n\u003ch3\u003eSuspense 简单用法\u003c/h3\u003e\n\u003cp\u003e在官网教程里面介绍到 Suspense 与 React.lazy 结合做 \u003ca href=\"https://reactjs.org/docs/code-splitting.html#reactlazy\" target=\"_blank\"\u003eCode-Spliting\u003c/a\u003e ，自然是可以这么用的，只是这更多的是代码分割，除了代码分割以外 IO 的处理，在 Beyond React 16 演讲中还提到了 \u003cstrong\u003edata fetching\u003c/strong\u003e，Dan 的第二个 demo 主要提到的也是 data fetching。下面先看看 Suspense 的一个简单的非代码分割的 demo：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Img = lazy(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e delay(\u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003edefault\u003c/span\u003e: ImageResource\n  }\n})\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ImageResource = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eprops\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e {\u003cspan class=\"hljs-attr\"\u003e...props\u003c/span\u003e} /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\n\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eComponent\u003c/span\u003e \u003c/span\u003e{\n  render() {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n      \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"App\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eSuspense\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efallback\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-attr\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003eLoading...\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e}\u0026gt;\n          \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eImg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"https://www.baidu.com/img/bd_logo1.png?where=super\"\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eSuspense\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在官网教程提到 React.lazy 要动态的调用 import 方式注入组件，返回一个 Promise。 同时 Promise 返回一个 default 的组件。所以就可以采用上面的方式，而不必用 import 方式，只是如此还是类似于代码分割，没有达到数据获取返回之前挂起组件的思路。\u003c/p\u003e\n\u003ch3\u003eDan 的例子\u003c/h3\u003e\n\u003cp\u003e在 Dan 的演讲里面多处地方有用到 Suspense 的意识，也就是 createFetcher 与 this.deferSetState 方法。deferSetState 通过异步修改组件显示与否，当 createFetcher 传参 Promise 状态结束后才执行异步 deferSetState，显示已经接收到数据的组件。这就是挂起 Suspense 的作用了。在 React 16.6 里面没有提供 deferSetState，可能也是更多的异步操作留到 17.0 大版本上。而 Suspense 组件，已经可以实现 children 的挂起行为了。\u003cstrong\u003e所以可以猜测，Suspense 组件作用就是 this.deferSetState\u003c/strong\u003e 。\u003c/p\u003e\n\u003cp\u003eDan 的 demo 里面，采用的 createFetcher 方法，类似于 \u003ca href=\"https://www.npmjs.com/package/simple-cache-provider\" target=\"_blank\"\u003esimple-cache-provider 包\u003c/a\u003e ，提供数据缓存控制。由于 Dan 的 demo 里的获取数据函数 Promise 没有写明具体的实现方式，不知道里面有没有什么巧门，还好在 demo 最后里有提到图片更新的 Promise，具体代码如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e imageFecther = createFether(\n  \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003esrc\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresolve\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e image = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Image();\n    image.onload = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e resolve(src);\n    image.src = src;\n  })\n)\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eImg\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprops\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \n      {\u003cspan class=\"hljs-attr\"\u003e...props\u003c/span\u003e}\n      \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{imageFecher.read(props.src)}\u003c/span\u003e\n    \u0026gt;\u003c/span\u003e\n  )\n}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这整个组件 Img 还是很简单的，若是平时的直接将 Promise 返回值到 img 标签的 src 将得到的是 \u003ccode\u003e[Object Promise]\u003c/code\u003e，而不是 url。只是为何凭借一个 resolve，Suspense 组件就知道可以有数据进来，可以解除挂起状态，并让 src 得到想要的 url 嗯？\u003c/p\u003e\n\u003cp\u003e由于 simple-cache-provider 包已经不再更新而且在 react 项目里面找不到了，所以单独下载 simple-cache-provider 包。这个缓存控制包，代码在300+，主要 api 有 createCache、createResource 和 SimpleCache。上面 demo 中的代码采用 simple-cache-provider 包实现，就要用到 createCache 来创建缓存，createResource 来获取资源。简化一下 simple-cache-provider 包，替换 createCache 以及 createResource，其具体实现如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e cacheResourceSimple = {};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e createResourceSimple = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003emiss\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresource, key\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!resource[key]) {\n      resource[key] = {\n        key,\n        \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n      }\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e _suspender = miss(key);\n      _suspender.then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n        resource[key].value = value;\n      });\n      \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e _suspender;\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e resource[key].value；\n    }\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e imgFetcher = createResourceSimple(\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003esrc\u003c/span\u003e =\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresolve\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e img = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Image();\n      img.onload = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e resolve(src);\n      img.src = src;\n    })\n)\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eImg\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eprops\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \n      {\u003cspan class=\"hljs-attr\"\u003e...props\u003c/span\u003e}\n      \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{imgFetcher(cacheResourceSimple,\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eprops.src\u003c/span\u003e)} \n    /\u0026gt;\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e图片组件的挂起表现正常，基本上就实现 Dan 的挂起图片的功能了。\u003c/p\u003e\n\u003cp\u003e只是上面的代码为什么可以实现图片组件的挂起呢？明明 imgFetcher 函数返回的也是一个 Promise，最后 src 将得到的还是 \u003ccode\u003e[Object Promise]\u003c/code\u003e 呀。抱着这样的疑惑，打断点试了试，发现上面代码神奇之处在于 \u003ccode\u003ethrow _suspender\u003c/code\u003e。在 simple-cache-provider 包里面的就是这样实现的，执行 _suspender 之后抛出错误。\u003c/p\u003e\n\u003cp\u003e在这里就要回到 react 源码了，当 \u003ccode\u003ethrow _suspender\u003c/code\u003e 的时候，会被 renderRoot 方法捕获 catch ，进入 throwException 抛错函数来处理，而 throwException 里面\n会判断 fiber 是否是 \u003ccode\u003eSymbol(react.suspense)\u003c/code\u003e 类型，并且挂起的组件非空，则会执行下面。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003ethenable.then(onResolveOrReject, onResolveOrReject);\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e nextChildren = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e简单的就是挂了个 then。\u003cstrong\u003e当图片 resolve 之后，会执行 \u003ccode\u003e_suspender.then\u003c/code\u003e，接下来又会执行 thenable.then\u003c/strong\u003e ，从而使得该组件在有数据返回的时候立刻异步渲染。后面的 nextChildren 置空，则是使得组件在数据没有返回前的渲染好像只是渲染 null 一样。具体 react 实现是复杂的，一环接一环的，这里就不做具体分析了。但是 \u003cstrong\u003e抛出 createResourceSimple 的传参 Promise 给到 react 捕获到\u003c/strong\u003e ，才有了 suspense data fetching 的行为。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e实现 Suspense 组件的另外一个更大的作用 suspense data fetching 的方法，只需要将 IO 接口请求的异步函数当作错误抛出，就可以了。官网里面没有介绍到这个方式，可能也是考虑到功能还不完善？丑媳妇迟早要见公婆的。\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=nLF0n9SACd4\" target=\"_blank\"\u003eBeyond React 16\u003c/a\u003e Dan 的这个视频，看到前面的 CPU time slicing 就兴奋不已了，倒是忘记后面新功能。\u003c/li\u003e\n\u003c/ol\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"March 24, 2021","title":"React Suspense data fetching 探究","content":"\u003cp\u003e最近 React 16.6 中提出了新组件 Suspense 允许 React 挂起组件渲染直到 IO 的数据返回。这个特性在 JSConf Iceland 中 \u003ca href=\"https://www.youtube.com/watch?v=nLF0n9SACd4\" target=\"_blank\"\u003eBeyond React 16\u003c/a\u003e 里面 Dan 就介绍到了，并在半年后的今天登陆 React 16.6。\u003c/p\u003e\n\u003ch3\u003eSuspense 简单用法\u003c/h3\u003e\n\u003cp\u003e在官网教程里面介绍到 Suspense 与 React.lazy 结合做 \u003ca href=\"https://reactjs.org/docs/code-splitting.html#reactlazy\" target=\"_blank\"\u003eCode-Spliting\u003c/a\u003e ，自然是可以这么用的，只是这更多的是代码分割，除了代码分割以外 IO 的处理，在 Beyond React 16 演讲中还提到了 \u003cstrong\u003edata fetching\u003c/strong\u003e，Dan 的第二个 demo 主要提到的也是 data fetching。下面先看看 Suspense 的一个简单的非代码分割的 demo：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Img = lazy(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e delay(\u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003edefault\u003c/span\u003e: ImageResource\n  }\n})\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ImageResource = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eprops\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e {\u003cspan class=\"hljs-attr\"\u003e...props\u003c/span\u003e} /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\n\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eComponent\u003c/span\u003e \u003c/span\u003e{\n  render() {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n      \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"App\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eSuspense\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efallback\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-attr\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003eLoading...\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e}\u0026gt;\n          \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eImg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"https://www.baidu.com/img/bd_logo1.png?where=super\"\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eSuspense\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在官网教程提到 React.lazy 要动态的调用 import 方式注入组件，返回一个 Promise。 同时 Promise 返回一个 default 的组件。所以就可以采用上面的方式，而不必用 import 方式，只是如此还是类似于代码分割，没有达到数据获取返回之前挂起组件的思路。\u003c/p\u003e\n\u003ch3\u003eDan 的例子\u003c/h3\u003e\n\u003cp\u003e在 Dan 的演讲里面多处地方有用到 Suspense 的意识，也就是 createFetcher 与 this.deferSetState 方法。deferSetState 通过异步修改组件显示与否，当 createFetcher 传参 Promise 状态结束后才执行异步 deferSetState，显示已经接收到数据的组件。这就是挂起 Suspense 的作用了。在 React 16.6 里面没有提供 deferSetState，可能也是更多的异步操作留到 17.0 大版本上。而 Suspense 组件，已经可以实现 children 的挂起行为了。\u003cstrong\u003e所以可以猜测，Suspense 组件作用就是 this.deferSetState\u003c/strong\u003e 。\u003c/p\u003e\n\u003cp\u003eDan 的 demo 里面，采用的 createFetcher 方法，类似于 \u003ca href=\"https://www.npmjs.com/package/simple-cache-provider\" target=\"_blank\"\u003esimple-cache-provider 包\u003c/a\u003e ，提供数据缓存控制。由于 Dan 的 demo 里的获取数据函数 Promise 没有写明具体的实现方式，不知道里面有没有什么巧门，还好在 demo 最后里有提到图片更新的 Promise，具体代码如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e imageFecther = createFether(\n  \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003esrc\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresolve\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e image = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Image();\n    image.onload = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e resolve(src);\n    image.src = src;\n  })\n)\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eImg\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprops\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \n      {\u003cspan class=\"hljs-attr\"\u003e...props\u003c/span\u003e}\n      \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{imageFecher.read(props.src)}\u003c/span\u003e\n    \u0026gt;\u003c/span\u003e\n  )\n}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这整个组件 Img 还是很简单的，若是平时的直接将 Promise 返回值到 img 标签的 src 将得到的是 \u003ccode\u003e[Object Promise]\u003c/code\u003e，而不是 url。只是为何凭借一个 resolve，Suspense 组件就知道可以有数据进来，可以解除挂起状态，并让 src 得到想要的 url 嗯？\u003c/p\u003e\n\u003cp\u003e由于 simple-cache-provider 包已经不再更新而且在 react 项目里面找不到了，所以单独下载 simple-cache-provider 包。这个缓存控制包，代码在300+，主要 api 有 createCache、createResource 和 SimpleCache。上面 demo 中的代码采用 simple-cache-provider 包实现，就要用到 createCache 来创建缓存，createResource 来获取资源。简化一下 simple-cache-provider 包，替换 createCache 以及 createResource，其具体实现如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e cacheResourceSimple = {};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e createResourceSimple = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003emiss\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresource, key\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!resource[key]) {\n      resource[key] = {\n        key,\n        \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n      }\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e _suspender = miss(key);\n      _suspender.then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n        resource[key].value = value;\n      });\n      \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e _suspender;\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e resource[key].value；\n    }\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e imgFetcher = createResourceSimple(\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003esrc\u003c/span\u003e =\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresolve\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e img = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Image();\n      img.onload = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e resolve(src);\n      img.src = src;\n    })\n)\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eImg\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eprops\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \n      {\u003cspan class=\"hljs-attr\"\u003e...props\u003c/span\u003e}\n      \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{imgFetcher(cacheResourceSimple,\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eprops.src\u003c/span\u003e)} \n    /\u0026gt;\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e图片组件的挂起表现正常，基本上就实现 Dan 的挂起图片的功能了。\u003c/p\u003e\n\u003cp\u003e只是上面的代码为什么可以实现图片组件的挂起呢？明明 imgFetcher 函数返回的也是一个 Promise，最后 src 将得到的还是 \u003ccode\u003e[Object Promise]\u003c/code\u003e 呀。抱着这样的疑惑，打断点试了试，发现上面代码神奇之处在于 \u003ccode\u003ethrow _suspender\u003c/code\u003e。在 simple-cache-provider 包里面的就是这样实现的，执行 _suspender 之后抛出错误。\u003c/p\u003e\n\u003cp\u003e在这里就要回到 react 源码了，当 \u003ccode\u003ethrow _suspender\u003c/code\u003e 的时候，会被 renderRoot 方法捕获 catch ，进入 throwException 抛错函数来处理，而 throwException 里面\n会判断 fiber 是否是 \u003ccode\u003eSymbol(react.suspense)\u003c/code\u003e 类型，并且挂起的组件非空，则会执行下面。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003ethenable.then(onResolveOrReject, onResolveOrReject);\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e nextChildren = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e简单的就是挂了个 then。\u003cstrong\u003e当图片 resolve 之后，会执行 \u003ccode\u003e_suspender.then\u003c/code\u003e，接下来又会执行 thenable.then\u003c/strong\u003e ，从而使得该组件在有数据返回的时候立刻异步渲染。后面的 nextChildren 置空，则是使得组件在数据没有返回前的渲染好像只是渲染 null 一样。具体 react 实现是复杂的，一环接一环的，这里就不做具体分析了。但是 \u003cstrong\u003e抛出 createResourceSimple 的传参 Promise 给到 react 捕获到\u003c/strong\u003e ，才有了 suspense data fetching 的行为。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e实现 Suspense 组件的另外一个更大的作用 suspense data fetching 的方法，只需要将 IO 接口请求的异步函数当作错误抛出，就可以了。官网里面没有介绍到这个方式，可能也是考虑到功能还不完善？丑媳妇迟早要见公婆的。\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=nLF0n9SACd4\" target=\"_blank\"\u003eBeyond React 16\u003c/a\u003e Dan 的这个视频，看到前面的 CPU time slicing 就兴奋不已了，倒是忘记后面新功能。\u003c/li\u003e\n\u003c/ol\u003e\n"}},"buildId":"r4Ww0YLm8YL5~6SwciWHH","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" async=""></script></body></html>