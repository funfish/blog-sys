<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">sticky 以及 swiper</title><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.587c5e31.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___2dTZ9 "><a class="logo___346dE" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___13XXt" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___29Pln"><h1 class="postTitle___1_m4g">sticky 以及 swiper</h1><span class="postTime___1x0_i">March 24, 2021</span></header><article class="postWrapper___3jnNg post-article"><div><p>最近为了新版官网，一直在学习 iphone 11 的效果图，结果越研究发现其复杂度实在远超想象，还要支持各种兼容问题。而我们这次的官网则是要向其学习，其中类似 apple 的翻页的布局是结构的重中之重。</p>
<h2>sticky 的翻页效果</h2>
<p>苹果官网上采用的是 sticky 的效果，就是 <code>position: sticky</code> 这个属性的兼容性比较一般，基本只有现代浏览器都支持。只是 apple 都用了，其在 ie 等浏览器也做了兼容处理，那为什么我们不试一试翻页效果呢？</p>
<p>没有找到合适的第三方库，于是采用自己摸索的方式，按照苹果的方式按葫芦画瓢，具体的结构大致如下</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sticky-container"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sticky-inner"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
.sticky-container { margin-top: -100vh; height: 200vh; } .sticky-inner {
position: sticky; top: 0; height: 100vh; }
</code></pre>
<p>每个模块翻页的模块都是一个 <code>sticky-container</code> 模块，并且通过 <code>margin-top</code> 往前上移一个屏幕的高度。内部模块再采用 <code>sticky</code> 的方式，使得上一个模块翻过的时候，下一个模块已经出现了，并且其内部模块牢牢的固定在顶部，达到翻页的效果。</p>
<p>同时这个 <code>sticky</code> 的方案满足长模块的要求，普通模块高度为 <code>100vh</code>，当模块的内容较多，<code>100vh</code> 不够的时候可以扩展开。同时 H5 也可以采用这种方式。</p>
<h3>sticky 兼容效果</h3>
<p>ie 浏览器毫无意外是不支持的，考虑到 2019 年 11 月份 ie 浏览器的中国份额已经接近 0.8% 的水平，于是采用简单的兼容方式，将 <code>sticky</code> 统统改为普通布局。只是在移动端，本来以为兼容效果是最好的，<code>caniuse</code> 里面基本移动端都是没问题，没有想到现实中有各种问题：</p>
<p>oppo 浏览器最新版不支持 <code>sticky</code>，uc 浏览器对嵌套 <code>sticky</code> 支持效果非常差，会出现大块的白屏情况，chrome 浏览器是最好的。可以通过简单的判断 <code>$('.sticky-inner').css('position') === 'stikcy'</code> 或者是 <code>-webkit-stikcy</code> 来判断是否支持。而 uc 的嵌套问题只能通过修改代码结构来实现。只是 UC 浏览器对 <code>sticky</code> 的滑动效果不太好，底部边缘会出现颤抖的情况，通过 GPU 加速的方式也无法消除问题，最后考虑还是将 UC 浏览器同样降级为非支持 <code>sticky</code> 的模式。</p>
<p>为了兼容非支持 <code>sticky</code> 模式的机型，特意查询了一下主流的代替方案，采用 <code>fixed</code> 和 <code>absolute</code> 来代替 <code>stikcy</code>，其中效果最好的要数 <code>stickybits</code> 和 <code>stickyfill</code> 这两个 <code>Polyfill</code> 方案了，但是其对长模块内容的 <code>sticky</code> 支持却不好。最后还是自己调试生成兼容版本。</p>
<h3>sticky 翻页</h3>
<p><code>sticky</code> 已经可以很好的解决翻页问题了，奈何领导提出这样的翻页效果不符合要求，滚动或者滑动过程存在可以看到其他页的效果（难道苹果不是也有同样的问题？），于是在上线前两天临时改了方案，经过评估最好的方案是用 <code>swiper</code>，只是由于整个功能页改为 <code>swiper</code> 需要时间较多，于是折中使用 <code>sticky</code> 翻页时，自动整体往上滑动的效果。</p>
<p>主要技术难点为页面定位问题，这个需要维护一个锚点位置的列表，在初始化和 <code>resize</code> 时候更新，而长模块内容的自动上划以及其自然翻滚要做区分处理，这个区分处理就很麻烦，需要耐心调试。而更加麻烦的是在 mac 下面表现很差，到处乱飞，以及 H5 的滑动也是乱飞的情况，需要一个个适配，于是在上线前一天理所当然的放弃了 H5 以及 mac 的效果，也好给领导交差。</p>
<h3>swiper 版本的翻页效果</h3>
<p>对于垂直翻页的效果，如果长模块内容复杂，可以下个定论，是不适合用 <code>swiper</code> 的，只能用 <code>sticky</code> 的方案，<code>swiper</code> 在长短屏切换时需要处理各种逻辑兼容问题，如果长模块内容复杂，则会增加复杂度。</p>
<p>相比较于 <code>stikcy</code> 的翻页模式，<code>swiper</code> 的翻页需要自己搭建，其本身自带的切换效果只有 <code>fade</code> <code>cube</code> 这些模式。pc 端用到的是 <code>wheel</code> 滚动，在事件 <code>transitionStart</code> 触发的时候修改 <code>swiper</code> 动画就可以了。需要注意的是由于是翻页效果，所以每个页面都要绝对定位，并设置 <code>z-index</code>；由于长模块内容在 <code>wheel</code> 触发的时候，不能直接翻页，需要判断是不是长模块内容本身的滚动，于是要动态设置 <code>mousewheel.enabled</code>。</p>
<p>移动端则比 pc 端复杂不少，由于其翻页是触摸式翻页，需要在 <code>progress</code> 里面同步修改翻页的 <code>transform</code>，同时由于长模块问题，需要动态设置 <code>allowTouchMove</code>，类似 pc 端的 <code>mousewheel.enabled</code>；</p>
<p>由于长模块的内容，存在 <code>fixed</code> 元素，而 <code>swiper</code> 的翻页效果为了达到顺滑，采用的 <code>transform</code> 动画，这样将导致长模块内的 <code>fixed</code> 失效。为此有两个方案可以实现：</p>
<ol>
<li>将长模块内容高度限制在 100vh，支持 overflow-y: scroll；长模块内分为 fixed 元素和长高度的空元素，长高度元素起高度撑开作用；由于 fixed 元素存在交互，需要将长高度元素的 z-index 放在最底层，所以无法自然滚动该元素，故采用控制滚动。fixed 元素在上下翻动的时候改为 absolute 布局。</li>
<li>将 swiper 内的长模块的内容完全移出来，在 swiper 翻页的时候，单独控制其 transform，原本的 swiper 模块只做高度撑开作用，来配合控制滚动。</li>
</ol>
<p>这两个方案分别用在了 pc 端和移动端，最后效果看来是第二种好，<code>absolute</code> 和 <code>fixed</code> 布局还是有差异，会导致页面抖动，需要不断调试。第二个方式这是需要自己修改 swiper 翻页模式，将 <code>fixed</code> 的元素和对应 <code>swiper</code> 页面的翻动结合在一起。</p>
<h4>swiper 切换模式</h4>
<p>初步尝试切换，采用在 <code>fade</code> 模式和 <code>transform</code> 修改，但在移动端的 <code>progress</code> 事件里修改 <code>transform</code> 时候，页面的动画无法生效，一直是 <code>translate3d(0px, 0px, 0px)</code>，除非采用 <code>!important</code> 增加 <code>transform</code> 的权重，并且要写在 <code>css</code> 样式中，无法做到动态修改，于是一开始移动端使用的切换效果是基于 <code>top</code> 的，调试的时候效果符合要求，但是用真机调试，发现 <code>top</code> 的效果还是差强人意。</p>
<p>后面立刻研究 <code>swiper</code> 的源码，从模式入手，发现其切换模式的添加，是采用 <code>swiper.use</code> 方法，该方法没有开放出来，有点类似 <code>Vue</code> 的模式。研究 <code>effect-fade.js</code> 文件可以发现下面代码：</p>
<pre class="hljs"><code><span class="hljs-comment">// ... 省略部分代码</span>
<span class="hljs-keyword">const</span> Fade = {
  setTranslate() {
    $slideEl
      .css({
        <span class="hljs-attr">opacity</span>: slideOpacity
      })
      .transform(<span class="hljs-string">`translate3d(<span class="hljs-subst">${tx}</span>px, <span class="hljs-subst">${ty}</span>px, 0px)`</span>);
  }
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"effect-fade"</span>,
  <span class="hljs-attr">on</span>: {
    setTranslate() {
      <span class="hljs-keyword">const</span> swiper = <span class="hljs-keyword">this</span>;
      <span class="hljs-keyword">if</span> (swiper.params.effect !== <span class="hljs-string">"fade"</span>) <span class="hljs-keyword">return</span>;
      swiper.fadeEffect.setTranslate();
    }
  }
};
</code></pre>
<p>移动端每次滑动的时候，其 <code>transform</code> 值都会被重新修改，导致 <code>progress</code> 里面的修改无效。于是我就自定义一种模式 <code>slide-page</code>，其在滑动的时候，读取当前 <code>progress</code> 来修改 <code>transform</code>，只是需要注意的是不能仅仅对当前页面修改，需要对全体页面都重新设置，避免切换的时带来的问题，并且需要同步到 <code>fixed</code> 的元素。这样的模式也适用于 pc 端。</p>
<h2>总结</h2>
<p><code>sticky</code> 的优势是最明显的，功能完备，pc 端兼容良好。而 <code>swiper</code> 需要在长短模块之间切换，<code>mac</code> 下由于高度是不变，没有正常布局的格式，所以会触发橡皮胶效果，体验整体没有 <code>sticky</code> 好。另外上面的方案还有改进点：对于长模块内容，内部可以去掉长高度元素，每次长模块滑动滑动都触发一次状态修改就可以了，没有必要采用 <code>z-index</code> 为负的滚动。</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"March 24, 2021","title":"sticky 以及 swiper","content":"\u003cp\u003e最近为了新版官网，一直在学习 iphone 11 的效果图，结果越研究发现其复杂度实在远超想象，还要支持各种兼容问题。而我们这次的官网则是要向其学习，其中类似 apple 的翻页的布局是结构的重中之重。\u003c/p\u003e\n\u003ch2\u003esticky 的翻页效果\u003c/h2\u003e\n\u003cp\u003e苹果官网上采用的是 sticky 的效果，就是 \u003ccode\u003eposition: sticky\u003c/code\u003e 这个属性的兼容性比较一般，基本只有现代浏览器都支持。只是 apple 都用了，其在 ie 等浏览器也做了兼容处理，那为什么我们不试一试翻页效果呢？\u003c/p\u003e\n\u003cp\u003e没有找到合适的第三方库，于是采用自己摸索的方式，按照苹果的方式按葫芦画瓢，具体的结构大致如下\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003emain\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003esection\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"sticky-container\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"sticky-inner\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003esection\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003emain\u003c/span\u003e\u0026gt;\u003c/span\u003e\n.sticky-container { margin-top: -100vh; height: 200vh; } .sticky-inner {\nposition: sticky; top: 0; height: 100vh; }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e每个模块翻页的模块都是一个 \u003ccode\u003esticky-container\u003c/code\u003e 模块，并且通过 \u003ccode\u003emargin-top\u003c/code\u003e 往前上移一个屏幕的高度。内部模块再采用 \u003ccode\u003esticky\u003c/code\u003e 的方式，使得上一个模块翻过的时候，下一个模块已经出现了，并且其内部模块牢牢的固定在顶部，达到翻页的效果。\u003c/p\u003e\n\u003cp\u003e同时这个 \u003ccode\u003esticky\u003c/code\u003e 的方案满足长模块的要求，普通模块高度为 \u003ccode\u003e100vh\u003c/code\u003e，当模块的内容较多，\u003ccode\u003e100vh\u003c/code\u003e 不够的时候可以扩展开。同时 H5 也可以采用这种方式。\u003c/p\u003e\n\u003ch3\u003esticky 兼容效果\u003c/h3\u003e\n\u003cp\u003eie 浏览器毫无意外是不支持的，考虑到 2019 年 11 月份 ie 浏览器的中国份额已经接近 0.8% 的水平，于是采用简单的兼容方式，将 \u003ccode\u003esticky\u003c/code\u003e 统统改为普通布局。只是在移动端，本来以为兼容效果是最好的，\u003ccode\u003ecaniuse\u003c/code\u003e 里面基本移动端都是没问题，没有想到现实中有各种问题：\u003c/p\u003e\n\u003cp\u003eoppo 浏览器最新版不支持 \u003ccode\u003esticky\u003c/code\u003e，uc 浏览器对嵌套 \u003ccode\u003esticky\u003c/code\u003e 支持效果非常差，会出现大块的白屏情况，chrome 浏览器是最好的。可以通过简单的判断 \u003ccode\u003e$('.sticky-inner').css('position') === 'stikcy'\u003c/code\u003e 或者是 \u003ccode\u003e-webkit-stikcy\u003c/code\u003e 来判断是否支持。而 uc 的嵌套问题只能通过修改代码结构来实现。只是 UC 浏览器对 \u003ccode\u003esticky\u003c/code\u003e 的滑动效果不太好，底部边缘会出现颤抖的情况，通过 GPU 加速的方式也无法消除问题，最后考虑还是将 UC 浏览器同样降级为非支持 \u003ccode\u003esticky\u003c/code\u003e 的模式。\u003c/p\u003e\n\u003cp\u003e为了兼容非支持 \u003ccode\u003esticky\u003c/code\u003e 模式的机型，特意查询了一下主流的代替方案，采用 \u003ccode\u003efixed\u003c/code\u003e 和 \u003ccode\u003eabsolute\u003c/code\u003e 来代替 \u003ccode\u003estikcy\u003c/code\u003e，其中效果最好的要数 \u003ccode\u003estickybits\u003c/code\u003e 和 \u003ccode\u003estickyfill\u003c/code\u003e 这两个 \u003ccode\u003ePolyfill\u003c/code\u003e 方案了，但是其对长模块内容的 \u003ccode\u003esticky\u003c/code\u003e 支持却不好。最后还是自己调试生成兼容版本。\u003c/p\u003e\n\u003ch3\u003esticky 翻页\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003esticky\u003c/code\u003e 已经可以很好的解决翻页问题了，奈何领导提出这样的翻页效果不符合要求，滚动或者滑动过程存在可以看到其他页的效果（难道苹果不是也有同样的问题？），于是在上线前两天临时改了方案，经过评估最好的方案是用 \u003ccode\u003eswiper\u003c/code\u003e，只是由于整个功能页改为 \u003ccode\u003eswiper\u003c/code\u003e 需要时间较多，于是折中使用 \u003ccode\u003esticky\u003c/code\u003e 翻页时，自动整体往上滑动的效果。\u003c/p\u003e\n\u003cp\u003e主要技术难点为页面定位问题，这个需要维护一个锚点位置的列表，在初始化和 \u003ccode\u003eresize\u003c/code\u003e 时候更新，而长模块内容的自动上划以及其自然翻滚要做区分处理，这个区分处理就很麻烦，需要耐心调试。而更加麻烦的是在 mac 下面表现很差，到处乱飞，以及 H5 的滑动也是乱飞的情况，需要一个个适配，于是在上线前一天理所当然的放弃了 H5 以及 mac 的效果，也好给领导交差。\u003c/p\u003e\n\u003ch3\u003eswiper 版本的翻页效果\u003c/h3\u003e\n\u003cp\u003e对于垂直翻页的效果，如果长模块内容复杂，可以下个定论，是不适合用 \u003ccode\u003eswiper\u003c/code\u003e 的，只能用 \u003ccode\u003esticky\u003c/code\u003e 的方案，\u003ccode\u003eswiper\u003c/code\u003e 在长短屏切换时需要处理各种逻辑兼容问题，如果长模块内容复杂，则会增加复杂度。\u003c/p\u003e\n\u003cp\u003e相比较于 \u003ccode\u003estikcy\u003c/code\u003e 的翻页模式，\u003ccode\u003eswiper\u003c/code\u003e 的翻页需要自己搭建，其本身自带的切换效果只有 \u003ccode\u003efade\u003c/code\u003e \u003ccode\u003ecube\u003c/code\u003e 这些模式。pc 端用到的是 \u003ccode\u003ewheel\u003c/code\u003e 滚动，在事件 \u003ccode\u003etransitionStart\u003c/code\u003e 触发的时候修改 \u003ccode\u003eswiper\u003c/code\u003e 动画就可以了。需要注意的是由于是翻页效果，所以每个页面都要绝对定位，并设置 \u003ccode\u003ez-index\u003c/code\u003e；由于长模块内容在 \u003ccode\u003ewheel\u003c/code\u003e 触发的时候，不能直接翻页，需要判断是不是长模块内容本身的滚动，于是要动态设置 \u003ccode\u003emousewheel.enabled\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e移动端则比 pc 端复杂不少，由于其翻页是触摸式翻页，需要在 \u003ccode\u003eprogress\u003c/code\u003e 里面同步修改翻页的 \u003ccode\u003etransform\u003c/code\u003e，同时由于长模块问题，需要动态设置 \u003ccode\u003eallowTouchMove\u003c/code\u003e，类似 pc 端的 \u003ccode\u003emousewheel.enabled\u003c/code\u003e；\u003c/p\u003e\n\u003cp\u003e由于长模块的内容，存在 \u003ccode\u003efixed\u003c/code\u003e 元素，而 \u003ccode\u003eswiper\u003c/code\u003e 的翻页效果为了达到顺滑，采用的 \u003ccode\u003etransform\u003c/code\u003e 动画，这样将导致长模块内的 \u003ccode\u003efixed\u003c/code\u003e 失效。为此有两个方案可以实现：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e将长模块内容高度限制在 100vh，支持 overflow-y: scroll；长模块内分为 fixed 元素和长高度的空元素，长高度元素起高度撑开作用；由于 fixed 元素存在交互，需要将长高度元素的 z-index 放在最底层，所以无法自然滚动该元素，故采用控制滚动。fixed 元素在上下翻动的时候改为 absolute 布局。\u003c/li\u003e\n\u003cli\u003e将 swiper 内的长模块的内容完全移出来，在 swiper 翻页的时候，单独控制其 transform，原本的 swiper 模块只做高度撑开作用，来配合控制滚动。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这两个方案分别用在了 pc 端和移动端，最后效果看来是第二种好，\u003ccode\u003eabsolute\u003c/code\u003e 和 \u003ccode\u003efixed\u003c/code\u003e 布局还是有差异，会导致页面抖动，需要不断调试。第二个方式这是需要自己修改 swiper 翻页模式，将 \u003ccode\u003efixed\u003c/code\u003e 的元素和对应 \u003ccode\u003eswiper\u003c/code\u003e 页面的翻动结合在一起。\u003c/p\u003e\n\u003ch4\u003eswiper 切换模式\u003c/h4\u003e\n\u003cp\u003e初步尝试切换，采用在 \u003ccode\u003efade\u003c/code\u003e 模式和 \u003ccode\u003etransform\u003c/code\u003e 修改，但在移动端的 \u003ccode\u003eprogress\u003c/code\u003e 事件里修改 \u003ccode\u003etransform\u003c/code\u003e 时候，页面的动画无法生效，一直是 \u003ccode\u003etranslate3d(0px, 0px, 0px)\u003c/code\u003e，除非采用 \u003ccode\u003e!important\u003c/code\u003e 增加 \u003ccode\u003etransform\u003c/code\u003e 的权重，并且要写在 \u003ccode\u003ecss\u003c/code\u003e 样式中，无法做到动态修改，于是一开始移动端使用的切换效果是基于 \u003ccode\u003etop\u003c/code\u003e 的，调试的时候效果符合要求，但是用真机调试，发现 \u003ccode\u003etop\u003c/code\u003e 的效果还是差强人意。\u003c/p\u003e\n\u003cp\u003e后面立刻研究 \u003ccode\u003eswiper\u003c/code\u003e 的源码，从模式入手，发现其切换模式的添加，是采用 \u003ccode\u003eswiper.use\u003c/code\u003e 方法，该方法没有开放出来，有点类似 \u003ccode\u003eVue\u003c/code\u003e 的模式。研究 \u003ccode\u003eeffect-fade.js\u003c/code\u003e 文件可以发现下面代码：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// ... 省略部分代码\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Fade = {\n  setTranslate() {\n    $slideEl\n      .css({\n        \u003cspan class=\"hljs-attr\"\u003eopacity\u003c/span\u003e: slideOpacity\n      })\n      .transform(\u003cspan class=\"hljs-string\"\u003e`translate3d(\u003cspan class=\"hljs-subst\"\u003e${tx}\u003c/span\u003epx, \u003cspan class=\"hljs-subst\"\u003e${ty}\u003c/span\u003epx, 0px)`\u003c/span\u003e);\n  }\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"effect-fade\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eon\u003c/span\u003e: {\n    setTranslate() {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e swiper = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (swiper.params.effect !== \u003cspan class=\"hljs-string\"\u003e\"fade\"\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n      swiper.fadeEffect.setTranslate();\n    }\n  }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e移动端每次滑动的时候，其 \u003ccode\u003etransform\u003c/code\u003e 值都会被重新修改，导致 \u003ccode\u003eprogress\u003c/code\u003e 里面的修改无效。于是我就自定义一种模式 \u003ccode\u003eslide-page\u003c/code\u003e，其在滑动的时候，读取当前 \u003ccode\u003eprogress\u003c/code\u003e 来修改 \u003ccode\u003etransform\u003c/code\u003e，只是需要注意的是不能仅仅对当前页面修改，需要对全体页面都重新设置，避免切换的时带来的问题，并且需要同步到 \u003ccode\u003efixed\u003c/code\u003e 的元素。这样的模式也适用于 pc 端。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003esticky\u003c/code\u003e 的优势是最明显的，功能完备，pc 端兼容良好。而 \u003ccode\u003eswiper\u003c/code\u003e 需要在长短模块之间切换，\u003ccode\u003emac\u003c/code\u003e 下由于高度是不变，没有正常布局的格式，所以会触发橡皮胶效果，体验整体没有 \u003ccode\u003esticky\u003c/code\u003e 好。另外上面的方案还有改进点：对于长模块内容，内部可以去掉长高度元素，每次长模块滑动滑动都触发一次状态修改就可以了，没有必要采用 \u003ccode\u003ez-index\u003c/code\u003e 为负的滚动。\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"March 24, 2021","title":"sticky 以及 swiper","content":"\u003cp\u003e最近为了新版官网，一直在学习 iphone 11 的效果图，结果越研究发现其复杂度实在远超想象，还要支持各种兼容问题。而我们这次的官网则是要向其学习，其中类似 apple 的翻页的布局是结构的重中之重。\u003c/p\u003e\n\u003ch2\u003esticky 的翻页效果\u003c/h2\u003e\n\u003cp\u003e苹果官网上采用的是 sticky 的效果，就是 \u003ccode\u003eposition: sticky\u003c/code\u003e 这个属性的兼容性比较一般，基本只有现代浏览器都支持。只是 apple 都用了，其在 ie 等浏览器也做了兼容处理，那为什么我们不试一试翻页效果呢？\u003c/p\u003e\n\u003cp\u003e没有找到合适的第三方库，于是采用自己摸索的方式，按照苹果的方式按葫芦画瓢，具体的结构大致如下\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003emain\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003esection\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"sticky-container\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"sticky-inner\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003esection\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003emain\u003c/span\u003e\u0026gt;\u003c/span\u003e\n.sticky-container { margin-top: -100vh; height: 200vh; } .sticky-inner {\nposition: sticky; top: 0; height: 100vh; }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e每个模块翻页的模块都是一个 \u003ccode\u003esticky-container\u003c/code\u003e 模块，并且通过 \u003ccode\u003emargin-top\u003c/code\u003e 往前上移一个屏幕的高度。内部模块再采用 \u003ccode\u003esticky\u003c/code\u003e 的方式，使得上一个模块翻过的时候，下一个模块已经出现了，并且其内部模块牢牢的固定在顶部，达到翻页的效果。\u003c/p\u003e\n\u003cp\u003e同时这个 \u003ccode\u003esticky\u003c/code\u003e 的方案满足长模块的要求，普通模块高度为 \u003ccode\u003e100vh\u003c/code\u003e，当模块的内容较多，\u003ccode\u003e100vh\u003c/code\u003e 不够的时候可以扩展开。同时 H5 也可以采用这种方式。\u003c/p\u003e\n\u003ch3\u003esticky 兼容效果\u003c/h3\u003e\n\u003cp\u003eie 浏览器毫无意外是不支持的，考虑到 2019 年 11 月份 ie 浏览器的中国份额已经接近 0.8% 的水平，于是采用简单的兼容方式，将 \u003ccode\u003esticky\u003c/code\u003e 统统改为普通布局。只是在移动端，本来以为兼容效果是最好的，\u003ccode\u003ecaniuse\u003c/code\u003e 里面基本移动端都是没问题，没有想到现实中有各种问题：\u003c/p\u003e\n\u003cp\u003eoppo 浏览器最新版不支持 \u003ccode\u003esticky\u003c/code\u003e，uc 浏览器对嵌套 \u003ccode\u003esticky\u003c/code\u003e 支持效果非常差，会出现大块的白屏情况，chrome 浏览器是最好的。可以通过简单的判断 \u003ccode\u003e$('.sticky-inner').css('position') === 'stikcy'\u003c/code\u003e 或者是 \u003ccode\u003e-webkit-stikcy\u003c/code\u003e 来判断是否支持。而 uc 的嵌套问题只能通过修改代码结构来实现。只是 UC 浏览器对 \u003ccode\u003esticky\u003c/code\u003e 的滑动效果不太好，底部边缘会出现颤抖的情况，通过 GPU 加速的方式也无法消除问题，最后考虑还是将 UC 浏览器同样降级为非支持 \u003ccode\u003esticky\u003c/code\u003e 的模式。\u003c/p\u003e\n\u003cp\u003e为了兼容非支持 \u003ccode\u003esticky\u003c/code\u003e 模式的机型，特意查询了一下主流的代替方案，采用 \u003ccode\u003efixed\u003c/code\u003e 和 \u003ccode\u003eabsolute\u003c/code\u003e 来代替 \u003ccode\u003estikcy\u003c/code\u003e，其中效果最好的要数 \u003ccode\u003estickybits\u003c/code\u003e 和 \u003ccode\u003estickyfill\u003c/code\u003e 这两个 \u003ccode\u003ePolyfill\u003c/code\u003e 方案了，但是其对长模块内容的 \u003ccode\u003esticky\u003c/code\u003e 支持却不好。最后还是自己调试生成兼容版本。\u003c/p\u003e\n\u003ch3\u003esticky 翻页\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003esticky\u003c/code\u003e 已经可以很好的解决翻页问题了，奈何领导提出这样的翻页效果不符合要求，滚动或者滑动过程存在可以看到其他页的效果（难道苹果不是也有同样的问题？），于是在上线前两天临时改了方案，经过评估最好的方案是用 \u003ccode\u003eswiper\u003c/code\u003e，只是由于整个功能页改为 \u003ccode\u003eswiper\u003c/code\u003e 需要时间较多，于是折中使用 \u003ccode\u003esticky\u003c/code\u003e 翻页时，自动整体往上滑动的效果。\u003c/p\u003e\n\u003cp\u003e主要技术难点为页面定位问题，这个需要维护一个锚点位置的列表，在初始化和 \u003ccode\u003eresize\u003c/code\u003e 时候更新，而长模块内容的自动上划以及其自然翻滚要做区分处理，这个区分处理就很麻烦，需要耐心调试。而更加麻烦的是在 mac 下面表现很差，到处乱飞，以及 H5 的滑动也是乱飞的情况，需要一个个适配，于是在上线前一天理所当然的放弃了 H5 以及 mac 的效果，也好给领导交差。\u003c/p\u003e\n\u003ch3\u003eswiper 版本的翻页效果\u003c/h3\u003e\n\u003cp\u003e对于垂直翻页的效果，如果长模块内容复杂，可以下个定论，是不适合用 \u003ccode\u003eswiper\u003c/code\u003e 的，只能用 \u003ccode\u003esticky\u003c/code\u003e 的方案，\u003ccode\u003eswiper\u003c/code\u003e 在长短屏切换时需要处理各种逻辑兼容问题，如果长模块内容复杂，则会增加复杂度。\u003c/p\u003e\n\u003cp\u003e相比较于 \u003ccode\u003estikcy\u003c/code\u003e 的翻页模式，\u003ccode\u003eswiper\u003c/code\u003e 的翻页需要自己搭建，其本身自带的切换效果只有 \u003ccode\u003efade\u003c/code\u003e \u003ccode\u003ecube\u003c/code\u003e 这些模式。pc 端用到的是 \u003ccode\u003ewheel\u003c/code\u003e 滚动，在事件 \u003ccode\u003etransitionStart\u003c/code\u003e 触发的时候修改 \u003ccode\u003eswiper\u003c/code\u003e 动画就可以了。需要注意的是由于是翻页效果，所以每个页面都要绝对定位，并设置 \u003ccode\u003ez-index\u003c/code\u003e；由于长模块内容在 \u003ccode\u003ewheel\u003c/code\u003e 触发的时候，不能直接翻页，需要判断是不是长模块内容本身的滚动，于是要动态设置 \u003ccode\u003emousewheel.enabled\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e移动端则比 pc 端复杂不少，由于其翻页是触摸式翻页，需要在 \u003ccode\u003eprogress\u003c/code\u003e 里面同步修改翻页的 \u003ccode\u003etransform\u003c/code\u003e，同时由于长模块问题，需要动态设置 \u003ccode\u003eallowTouchMove\u003c/code\u003e，类似 pc 端的 \u003ccode\u003emousewheel.enabled\u003c/code\u003e；\u003c/p\u003e\n\u003cp\u003e由于长模块的内容，存在 \u003ccode\u003efixed\u003c/code\u003e 元素，而 \u003ccode\u003eswiper\u003c/code\u003e 的翻页效果为了达到顺滑，采用的 \u003ccode\u003etransform\u003c/code\u003e 动画，这样将导致长模块内的 \u003ccode\u003efixed\u003c/code\u003e 失效。为此有两个方案可以实现：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e将长模块内容高度限制在 100vh，支持 overflow-y: scroll；长模块内分为 fixed 元素和长高度的空元素，长高度元素起高度撑开作用；由于 fixed 元素存在交互，需要将长高度元素的 z-index 放在最底层，所以无法自然滚动该元素，故采用控制滚动。fixed 元素在上下翻动的时候改为 absolute 布局。\u003c/li\u003e\n\u003cli\u003e将 swiper 内的长模块的内容完全移出来，在 swiper 翻页的时候，单独控制其 transform，原本的 swiper 模块只做高度撑开作用，来配合控制滚动。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这两个方案分别用在了 pc 端和移动端，最后效果看来是第二种好，\u003ccode\u003eabsolute\u003c/code\u003e 和 \u003ccode\u003efixed\u003c/code\u003e 布局还是有差异，会导致页面抖动，需要不断调试。第二个方式这是需要自己修改 swiper 翻页模式，将 \u003ccode\u003efixed\u003c/code\u003e 的元素和对应 \u003ccode\u003eswiper\u003c/code\u003e 页面的翻动结合在一起。\u003c/p\u003e\n\u003ch4\u003eswiper 切换模式\u003c/h4\u003e\n\u003cp\u003e初步尝试切换，采用在 \u003ccode\u003efade\u003c/code\u003e 模式和 \u003ccode\u003etransform\u003c/code\u003e 修改，但在移动端的 \u003ccode\u003eprogress\u003c/code\u003e 事件里修改 \u003ccode\u003etransform\u003c/code\u003e 时候，页面的动画无法生效，一直是 \u003ccode\u003etranslate3d(0px, 0px, 0px)\u003c/code\u003e，除非采用 \u003ccode\u003e!important\u003c/code\u003e 增加 \u003ccode\u003etransform\u003c/code\u003e 的权重，并且要写在 \u003ccode\u003ecss\u003c/code\u003e 样式中，无法做到动态修改，于是一开始移动端使用的切换效果是基于 \u003ccode\u003etop\u003c/code\u003e 的，调试的时候效果符合要求，但是用真机调试，发现 \u003ccode\u003etop\u003c/code\u003e 的效果还是差强人意。\u003c/p\u003e\n\u003cp\u003e后面立刻研究 \u003ccode\u003eswiper\u003c/code\u003e 的源码，从模式入手，发现其切换模式的添加，是采用 \u003ccode\u003eswiper.use\u003c/code\u003e 方法，该方法没有开放出来，有点类似 \u003ccode\u003eVue\u003c/code\u003e 的模式。研究 \u003ccode\u003eeffect-fade.js\u003c/code\u003e 文件可以发现下面代码：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// ... 省略部分代码\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Fade = {\n  setTranslate() {\n    $slideEl\n      .css({\n        \u003cspan class=\"hljs-attr\"\u003eopacity\u003c/span\u003e: slideOpacity\n      })\n      .transform(\u003cspan class=\"hljs-string\"\u003e`translate3d(\u003cspan class=\"hljs-subst\"\u003e${tx}\u003c/span\u003epx, \u003cspan class=\"hljs-subst\"\u003e${ty}\u003c/span\u003epx, 0px)`\u003c/span\u003e);\n  }\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"effect-fade\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eon\u003c/span\u003e: {\n    setTranslate() {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e swiper = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (swiper.params.effect !== \u003cspan class=\"hljs-string\"\u003e\"fade\"\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n      swiper.fadeEffect.setTranslate();\n    }\n  }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e移动端每次滑动的时候，其 \u003ccode\u003etransform\u003c/code\u003e 值都会被重新修改，导致 \u003ccode\u003eprogress\u003c/code\u003e 里面的修改无效。于是我就自定义一种模式 \u003ccode\u003eslide-page\u003c/code\u003e，其在滑动的时候，读取当前 \u003ccode\u003eprogress\u003c/code\u003e 来修改 \u003ccode\u003etransform\u003c/code\u003e，只是需要注意的是不能仅仅对当前页面修改，需要对全体页面都重新设置，避免切换的时带来的问题，并且需要同步到 \u003ccode\u003efixed\u003c/code\u003e 的元素。这样的模式也适用于 pc 端。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003esticky\u003c/code\u003e 的优势是最明显的，功能完备，pc 端兼容良好。而 \u003ccode\u003eswiper\u003c/code\u003e 需要在长短模块之间切换，\u003ccode\u003emac\u003c/code\u003e 下由于高度是不变，没有正常布局的格式，所以会触发橡皮胶效果，体验整体没有 \u003ccode\u003esticky\u003c/code\u003e 好。另外上面的方案还有改进点：对于长模块内容，内部可以去掉长高度元素，每次长模块滑动滑动都触发一次状态修改就可以了，没有必要采用 \u003ccode\u003ez-index\u003c/code\u003e 为负的滚动。\u003c/p\u003e\n"}},"buildId":"r4Ww0YLm8YL5~6SwciWHH","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" async=""></script></body></html>