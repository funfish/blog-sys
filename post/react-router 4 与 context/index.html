<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">react-router 4 与 context</title><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.587c5e31.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___2dTZ9 "><a class="logo___346dE" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___13XXt" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___29Pln"><h1 class="postTitle___1_m4g">react-router 4 与 context</h1><span class="postTime___1x0_i">March 24, 2021</span></header><article class="postWrapper___3jnNg post-article"><div><h2>前言</h2>
<p>最近我司要上线一个 Hybird 上的 SPA，17 年年底的时候已经写过 demo 给产品和 leader 看了，近期准备要上线。问题在于，当时准备仓促，又想要玩一玩 react，导致了用的版本是比较成熟的，嗯。。。。意思就是比较老的版本，react-router 是 3.x 版本，而 react 也只是 16.0 而已。对于有追求的我而言，升级势在必行。</p>
<h2>问题所在</h2>
<p>在 Vue 应用里面用 Vue-router 就是一个 routes 的事情，甚至连 routes 都可以不是嵌套解构，直接一维路由，毕竟业务少。到了之前写的 react 也是采用了这种方式，如下：</p>
<pre class="hljs"><code>ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span> <span class="hljs-attr">routes</span>=<span class="hljs-string">{RouteConfig}</span> <span class="hljs-attr">history</span>=<span class="hljs-string">{hashHistory}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></span>,
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)
);
</code></pre>
<p>RouteConfig 基本上也是一维结构，传入到 routes 就好了。然而 routes 这个 props 已经在 react-router 4 里面消失掉了，之前版本采用的是静态路由来配置的，而到了 react-router 4，则采用动态组件。。。如果还需要静态的方式可以采用 <code>react-router-config</code>。这个变化使得 react-router 4 升级变得麻烦，由路由配置变成动态映射，这里还有官网提到的<a href="https://reacttraining.com/react-router/web/guides/philosophy" target="_blank">哲学</a>。吐槽一下：开始看官网教程的时候，感觉像一坨屎一样，东一块西一块的，不知道在说什么，这也是去年选 react-router 版本的时候直接放弃 V4 的原因。最近看这个官网，却越看越好，觉得写得相当的优秀用心，赞一个。</p>
<p>对于 APP 上面的页面过渡动画效果，则采用 <code>react-addons-css-transition-group</code> 的 ReactCSSTransitionGroup 组件，这也是比较成熟的方法了，这也是之前官网推荐的方式。让而到了当你点开<a href="https://www.npmjs.com/package/react-addons-css-transition-group" target="_blank">npm上的介绍</a>时候，发现原来 <code>react-addons-css-transition-group</code> 已经不被推荐了：</p>
<blockquote>
<p>The code in this package has moved. We recommend you to use CSSTransitionGroup from react-transition-group instead.</p>
<p>In particular, its version 1.x is a drop-in replacement for the last released version of react-addons-css-transition-group.</p>
</blockquote>
<p>然而现实是无情的，只能使用 <code>react-addons-css-transition-group</code> 的 V 1.x 版本，这对于一个前端工程师怎么可以容忍呢？新版本里面肯定有适合的 API 嘛，为什么一定要用 ReactCSSTransitionGroup 呢？然而官网一开始看也是烂得不能入眼（可能是英文的缘故没有耐心看）。最后还是在 react-router 4 的<a href="https://reacttraining.com/react-router/web/example/animated-transitions" target="_blank">官网</a>里面找到解决办法。</p>
<p><strong>只是一开始傻乎乎的用，抄也没有抄全，部分按照自己的思路走，经常报错</strong>，只有全抄过来才对。。妈呀太可怕了。于是乎想要看看研究一下 react-router 4 的设计！</p>
<h3>从 Router 出发的 Context</h3>
<p>react-router 4 里面依然有 Router，精简一下，Router 代码如下：</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Router</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">static</span> contextTypes = {
    <span class="hljs-attr">router</span>: PropTypes.object
  };
  <span class="hljs-keyword">static</span> childContextTypes = {
    <span class="hljs-attr">router</span>: PropTypes.object.isRequired
  };
  getChildContext() {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">router</span>: {
        ...this.context.router,
        <span class="hljs-attr">history</span>: <span class="hljs-keyword">this</span>.props.history,
        <span class="hljs-attr">route</span>: {
          <span class="hljs-attr">location</span>: <span class="hljs-keyword">this</span>.props.history.location,
          <span class="hljs-attr">match</span>: <span class="hljs-keyword">this</span>.state.match
        }
      }
    };
  }
  state = {
    <span class="hljs-attr">match</span>: <span class="hljs-keyword">this</span>.computeMatch(<span class="hljs-keyword">this</span>.props.history.location.pathname)
  };
  computeMatch(pathname) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">path</span>: <span class="hljs-string">"/"</span>,
      <span class="hljs-attr">url</span>: <span class="hljs-string">"/"</span>,
      <span class="hljs-attr">params</span>: {},
      <span class="hljs-attr">isExact</span>: pathname === <span class="hljs-string">"/"</span>
    };
  }
  render() {
    <span class="hljs-keyword">const</span> { children } = <span class="hljs-keyword">this</span>.props;
    <span class="hljs-keyword">return</span> children ? React.Children.only(children) : <span class="hljs-literal">null</span>;
  }
}
</code></pre>
<p>去除掉提示性报错，PropTypes以及需要在 componentWillMount/componentWillUnmount 和服务端渲染相关的操作 <code>this.unlisten</code> 部分，就只剩下这么一点点了。 Router 组件负责渲染子节点，没有就 null，简单吧。那要 Router 有何用？看看大头 childContextTypes/getChildContext 这又是什么？</p>
<p>React 是有自己的 Context API 的，只是不建议开发者使用，并称之为实验性特性，可能移除，不熟悉 Redux/MobX 的最好都不要碰 Context API，俨然是不让人用的样子。Context API 使用还挺简单的，只要在 context 的提供者组件上申明一下就好了，包括 childContextTypes 以及 getChildContext 方法，这样在子组件里面在定义声明一下 contextTypes 就能够使用了。子组件里面怎么使用呢？通过 contextTypes 声明后直接用 <code>this.context</code> 就能够访问了。上面的 Router 中，其子组件在声明后，若要访问 Router 中的 router，直接用 <code>this.context.router</code> 就好了，是不是很简单！甚至在组件的生命周期里面也有 Context 传过来，这岂不是非常好，这样就不用一直 props 参数到子组件了，用 Context API 就好了，为何官方是不推荐使用的呢？</p>
<p>官网提到：</p>
<blockquote>
<p>问题在于，组件提供的context值改变，后代元素如果 shouldComponentUpdate 返回 false 那么context的将不会更新。这使得使用context的组件完全失控，所以基本上没有办法可靠的更新context。</p>
</blockquote>
<p>这就是问题所在了，所以是不推荐的。嗯。。。至于 react-router 4 里面这么用嘛。。。。反正也没有用到 shouldComponentUpdate 钩子，而且大神这么用还显得非常溜呢。再查 Context API 的时候，忽然发现原来上个月 React 16.3 有了全新的 Context API，<strong>不再是不建议使用了</strong>。</p>
<h3>React 16.3 Context API</h3>
<blockquote>
<p>Context provides a way to pass data through the component tree without having to pass props down manually at every level.</p>
</blockquote>
<p>看到官网介绍，大大觉得这个功能很实在，这不就解决了父子/孙子组件之间的通信问题了吗，呀，那那 redux 是不是可以不用了。。。。当然不是。这里先不说为什么，先看看 React 16.3 Context API 有什么：</p>
<ol>
<li>React.createContext<T>(defaultValue: T)</li>
<li>Provider: React.ComponentType&lt;{value: T}&gt;</li>
<li>Consumer: React.ComponentType&lt;{children: (value: T)=&gt; React.ReactNode}&gt;</li>
</ol>
<p>第一个是创建方法，生成一个 { Provider, Consumer } 对。Consumer 将从最近的 Provider 中读取 context value，如果没有匹配的 Provider，将从 defaultValue 中读取值。是不是也很简单？但是意义却是非凡的。Provider 和 Consumer 可以放在自己想想要用的组件上面，不用顾虑组件的层级关系。可以通过对创建的 <code>React.createContext</code> import 到想要用的组件就好了。这不就是相当于穿梭机嘛。数据飞来飞去多有趣。官网给了很好的<a href="https://reactjs.org/docs/context.html#when-to-use-context" target="_blank">例子</a>，这里就不介绍具体用法了。反正记住：创建的{ Provider, Consumer } 对，Provider 组件提供 context value， 而这个 value 是以 props 的形式进入 Consumer 的子组件的，是不是很骚，不是 <code>this.context</code>，而是通过 <code>this.props</code> 传入的！还是下面这个简单例子吧：</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> ThemeContext = React.createContext({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'ni'</span>
});
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{name:</span> '<span class="hljs-attr">noNi</span>'}&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span>
  { context =&gt; (
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{ context.name }<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  )}
  <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span>
</code></pre>
<p>上面例子是不推荐用的，太暴殄天物了，这里是只是简单介绍一下形式而已，**Context API 的优势在于多层次的嵌套组件！**Provider 组件里面的传值 value 一般不是固定的嘛，要不然传值干嘛？一般传入 state/props 作为 value，state/props 一变化就可以触发组件 Provider/Consumer 更新了。</p>
<p>可以看出这个 Context API ，和 Redux 的功能似乎有点重叠，都是通信问题。只是很明显的是 Redux 和 Context API 是有区别的，Redux 分离了数据和视图，而 Context API 还是在视图层做文章，并且过于灵活，不利于团队开发，不如 Redux 的数据控制来的规范清晰。并且 Redux 更多的是存储数据，Context API 更多还是一个状态的变化，一个从父组件传递到子组件的状态而已，这么看来更像是 state。另外呢，**对于 SPA 还有个问题，当页面切换的时候，需要传递给下个页面的信息，可以通过路由拼接参数传递，或者就是用 Redux 存储了，而这里 Context API 完全没有用武之地。。。还是很悲哀的。。**这么看来 Redux 还是很会有必要的。为此还有一篇<a href="http://blog.isquaredsoftware.com/2018/03/redux-not-dead-yet/" target="_blank">澄清的采访</a>。当然对于小项目嘛，这个 Context API 完全是福利呀，为了传递个 props 而已，就不要用沉重麻烦的 redux 啦，多幸福。</p>
<h3>Router 与 Route</h3>
<p>说 Context 好像说远了，回到 react-router 4 里面，Router 组件通过 Context API(老版本) 给组件传递了 Context，也就是 router，看看 router 是什么：</p>
<pre class="hljs"><code>  getChildContext() {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">router</span>: {
        ...this.context.router,
        <span class="hljs-attr">history</span>: <span class="hljs-keyword">this</span>.props.history,
        <span class="hljs-attr">route</span>: {
          <span class="hljs-attr">location</span>: <span class="hljs-keyword">this</span>.props.history.location,
          <span class="hljs-attr">match</span>: <span class="hljs-keyword">this</span>.state.match
        }
      }
    };
  }
</code></pre>
<p>里面有 history，这个也就是</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { Router } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router'</span>
<span class="hljs-keyword">import</span> createBrowserHistory <span class="hljs-keyword">from</span> <span class="hljs-string">'history/createBrowserHistory'</span>

<span class="hljs-keyword">const</span> history = createBrowserHistory();
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span> <span class="hljs-attr">history</span>=<span class="hljs-string">{history}</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></span>
</code></pre>
<p>通过 createBrowserHistory 方法创建的 history，并传入给到 Router 组件。Context 里面第二个是 route，可以看出 router.location 就是 history 里面的 location，而 route.match 是 Router 组件里面 state.match，这个 match 在后面会介绍到。</p>
<p>上面就是 Router 组件了。常见的 Route 组件 写法：</p>
<pre class="hljs"><code>&lt;Router&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{Home}/</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/news"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{NewsFeed}/</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;<span class="hljs-regexp">/Router&gt;
</span></code></pre>
<p>再来看看 Route 组件代码：</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Route</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-comment">// 已简化部分代码</span>
  <span class="hljs-keyword">static</span> contextTypes = {
    <span class="hljs-attr">router</span>: PropTypes.shape({
      <span class="hljs-attr">history</span>: PropTypes.object.isRequired,
      <span class="hljs-attr">route</span>: PropTypes.object.isRequired,
      <span class="hljs-attr">staticContext</span>: PropTypes.object
    })
  };
  <span class="hljs-keyword">static</span> childContextTypes = {
    <span class="hljs-attr">router</span>: PropTypes.object.isRequired
  };
  getChildContext() {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">router</span>: {
        ...this.context.router,
        <span class="hljs-attr">route</span>: {
          <span class="hljs-attr">location</span>: <span class="hljs-keyword">this</span>.props.location || <span class="hljs-keyword">this</span>.context.router.route.location,
          <span class="hljs-attr">match</span>: <span class="hljs-keyword">this</span>.state.match
        }
      }
    };
  }
  state = {
    <span class="hljs-attr">match</span>: <span class="hljs-keyword">this</span>.computeMatch(<span class="hljs-keyword">this</span>.props, <span class="hljs-keyword">this</span>.context.router)
  };
  computeMatch({ computedMatch, location, path, strict, exact, sensitive }, router) {
    <span class="hljs-keyword">if</span> (computedMatch) <span class="hljs-keyword">return</span> computedMatch;<span class="hljs-comment">// 若Switch 组件已经帮我们计算好了，就返回</span>
    <span class="hljs-keyword">const</span> { route } = router;
    <span class="hljs-comment">// 传的props有location，就用location，没有，就用 context.router.route</span>
    <span class="hljs-keyword">const</span> pathname = (location || route.location).pathname; 
    <span class="hljs-keyword">return</span> matchPath(pathname, { path, strict, exact, sensitive }, route.match);
  }
  componentWillReceiveProps(nextProps, nextContext) {
    <span class="hljs-keyword">this</span>.setState({
      <span class="hljs-attr">match</span>: <span class="hljs-keyword">this</span>.computeMatch(nextProps, nextContext.router)
    });
  }
  render() {
    <span class="hljs-keyword">const</span> { match } = <span class="hljs-keyword">this</span>.state;
    <span class="hljs-keyword">const</span> { children, component, render } = <span class="hljs-keyword">this</span>.props;
    <span class="hljs-keyword">const</span> { history, route, staticContext } = <span class="hljs-keyword">this</span>.context.router;
    <span class="hljs-keyword">const</span> location = <span class="hljs-keyword">this</span>.props.location || route.location;
    <span class="hljs-keyword">const</span> props = { match, location, history, staticContext };

    <span class="hljs-keyword">if</span> (component) <span class="hljs-keyword">return</span> match ? React.createElement(component, props) : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (render) <span class="hljs-keyword">return</span> match ? render(props) : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> children === <span class="hljs-string">"function"</span>) <span class="hljs-keyword">return</span> children(props);
    <span class="hljs-keyword">if</span> (children &amp;&amp; !isEmptyChildren(children))
      <span class="hljs-keyword">return</span> React.Children.only(children);

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
}
</code></pre>
<p>可以看出 Route 组件的重点有三处：</p>
<ol>
<li>获取传递过来的 Context，并 getChildContext，新建 route。</li>
<li>match变化，location.pathname 变化的时候，修改 match。</li>
<li>根据 props 内容的不同，分别以 component/render/Children 的方式渲染子组件。</li>
</ol>
<p>这里重点看看 match，这个 match 是当前地址与该 Route 组件匹配关系。我们来看看 computeMatch 里面的 matchPath 方法：</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> pathToRegexp <span class="hljs-keyword">from</span> <span class="hljs-string">"path-to-regexp"</span>;
<span class="hljs-keyword">const</span> matchPath = <span class="hljs-function">(<span class="hljs-params">pathname, options = {}, parent</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">"string"</span>) options = { <span class="hljs-attr">path</span>: options };
  <span class="hljs-keyword">const</span> { path, exact = <span class="hljs-literal">false</span>, strict = <span class="hljs-literal">false</span>, sensitive = <span class="hljs-literal">false</span> } = options;
  <span class="hljs-comment">// 此时的parent就是 Router 里面的 state.math！如果当前路由是根路径的话， match 为 true，否之为 false；为根路径就正常渲染好了</span>
  <span class="hljs-keyword">if</span> (path == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> parent;

  <span class="hljs-keyword">const</span> { re, keys } = compilePath(path, { <span class="hljs-attr">end</span>: exact, strict, sensitive });
  <span class="hljs-comment">// match：当前定义的路由 pathname 是否匹配 Route 的 props.path</span>
  <span class="hljs-keyword">const</span> match = re.exec(pathname);
  <span class="hljs-comment">// 不匹配，则说明该 Route 组件没有匹配上，不会渲染任何子组件</span>
  <span class="hljs-keyword">if</span> (!match) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">const</span> [url, ...values] = match;
  <span class="hljs-keyword">const</span> isExact = pathname === url;
  <span class="hljs-comment">// 完全比配情况</span>
  <span class="hljs-keyword">if</span> (exact &amp;&amp; !isExact) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">return</span> {
    path,
    <span class="hljs-attr">url</span>: path === <span class="hljs-string">"/"</span> &amp;&amp; url === <span class="hljs-string">""</span> ? <span class="hljs-string">"/"</span> : url, 
    isExact,
    <span class="hljs-attr">params</span>: keys.reduce(<span class="hljs-function">(<span class="hljs-params">memo, key, index</span>) =&gt;</span> {
      memo[key.name] = values[index];
      <span class="hljs-keyword">return</span> memo;
    }, {})
  };
};
<span class="hljs-keyword">const</span> compilePath = <span class="hljs-function">(<span class="hljs-params">pattern, options</span>) =&gt;</span> {
  <span class="hljs-comment">// 去除缓存机制的主要部分</span>
  <span class="hljs-keyword">const</span> keys = [];
  <span class="hljs-keyword">const</span> re = pathToRegexp(pattern, keys, options);
  <span class="hljs-keyword">const</span> compiledPattern = { re, keys };
  <span class="hljs-keyword">return</span> compiledPattern;
};
</code></pre>
<p>可以看出 matchPath 方法，主要还是依赖于 <code>path-to-regexp</code> 包，这个在 vue-router 里面有经常看到。通过这个包，可以将传入的 pathname，与 Route 组件 props 过来的 path 进行匹配。如果不匹配则 match 为 null，在渲染的时候如果是 component/render 的方式，则 match 为 null，同时 Route 组件的渲染结果就是 null，也就是<strong>意味着该 Route 组件不匹配 pathname。</strong></p>
<p>看看computeMatch 方法里面的 pathname 变量。这个 pathname 可以是传入参数 location 的，也可以是 context.router.route 的 patchname，而后者就是 history.pathname，也是当前地址。**这个当前地址和传参 location.pathname 会不一样吗？**会的！当然会！通过控制 Route 的 props.location 就可以修改 matchPath 的传参 pathname，从而使得当前地址与该 Route 的匹配关系变更为 props 过来的 location.pathname 与该 Route 组件的匹配关系。是不是有种为所欲为的 feel。</p>
<p>Route 里面还有个值得注意的 props，是 exact，意思为是否全匹配。如果不设置，如果当要求的 <code>pathname = '/one'</code> 时，path 为 '/'，'/one' 或则 '/one/two' 的三个 Route 组件都会被匹配到。只有全匹配的时候才能精准匹配 '/one' 的组件。这也是为什么上面的 Route 写法里面会有一个 div 包裹两个 Route 组件，毕竟可能两个组件都匹配上，而 Router 组件又只能有一个 child。</p>
<h3>Switch 组件</h3>
<p>Switch 出场率还是很高的，而且 switch 这个单词也很形象，切换路由。常见的用法就是用 Switch 组件，包裹 n 个 Route 组件。Switch 组件只会渲染一个 Route 组件，如果不是精准的 Route 组件，也只会渲染一个，所以美名为切换：只能留一个的意思。</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Switch</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-comment">// 已简化部分代码</span>
  <span class="hljs-keyword">static</span> contextTypes = {
    <span class="hljs-attr">router</span>: PropTypes.shape({
      <span class="hljs-attr">route</span>: PropTypes.object.isRequired
    }).isRequired
  };
  render() {
    <span class="hljs-keyword">const</span> { route } = <span class="hljs-keyword">this</span>.context.router;
    <span class="hljs-keyword">const</span> { children } = <span class="hljs-keyword">this</span>.props;
    <span class="hljs-keyword">const</span> location = <span class="hljs-keyword">this</span>.props.location || route.location;

    <span class="hljs-keyword">let</span> match, child;
    React.Children.forEach(children, element =&gt; {
      <span class="hljs-keyword">if</span> (match == <span class="hljs-literal">null</span> &amp;&amp; React.isValidElement(element)) {
        <span class="hljs-keyword">const</span> {
          <span class="hljs-attr">path</span>: pathProp,
          exact,
          strict,
          sensitive,
          <span class="hljs-keyword">from</span>
        } = element.props;
        <span class="hljs-keyword">const</span> path = pathProp || <span class="hljs-keyword">from</span>;

        child = element;
        match = matchPath(
          location.pathname,
          { path, exact, strict, sensitive },
          route.match
        );
      }
    });
    <span class="hljs-keyword">return</span> match
      ? React.cloneElement(child, { location, <span class="hljs-attr">computedMatch</span>: match })
      : <span class="hljs-literal">null</span>;
  }
}
</code></pre>
<p>这个 Switch 组件还是蛮简单的，对子节点 Route 组件进行遍历。对于 match 变量，和 Route 里面计算 math 的相同，都是调用 matchPath 方法，只是不同的地方在于传入 matchPath 的 pathname 参数是 Swith 自己的 props.location.patchname，而不是 Route 自己的 props.location.pathname。当计算出 match 之后，若符合就不会继续遍历其他 Route 组件了，从而实现仅渲染单个 Route 组件。</p>
<p>在回头看看 Route 组件里面的 computeMatch 方法，当有 props.computedMatch 的时候，直接返回 computedMatch，不会继续下面自己的 matchPath 方法了，这个 props.computedMatch 正是 Switch 计算出来 match 变量。直接让 Route 组件自己的 props.location 与 context.router.route 无效化。<strong>这就说明了 Switch 组件对其下面 Route 组件的渲染不仅是单独渲染，更有筛选作用。</strong></p>
<p>这个时候在看看开头说的项目中遇到的 SPA 路由切换问题，官网给出的<a href="https://reacttraining.com/react-router/web/example/animated-transitions" target="_blank">方案</a> 采用的方式，通过 Switch 组件的 props.location 实现对其下面的 Route 组件渲染。当路由变化的时候，前一个 Route 组件不会立马消失，而是在 Switch 组件下继续现实，route 的 key 值并没有变化。同时新的 Route 也会继续出现，从而实现过渡效果。</p>
<h3>其他组件</h3>
<p>Redirct 组件里面需要注意的是 props.from 是在 Switch 组件里面生效的，<code>const path = pathProp || from</code>，来计算 computedMatch，最后的结果则是
从 match 的里面结合 to 得出的路径，不是简简单单的 '/nameList/:id'，要具体到 id 是多少。当然这里还是用到了 <code>path-to-regexp</code> 模块。</p>
<p>StaticRouter 针对服务端渲染的问题，有新的 Context 传过来 staticContext，在 Redirct 里面用得比较多。</p>
<p>withRouter 是个 HOC 高阶组件，意在通过修饰者语句将组件传入 withRouter 里面。<a href="https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over" target="_blank">官网</a>里面介绍了一点。withRouter 可以将 Route 组件里面 match location history 传给过来目标组件，用处还是挺好的。</p>
<p>MemoryRouter 和 Promt 组件都比较简单，这里就不介绍了。</p>
<h2>参考</h2>
<ol>
<li><a href="https://reacttraining.com/react-router/core/guides/philosophy" target="_blank">官方文档 react-router 4</a></li>
<li><a href="https://reactjs.org/docs/context.html" target="_blank">官方文档 react 16.3 context</a></li>
</ol>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"March 24, 2021","title":"react-router 4 与 context","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e最近我司要上线一个 Hybird 上的 SPA，17 年年底的时候已经写过 demo 给产品和 leader 看了，近期准备要上线。问题在于，当时准备仓促，又想要玩一玩 react，导致了用的版本是比较成熟的，嗯。。。。意思就是比较老的版本，react-router 是 3.x 版本，而 react 也只是 16.0 而已。对于有追求的我而言，升级势在必行。\u003c/p\u003e\n\u003ch2\u003e问题所在\u003c/h2\u003e\n\u003cp\u003e在 Vue 应用里面用 Vue-router 就是一个 routes 的事情，甚至连 routes 都可以不是嵌套解构，直接一维路由，毕竟业务少。到了之前写的 react 也是采用了这种方式，如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eReactDOM.render(\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eRouter\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eroutes\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{RouteConfig}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehistory\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{hashHistory}\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eRouter\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e,\n  \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.getElementById(\u003cspan class=\"hljs-string\"\u003e'root'\u003c/span\u003e)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRouteConfig 基本上也是一维结构，传入到 routes 就好了。然而 routes 这个 props 已经在 react-router 4 里面消失掉了，之前版本采用的是静态路由来配置的，而到了 react-router 4，则采用动态组件。。。如果还需要静态的方式可以采用 \u003ccode\u003ereact-router-config\u003c/code\u003e。这个变化使得 react-router 4 升级变得麻烦，由路由配置变成动态映射，这里还有官网提到的\u003ca href=\"https://reacttraining.com/react-router/web/guides/philosophy\" target=\"_blank\"\u003e哲学\u003c/a\u003e。吐槽一下：开始看官网教程的时候，感觉像一坨屎一样，东一块西一块的，不知道在说什么，这也是去年选 react-router 版本的时候直接放弃 V4 的原因。最近看这个官网，却越看越好，觉得写得相当的优秀用心，赞一个。\u003c/p\u003e\n\u003cp\u003e对于 APP 上面的页面过渡动画效果，则采用 \u003ccode\u003ereact-addons-css-transition-group\u003c/code\u003e 的 ReactCSSTransitionGroup 组件，这也是比较成熟的方法了，这也是之前官网推荐的方式。让而到了当你点开\u003ca href=\"https://www.npmjs.com/package/react-addons-css-transition-group\" target=\"_blank\"\u003enpm上的介绍\u003c/a\u003e时候，发现原来 \u003ccode\u003ereact-addons-css-transition-group\u003c/code\u003e 已经不被推荐了：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe code in this package has moved. We recommend you to use CSSTransitionGroup from react-transition-group instead.\u003c/p\u003e\n\u003cp\u003eIn particular, its version 1.x is a drop-in replacement for the last released version of react-addons-css-transition-group.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e然而现实是无情的，只能使用 \u003ccode\u003ereact-addons-css-transition-group\u003c/code\u003e 的 V 1.x 版本，这对于一个前端工程师怎么可以容忍呢？新版本里面肯定有适合的 API 嘛，为什么一定要用 ReactCSSTransitionGroup 呢？然而官网一开始看也是烂得不能入眼（可能是英文的缘故没有耐心看）。最后还是在 react-router 4 的\u003ca href=\"https://reacttraining.com/react-router/web/example/animated-transitions\" target=\"_blank\"\u003e官网\u003c/a\u003e里面找到解决办法。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e只是一开始傻乎乎的用，抄也没有抄全，部分按照自己的思路走，经常报错\u003c/strong\u003e，只有全抄过来才对。。妈呀太可怕了。于是乎想要看看研究一下 react-router 4 的设计！\u003c/p\u003e\n\u003ch3\u003e从 Router 出发的 Context\u003c/h3\u003e\n\u003cp\u003ereact-router 4 里面依然有 Router，精简一下，Router 代码如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eRouter\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title\"\u003eComponent\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e contextTypes = {\n    \u003cspan class=\"hljs-attr\"\u003erouter\u003c/span\u003e: PropTypes.object\n  };\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e childContextTypes = {\n    \u003cspan class=\"hljs-attr\"\u003erouter\u003c/span\u003e: PropTypes.object.isRequired\n  };\n  getChildContext() {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n      \u003cspan class=\"hljs-attr\"\u003erouter\u003c/span\u003e: {\n        ...this.context.router,\n        \u003cspan class=\"hljs-attr\"\u003ehistory\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props.history,\n        \u003cspan class=\"hljs-attr\"\u003eroute\u003c/span\u003e: {\n          \u003cspan class=\"hljs-attr\"\u003elocation\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props.history.location,\n          \u003cspan class=\"hljs-attr\"\u003ematch\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state.match\n        }\n      }\n    };\n  }\n  state = {\n    \u003cspan class=\"hljs-attr\"\u003ematch\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.computeMatch(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props.history.location.pathname)\n  };\n  computeMatch(pathname) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n      \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eurl\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eparams\u003c/span\u003e: {},\n      \u003cspan class=\"hljs-attr\"\u003eisExact\u003c/span\u003e: pathname === \u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e\n    };\n  }\n  render() {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { children } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e children ? React.Children.only(children) : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e去除掉提示性报错，PropTypes以及需要在 componentWillMount/componentWillUnmount 和服务端渲染相关的操作 \u003ccode\u003ethis.unlisten\u003c/code\u003e 部分，就只剩下这么一点点了。 Router 组件负责渲染子节点，没有就 null，简单吧。那要 Router 有何用？看看大头 childContextTypes/getChildContext 这又是什么？\u003c/p\u003e\n\u003cp\u003eReact 是有自己的 Context API 的，只是不建议开发者使用，并称之为实验性特性，可能移除，不熟悉 Redux/MobX 的最好都不要碰 Context API，俨然是不让人用的样子。Context API 使用还挺简单的，只要在 context 的提供者组件上申明一下就好了，包括 childContextTypes 以及 getChildContext 方法，这样在子组件里面在定义声明一下 contextTypes 就能够使用了。子组件里面怎么使用呢？通过 contextTypes 声明后直接用 \u003ccode\u003ethis.context\u003c/code\u003e 就能够访问了。上面的 Router 中，其子组件在声明后，若要访问 Router 中的 router，直接用 \u003ccode\u003ethis.context.router\u003c/code\u003e 就好了，是不是很简单！甚至在组件的生命周期里面也有 Context 传过来，这岂不是非常好，这样就不用一直 props 参数到子组件了，用 Context API 就好了，为何官方是不推荐使用的呢？\u003c/p\u003e\n\u003cp\u003e官网提到：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e问题在于，组件提供的context值改变，后代元素如果 shouldComponentUpdate 返回 false 那么context的将不会更新。这使得使用context的组件完全失控，所以基本上没有办法可靠的更新context。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这就是问题所在了，所以是不推荐的。嗯。。。至于 react-router 4 里面这么用嘛。。。。反正也没有用到 shouldComponentUpdate 钩子，而且大神这么用还显得非常溜呢。再查 Context API 的时候，忽然发现原来上个月 React 16.3 有了全新的 Context API，\u003cstrong\u003e不再是不建议使用了\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3\u003eReact 16.3 Context API\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eContext provides a way to pass data through the component tree without having to pass props down manually at every level.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e看到官网介绍，大大觉得这个功能很实在，这不就解决了父子/孙子组件之间的通信问题了吗，呀，那那 redux 是不是可以不用了。。。。当然不是。这里先不说为什么，先看看 React 16.3 Context API 有什么：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eReact.createContext\u003cT\u003e(defaultValue: T)\u003c/li\u003e\n\u003cli\u003eProvider: React.ComponentType\u0026lt;{value: T}\u0026gt;\u003c/li\u003e\n\u003cli\u003eConsumer: React.ComponentType\u0026lt;{children: (value: T)=\u0026gt; React.ReactNode}\u0026gt;\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e第一个是创建方法，生成一个 { Provider, Consumer } 对。Consumer 将从最近的 Provider 中读取 context value，如果没有匹配的 Provider，将从 defaultValue 中读取值。是不是也很简单？但是意义却是非凡的。Provider 和 Consumer 可以放在自己想想要用的组件上面，不用顾虑组件的层级关系。可以通过对创建的 \u003ccode\u003eReact.createContext\u003c/code\u003e import 到想要用的组件就好了。这不就是相当于穿梭机嘛。数据飞来飞去多有趣。官网给了很好的\u003ca href=\"https://reactjs.org/docs/context.html#when-to-use-context\" target=\"_blank\"\u003e例子\u003c/a\u003e，这里就不介绍具体用法了。反正记住：创建的{ Provider, Consumer } 对，Provider 组件提供 context value， 而这个 value 是以 props 的形式进入 Consumer 的子组件的，是不是很骚，不是 \u003ccode\u003ethis.context\u003c/code\u003e，而是通过 \u003ccode\u003ethis.props\u003c/code\u003e 传入的！还是下面这个简单例子吧：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ThemeContext = React.createContext({\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'ni'\u003c/span\u003e\n});\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eThemeContext.Provider\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{name:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003enoNi\u003c/span\u003e'}\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eThemeContext.Consumer\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  { context =\u0026gt; (\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u0026gt;\u003c/span\u003e{ context.name }\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  )}\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eThemeContext.Consumer\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eThemeContext.Provider\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面例子是不推荐用的，太暴殄天物了，这里是只是简单介绍一下形式而已，**Context API 的优势在于多层次的嵌套组件！**Provider 组件里面的传值 value 一般不是固定的嘛，要不然传值干嘛？一般传入 state/props 作为 value，state/props 一变化就可以触发组件 Provider/Consumer 更新了。\u003c/p\u003e\n\u003cp\u003e可以看出这个 Context API ，和 Redux 的功能似乎有点重叠，都是通信问题。只是很明显的是 Redux 和 Context API 是有区别的，Redux 分离了数据和视图，而 Context API 还是在视图层做文章，并且过于灵活，不利于团队开发，不如 Redux 的数据控制来的规范清晰。并且 Redux 更多的是存储数据，Context API 更多还是一个状态的变化，一个从父组件传递到子组件的状态而已，这么看来更像是 state。另外呢，**对于 SPA 还有个问题，当页面切换的时候，需要传递给下个页面的信息，可以通过路由拼接参数传递，或者就是用 Redux 存储了，而这里 Context API 完全没有用武之地。。。还是很悲哀的。。**这么看来 Redux 还是很会有必要的。为此还有一篇\u003ca href=\"http://blog.isquaredsoftware.com/2018/03/redux-not-dead-yet/\" target=\"_blank\"\u003e澄清的采访\u003c/a\u003e。当然对于小项目嘛，这个 Context API 完全是福利呀，为了传递个 props 而已，就不要用沉重麻烦的 redux 啦，多幸福。\u003c/p\u003e\n\u003ch3\u003eRouter 与 Route\u003c/h3\u003e\n\u003cp\u003e说 Context 好像说远了，回到 react-router 4 里面，Router 组件通过 Context API(老版本) 给组件传递了 Context，也就是 router，看看 router 是什么：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e  getChildContext() {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n      \u003cspan class=\"hljs-attr\"\u003erouter\u003c/span\u003e: {\n        ...this.context.router,\n        \u003cspan class=\"hljs-attr\"\u003ehistory\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props.history,\n        \u003cspan class=\"hljs-attr\"\u003eroute\u003c/span\u003e: {\n          \u003cspan class=\"hljs-attr\"\u003elocation\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props.history.location,\n          \u003cspan class=\"hljs-attr\"\u003ematch\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state.match\n        }\n      }\n    };\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e里面有 history，这个也就是\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { Router } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-router'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e createBrowserHistory \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'history/createBrowserHistory'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e history = createBrowserHistory();\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eRouter\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehistory\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{history}\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eApp\u003c/span\u003e/\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eRouter\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过 createBrowserHistory 方法创建的 history，并传入给到 Router 组件。Context 里面第二个是 route，可以看出 router.location 就是 history 里面的 location，而 route.match 是 Router 组件里面 state.match，这个 match 在后面会介绍到。\u003c/p\u003e\n\u003cp\u003e上面就是 Router 组件了。常见的 Route 组件 写法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u0026lt;Router\u0026gt;\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eRoute\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eexact\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{Home}/\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eRoute\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/news\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{NewsFeed}/\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u0026lt;\u003cspan class=\"hljs-regexp\"\u003e/Router\u0026gt;\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再来看看 Route 组件代码：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eRoute\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title\"\u003eComponent\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 已简化部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e contextTypes = {\n    \u003cspan class=\"hljs-attr\"\u003erouter\u003c/span\u003e: PropTypes.shape({\n      \u003cspan class=\"hljs-attr\"\u003ehistory\u003c/span\u003e: PropTypes.object.isRequired,\n      \u003cspan class=\"hljs-attr\"\u003eroute\u003c/span\u003e: PropTypes.object.isRequired,\n      \u003cspan class=\"hljs-attr\"\u003estaticContext\u003c/span\u003e: PropTypes.object\n    })\n  };\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e childContextTypes = {\n    \u003cspan class=\"hljs-attr\"\u003erouter\u003c/span\u003e: PropTypes.object.isRequired\n  };\n  getChildContext() {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n      \u003cspan class=\"hljs-attr\"\u003erouter\u003c/span\u003e: {\n        ...this.context.router,\n        \u003cspan class=\"hljs-attr\"\u003eroute\u003c/span\u003e: {\n          \u003cspan class=\"hljs-attr\"\u003elocation\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props.location || \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.context.router.route.location,\n          \u003cspan class=\"hljs-attr\"\u003ematch\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state.match\n        }\n      }\n    };\n  }\n  state = {\n    \u003cspan class=\"hljs-attr\"\u003ematch\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.computeMatch(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.context.router)\n  };\n  computeMatch({ computedMatch, location, path, strict, exact, sensitive }, router) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (computedMatch) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e computedMatch;\u003cspan class=\"hljs-comment\"\u003e// 若Switch 组件已经帮我们计算好了，就返回\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { route } = router;\n    \u003cspan class=\"hljs-comment\"\u003e// 传的props有location，就用location，没有，就用 context.router.route\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pathname = (location || route.location).pathname; \n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e matchPath(pathname, { path, strict, exact, sensitive }, route.match);\n  }\n  componentWillReceiveProps(nextProps, nextContext) {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.setState({\n      \u003cspan class=\"hljs-attr\"\u003ematch\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.computeMatch(nextProps, nextContext.router)\n    });\n  }\n  render() {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { match } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { children, component, render } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { history, route, staticContext } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.context.router;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e location = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props.location || route.location;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e props = { match, location, history, staticContext };\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e match ? React.createElement(component, props) : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (render) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e match ? render(props) : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e children === \u003cspan class=\"hljs-string\"\u003e\"function\"\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e children(props);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (children \u0026amp;\u0026amp; !isEmptyChildren(children))\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e React.Children.only(children);\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看出 Route 组件的重点有三处：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e获取传递过来的 Context，并 getChildContext，新建 route。\u003c/li\u003e\n\u003cli\u003ematch变化，location.pathname 变化的时候，修改 match。\u003c/li\u003e\n\u003cli\u003e根据 props 内容的不同，分别以 component/render/Children 的方式渲染子组件。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这里重点看看 match，这个 match 是当前地址与该 Route 组件匹配关系。我们来看看 computeMatch 里面的 matchPath 方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pathToRegexp \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"path-to-regexp\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e matchPath = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003epathname, options = {}, parent\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e options === \u003cspan class=\"hljs-string\"\u003e\"string\"\u003c/span\u003e) options = { \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: options };\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { path, exact = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, strict = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, sensitive = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e } = options;\n  \u003cspan class=\"hljs-comment\"\u003e// 此时的parent就是 Router 里面的 state.math！如果当前路由是根路径的话， match 为 true，否之为 false；为根路径就正常渲染好了\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (path == \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e parent;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { re, keys } = compilePath(path, { \u003cspan class=\"hljs-attr\"\u003eend\u003c/span\u003e: exact, strict, sensitive });\n  \u003cspan class=\"hljs-comment\"\u003e// match：当前定义的路由 pathname 是否匹配 Route 的 props.path\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e match = re.exec(pathname);\n  \u003cspan class=\"hljs-comment\"\u003e// 不匹配，则说明该 Route 组件没有匹配上，不会渲染任何子组件\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!match) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [url, ...values] = match;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isExact = pathname === url;\n  \u003cspan class=\"hljs-comment\"\u003e// 完全比配情况\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (exact \u0026amp;\u0026amp; !isExact) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    path,\n    \u003cspan class=\"hljs-attr\"\u003eurl\u003c/span\u003e: path === \u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e \u0026amp;\u0026amp; url === \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e ? \u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e : url, \n    isExact,\n    \u003cspan class=\"hljs-attr\"\u003eparams\u003c/span\u003e: keys.reduce(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ememo, key, index\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n      memo[key.name] = values[index];\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e memo;\n    }, {})\n  };\n};\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e compilePath = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003epattern, options\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 去除缓存机制的主要部分\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e keys = [];\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e re = pathToRegexp(pattern, keys, options);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e compiledPattern = { re, keys };\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e compiledPattern;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看出 matchPath 方法，主要还是依赖于 \u003ccode\u003epath-to-regexp\u003c/code\u003e 包，这个在 vue-router 里面有经常看到。通过这个包，可以将传入的 pathname，与 Route 组件 props 过来的 path 进行匹配。如果不匹配则 match 为 null，在渲染的时候如果是 component/render 的方式，则 match 为 null，同时 Route 组件的渲染结果就是 null，也就是\u003cstrong\u003e意味着该 Route 组件不匹配 pathname。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e看看computeMatch 方法里面的 pathname 变量。这个 pathname 可以是传入参数 location 的，也可以是 context.router.route 的 patchname，而后者就是 history.pathname，也是当前地址。**这个当前地址和传参 location.pathname 会不一样吗？**会的！当然会！通过控制 Route 的 props.location 就可以修改 matchPath 的传参 pathname，从而使得当前地址与该 Route 的匹配关系变更为 props 过来的 location.pathname 与该 Route 组件的匹配关系。是不是有种为所欲为的 feel。\u003c/p\u003e\n\u003cp\u003eRoute 里面还有个值得注意的 props，是 exact，意思为是否全匹配。如果不设置，如果当要求的 \u003ccode\u003epathname = '/one'\u003c/code\u003e 时，path 为 '/'，'/one' 或则 '/one/two' 的三个 Route 组件都会被匹配到。只有全匹配的时候才能精准匹配 '/one' 的组件。这也是为什么上面的 Route 写法里面会有一个 div 包裹两个 Route 组件，毕竟可能两个组件都匹配上，而 Router 组件又只能有一个 child。\u003c/p\u003e\n\u003ch3\u003eSwitch 组件\u003c/h3\u003e\n\u003cp\u003eSwitch 出场率还是很高的，而且 switch 这个单词也很形象，切换路由。常见的用法就是用 Switch 组件，包裹 n 个 Route 组件。Switch 组件只会渲染一个 Route 组件，如果不是精准的 Route 组件，也只会渲染一个，所以美名为切换：只能留一个的意思。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eSwitch\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title\"\u003eComponent\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 已简化部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e contextTypes = {\n    \u003cspan class=\"hljs-attr\"\u003erouter\u003c/span\u003e: PropTypes.shape({\n      \u003cspan class=\"hljs-attr\"\u003eroute\u003c/span\u003e: PropTypes.object.isRequired\n    }).isRequired\n  };\n  render() {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { route } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.context.router;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { children } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e location = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props.location || route.location;\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e match, child;\n    React.Children.forEach(children, element =\u0026gt; {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (match == \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026amp;\u0026amp; React.isValidElement(element)) {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e {\n          \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: pathProp,\n          exact,\n          strict,\n          sensitive,\n          \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e\n        } = element.props;\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e path = pathProp || \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e;\n\n        child = element;\n        match = matchPath(\n          location.pathname,\n          { path, exact, strict, sensitive },\n          route.match\n        );\n      }\n    });\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e match\n      ? React.cloneElement(child, { location, \u003cspan class=\"hljs-attr\"\u003ecomputedMatch\u003c/span\u003e: match })\n      : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个 Switch 组件还是蛮简单的，对子节点 Route 组件进行遍历。对于 match 变量，和 Route 里面计算 math 的相同，都是调用 matchPath 方法，只是不同的地方在于传入 matchPath 的 pathname 参数是 Swith 自己的 props.location.patchname，而不是 Route 自己的 props.location.pathname。当计算出 match 之后，若符合就不会继续遍历其他 Route 组件了，从而实现仅渲染单个 Route 组件。\u003c/p\u003e\n\u003cp\u003e在回头看看 Route 组件里面的 computeMatch 方法，当有 props.computedMatch 的时候，直接返回 computedMatch，不会继续下面自己的 matchPath 方法了，这个 props.computedMatch 正是 Switch 计算出来 match 变量。直接让 Route 组件自己的 props.location 与 context.router.route 无效化。\u003cstrong\u003e这就说明了 Switch 组件对其下面 Route 组件的渲染不仅是单独渲染，更有筛选作用。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e这个时候在看看开头说的项目中遇到的 SPA 路由切换问题，官网给出的\u003ca href=\"https://reacttraining.com/react-router/web/example/animated-transitions\" target=\"_blank\"\u003e方案\u003c/a\u003e 采用的方式，通过 Switch 组件的 props.location 实现对其下面的 Route 组件渲染。当路由变化的时候，前一个 Route 组件不会立马消失，而是在 Switch 组件下继续现实，route 的 key 值并没有变化。同时新的 Route 也会继续出现，从而实现过渡效果。\u003c/p\u003e\n\u003ch3\u003e其他组件\u003c/h3\u003e\n\u003cp\u003eRedirct 组件里面需要注意的是 props.from 是在 Switch 组件里面生效的，\u003ccode\u003econst path = pathProp || from\u003c/code\u003e，来计算 computedMatch，最后的结果则是\n从 match 的里面结合 to 得出的路径，不是简简单单的 '/nameList/:id'，要具体到 id 是多少。当然这里还是用到了 \u003ccode\u003epath-to-regexp\u003c/code\u003e 模块。\u003c/p\u003e\n\u003cp\u003eStaticRouter 针对服务端渲染的问题，有新的 Context 传过来 staticContext，在 Redirct 里面用得比较多。\u003c/p\u003e\n\u003cp\u003ewithRouter 是个 HOC 高阶组件，意在通过修饰者语句将组件传入 withRouter 里面。\u003ca href=\"https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over\" target=\"_blank\"\u003e官网\u003c/a\u003e里面介绍了一点。withRouter 可以将 Route 组件里面 match location history 传给过来目标组件，用处还是挺好的。\u003c/p\u003e\n\u003cp\u003eMemoryRouter 和 Promt 组件都比较简单，这里就不介绍了。\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://reacttraining.com/react-router/core/guides/philosophy\" target=\"_blank\"\u003e官方文档 react-router 4\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://reactjs.org/docs/context.html\" target=\"_blank\"\u003e官方文档 react 16.3 context\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"March 24, 2021","title":"react-router 4 与 context","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e最近我司要上线一个 Hybird 上的 SPA，17 年年底的时候已经写过 demo 给产品和 leader 看了，近期准备要上线。问题在于，当时准备仓促，又想要玩一玩 react，导致了用的版本是比较成熟的，嗯。。。。意思就是比较老的版本，react-router 是 3.x 版本，而 react 也只是 16.0 而已。对于有追求的我而言，升级势在必行。\u003c/p\u003e\n\u003ch2\u003e问题所在\u003c/h2\u003e\n\u003cp\u003e在 Vue 应用里面用 Vue-router 就是一个 routes 的事情，甚至连 routes 都可以不是嵌套解构，直接一维路由，毕竟业务少。到了之前写的 react 也是采用了这种方式，如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eReactDOM.render(\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eRouter\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eroutes\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{RouteConfig}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehistory\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{hashHistory}\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eRouter\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e,\n  \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.getElementById(\u003cspan class=\"hljs-string\"\u003e'root'\u003c/span\u003e)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRouteConfig 基本上也是一维结构，传入到 routes 就好了。然而 routes 这个 props 已经在 react-router 4 里面消失掉了，之前版本采用的是静态路由来配置的，而到了 react-router 4，则采用动态组件。。。如果还需要静态的方式可以采用 \u003ccode\u003ereact-router-config\u003c/code\u003e。这个变化使得 react-router 4 升级变得麻烦，由路由配置变成动态映射，这里还有官网提到的\u003ca href=\"https://reacttraining.com/react-router/web/guides/philosophy\" target=\"_blank\"\u003e哲学\u003c/a\u003e。吐槽一下：开始看官网教程的时候，感觉像一坨屎一样，东一块西一块的，不知道在说什么，这也是去年选 react-router 版本的时候直接放弃 V4 的原因。最近看这个官网，却越看越好，觉得写得相当的优秀用心，赞一个。\u003c/p\u003e\n\u003cp\u003e对于 APP 上面的页面过渡动画效果，则采用 \u003ccode\u003ereact-addons-css-transition-group\u003c/code\u003e 的 ReactCSSTransitionGroup 组件，这也是比较成熟的方法了，这也是之前官网推荐的方式。让而到了当你点开\u003ca href=\"https://www.npmjs.com/package/react-addons-css-transition-group\" target=\"_blank\"\u003enpm上的介绍\u003c/a\u003e时候，发现原来 \u003ccode\u003ereact-addons-css-transition-group\u003c/code\u003e 已经不被推荐了：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe code in this package has moved. We recommend you to use CSSTransitionGroup from react-transition-group instead.\u003c/p\u003e\n\u003cp\u003eIn particular, its version 1.x is a drop-in replacement for the last released version of react-addons-css-transition-group.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e然而现实是无情的，只能使用 \u003ccode\u003ereact-addons-css-transition-group\u003c/code\u003e 的 V 1.x 版本，这对于一个前端工程师怎么可以容忍呢？新版本里面肯定有适合的 API 嘛，为什么一定要用 ReactCSSTransitionGroup 呢？然而官网一开始看也是烂得不能入眼（可能是英文的缘故没有耐心看）。最后还是在 react-router 4 的\u003ca href=\"https://reacttraining.com/react-router/web/example/animated-transitions\" target=\"_blank\"\u003e官网\u003c/a\u003e里面找到解决办法。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e只是一开始傻乎乎的用，抄也没有抄全，部分按照自己的思路走，经常报错\u003c/strong\u003e，只有全抄过来才对。。妈呀太可怕了。于是乎想要看看研究一下 react-router 4 的设计！\u003c/p\u003e\n\u003ch3\u003e从 Router 出发的 Context\u003c/h3\u003e\n\u003cp\u003ereact-router 4 里面依然有 Router，精简一下，Router 代码如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eRouter\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title\"\u003eComponent\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e contextTypes = {\n    \u003cspan class=\"hljs-attr\"\u003erouter\u003c/span\u003e: PropTypes.object\n  };\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e childContextTypes = {\n    \u003cspan class=\"hljs-attr\"\u003erouter\u003c/span\u003e: PropTypes.object.isRequired\n  };\n  getChildContext() {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n      \u003cspan class=\"hljs-attr\"\u003erouter\u003c/span\u003e: {\n        ...this.context.router,\n        \u003cspan class=\"hljs-attr\"\u003ehistory\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props.history,\n        \u003cspan class=\"hljs-attr\"\u003eroute\u003c/span\u003e: {\n          \u003cspan class=\"hljs-attr\"\u003elocation\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props.history.location,\n          \u003cspan class=\"hljs-attr\"\u003ematch\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state.match\n        }\n      }\n    };\n  }\n  state = {\n    \u003cspan class=\"hljs-attr\"\u003ematch\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.computeMatch(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props.history.location.pathname)\n  };\n  computeMatch(pathname) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n      \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eurl\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eparams\u003c/span\u003e: {},\n      \u003cspan class=\"hljs-attr\"\u003eisExact\u003c/span\u003e: pathname === \u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e\n    };\n  }\n  render() {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { children } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e children ? React.Children.only(children) : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e去除掉提示性报错，PropTypes以及需要在 componentWillMount/componentWillUnmount 和服务端渲染相关的操作 \u003ccode\u003ethis.unlisten\u003c/code\u003e 部分，就只剩下这么一点点了。 Router 组件负责渲染子节点，没有就 null，简单吧。那要 Router 有何用？看看大头 childContextTypes/getChildContext 这又是什么？\u003c/p\u003e\n\u003cp\u003eReact 是有自己的 Context API 的，只是不建议开发者使用，并称之为实验性特性，可能移除，不熟悉 Redux/MobX 的最好都不要碰 Context API，俨然是不让人用的样子。Context API 使用还挺简单的，只要在 context 的提供者组件上申明一下就好了，包括 childContextTypes 以及 getChildContext 方法，这样在子组件里面在定义声明一下 contextTypes 就能够使用了。子组件里面怎么使用呢？通过 contextTypes 声明后直接用 \u003ccode\u003ethis.context\u003c/code\u003e 就能够访问了。上面的 Router 中，其子组件在声明后，若要访问 Router 中的 router，直接用 \u003ccode\u003ethis.context.router\u003c/code\u003e 就好了，是不是很简单！甚至在组件的生命周期里面也有 Context 传过来，这岂不是非常好，这样就不用一直 props 参数到子组件了，用 Context API 就好了，为何官方是不推荐使用的呢？\u003c/p\u003e\n\u003cp\u003e官网提到：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e问题在于，组件提供的context值改变，后代元素如果 shouldComponentUpdate 返回 false 那么context的将不会更新。这使得使用context的组件完全失控，所以基本上没有办法可靠的更新context。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这就是问题所在了，所以是不推荐的。嗯。。。至于 react-router 4 里面这么用嘛。。。。反正也没有用到 shouldComponentUpdate 钩子，而且大神这么用还显得非常溜呢。再查 Context API 的时候，忽然发现原来上个月 React 16.3 有了全新的 Context API，\u003cstrong\u003e不再是不建议使用了\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3\u003eReact 16.3 Context API\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eContext provides a way to pass data through the component tree without having to pass props down manually at every level.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e看到官网介绍，大大觉得这个功能很实在，这不就解决了父子/孙子组件之间的通信问题了吗，呀，那那 redux 是不是可以不用了。。。。当然不是。这里先不说为什么，先看看 React 16.3 Context API 有什么：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eReact.createContext\u003cT\u003e(defaultValue: T)\u003c/li\u003e\n\u003cli\u003eProvider: React.ComponentType\u0026lt;{value: T}\u0026gt;\u003c/li\u003e\n\u003cli\u003eConsumer: React.ComponentType\u0026lt;{children: (value: T)=\u0026gt; React.ReactNode}\u0026gt;\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e第一个是创建方法，生成一个 { Provider, Consumer } 对。Consumer 将从最近的 Provider 中读取 context value，如果没有匹配的 Provider，将从 defaultValue 中读取值。是不是也很简单？但是意义却是非凡的。Provider 和 Consumer 可以放在自己想想要用的组件上面，不用顾虑组件的层级关系。可以通过对创建的 \u003ccode\u003eReact.createContext\u003c/code\u003e import 到想要用的组件就好了。这不就是相当于穿梭机嘛。数据飞来飞去多有趣。官网给了很好的\u003ca href=\"https://reactjs.org/docs/context.html#when-to-use-context\" target=\"_blank\"\u003e例子\u003c/a\u003e，这里就不介绍具体用法了。反正记住：创建的{ Provider, Consumer } 对，Provider 组件提供 context value， 而这个 value 是以 props 的形式进入 Consumer 的子组件的，是不是很骚，不是 \u003ccode\u003ethis.context\u003c/code\u003e，而是通过 \u003ccode\u003ethis.props\u003c/code\u003e 传入的！还是下面这个简单例子吧：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ThemeContext = React.createContext({\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'ni'\u003c/span\u003e\n});\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eThemeContext.Provider\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{name:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003enoNi\u003c/span\u003e'}\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eThemeContext.Consumer\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  { context =\u0026gt; (\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u0026gt;\u003c/span\u003e{ context.name }\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  )}\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eThemeContext.Consumer\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eThemeContext.Provider\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面例子是不推荐用的，太暴殄天物了，这里是只是简单介绍一下形式而已，**Context API 的优势在于多层次的嵌套组件！**Provider 组件里面的传值 value 一般不是固定的嘛，要不然传值干嘛？一般传入 state/props 作为 value，state/props 一变化就可以触发组件 Provider/Consumer 更新了。\u003c/p\u003e\n\u003cp\u003e可以看出这个 Context API ，和 Redux 的功能似乎有点重叠，都是通信问题。只是很明显的是 Redux 和 Context API 是有区别的，Redux 分离了数据和视图，而 Context API 还是在视图层做文章，并且过于灵活，不利于团队开发，不如 Redux 的数据控制来的规范清晰。并且 Redux 更多的是存储数据，Context API 更多还是一个状态的变化，一个从父组件传递到子组件的状态而已，这么看来更像是 state。另外呢，**对于 SPA 还有个问题，当页面切换的时候，需要传递给下个页面的信息，可以通过路由拼接参数传递，或者就是用 Redux 存储了，而这里 Context API 完全没有用武之地。。。还是很悲哀的。。**这么看来 Redux 还是很会有必要的。为此还有一篇\u003ca href=\"http://blog.isquaredsoftware.com/2018/03/redux-not-dead-yet/\" target=\"_blank\"\u003e澄清的采访\u003c/a\u003e。当然对于小项目嘛，这个 Context API 完全是福利呀，为了传递个 props 而已，就不要用沉重麻烦的 redux 啦，多幸福。\u003c/p\u003e\n\u003ch3\u003eRouter 与 Route\u003c/h3\u003e\n\u003cp\u003e说 Context 好像说远了，回到 react-router 4 里面，Router 组件通过 Context API(老版本) 给组件传递了 Context，也就是 router，看看 router 是什么：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e  getChildContext() {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n      \u003cspan class=\"hljs-attr\"\u003erouter\u003c/span\u003e: {\n        ...this.context.router,\n        \u003cspan class=\"hljs-attr\"\u003ehistory\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props.history,\n        \u003cspan class=\"hljs-attr\"\u003eroute\u003c/span\u003e: {\n          \u003cspan class=\"hljs-attr\"\u003elocation\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props.history.location,\n          \u003cspan class=\"hljs-attr\"\u003ematch\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state.match\n        }\n      }\n    };\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e里面有 history，这个也就是\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { Router } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-router'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e createBrowserHistory \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'history/createBrowserHistory'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e history = createBrowserHistory();\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eRouter\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehistory\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{history}\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eApp\u003c/span\u003e/\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eRouter\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过 createBrowserHistory 方法创建的 history，并传入给到 Router 组件。Context 里面第二个是 route，可以看出 router.location 就是 history 里面的 location，而 route.match 是 Router 组件里面 state.match，这个 match 在后面会介绍到。\u003c/p\u003e\n\u003cp\u003e上面就是 Router 组件了。常见的 Route 组件 写法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u0026lt;Router\u0026gt;\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eRoute\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eexact\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{Home}/\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eRoute\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/news\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{NewsFeed}/\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u0026lt;\u003cspan class=\"hljs-regexp\"\u003e/Router\u0026gt;\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再来看看 Route 组件代码：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eRoute\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title\"\u003eComponent\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 已简化部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e contextTypes = {\n    \u003cspan class=\"hljs-attr\"\u003erouter\u003c/span\u003e: PropTypes.shape({\n      \u003cspan class=\"hljs-attr\"\u003ehistory\u003c/span\u003e: PropTypes.object.isRequired,\n      \u003cspan class=\"hljs-attr\"\u003eroute\u003c/span\u003e: PropTypes.object.isRequired,\n      \u003cspan class=\"hljs-attr\"\u003estaticContext\u003c/span\u003e: PropTypes.object\n    })\n  };\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e childContextTypes = {\n    \u003cspan class=\"hljs-attr\"\u003erouter\u003c/span\u003e: PropTypes.object.isRequired\n  };\n  getChildContext() {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n      \u003cspan class=\"hljs-attr\"\u003erouter\u003c/span\u003e: {\n        ...this.context.router,\n        \u003cspan class=\"hljs-attr\"\u003eroute\u003c/span\u003e: {\n          \u003cspan class=\"hljs-attr\"\u003elocation\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props.location || \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.context.router.route.location,\n          \u003cspan class=\"hljs-attr\"\u003ematch\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state.match\n        }\n      }\n    };\n  }\n  state = {\n    \u003cspan class=\"hljs-attr\"\u003ematch\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.computeMatch(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.context.router)\n  };\n  computeMatch({ computedMatch, location, path, strict, exact, sensitive }, router) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (computedMatch) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e computedMatch;\u003cspan class=\"hljs-comment\"\u003e// 若Switch 组件已经帮我们计算好了，就返回\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { route } = router;\n    \u003cspan class=\"hljs-comment\"\u003e// 传的props有location，就用location，没有，就用 context.router.route\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pathname = (location || route.location).pathname; \n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e matchPath(pathname, { path, strict, exact, sensitive }, route.match);\n  }\n  componentWillReceiveProps(nextProps, nextContext) {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.setState({\n      \u003cspan class=\"hljs-attr\"\u003ematch\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.computeMatch(nextProps, nextContext.router)\n    });\n  }\n  render() {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { match } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { children, component, render } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { history, route, staticContext } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.context.router;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e location = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props.location || route.location;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e props = { match, location, history, staticContext };\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e match ? React.createElement(component, props) : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (render) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e match ? render(props) : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e children === \u003cspan class=\"hljs-string\"\u003e\"function\"\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e children(props);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (children \u0026amp;\u0026amp; !isEmptyChildren(children))\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e React.Children.only(children);\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看出 Route 组件的重点有三处：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e获取传递过来的 Context，并 getChildContext，新建 route。\u003c/li\u003e\n\u003cli\u003ematch变化，location.pathname 变化的时候，修改 match。\u003c/li\u003e\n\u003cli\u003e根据 props 内容的不同，分别以 component/render/Children 的方式渲染子组件。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这里重点看看 match，这个 match 是当前地址与该 Route 组件匹配关系。我们来看看 computeMatch 里面的 matchPath 方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pathToRegexp \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"path-to-regexp\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e matchPath = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003epathname, options = {}, parent\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e options === \u003cspan class=\"hljs-string\"\u003e\"string\"\u003c/span\u003e) options = { \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: options };\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { path, exact = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, strict = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, sensitive = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e } = options;\n  \u003cspan class=\"hljs-comment\"\u003e// 此时的parent就是 Router 里面的 state.math！如果当前路由是根路径的话， match 为 true，否之为 false；为根路径就正常渲染好了\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (path == \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e parent;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { re, keys } = compilePath(path, { \u003cspan class=\"hljs-attr\"\u003eend\u003c/span\u003e: exact, strict, sensitive });\n  \u003cspan class=\"hljs-comment\"\u003e// match：当前定义的路由 pathname 是否匹配 Route 的 props.path\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e match = re.exec(pathname);\n  \u003cspan class=\"hljs-comment\"\u003e// 不匹配，则说明该 Route 组件没有匹配上，不会渲染任何子组件\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!match) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [url, ...values] = match;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isExact = pathname === url;\n  \u003cspan class=\"hljs-comment\"\u003e// 完全比配情况\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (exact \u0026amp;\u0026amp; !isExact) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    path,\n    \u003cspan class=\"hljs-attr\"\u003eurl\u003c/span\u003e: path === \u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e \u0026amp;\u0026amp; url === \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e ? \u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e : url, \n    isExact,\n    \u003cspan class=\"hljs-attr\"\u003eparams\u003c/span\u003e: keys.reduce(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ememo, key, index\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n      memo[key.name] = values[index];\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e memo;\n    }, {})\n  };\n};\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e compilePath = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003epattern, options\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 去除缓存机制的主要部分\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e keys = [];\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e re = pathToRegexp(pattern, keys, options);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e compiledPattern = { re, keys };\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e compiledPattern;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看出 matchPath 方法，主要还是依赖于 \u003ccode\u003epath-to-regexp\u003c/code\u003e 包，这个在 vue-router 里面有经常看到。通过这个包，可以将传入的 pathname，与 Route 组件 props 过来的 path 进行匹配。如果不匹配则 match 为 null，在渲染的时候如果是 component/render 的方式，则 match 为 null，同时 Route 组件的渲染结果就是 null，也就是\u003cstrong\u003e意味着该 Route 组件不匹配 pathname。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e看看computeMatch 方法里面的 pathname 变量。这个 pathname 可以是传入参数 location 的，也可以是 context.router.route 的 patchname，而后者就是 history.pathname，也是当前地址。**这个当前地址和传参 location.pathname 会不一样吗？**会的！当然会！通过控制 Route 的 props.location 就可以修改 matchPath 的传参 pathname，从而使得当前地址与该 Route 的匹配关系变更为 props 过来的 location.pathname 与该 Route 组件的匹配关系。是不是有种为所欲为的 feel。\u003c/p\u003e\n\u003cp\u003eRoute 里面还有个值得注意的 props，是 exact，意思为是否全匹配。如果不设置，如果当要求的 \u003ccode\u003epathname = '/one'\u003c/code\u003e 时，path 为 '/'，'/one' 或则 '/one/two' 的三个 Route 组件都会被匹配到。只有全匹配的时候才能精准匹配 '/one' 的组件。这也是为什么上面的 Route 写法里面会有一个 div 包裹两个 Route 组件，毕竟可能两个组件都匹配上，而 Router 组件又只能有一个 child。\u003c/p\u003e\n\u003ch3\u003eSwitch 组件\u003c/h3\u003e\n\u003cp\u003eSwitch 出场率还是很高的，而且 switch 这个单词也很形象，切换路由。常见的用法就是用 Switch 组件，包裹 n 个 Route 组件。Switch 组件只会渲染一个 Route 组件，如果不是精准的 Route 组件，也只会渲染一个，所以美名为切换：只能留一个的意思。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eSwitch\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title\"\u003eComponent\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 已简化部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e contextTypes = {\n    \u003cspan class=\"hljs-attr\"\u003erouter\u003c/span\u003e: PropTypes.shape({\n      \u003cspan class=\"hljs-attr\"\u003eroute\u003c/span\u003e: PropTypes.object.isRequired\n    }).isRequired\n  };\n  render() {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { route } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.context.router;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { children } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e location = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props.location || route.location;\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e match, child;\n    React.Children.forEach(children, element =\u0026gt; {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (match == \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026amp;\u0026amp; React.isValidElement(element)) {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e {\n          \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: pathProp,\n          exact,\n          strict,\n          sensitive,\n          \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e\n        } = element.props;\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e path = pathProp || \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e;\n\n        child = element;\n        match = matchPath(\n          location.pathname,\n          { path, exact, strict, sensitive },\n          route.match\n        );\n      }\n    });\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e match\n      ? React.cloneElement(child, { location, \u003cspan class=\"hljs-attr\"\u003ecomputedMatch\u003c/span\u003e: match })\n      : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个 Switch 组件还是蛮简单的，对子节点 Route 组件进行遍历。对于 match 变量，和 Route 里面计算 math 的相同，都是调用 matchPath 方法，只是不同的地方在于传入 matchPath 的 pathname 参数是 Swith 自己的 props.location.patchname，而不是 Route 自己的 props.location.pathname。当计算出 match 之后，若符合就不会继续遍历其他 Route 组件了，从而实现仅渲染单个 Route 组件。\u003c/p\u003e\n\u003cp\u003e在回头看看 Route 组件里面的 computeMatch 方法，当有 props.computedMatch 的时候，直接返回 computedMatch，不会继续下面自己的 matchPath 方法了，这个 props.computedMatch 正是 Switch 计算出来 match 变量。直接让 Route 组件自己的 props.location 与 context.router.route 无效化。\u003cstrong\u003e这就说明了 Switch 组件对其下面 Route 组件的渲染不仅是单独渲染，更有筛选作用。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e这个时候在看看开头说的项目中遇到的 SPA 路由切换问题，官网给出的\u003ca href=\"https://reacttraining.com/react-router/web/example/animated-transitions\" target=\"_blank\"\u003e方案\u003c/a\u003e 采用的方式，通过 Switch 组件的 props.location 实现对其下面的 Route 组件渲染。当路由变化的时候，前一个 Route 组件不会立马消失，而是在 Switch 组件下继续现实，route 的 key 值并没有变化。同时新的 Route 也会继续出现，从而实现过渡效果。\u003c/p\u003e\n\u003ch3\u003e其他组件\u003c/h3\u003e\n\u003cp\u003eRedirct 组件里面需要注意的是 props.from 是在 Switch 组件里面生效的，\u003ccode\u003econst path = pathProp || from\u003c/code\u003e，来计算 computedMatch，最后的结果则是\n从 match 的里面结合 to 得出的路径，不是简简单单的 '/nameList/:id'，要具体到 id 是多少。当然这里还是用到了 \u003ccode\u003epath-to-regexp\u003c/code\u003e 模块。\u003c/p\u003e\n\u003cp\u003eStaticRouter 针对服务端渲染的问题，有新的 Context 传过来 staticContext，在 Redirct 里面用得比较多。\u003c/p\u003e\n\u003cp\u003ewithRouter 是个 HOC 高阶组件，意在通过修饰者语句将组件传入 withRouter 里面。\u003ca href=\"https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over\" target=\"_blank\"\u003e官网\u003c/a\u003e里面介绍了一点。withRouter 可以将 Route 组件里面 match location history 传给过来目标组件，用处还是挺好的。\u003c/p\u003e\n\u003cp\u003eMemoryRouter 和 Promt 组件都比较简单，这里就不介绍了。\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://reacttraining.com/react-router/core/guides/philosophy\" target=\"_blank\"\u003e官方文档 react-router 4\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://reactjs.org/docs/context.html\" target=\"_blank\"\u003e官方文档 react 16.3 context\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n"}},"buildId":"r4Ww0YLm8YL5~6SwciWHH","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" async=""></script></body></html>