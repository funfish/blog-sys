<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">nest 技术点 </title><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.587c5e31.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___2dTZ9 "><a class="logo___346dE" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___13XXt" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___29Pln"><h1 class="postTitle___1_m4g">nest 技术点 </h1><span class="postTime___1x0_i">March 24, 2021</span></header><article class="postWrapper___3jnNg post-article"><div><p><a href="https://github.com/funfish/blog/blob/master/43.%20nest%20%E5%88%9D%E5%A7%8B%E5%8C%96.mdown" target="_blank">上文</a>提到的初始化，还是有不少纰漏的地方，而且只是粗糙的介绍了初始化的过程，还有很多细节点没有介绍到。下面着重介绍一下：</p>
<h2>循环引用</h2>
<p>一般使用的时候是不推荐循环引用的，只是有的时候，需要用到循环引用，那要如何处理呢？按照官方介绍的是 <code>forwardRef</code> 函数来表示引用关系，比如 <code>@Inject(forwardRef(() =&gt; CatsService))</code> 这样的方式。循环引用，包含正向引用和模块的引用，这里介绍一下正向引用，也就是依赖引用。</p>
<p>前文初始化中提到：<strong><code>resolveSingleParam</code> 通过迭代获取了需要注入的依赖，需要传入的依赖通过 <code>instances</code> 传入到 <code>callback</code>，再在 <code>callback</code>中完成该 <code>provider</code> 的实例化，从而完成初始化</strong>。在循环引用里面，也是要通过 <code>resolveSingleParam</code> 来解决循环问题。而该方法下面，有两个功能：</p>
<pre class="hljs"><code>public resolveParamToken&lt;T&gt;(
  wrapper: InstanceWrapper&lt;T&gt;,
  <span class="hljs-attr">param</span>: Type&lt;any&gt; | string | symbol | any,
) {
  <span class="hljs-keyword">if</span> (!param.forwardRef) {
    <span class="hljs-keyword">return</span> param;
  }
  wrapper.forwardRef = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> param.forwardRef();
}

public <span class="hljs-keyword">async</span> resolveComponentHost&lt;T&gt;(
  <span class="hljs-built_in">module</span>: Module,
  <span class="hljs-attr">instanceWrapper</span>: InstanceWrapper&lt;T&gt;,
  contextId = STATIC_CONTEXT,
  inquirer?: InstanceWrapper,
): <span class="hljs-built_in">Promise</span>&lt;InstanceWrapper&gt; {
  <span class="hljs-keyword">const</span> inquirerId = <span class="hljs-keyword">this</span>.getInquirerId(inquirer);
  <span class="hljs-keyword">const</span> instanceHost = instanceWrapper.getInstanceByContextId(contextId, inquirerId);
  <span class="hljs-keyword">if</span> (!instanceHost.isResolved &amp;&amp; !instanceWrapper.forwardRef) {
    <span class="hljs-comment">// 正常过程</span>
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.loadProvider(instanceWrapper, <span class="hljs-built_in">module</span>, contextId, inquirer);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (
    <span class="hljs-comment">// 循环引用</span>
    !instanceHost.isResolved &amp;&amp;
    instanceWrapper.forwardRef &amp;&amp;
    (contextId !== STATIC_CONTEXT || !!inquirerId)
  ) {
    instanceHost.donePromise &amp;&amp;
      instanceHost.donePromise.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.loadProvider(instanceWrapper, <span class="hljs-built_in">module</span>, contextId, inquirer));
  }
  <span class="hljs-comment">// 省略部分代码</span>
  <span class="hljs-keyword">return</span> instanceWrapper;
}
</code></pre>
<p>可以看到 <code>resolveParamToken</code> 里面由于存在 <code>formward</code> 的关系，InstanceWrapper 的 <code>forwardRef</code> 属性被设置为 <code>true</code>，并且拿到了 <code>@Inject(forwardRef(() =&gt; CatsService))</code> 里面 <code>CatsService</code> 这个类。后面通过这个类名，找到对应的 instanceWrapper，并到达 <code>resolveComponentHost</code> 方法。在该方法的条件里面循环引用会走到 <code>donePromise</code>。只是这里第一个问题，前面提到的传入 <code>resolveComponentHost</code> 的 instanceWrapper 是注入项 <code>CatsService</code>，而引用方的 wrapper 设置了 <code>forwardRef</code> 的，但是注入项 <code>CatsService</code> 并没有，所以不可能到循环里面的。那这是为什么呢？</p>
<p>在 debug 的时候就发现代码执行一直是跳来跳去的，并不是阅读顺序上的从上到下。这是由于采用了多个 map 结构，比如下面的：</p>
<pre class="hljs"><code>private <span class="hljs-keyword">async</span> createInstancesOfProviders(<span class="hljs-built_in">module</span>: Module) {
  <span class="hljs-keyword">const</span> { providers } = <span class="hljs-built_in">module</span>;
  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(
    [...providers.values()].map(<span class="hljs-keyword">async</span> wrapper =&gt;
      <span class="hljs-keyword">this</span>.injector.loadProvider(wrapper, <span class="hljs-built_in">module</span>),
    ),
  );
}
</code></pre>
<p>对于 <code>Promise.all</code> 会遍历其下面的所有异步事件，只是里面的执行顺序是如何的呢？<strong>如果遇到异步里面有异步如何处理？</strong> 对于第一个异步事件，会执行里面的同步语句，直到遇到第一个 <code>await</code> 语句，会执行其里面的同步语句，<strong>若遇到 <code>await</code>再执行里面的同步部分，直到返回非异步语句，并开始执行 <code>Promise.all</code> 下的第二个异步语句，按这样的逻辑依次循环</strong></p>
<p>回到前面，在 <code>resolveParamToken</code> 之后，由于异步返回的问题，会先执行其他遍历的异步语句到 <code>resolveParamToken</code> 之后，于是 <code>CatsService</code> 的 instanceWrapper 也被设置了 <code>forwardRef</code>。</p>
<p>进入 <code>donePromise.then</code> 操作，要执行 <code>then</code> 需要有 <code>resolve</code> 的过程，但是 <code>resolve</code> 在 <code>callback</code> 里面执行，而随后则马上返回 <code>CatsService</code> 的 instanceWrapper。按照前文介绍的，依赖的注入，是不断的迭代传入实例的，但是这里本来是需要继续迭代的，现在进入了 Promise 里面，传递链被中断，要如何返回含有实例的 instanceWrapper ？这也是可以由上面的 <code>Promise.all</code> 的问题来解答，在一个遍历里面出现中断，执行 <code>Promise.all</code> 的下一个异步，从而使得对象 <code>instanceWrapper.instance</code> 能够异步的添加上实例。</p>
<p>后面遍历的时候已经获取到 <code>CatsService</code> 的实例了，在 <code>callback</code> 里面 <code>resolve</code> 的时候，则会回到前面的 <code>donePromise.then</code> 从而继续加载实例，由于存在 <code>isResolved</code>，这里就有第二个问题了，既然遍历的过程中已经创建实例了，为什么还有继续 <code>donePromise.then</code> 的过程呢？这里有个猜测：可能避免循环漏掉了的问题吧，只是具体用途也没有想出来。</p>
<p>除了正向引用，还有模块引用，也和正向引用有点类似，依赖于 <code>forwardRef</code> 写法。模块引用里面，采用的是缓存判断，如果缓存里面有该模块，则不会继续当前遍历。</p>
<p>typescript 在编译循环引用的参数时候，参数会被转为 undefined，是无法识别的。正向引用需要 <code>inject</code> 修饰器来添加额外的参数，来覆盖参数的 undefined，同样的模块引用也需要 <code>forwardRef</code> 来表示非直接循环，从而可以编译出正确的参数。（至于为什么 typescript 无法编译出循环参数，我就不晓得了。。。。）</p>
<h2>注入作用域</h2>
<p>这里虽然翻译是叫做注入作用域，但是，感觉更多的是<strong>隔离</strong>的作用。前文提到的依赖注入，有个特点，就是由<strong>依赖生成的实例，会被所有引用方共享。</strong> 这在大部分时候是没有问题的，只是有时可能有特别的需求，比如需要用到依赖生成实例的静态变量，导致依赖生成的实例共享就会被相互污染。于是就有了注入作用域的概念，字面理解：注入的依赖有自己的作用域，而不会在所有需要的类中共享。</p>
<p>具体的使用方法：</p>
<pre class="hljs"><code>@Injectable({ <span class="hljs-attr">scope</span>: Scope.REQUEST })
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CatsService</span> </span>{}
</code></pre>
<p><code>Injectable</code> 里面的传参只可以配置 scope 字段或者不传，表示 <code>CatsService</code> 的作用域，不传的话，默认则是在所有类中共享依赖的实例。常见的配置有：</p>
<ol>
<li><code>DEFAULT</code> 依赖的实例在所有需要的类中共享；</li>
<li><code>TRANSIENT</code> 在每个需要依赖的类中，单独传递实例，而不与其他类共享，为单例模式；</li>
<li><code>REQUEST</code> 依赖的实例不会在初始化中生成，而是在每次请求的时候，都会重新生成对应实例，并在该请求的所有类中共享该实例；</li>
</ol>
<p>先看看 <code>TRANSIENT</code> 模式，按照前文说的依赖注入的方式，一旦一个依赖被标记为 <code>isResolved</code>，其实例就已经是生成的了，下次还需要该依赖的时候，则直接用已经生成的实例。<code>TRANSIENT</code> 模式在第一个依赖生成的时候，就和默认方式不一样了。</p>
<pre class="hljs"><code>public <span class="hljs-keyword">async</span> loadInstance&lt;T&gt;(
  wrapper: InstanceWrapper&lt;T&gt;, <span class="hljs-attr">collection</span>: <span class="hljs-built_in">Map</span>&lt;string, InstanceWrapper&gt;,
  <span class="hljs-attr">module</span>: Module, contextId = STATIC_CONTEXT, inquirer?: InstanceWrapper,
) {
  <span class="hljs-keyword">const</span> inquirerId = <span class="hljs-keyword">this</span>.getInquirerId(inquirer);
  <span class="hljs-keyword">const</span> instanceHost = wrapper.getInstanceByContextId(contextId, inquirerId);

  <span class="hljs-keyword">if</span> (instanceHost.isPending) {
    <span class="hljs-keyword">return</span> instanceHost.donePromise;
  }
  <span class="hljs-keyword">const</span> done = <span class="hljs-keyword">this</span>.applyDoneHook(instanceHost);
  <span class="hljs-keyword">const</span> { name, inject } = wrapper;
  <span class="hljs-keyword">const</span> targetWrapper = collection.get(name);
  <span class="hljs-keyword">if</span> (isUndefined(targetWrapper)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();
  }
  <span class="hljs-keyword">if</span> (instanceHost.isResolved) {
    <span class="hljs-keyword">return</span> done();
  }
  <span class="hljs-keyword">const</span> callback = <span class="hljs-keyword">async</span> (instances: unknown[]) =&gt; {
    <span class="hljs-keyword">const</span> properties = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.resolveProperties(wrapper, <span class="hljs-built_in">module</span>, inject,contextId, wrapper, inquirer);
    <span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.instantiateClass(instances, wrapper, targetWrapper, contextId, inquirer);
    <span class="hljs-keyword">this</span>.applyProperties(instance, properties);
    done();
  };
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.resolveConstructorParams&lt;T&gt;(wrapper, <span class="hljs-built_in">module</span>, inject, callback, contextId, wrapper, inquirer);
}

public getInstanceByContextId(contextId: ContextId, inquirerId?: string) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.scope === Scope.TRANSIENT &amp;&amp; inquirerId) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getInstanceByInquirerId(contextId, inquirerId);
  }
  <span class="hljs-comment">// 如果不是 TRANSIENT 则会返回静态实例，也就是通用实例</span>
  <span class="hljs-keyword">const</span> instancePerContext = <span class="hljs-keyword">this</span>.values.get(contextId);
  <span class="hljs-keyword">return</span> instancePerContext
    ? instancePerContext
    : <span class="hljs-keyword">this</span>.cloneStaticInstance(contextId);
}
</code></pre>
<p>这里有个细节地方，在加载实例的通用入口 <code>loadInstance</code> 里面，<code>getInstanceByContextId</code> 方法会判断是否是 <code>TRANSIENT</code> 模式，如果是，则会进入 <code>getInstanceByInquirerId</code> 根据引用方类来获得实例，自然不同的。<code>getInstanceByInquirerId</code> 正如名字，通过引用方，也就是 <code>InquirerId</code> 来获取实例，<code>getInstanceByContextId</code> 则是通过上 <code>ContextId</code> 来获取实例，而 <code>ContextId</code> 默认是静态实例的 id，也就是 1。在 <code>getInstanceByInquirerId</code> 里面会通过 <code>InquirerId</code> 在通过获取引用方的实例集合，再通过 <code>contextId</code> 获得最后的实例，这个就是 <code>TRANSIENT</code> 的特色，<strong>依赖通过实例的引用方的 <code>InquirerId</code>，再通过 <code>ContextId</code> 来获取，所以不同的类，注入相同的依赖类，实例的时候，也会获取到不同的依赖实例</strong>。</p>
<p><code>getInstanceByContextId</code> 和 <code>getInstanceByInquirerId</code> 若无法根据 <code>contextId</code> 获得实例，都会有一个克隆实例的机制，<code>getInstanceByContextId</code> 里面是 <code>cloneStaticInstance</code>，这里看看 <code>getInstanceByInquirerId</code> 返回的 <code>cloneTransientInstance</code>：</p>
<pre class="hljs"><code>public cloneTransientInstance(contextId: ContextId, <span class="hljs-attr">inquirerId</span>: string) {
  <span class="hljs-keyword">const</span> staticInstance = <span class="hljs-keyword">this</span>.getInstanceByContextId(STATIC_CONTEXT);
  <span class="hljs-keyword">const</span> instancePerContext: InstancePerContext&lt;T&gt; = {
    ...staticInstance,
    <span class="hljs-attr">instance</span>: <span class="hljs-literal">undefined</span>,
    <span class="hljs-attr">isResolved</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">isPending</span>: <span class="hljs-literal">false</span>,
  };
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isNewable()) {
    instancePerContext.instance = <span class="hljs-built_in">Object</span>.create(<span class="hljs-keyword">this</span>.metatype.prototype);
  }
  <span class="hljs-keyword">this</span>.setInstanceByInquirerId(contextId, inquirerId, instancePerContext);
  <span class="hljs-keyword">return</span> instancePerContext;
}
</code></pre>
<p>可以看到返回的 <code>instancePerContext</code> 是一个新对象，对象里面的 <code>instance</code> 实例已经为 <code>undefined</code>，并且 <code>isResolved</code> 和 <code>isPending</code> 为 <code>false</code>；这样若一个依赖已经被实例过了，当别的类需要这个依赖的实例，遍历的时候就会进入 <code>loadInstance</code> 函数，并克隆实例，从而获得新的实例对象可以继续遍历。</p>
<h3>注入作用域之 REQUEST</h3>
<p><code>REQUEST</code> 模式不会在一开始初始化的时候就实例好所有的依赖，而且是在请求的时候去实例化依赖。<code>DEFAULT</code>、<code>TRANSIENT</code> 和 <code>REQUEST</code> 都会在初始化的时候创建路由，但是 <code>REQUEST</code> 是在发生请求的时候，再创建新的上下文环境，每个请求都是新的。在创建路由的时候，会根据 <code>isDependencyTreeStatic</code> 的返回，来判断是不是要实现 <code>REQUEST</code> 的路由：</p>
<pre class="hljs"><code>public isDependencyTreeStatic(lookupRegistry: string[] = []): boolean {
  <span class="hljs-keyword">if</span> (!isUndefined(<span class="hljs-keyword">this</span>.isTreeStatic)) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isTreeStatic;
  }
  <span class="hljs-comment">// 为 REQUEST 模式，则 isTreeStatic 为 false</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.scope === Scope.REQUEST) {
    <span class="hljs-keyword">this</span>.isTreeStatic = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isTreeStatic;
  }
  <span class="hljs-keyword">if</span> (lookupRegistry.includes(<span class="hljs-keyword">this</span>[INSTANCE_ID_SYMBOL])) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  lookupRegistry = lookupRegistry.concat(<span class="hljs-keyword">this</span>[INSTANCE_ID_SYMBOL]);

  <span class="hljs-keyword">const</span> { dependencies, properties, enhancers } = <span class="hljs-keyword">this</span>[
    INSTANCE_METADATA_SYMBOL
  ];
  <span class="hljs-keyword">let</span> isStatic =
    (dependencies &amp;&amp;
      <span class="hljs-keyword">this</span>.isWrapperListStatic(dependencies, lookupRegistry)) ||
    !dependencies;

  <span class="hljs-keyword">if</span> (!isStatic || !(properties || enhancers)) {
    <span class="hljs-keyword">this</span>.isTreeStatic = isStatic;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isTreeStatic;
  }
  <span class="hljs-comment">// 省略下面的代码</span>
}
</code></pre>
<p><code>isDependencyTreeStatic</code> 计算是否是静态实例，比如 <code>DEFAULT</code> 和 <code>TRANSIENT</code> 模式。上面还可以看到 <code>isWrapperListStatic</code> 这个功能，如果一个类注入了依赖，若依赖是 <code>REQUEST</code> 模式，则这个类也会是 <code>REQUEST</code> 模式，从而实现作用域的传递。</p>
<p>这个 <code>isDependencyTreeStatic</code> 在初始化的时候，其实就已经调用了，在 <code>instantiateClass</code> 里面的 <code>isStatic</code> 方法就通过 <code>isDependencyTreeStatic</code> 来判断是否是静态实例，如果是则 <code>instantiateClass</code> 会 new 一个实例。</p>
<p>下面看一下 <code>REQUEST</code> 下路由处理函数的机制：</p>
<pre class="hljs"><code>public createRequestScopedHandler(
  instanceWrapper: InstanceWrapper, <span class="hljs-attr">requestMethod</span>: RequestMethod,
  <span class="hljs-attr">module</span>: Module, <span class="hljs-attr">moduleKey</span>: string, <span class="hljs-attr">methodName</span>: string,
) {
  <span class="hljs-keyword">const</span> { instance } = instanceWrapper;
  <span class="hljs-keyword">const</span> collection = <span class="hljs-built_in">module</span>.controllers;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> &lt;TRequest, TResponse&gt;<span class="hljs-function">(<span class="hljs-params">req: TRequest, res: TResponse, next: (</span>) =&gt;</span> <span class="hljs-keyword">void</span>) =&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> contextId = <span class="hljs-keyword">this</span>.getContextId(req);
      <span class="hljs-keyword">this</span>.container.registerRequestProvider(req, contextId);

      <span class="hljs-keyword">const</span> contextInstance = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.injector.loadPerContext(
        instance, <span class="hljs-built_in">module</span>, collection,contextId);
      <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.createCallbackProxy(
        contextInstance, contextInstance[methodName], methodName,
        moduleKey, requestMethod, contextId, instanceWrapper.id,
      )(req, res, next);
    } <span class="hljs-keyword">catch</span> (err) {<span class="hljs-comment">/*省略部分代码*/</span>}
  }
}
</code></pre>
<p><code>ContextId</code> 默认是静态 id，在 <code>REQUEST</code> 模式下，<strong>若发生请求的时候，则是当前请求的 <code>ContextId</code>，若没有则创建一个随机数 <code>Math.random()</code>。</strong> 普通的请求最后都会创建一个随机数，至于其他的情况就不明确了，只是随机数还是有可能重复的，当然官方有介绍到由于采用的 <code>WeakMap</code>，里面的 key 是个对象，什么对象呢？<code>{ id: 1 }</code>。里面的 id 可能会重复，但是 key 已经是个不同的对象，所以就算是重复请求同一个路径，key 是不同的对象，那 <code>ContextId</code> 就是安全的。</p>
<p><code>loadPerContext</code> 方法则是加载实例调用的，还是 <code>loadInstance</code> 方法，然后经过 <code>getInstanceByContextId</code> 又是一个全新的 instanceWrapper，里面的 <code>instance</code> 实例已经为 <code>undefined</code>，并且 <code>isResolved</code> 和 <code>isPending</code> 为 <code>false</code>，于是又可以继续迭代下去。最后 <code>createCallbackProxy</code> 则和普通的模式一样了。</p>
<p>还有复杂的，比如 <code>REQUEST</code> 和 <code>TRANSIENT</code> 结合，与循环依赖结合等等，这些复杂的情况就不一一讨论了，正常人都不会这么用的。。。。</p>
<h2>中间件</h2>
<p>在初始化的过程中，其实省略了中间件是如何加入应用，并结合路由的过程，只是简单描述了中间件添加到配置中。主要也是这部分没有什么特别的，顺着代码下去就能明白，这介绍一下最后的环节：</p>
<pre class="hljs"><code>private <span class="hljs-keyword">async</span> bindHandler(
  wrapper: InstanceWrapper&lt;NestMiddleware&gt;, <span class="hljs-attr">applicationRef</span>: HttpServer,
  <span class="hljs-attr">method</span>: RequestMethod, <span class="hljs-attr">path</span>: string, <span class="hljs-attr">module</span>: Module,
  <span class="hljs-attr">collection</span>: <span class="hljs-built_in">Map</span>&lt;string, InstanceWrapper&gt;,
) {
  <span class="hljs-keyword">const</span> { instance, metatype } = wrapper;
  <span class="hljs-keyword">if</span> (isUndefined(instance.use)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidMiddlewareException(metatype.name);
  }
  <span class="hljs-keyword">const</span> router = applicationRef.createMiddlewareFactory(method);
  <span class="hljs-keyword">const</span> isStatic = wrapper.isDependencyTreeStatic();
  <span class="hljs-keyword">if</span> (isStatic) {
    <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.createProxy(instance);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.registerHandler(router, path, proxy);
  }
  <span class="hljs-comment">// ..。省略后面代码</span>
}

private <span class="hljs-keyword">async</span> createProxy( instance: NestMiddleware, contextId = STATIC_CONTEXT) {
  <span class="hljs-keyword">const</span> exceptionsHandler = <span class="hljs-keyword">this</span>.routerExceptionFilter.create(
    instance, instance.use, <span class="hljs-literal">undefined</span>, contextId,
  );
  <span class="hljs-keyword">const</span> middleware = instance.use.bind(instance);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.routerProxy.createProxy(middleware, exceptionsHandler);
}

private registerHandler(
  router: <span class="hljs-function">(<span class="hljs-params">...args: any[]</span>) =&gt;</span> <span class="hljs-keyword">void</span>, <span class="hljs-attr">path</span>: string,
  <span class="hljs-attr">proxy</span>: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">TRequest,</span> <span class="hljs-attr">TResponse</span>&gt;</span>(req: TRequest, res: TResponse, next: () =&gt; void) =&gt; void,
) {
  const prefix = this.config.getGlobalPrefix();
  const basePath = validatePath(prefix);
  if (basePath &amp;&amp; path === '/*') {
    path = '*';
  }
  router(basePath + path, proxy);
}
</span></code></pre>
<p>通过 <code>createProxy</code> 创建的代理返回的 <code>this.routerProxy.createProxy</code> 和初始化路由最后实现代理的方式一致，而 <code>router</code> 的实现 <code>applicationRef.createMiddlewareFactory(method)</code> 和初始化路由里面的路由方法创建 <code>const routerMethod = this.routerMethodFactory.get(router, requestMethod).bind(router);</code> 是一模一样的。</p>
<p>于是可以发现中间件的注册，其实和普通路由的注册一样，只是路由的实现是通过对应的 <code>method</code>，而中间是通过 <code>use</code> 方法。最后当请求发送过来的时候，先依次通过这些中间件处理，在 <code>next()</code> 下流转，最后才到路由处理函数。本质还是用到 <code>express</code> 中间件的方法。</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"March 24, 2021","title":"nest 技术点 ","content":"\u003cp\u003e\u003ca href=\"https://github.com/funfish/blog/blob/master/43.%20nest%20%E5%88%9D%E5%A7%8B%E5%8C%96.mdown\" target=\"_blank\"\u003e上文\u003c/a\u003e提到的初始化，还是有不少纰漏的地方，而且只是粗糙的介绍了初始化的过程，还有很多细节点没有介绍到。下面着重介绍一下：\u003c/p\u003e\n\u003ch2\u003e循环引用\u003c/h2\u003e\n\u003cp\u003e一般使用的时候是不推荐循环引用的，只是有的时候，需要用到循环引用，那要如何处理呢？按照官方介绍的是 \u003ccode\u003eforwardRef\u003c/code\u003e 函数来表示引用关系，比如 \u003ccode\u003e@Inject(forwardRef(() =\u0026gt; CatsService))\u003c/code\u003e 这样的方式。循环引用，包含正向引用和模块的引用，这里介绍一下正向引用，也就是依赖引用。\u003c/p\u003e\n\u003cp\u003e前文初始化中提到：\u003cstrong\u003e\u003ccode\u003eresolveSingleParam\u003c/code\u003e 通过迭代获取了需要注入的依赖，需要传入的依赖通过 \u003ccode\u003einstances\u003c/code\u003e 传入到 \u003ccode\u003ecallback\u003c/code\u003e，再在 \u003ccode\u003ecallback\u003c/code\u003e中完成该 \u003ccode\u003eprovider\u003c/code\u003e 的实例化，从而完成初始化\u003c/strong\u003e。在循环引用里面，也是要通过 \u003ccode\u003eresolveSingleParam\u003c/code\u003e 来解决循环问题。而该方法下面，有两个功能：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic resolveParamToken\u0026lt;T\u0026gt;(\n  wrapper: InstanceWrapper\u0026lt;T\u0026gt;,\n  \u003cspan class=\"hljs-attr\"\u003eparam\u003c/span\u003e: Type\u0026lt;any\u0026gt; | string | symbol | any,\n) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!param.forwardRef) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e param;\n  }\n  wrapper.forwardRef = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e param.forwardRef();\n}\n\npublic \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e resolveComponentHost\u0026lt;T\u0026gt;(\n  \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e: Module,\n  \u003cspan class=\"hljs-attr\"\u003einstanceWrapper\u003c/span\u003e: InstanceWrapper\u0026lt;T\u0026gt;,\n  contextId = STATIC_CONTEXT,\n  inquirer?: InstanceWrapper,\n): \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026lt;InstanceWrapper\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e inquirerId = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.getInquirerId(inquirer);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instanceHost = instanceWrapper.getInstanceByContextId(contextId, inquirerId);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!instanceHost.isResolved \u0026amp;\u0026amp; !instanceWrapper.forwardRef) {\n    \u003cspan class=\"hljs-comment\"\u003e// 正常过程\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.loadProvider(instanceWrapper, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, contextId, inquirer);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n    \u003cspan class=\"hljs-comment\"\u003e// 循环引用\u003c/span\u003e\n    !instanceHost.isResolved \u0026amp;\u0026amp;\n    instanceWrapper.forwardRef \u0026amp;\u0026amp;\n    (contextId !== STATIC_CONTEXT || !!inquirerId)\n  ) {\n    instanceHost.donePromise \u0026amp;\u0026amp;\n      instanceHost.donePromise.then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.loadProvider(instanceWrapper, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, contextId, inquirer));\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e instanceWrapper;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到 \u003ccode\u003eresolveParamToken\u003c/code\u003e 里面由于存在 \u003ccode\u003eformward\u003c/code\u003e 的关系，InstanceWrapper 的 \u003ccode\u003eforwardRef\u003c/code\u003e 属性被设置为 \u003ccode\u003etrue\u003c/code\u003e，并且拿到了 \u003ccode\u003e@Inject(forwardRef(() =\u0026gt; CatsService))\u003c/code\u003e 里面 \u003ccode\u003eCatsService\u003c/code\u003e 这个类。后面通过这个类名，找到对应的 instanceWrapper，并到达 \u003ccode\u003eresolveComponentHost\u003c/code\u003e 方法。在该方法的条件里面循环引用会走到 \u003ccode\u003edonePromise\u003c/code\u003e。只是这里第一个问题，前面提到的传入 \u003ccode\u003eresolveComponentHost\u003c/code\u003e 的 instanceWrapper 是注入项 \u003ccode\u003eCatsService\u003c/code\u003e，而引用方的 wrapper 设置了 \u003ccode\u003eforwardRef\u003c/code\u003e 的，但是注入项 \u003ccode\u003eCatsService\u003c/code\u003e 并没有，所以不可能到循环里面的。那这是为什么呢？\u003c/p\u003e\n\u003cp\u003e在 debug 的时候就发现代码执行一直是跳来跳去的，并不是阅读顺序上的从上到下。这是由于采用了多个 map 结构，比如下面的：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eprivate \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e createInstancesOfProviders(\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e: Module) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { providers } = \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.all(\n    [...providers.values()].map(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e wrapper =\u0026gt;\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.injector.loadProvider(wrapper, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e),\n    ),\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于 \u003ccode\u003ePromise.all\u003c/code\u003e 会遍历其下面的所有异步事件，只是里面的执行顺序是如何的呢？\u003cstrong\u003e如果遇到异步里面有异步如何处理？\u003c/strong\u003e 对于第一个异步事件，会执行里面的同步语句，直到遇到第一个 \u003ccode\u003eawait\u003c/code\u003e 语句，会执行其里面的同步语句，\u003cstrong\u003e若遇到 \u003ccode\u003eawait\u003c/code\u003e再执行里面的同步部分，直到返回非异步语句，并开始执行 \u003ccode\u003ePromise.all\u003c/code\u003e 下的第二个异步语句，按这样的逻辑依次循环\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e回到前面，在 \u003ccode\u003eresolveParamToken\u003c/code\u003e 之后，由于异步返回的问题，会先执行其他遍历的异步语句到 \u003ccode\u003eresolveParamToken\u003c/code\u003e 之后，于是 \u003ccode\u003eCatsService\u003c/code\u003e 的 instanceWrapper 也被设置了 \u003ccode\u003eforwardRef\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e进入 \u003ccode\u003edonePromise.then\u003c/code\u003e 操作，要执行 \u003ccode\u003ethen\u003c/code\u003e 需要有 \u003ccode\u003eresolve\u003c/code\u003e 的过程，但是 \u003ccode\u003eresolve\u003c/code\u003e 在 \u003ccode\u003ecallback\u003c/code\u003e 里面执行，而随后则马上返回 \u003ccode\u003eCatsService\u003c/code\u003e 的 instanceWrapper。按照前文介绍的，依赖的注入，是不断的迭代传入实例的，但是这里本来是需要继续迭代的，现在进入了 Promise 里面，传递链被中断，要如何返回含有实例的 instanceWrapper ？这也是可以由上面的 \u003ccode\u003ePromise.all\u003c/code\u003e 的问题来解答，在一个遍历里面出现中断，执行 \u003ccode\u003ePromise.all\u003c/code\u003e 的下一个异步，从而使得对象 \u003ccode\u003einstanceWrapper.instance\u003c/code\u003e 能够异步的添加上实例。\u003c/p\u003e\n\u003cp\u003e后面遍历的时候已经获取到 \u003ccode\u003eCatsService\u003c/code\u003e 的实例了，在 \u003ccode\u003ecallback\u003c/code\u003e 里面 \u003ccode\u003eresolve\u003c/code\u003e 的时候，则会回到前面的 \u003ccode\u003edonePromise.then\u003c/code\u003e 从而继续加载实例，由于存在 \u003ccode\u003eisResolved\u003c/code\u003e，这里就有第二个问题了，既然遍历的过程中已经创建实例了，为什么还有继续 \u003ccode\u003edonePromise.then\u003c/code\u003e 的过程呢？这里有个猜测：可能避免循环漏掉了的问题吧，只是具体用途也没有想出来。\u003c/p\u003e\n\u003cp\u003e除了正向引用，还有模块引用，也和正向引用有点类似，依赖于 \u003ccode\u003eforwardRef\u003c/code\u003e 写法。模块引用里面，采用的是缓存判断，如果缓存里面有该模块，则不会继续当前遍历。\u003c/p\u003e\n\u003cp\u003etypescript 在编译循环引用的参数时候，参数会被转为 undefined，是无法识别的。正向引用需要 \u003ccode\u003einject\u003c/code\u003e 修饰器来添加额外的参数，来覆盖参数的 undefined，同样的模块引用也需要 \u003ccode\u003eforwardRef\u003c/code\u003e 来表示非直接循环，从而可以编译出正确的参数。（至于为什么 typescript 无法编译出循环参数，我就不晓得了。。。。）\u003c/p\u003e\n\u003ch2\u003e注入作用域\u003c/h2\u003e\n\u003cp\u003e这里虽然翻译是叫做注入作用域，但是，感觉更多的是\u003cstrong\u003e隔离\u003c/strong\u003e的作用。前文提到的依赖注入，有个特点，就是由\u003cstrong\u003e依赖生成的实例，会被所有引用方共享。\u003c/strong\u003e 这在大部分时候是没有问题的，只是有时可能有特别的需求，比如需要用到依赖生成实例的静态变量，导致依赖生成的实例共享就会被相互污染。于是就有了注入作用域的概念，字面理解：注入的依赖有自己的作用域，而不会在所有需要的类中共享。\u003c/p\u003e\n\u003cp\u003e具体的使用方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e@Injectable({ \u003cspan class=\"hljs-attr\"\u003escope\u003c/span\u003e: Scope.REQUEST })\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eCatsService\u003c/span\u003e \u003c/span\u003e{}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eInjectable\u003c/code\u003e 里面的传参只可以配置 scope 字段或者不传，表示 \u003ccode\u003eCatsService\u003c/code\u003e 的作用域，不传的话，默认则是在所有类中共享依赖的实例。常见的配置有：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eDEFAULT\u003c/code\u003e 依赖的实例在所有需要的类中共享；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTRANSIENT\u003c/code\u003e 在每个需要依赖的类中，单独传递实例，而不与其他类共享，为单例模式；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eREQUEST\u003c/code\u003e 依赖的实例不会在初始化中生成，而是在每次请求的时候，都会重新生成对应实例，并在该请求的所有类中共享该实例；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e先看看 \u003ccode\u003eTRANSIENT\u003c/code\u003e 模式，按照前文说的依赖注入的方式，一旦一个依赖被标记为 \u003ccode\u003eisResolved\u003c/code\u003e，其实例就已经是生成的了，下次还需要该依赖的时候，则直接用已经生成的实例。\u003ccode\u003eTRANSIENT\u003c/code\u003e 模式在第一个依赖生成的时候，就和默认方式不一样了。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e loadInstance\u0026lt;T\u0026gt;(\n  wrapper: InstanceWrapper\u0026lt;T\u0026gt;, \u003cspan class=\"hljs-attr\"\u003ecollection\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eMap\u003c/span\u003e\u0026lt;string, InstanceWrapper\u0026gt;,\n  \u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: Module, contextId = STATIC_CONTEXT, inquirer?: InstanceWrapper,\n) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e inquirerId = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.getInquirerId(inquirer);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instanceHost = wrapper.getInstanceByContextId(contextId, inquirerId);\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (instanceHost.isPending) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e instanceHost.donePromise;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e done = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.applyDoneHook(instanceHost);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { name, inject } = wrapper;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e targetWrapper = collection.get(name);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isUndefined(targetWrapper)) {\n    \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e RuntimeException();\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (instanceHost.isResolved) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e done();\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e callback = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (instances: unknown[]) =\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e properties = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.resolveProperties(wrapper, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, inject,contextId, wrapper, inquirer);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instance = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.instantiateClass(instances, wrapper, targetWrapper, contextId, inquirer);\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.applyProperties(instance, properties);\n    done();\n  };\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.resolveConstructorParams\u0026lt;T\u0026gt;(wrapper, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, inject, callback, contextId, wrapper, inquirer);\n}\n\npublic getInstanceByContextId(contextId: ContextId, inquirerId?: string) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.scope === Scope.TRANSIENT \u0026amp;\u0026amp; inquirerId) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.getInstanceByInquirerId(contextId, inquirerId);\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 如果不是 TRANSIENT 则会返回静态实例，也就是通用实例\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instancePerContext = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.values.get(contextId);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e instancePerContext\n    ? instancePerContext\n    : \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.cloneStaticInstance(contextId);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里有个细节地方，在加载实例的通用入口 \u003ccode\u003eloadInstance\u003c/code\u003e 里面，\u003ccode\u003egetInstanceByContextId\u003c/code\u003e 方法会判断是否是 \u003ccode\u003eTRANSIENT\u003c/code\u003e 模式，如果是，则会进入 \u003ccode\u003egetInstanceByInquirerId\u003c/code\u003e 根据引用方类来获得实例，自然不同的。\u003ccode\u003egetInstanceByInquirerId\u003c/code\u003e 正如名字，通过引用方，也就是 \u003ccode\u003eInquirerId\u003c/code\u003e 来获取实例，\u003ccode\u003egetInstanceByContextId\u003c/code\u003e 则是通过上 \u003ccode\u003eContextId\u003c/code\u003e 来获取实例，而 \u003ccode\u003eContextId\u003c/code\u003e 默认是静态实例的 id，也就是 1。在 \u003ccode\u003egetInstanceByInquirerId\u003c/code\u003e 里面会通过 \u003ccode\u003eInquirerId\u003c/code\u003e 在通过获取引用方的实例集合，再通过 \u003ccode\u003econtextId\u003c/code\u003e 获得最后的实例，这个就是 \u003ccode\u003eTRANSIENT\u003c/code\u003e 的特色，\u003cstrong\u003e依赖通过实例的引用方的 \u003ccode\u003eInquirerId\u003c/code\u003e，再通过 \u003ccode\u003eContextId\u003c/code\u003e 来获取，所以不同的类，注入相同的依赖类，实例的时候，也会获取到不同的依赖实例\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egetInstanceByContextId\u003c/code\u003e 和 \u003ccode\u003egetInstanceByInquirerId\u003c/code\u003e 若无法根据 \u003ccode\u003econtextId\u003c/code\u003e 获得实例，都会有一个克隆实例的机制，\u003ccode\u003egetInstanceByContextId\u003c/code\u003e 里面是 \u003ccode\u003ecloneStaticInstance\u003c/code\u003e，这里看看 \u003ccode\u003egetInstanceByInquirerId\u003c/code\u003e 返回的 \u003ccode\u003ecloneTransientInstance\u003c/code\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic cloneTransientInstance(contextId: ContextId, \u003cspan class=\"hljs-attr\"\u003einquirerId\u003c/span\u003e: string) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e staticInstance = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.getInstanceByContextId(STATIC_CONTEXT);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instancePerContext: InstancePerContext\u0026lt;T\u0026gt; = {\n    ...staticInstance,\n    \u003cspan class=\"hljs-attr\"\u003einstance\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eisResolved\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eisPending\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n  };\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isNewable()) {\n    instancePerContext.instance = \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.create(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.metatype.prototype);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.setInstanceByInquirerId(contextId, inquirerId, instancePerContext);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e instancePerContext;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到返回的 \u003ccode\u003einstancePerContext\u003c/code\u003e 是一个新对象，对象里面的 \u003ccode\u003einstance\u003c/code\u003e 实例已经为 \u003ccode\u003eundefined\u003c/code\u003e，并且 \u003ccode\u003eisResolved\u003c/code\u003e 和 \u003ccode\u003eisPending\u003c/code\u003e 为 \u003ccode\u003efalse\u003c/code\u003e；这样若一个依赖已经被实例过了，当别的类需要这个依赖的实例，遍历的时候就会进入 \u003ccode\u003eloadInstance\u003c/code\u003e 函数，并克隆实例，从而获得新的实例对象可以继续遍历。\u003c/p\u003e\n\u003ch3\u003e注入作用域之 REQUEST\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eREQUEST\u003c/code\u003e 模式不会在一开始初始化的时候就实例好所有的依赖，而且是在请求的时候去实例化依赖。\u003ccode\u003eDEFAULT\u003c/code\u003e、\u003ccode\u003eTRANSIENT\u003c/code\u003e 和 \u003ccode\u003eREQUEST\u003c/code\u003e 都会在初始化的时候创建路由，但是 \u003ccode\u003eREQUEST\u003c/code\u003e 是在发生请求的时候，再创建新的上下文环境，每个请求都是新的。在创建路由的时候，会根据 \u003ccode\u003eisDependencyTreeStatic\u003c/code\u003e 的返回，来判断是不是要实现 \u003ccode\u003eREQUEST\u003c/code\u003e 的路由：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic isDependencyTreeStatic(lookupRegistry: string[] = []): boolean {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isUndefined(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isTreeStatic)) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isTreeStatic;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 为 REQUEST 模式，则 isTreeStatic 为 false\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.scope === Scope.REQUEST) {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isTreeStatic = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isTreeStatic;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (lookupRegistry.includes(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e[INSTANCE_ID_SYMBOL])) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  }\n  lookupRegistry = lookupRegistry.concat(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e[INSTANCE_ID_SYMBOL]);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { dependencies, properties, enhancers } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e[\n    INSTANCE_METADATA_SYMBOL\n  ];\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e isStatic =\n    (dependencies \u0026amp;\u0026amp;\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isWrapperListStatic(dependencies, lookupRegistry)) ||\n    !dependencies;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isStatic || !(properties || enhancers)) {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isTreeStatic = isStatic;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isTreeStatic;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 省略下面的代码\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eisDependencyTreeStatic\u003c/code\u003e 计算是否是静态实例，比如 \u003ccode\u003eDEFAULT\u003c/code\u003e 和 \u003ccode\u003eTRANSIENT\u003c/code\u003e 模式。上面还可以看到 \u003ccode\u003eisWrapperListStatic\u003c/code\u003e 这个功能，如果一个类注入了依赖，若依赖是 \u003ccode\u003eREQUEST\u003c/code\u003e 模式，则这个类也会是 \u003ccode\u003eREQUEST\u003c/code\u003e 模式，从而实现作用域的传递。\u003c/p\u003e\n\u003cp\u003e这个 \u003ccode\u003eisDependencyTreeStatic\u003c/code\u003e 在初始化的时候，其实就已经调用了，在 \u003ccode\u003einstantiateClass\u003c/code\u003e 里面的 \u003ccode\u003eisStatic\u003c/code\u003e 方法就通过 \u003ccode\u003eisDependencyTreeStatic\u003c/code\u003e 来判断是否是静态实例，如果是则 \u003ccode\u003einstantiateClass\u003c/code\u003e 会 new 一个实例。\u003c/p\u003e\n\u003cp\u003e下面看一下 \u003ccode\u003eREQUEST\u003c/code\u003e 下路由处理函数的机制：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic createRequestScopedHandler(\n  instanceWrapper: InstanceWrapper, \u003cspan class=\"hljs-attr\"\u003erequestMethod\u003c/span\u003e: RequestMethod,\n  \u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: Module, \u003cspan class=\"hljs-attr\"\u003emoduleKey\u003c/span\u003e: string, \u003cspan class=\"hljs-attr\"\u003emethodName\u003c/span\u003e: string,\n) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { instance } = instanceWrapper;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e collection = \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.controllers;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u0026lt;TRequest, TResponse\u0026gt;\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq: TRequest, res: TResponse, next: (\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e) =\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e contextId = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.getContextId(req);\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.container.registerRequestProvider(req, contextId);\n\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e contextInstance = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.injector.loadPerContext(\n        instance, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, collection,contextId);\n      \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createCallbackProxy(\n        contextInstance, contextInstance[methodName], methodName,\n        moduleKey, requestMethod, contextId, instanceWrapper.id,\n      )(req, res, next);\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (err) {\u003cspan class=\"hljs-comment\"\u003e/*省略部分代码*/\u003c/span\u003e}\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eContextId\u003c/code\u003e 默认是静态 id，在 \u003ccode\u003eREQUEST\u003c/code\u003e 模式下，\u003cstrong\u003e若发生请求的时候，则是当前请求的 \u003ccode\u003eContextId\u003c/code\u003e，若没有则创建一个随机数 \u003ccode\u003eMath.random()\u003c/code\u003e。\u003c/strong\u003e 普通的请求最后都会创建一个随机数，至于其他的情况就不明确了，只是随机数还是有可能重复的，当然官方有介绍到由于采用的 \u003ccode\u003eWeakMap\u003c/code\u003e，里面的 key 是个对象，什么对象呢？\u003ccode\u003e{ id: 1 }\u003c/code\u003e。里面的 id 可能会重复，但是 key 已经是个不同的对象，所以就算是重复请求同一个路径，key 是不同的对象，那 \u003ccode\u003eContextId\u003c/code\u003e 就是安全的。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eloadPerContext\u003c/code\u003e 方法则是加载实例调用的，还是 \u003ccode\u003eloadInstance\u003c/code\u003e 方法，然后经过 \u003ccode\u003egetInstanceByContextId\u003c/code\u003e 又是一个全新的 instanceWrapper，里面的 \u003ccode\u003einstance\u003c/code\u003e 实例已经为 \u003ccode\u003eundefined\u003c/code\u003e，并且 \u003ccode\u003eisResolved\u003c/code\u003e 和 \u003ccode\u003eisPending\u003c/code\u003e 为 \u003ccode\u003efalse\u003c/code\u003e，于是又可以继续迭代下去。最后 \u003ccode\u003ecreateCallbackProxy\u003c/code\u003e 则和普通的模式一样了。\u003c/p\u003e\n\u003cp\u003e还有复杂的，比如 \u003ccode\u003eREQUEST\u003c/code\u003e 和 \u003ccode\u003eTRANSIENT\u003c/code\u003e 结合，与循环依赖结合等等，这些复杂的情况就不一一讨论了，正常人都不会这么用的。。。。\u003c/p\u003e\n\u003ch2\u003e中间件\u003c/h2\u003e\n\u003cp\u003e在初始化的过程中，其实省略了中间件是如何加入应用，并结合路由的过程，只是简单描述了中间件添加到配置中。主要也是这部分没有什么特别的，顺着代码下去就能明白，这介绍一下最后的环节：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eprivate \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e bindHandler(\n  wrapper: InstanceWrapper\u0026lt;NestMiddleware\u0026gt;, \u003cspan class=\"hljs-attr\"\u003eapplicationRef\u003c/span\u003e: HttpServer,\n  \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: RequestMethod, \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: string, \u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: Module,\n  \u003cspan class=\"hljs-attr\"\u003ecollection\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eMap\u003c/span\u003e\u0026lt;string, InstanceWrapper\u0026gt;,\n) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { instance, metatype } = wrapper;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isUndefined(instance.use)) {\n    \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e InvalidMiddlewareException(metatype.name);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e router = applicationRef.createMiddlewareFactory(method);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isStatic = wrapper.isDependencyTreeStatic();\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isStatic) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e proxy = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createProxy(instance);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.registerHandler(router, path, proxy);\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// ..。省略后面代码\u003c/span\u003e\n}\n\nprivate \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e createProxy( instance: NestMiddleware, contextId = STATIC_CONTEXT) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e exceptionsHandler = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.routerExceptionFilter.create(\n    instance, instance.use, \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e, contextId,\n  );\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e middleware = instance.use.bind(instance);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.routerProxy.createProxy(middleware, exceptionsHandler);\n}\n\nprivate registerHandler(\n  router: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e...args: any[]\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: string,\n  \u003cspan class=\"hljs-attr\"\u003eproxy\u003c/span\u003e: \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eTRequest,\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eTResponse\u003c/span\u003e\u0026gt;\u003c/span\u003e(req: TRequest, res: TResponse, next: () =\u0026gt; void) =\u0026gt; void,\n) {\n  const prefix = this.config.getGlobalPrefix();\n  const basePath = validatePath(prefix);\n  if (basePath \u0026amp;\u0026amp; path === '/*') {\n    path = '*';\n  }\n  router(basePath + path, proxy);\n}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过 \u003ccode\u003ecreateProxy\u003c/code\u003e 创建的代理返回的 \u003ccode\u003ethis.routerProxy.createProxy\u003c/code\u003e 和初始化路由最后实现代理的方式一致，而 \u003ccode\u003erouter\u003c/code\u003e 的实现 \u003ccode\u003eapplicationRef.createMiddlewareFactory(method)\u003c/code\u003e 和初始化路由里面的路由方法创建 \u003ccode\u003econst routerMethod = this.routerMethodFactory.get(router, requestMethod).bind(router);\u003c/code\u003e 是一模一样的。\u003c/p\u003e\n\u003cp\u003e于是可以发现中间件的注册，其实和普通路由的注册一样，只是路由的实现是通过对应的 \u003ccode\u003emethod\u003c/code\u003e，而中间是通过 \u003ccode\u003euse\u003c/code\u003e 方法。最后当请求发送过来的时候，先依次通过这些中间件处理，在 \u003ccode\u003enext()\u003c/code\u003e 下流转，最后才到路由处理函数。本质还是用到 \u003ccode\u003eexpress\u003c/code\u003e 中间件的方法。\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"March 24, 2021","title":"nest 技术点 ","content":"\u003cp\u003e\u003ca href=\"https://github.com/funfish/blog/blob/master/43.%20nest%20%E5%88%9D%E5%A7%8B%E5%8C%96.mdown\" target=\"_blank\"\u003e上文\u003c/a\u003e提到的初始化，还是有不少纰漏的地方，而且只是粗糙的介绍了初始化的过程，还有很多细节点没有介绍到。下面着重介绍一下：\u003c/p\u003e\n\u003ch2\u003e循环引用\u003c/h2\u003e\n\u003cp\u003e一般使用的时候是不推荐循环引用的，只是有的时候，需要用到循环引用，那要如何处理呢？按照官方介绍的是 \u003ccode\u003eforwardRef\u003c/code\u003e 函数来表示引用关系，比如 \u003ccode\u003e@Inject(forwardRef(() =\u0026gt; CatsService))\u003c/code\u003e 这样的方式。循环引用，包含正向引用和模块的引用，这里介绍一下正向引用，也就是依赖引用。\u003c/p\u003e\n\u003cp\u003e前文初始化中提到：\u003cstrong\u003e\u003ccode\u003eresolveSingleParam\u003c/code\u003e 通过迭代获取了需要注入的依赖，需要传入的依赖通过 \u003ccode\u003einstances\u003c/code\u003e 传入到 \u003ccode\u003ecallback\u003c/code\u003e，再在 \u003ccode\u003ecallback\u003c/code\u003e中完成该 \u003ccode\u003eprovider\u003c/code\u003e 的实例化，从而完成初始化\u003c/strong\u003e。在循环引用里面，也是要通过 \u003ccode\u003eresolveSingleParam\u003c/code\u003e 来解决循环问题。而该方法下面，有两个功能：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic resolveParamToken\u0026lt;T\u0026gt;(\n  wrapper: InstanceWrapper\u0026lt;T\u0026gt;,\n  \u003cspan class=\"hljs-attr\"\u003eparam\u003c/span\u003e: Type\u0026lt;any\u0026gt; | string | symbol | any,\n) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!param.forwardRef) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e param;\n  }\n  wrapper.forwardRef = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e param.forwardRef();\n}\n\npublic \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e resolveComponentHost\u0026lt;T\u0026gt;(\n  \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e: Module,\n  \u003cspan class=\"hljs-attr\"\u003einstanceWrapper\u003c/span\u003e: InstanceWrapper\u0026lt;T\u0026gt;,\n  contextId = STATIC_CONTEXT,\n  inquirer?: InstanceWrapper,\n): \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026lt;InstanceWrapper\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e inquirerId = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.getInquirerId(inquirer);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instanceHost = instanceWrapper.getInstanceByContextId(contextId, inquirerId);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!instanceHost.isResolved \u0026amp;\u0026amp; !instanceWrapper.forwardRef) {\n    \u003cspan class=\"hljs-comment\"\u003e// 正常过程\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.loadProvider(instanceWrapper, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, contextId, inquirer);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n    \u003cspan class=\"hljs-comment\"\u003e// 循环引用\u003c/span\u003e\n    !instanceHost.isResolved \u0026amp;\u0026amp;\n    instanceWrapper.forwardRef \u0026amp;\u0026amp;\n    (contextId !== STATIC_CONTEXT || !!inquirerId)\n  ) {\n    instanceHost.donePromise \u0026amp;\u0026amp;\n      instanceHost.donePromise.then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.loadProvider(instanceWrapper, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, contextId, inquirer));\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e instanceWrapper;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到 \u003ccode\u003eresolveParamToken\u003c/code\u003e 里面由于存在 \u003ccode\u003eformward\u003c/code\u003e 的关系，InstanceWrapper 的 \u003ccode\u003eforwardRef\u003c/code\u003e 属性被设置为 \u003ccode\u003etrue\u003c/code\u003e，并且拿到了 \u003ccode\u003e@Inject(forwardRef(() =\u0026gt; CatsService))\u003c/code\u003e 里面 \u003ccode\u003eCatsService\u003c/code\u003e 这个类。后面通过这个类名，找到对应的 instanceWrapper，并到达 \u003ccode\u003eresolveComponentHost\u003c/code\u003e 方法。在该方法的条件里面循环引用会走到 \u003ccode\u003edonePromise\u003c/code\u003e。只是这里第一个问题，前面提到的传入 \u003ccode\u003eresolveComponentHost\u003c/code\u003e 的 instanceWrapper 是注入项 \u003ccode\u003eCatsService\u003c/code\u003e，而引用方的 wrapper 设置了 \u003ccode\u003eforwardRef\u003c/code\u003e 的，但是注入项 \u003ccode\u003eCatsService\u003c/code\u003e 并没有，所以不可能到循环里面的。那这是为什么呢？\u003c/p\u003e\n\u003cp\u003e在 debug 的时候就发现代码执行一直是跳来跳去的，并不是阅读顺序上的从上到下。这是由于采用了多个 map 结构，比如下面的：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eprivate \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e createInstancesOfProviders(\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e: Module) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { providers } = \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.all(\n    [...providers.values()].map(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e wrapper =\u0026gt;\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.injector.loadProvider(wrapper, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e),\n    ),\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于 \u003ccode\u003ePromise.all\u003c/code\u003e 会遍历其下面的所有异步事件，只是里面的执行顺序是如何的呢？\u003cstrong\u003e如果遇到异步里面有异步如何处理？\u003c/strong\u003e 对于第一个异步事件，会执行里面的同步语句，直到遇到第一个 \u003ccode\u003eawait\u003c/code\u003e 语句，会执行其里面的同步语句，\u003cstrong\u003e若遇到 \u003ccode\u003eawait\u003c/code\u003e再执行里面的同步部分，直到返回非异步语句，并开始执行 \u003ccode\u003ePromise.all\u003c/code\u003e 下的第二个异步语句，按这样的逻辑依次循环\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e回到前面，在 \u003ccode\u003eresolveParamToken\u003c/code\u003e 之后，由于异步返回的问题，会先执行其他遍历的异步语句到 \u003ccode\u003eresolveParamToken\u003c/code\u003e 之后，于是 \u003ccode\u003eCatsService\u003c/code\u003e 的 instanceWrapper 也被设置了 \u003ccode\u003eforwardRef\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e进入 \u003ccode\u003edonePromise.then\u003c/code\u003e 操作，要执行 \u003ccode\u003ethen\u003c/code\u003e 需要有 \u003ccode\u003eresolve\u003c/code\u003e 的过程，但是 \u003ccode\u003eresolve\u003c/code\u003e 在 \u003ccode\u003ecallback\u003c/code\u003e 里面执行，而随后则马上返回 \u003ccode\u003eCatsService\u003c/code\u003e 的 instanceWrapper。按照前文介绍的，依赖的注入，是不断的迭代传入实例的，但是这里本来是需要继续迭代的，现在进入了 Promise 里面，传递链被中断，要如何返回含有实例的 instanceWrapper ？这也是可以由上面的 \u003ccode\u003ePromise.all\u003c/code\u003e 的问题来解答，在一个遍历里面出现中断，执行 \u003ccode\u003ePromise.all\u003c/code\u003e 的下一个异步，从而使得对象 \u003ccode\u003einstanceWrapper.instance\u003c/code\u003e 能够异步的添加上实例。\u003c/p\u003e\n\u003cp\u003e后面遍历的时候已经获取到 \u003ccode\u003eCatsService\u003c/code\u003e 的实例了，在 \u003ccode\u003ecallback\u003c/code\u003e 里面 \u003ccode\u003eresolve\u003c/code\u003e 的时候，则会回到前面的 \u003ccode\u003edonePromise.then\u003c/code\u003e 从而继续加载实例，由于存在 \u003ccode\u003eisResolved\u003c/code\u003e，这里就有第二个问题了，既然遍历的过程中已经创建实例了，为什么还有继续 \u003ccode\u003edonePromise.then\u003c/code\u003e 的过程呢？这里有个猜测：可能避免循环漏掉了的问题吧，只是具体用途也没有想出来。\u003c/p\u003e\n\u003cp\u003e除了正向引用，还有模块引用，也和正向引用有点类似，依赖于 \u003ccode\u003eforwardRef\u003c/code\u003e 写法。模块引用里面，采用的是缓存判断，如果缓存里面有该模块，则不会继续当前遍历。\u003c/p\u003e\n\u003cp\u003etypescript 在编译循环引用的参数时候，参数会被转为 undefined，是无法识别的。正向引用需要 \u003ccode\u003einject\u003c/code\u003e 修饰器来添加额外的参数，来覆盖参数的 undefined，同样的模块引用也需要 \u003ccode\u003eforwardRef\u003c/code\u003e 来表示非直接循环，从而可以编译出正确的参数。（至于为什么 typescript 无法编译出循环参数，我就不晓得了。。。。）\u003c/p\u003e\n\u003ch2\u003e注入作用域\u003c/h2\u003e\n\u003cp\u003e这里虽然翻译是叫做注入作用域，但是，感觉更多的是\u003cstrong\u003e隔离\u003c/strong\u003e的作用。前文提到的依赖注入，有个特点，就是由\u003cstrong\u003e依赖生成的实例，会被所有引用方共享。\u003c/strong\u003e 这在大部分时候是没有问题的，只是有时可能有特别的需求，比如需要用到依赖生成实例的静态变量，导致依赖生成的实例共享就会被相互污染。于是就有了注入作用域的概念，字面理解：注入的依赖有自己的作用域，而不会在所有需要的类中共享。\u003c/p\u003e\n\u003cp\u003e具体的使用方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e@Injectable({ \u003cspan class=\"hljs-attr\"\u003escope\u003c/span\u003e: Scope.REQUEST })\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eCatsService\u003c/span\u003e \u003c/span\u003e{}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eInjectable\u003c/code\u003e 里面的传参只可以配置 scope 字段或者不传，表示 \u003ccode\u003eCatsService\u003c/code\u003e 的作用域，不传的话，默认则是在所有类中共享依赖的实例。常见的配置有：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eDEFAULT\u003c/code\u003e 依赖的实例在所有需要的类中共享；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTRANSIENT\u003c/code\u003e 在每个需要依赖的类中，单独传递实例，而不与其他类共享，为单例模式；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eREQUEST\u003c/code\u003e 依赖的实例不会在初始化中生成，而是在每次请求的时候，都会重新生成对应实例，并在该请求的所有类中共享该实例；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e先看看 \u003ccode\u003eTRANSIENT\u003c/code\u003e 模式，按照前文说的依赖注入的方式，一旦一个依赖被标记为 \u003ccode\u003eisResolved\u003c/code\u003e，其实例就已经是生成的了，下次还需要该依赖的时候，则直接用已经生成的实例。\u003ccode\u003eTRANSIENT\u003c/code\u003e 模式在第一个依赖生成的时候，就和默认方式不一样了。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e loadInstance\u0026lt;T\u0026gt;(\n  wrapper: InstanceWrapper\u0026lt;T\u0026gt;, \u003cspan class=\"hljs-attr\"\u003ecollection\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eMap\u003c/span\u003e\u0026lt;string, InstanceWrapper\u0026gt;,\n  \u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: Module, contextId = STATIC_CONTEXT, inquirer?: InstanceWrapper,\n) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e inquirerId = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.getInquirerId(inquirer);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instanceHost = wrapper.getInstanceByContextId(contextId, inquirerId);\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (instanceHost.isPending) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e instanceHost.donePromise;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e done = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.applyDoneHook(instanceHost);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { name, inject } = wrapper;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e targetWrapper = collection.get(name);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isUndefined(targetWrapper)) {\n    \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e RuntimeException();\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (instanceHost.isResolved) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e done();\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e callback = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (instances: unknown[]) =\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e properties = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.resolveProperties(wrapper, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, inject,contextId, wrapper, inquirer);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instance = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.instantiateClass(instances, wrapper, targetWrapper, contextId, inquirer);\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.applyProperties(instance, properties);\n    done();\n  };\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.resolveConstructorParams\u0026lt;T\u0026gt;(wrapper, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, inject, callback, contextId, wrapper, inquirer);\n}\n\npublic getInstanceByContextId(contextId: ContextId, inquirerId?: string) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.scope === Scope.TRANSIENT \u0026amp;\u0026amp; inquirerId) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.getInstanceByInquirerId(contextId, inquirerId);\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 如果不是 TRANSIENT 则会返回静态实例，也就是通用实例\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instancePerContext = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.values.get(contextId);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e instancePerContext\n    ? instancePerContext\n    : \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.cloneStaticInstance(contextId);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里有个细节地方，在加载实例的通用入口 \u003ccode\u003eloadInstance\u003c/code\u003e 里面，\u003ccode\u003egetInstanceByContextId\u003c/code\u003e 方法会判断是否是 \u003ccode\u003eTRANSIENT\u003c/code\u003e 模式，如果是，则会进入 \u003ccode\u003egetInstanceByInquirerId\u003c/code\u003e 根据引用方类来获得实例，自然不同的。\u003ccode\u003egetInstanceByInquirerId\u003c/code\u003e 正如名字，通过引用方，也就是 \u003ccode\u003eInquirerId\u003c/code\u003e 来获取实例，\u003ccode\u003egetInstanceByContextId\u003c/code\u003e 则是通过上 \u003ccode\u003eContextId\u003c/code\u003e 来获取实例，而 \u003ccode\u003eContextId\u003c/code\u003e 默认是静态实例的 id，也就是 1。在 \u003ccode\u003egetInstanceByInquirerId\u003c/code\u003e 里面会通过 \u003ccode\u003eInquirerId\u003c/code\u003e 在通过获取引用方的实例集合，再通过 \u003ccode\u003econtextId\u003c/code\u003e 获得最后的实例，这个就是 \u003ccode\u003eTRANSIENT\u003c/code\u003e 的特色，\u003cstrong\u003e依赖通过实例的引用方的 \u003ccode\u003eInquirerId\u003c/code\u003e，再通过 \u003ccode\u003eContextId\u003c/code\u003e 来获取，所以不同的类，注入相同的依赖类，实例的时候，也会获取到不同的依赖实例\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egetInstanceByContextId\u003c/code\u003e 和 \u003ccode\u003egetInstanceByInquirerId\u003c/code\u003e 若无法根据 \u003ccode\u003econtextId\u003c/code\u003e 获得实例，都会有一个克隆实例的机制，\u003ccode\u003egetInstanceByContextId\u003c/code\u003e 里面是 \u003ccode\u003ecloneStaticInstance\u003c/code\u003e，这里看看 \u003ccode\u003egetInstanceByInquirerId\u003c/code\u003e 返回的 \u003ccode\u003ecloneTransientInstance\u003c/code\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic cloneTransientInstance(contextId: ContextId, \u003cspan class=\"hljs-attr\"\u003einquirerId\u003c/span\u003e: string) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e staticInstance = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.getInstanceByContextId(STATIC_CONTEXT);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instancePerContext: InstancePerContext\u0026lt;T\u0026gt; = {\n    ...staticInstance,\n    \u003cspan class=\"hljs-attr\"\u003einstance\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eisResolved\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eisPending\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n  };\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isNewable()) {\n    instancePerContext.instance = \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.create(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.metatype.prototype);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.setInstanceByInquirerId(contextId, inquirerId, instancePerContext);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e instancePerContext;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到返回的 \u003ccode\u003einstancePerContext\u003c/code\u003e 是一个新对象，对象里面的 \u003ccode\u003einstance\u003c/code\u003e 实例已经为 \u003ccode\u003eundefined\u003c/code\u003e，并且 \u003ccode\u003eisResolved\u003c/code\u003e 和 \u003ccode\u003eisPending\u003c/code\u003e 为 \u003ccode\u003efalse\u003c/code\u003e；这样若一个依赖已经被实例过了，当别的类需要这个依赖的实例，遍历的时候就会进入 \u003ccode\u003eloadInstance\u003c/code\u003e 函数，并克隆实例，从而获得新的实例对象可以继续遍历。\u003c/p\u003e\n\u003ch3\u003e注入作用域之 REQUEST\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eREQUEST\u003c/code\u003e 模式不会在一开始初始化的时候就实例好所有的依赖，而且是在请求的时候去实例化依赖。\u003ccode\u003eDEFAULT\u003c/code\u003e、\u003ccode\u003eTRANSIENT\u003c/code\u003e 和 \u003ccode\u003eREQUEST\u003c/code\u003e 都会在初始化的时候创建路由，但是 \u003ccode\u003eREQUEST\u003c/code\u003e 是在发生请求的时候，再创建新的上下文环境，每个请求都是新的。在创建路由的时候，会根据 \u003ccode\u003eisDependencyTreeStatic\u003c/code\u003e 的返回，来判断是不是要实现 \u003ccode\u003eREQUEST\u003c/code\u003e 的路由：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic isDependencyTreeStatic(lookupRegistry: string[] = []): boolean {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isUndefined(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isTreeStatic)) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isTreeStatic;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 为 REQUEST 模式，则 isTreeStatic 为 false\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.scope === Scope.REQUEST) {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isTreeStatic = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isTreeStatic;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (lookupRegistry.includes(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e[INSTANCE_ID_SYMBOL])) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  }\n  lookupRegistry = lookupRegistry.concat(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e[INSTANCE_ID_SYMBOL]);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { dependencies, properties, enhancers } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e[\n    INSTANCE_METADATA_SYMBOL\n  ];\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e isStatic =\n    (dependencies \u0026amp;\u0026amp;\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isWrapperListStatic(dependencies, lookupRegistry)) ||\n    !dependencies;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isStatic || !(properties || enhancers)) {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isTreeStatic = isStatic;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.isTreeStatic;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 省略下面的代码\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eisDependencyTreeStatic\u003c/code\u003e 计算是否是静态实例，比如 \u003ccode\u003eDEFAULT\u003c/code\u003e 和 \u003ccode\u003eTRANSIENT\u003c/code\u003e 模式。上面还可以看到 \u003ccode\u003eisWrapperListStatic\u003c/code\u003e 这个功能，如果一个类注入了依赖，若依赖是 \u003ccode\u003eREQUEST\u003c/code\u003e 模式，则这个类也会是 \u003ccode\u003eREQUEST\u003c/code\u003e 模式，从而实现作用域的传递。\u003c/p\u003e\n\u003cp\u003e这个 \u003ccode\u003eisDependencyTreeStatic\u003c/code\u003e 在初始化的时候，其实就已经调用了，在 \u003ccode\u003einstantiateClass\u003c/code\u003e 里面的 \u003ccode\u003eisStatic\u003c/code\u003e 方法就通过 \u003ccode\u003eisDependencyTreeStatic\u003c/code\u003e 来判断是否是静态实例，如果是则 \u003ccode\u003einstantiateClass\u003c/code\u003e 会 new 一个实例。\u003c/p\u003e\n\u003cp\u003e下面看一下 \u003ccode\u003eREQUEST\u003c/code\u003e 下路由处理函数的机制：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003epublic createRequestScopedHandler(\n  instanceWrapper: InstanceWrapper, \u003cspan class=\"hljs-attr\"\u003erequestMethod\u003c/span\u003e: RequestMethod,\n  \u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: Module, \u003cspan class=\"hljs-attr\"\u003emoduleKey\u003c/span\u003e: string, \u003cspan class=\"hljs-attr\"\u003emethodName\u003c/span\u003e: string,\n) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { instance } = instanceWrapper;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e collection = \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.controllers;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u0026lt;TRequest, TResponse\u0026gt;\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq: TRequest, res: TResponse, next: (\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e) =\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e contextId = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.getContextId(req);\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.container.registerRequestProvider(req, contextId);\n\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e contextInstance = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.injector.loadPerContext(\n        instance, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e, collection,contextId);\n      \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createCallbackProxy(\n        contextInstance, contextInstance[methodName], methodName,\n        moduleKey, requestMethod, contextId, instanceWrapper.id,\n      )(req, res, next);\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (err) {\u003cspan class=\"hljs-comment\"\u003e/*省略部分代码*/\u003c/span\u003e}\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eContextId\u003c/code\u003e 默认是静态 id，在 \u003ccode\u003eREQUEST\u003c/code\u003e 模式下，\u003cstrong\u003e若发生请求的时候，则是当前请求的 \u003ccode\u003eContextId\u003c/code\u003e，若没有则创建一个随机数 \u003ccode\u003eMath.random()\u003c/code\u003e。\u003c/strong\u003e 普通的请求最后都会创建一个随机数，至于其他的情况就不明确了，只是随机数还是有可能重复的，当然官方有介绍到由于采用的 \u003ccode\u003eWeakMap\u003c/code\u003e，里面的 key 是个对象，什么对象呢？\u003ccode\u003e{ id: 1 }\u003c/code\u003e。里面的 id 可能会重复，但是 key 已经是个不同的对象，所以就算是重复请求同一个路径，key 是不同的对象，那 \u003ccode\u003eContextId\u003c/code\u003e 就是安全的。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eloadPerContext\u003c/code\u003e 方法则是加载实例调用的，还是 \u003ccode\u003eloadInstance\u003c/code\u003e 方法，然后经过 \u003ccode\u003egetInstanceByContextId\u003c/code\u003e 又是一个全新的 instanceWrapper，里面的 \u003ccode\u003einstance\u003c/code\u003e 实例已经为 \u003ccode\u003eundefined\u003c/code\u003e，并且 \u003ccode\u003eisResolved\u003c/code\u003e 和 \u003ccode\u003eisPending\u003c/code\u003e 为 \u003ccode\u003efalse\u003c/code\u003e，于是又可以继续迭代下去。最后 \u003ccode\u003ecreateCallbackProxy\u003c/code\u003e 则和普通的模式一样了。\u003c/p\u003e\n\u003cp\u003e还有复杂的，比如 \u003ccode\u003eREQUEST\u003c/code\u003e 和 \u003ccode\u003eTRANSIENT\u003c/code\u003e 结合，与循环依赖结合等等，这些复杂的情况就不一一讨论了，正常人都不会这么用的。。。。\u003c/p\u003e\n\u003ch2\u003e中间件\u003c/h2\u003e\n\u003cp\u003e在初始化的过程中，其实省略了中间件是如何加入应用，并结合路由的过程，只是简单描述了中间件添加到配置中。主要也是这部分没有什么特别的，顺着代码下去就能明白，这介绍一下最后的环节：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eprivate \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e bindHandler(\n  wrapper: InstanceWrapper\u0026lt;NestMiddleware\u0026gt;, \u003cspan class=\"hljs-attr\"\u003eapplicationRef\u003c/span\u003e: HttpServer,\n  \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: RequestMethod, \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: string, \u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: Module,\n  \u003cspan class=\"hljs-attr\"\u003ecollection\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eMap\u003c/span\u003e\u0026lt;string, InstanceWrapper\u0026gt;,\n) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { instance, metatype } = wrapper;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isUndefined(instance.use)) {\n    \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e InvalidMiddlewareException(metatype.name);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e router = applicationRef.createMiddlewareFactory(method);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isStatic = wrapper.isDependencyTreeStatic();\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isStatic) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e proxy = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.createProxy(instance);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.registerHandler(router, path, proxy);\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// ..。省略后面代码\u003c/span\u003e\n}\n\nprivate \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e createProxy( instance: NestMiddleware, contextId = STATIC_CONTEXT) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e exceptionsHandler = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.routerExceptionFilter.create(\n    instance, instance.use, \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e, contextId,\n  );\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e middleware = instance.use.bind(instance);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.routerProxy.createProxy(middleware, exceptionsHandler);\n}\n\nprivate registerHandler(\n  router: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e...args: any[]\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: string,\n  \u003cspan class=\"hljs-attr\"\u003eproxy\u003c/span\u003e: \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eTRequest,\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eTResponse\u003c/span\u003e\u0026gt;\u003c/span\u003e(req: TRequest, res: TResponse, next: () =\u0026gt; void) =\u0026gt; void,\n) {\n  const prefix = this.config.getGlobalPrefix();\n  const basePath = validatePath(prefix);\n  if (basePath \u0026amp;\u0026amp; path === '/*') {\n    path = '*';\n  }\n  router(basePath + path, proxy);\n}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过 \u003ccode\u003ecreateProxy\u003c/code\u003e 创建的代理返回的 \u003ccode\u003ethis.routerProxy.createProxy\u003c/code\u003e 和初始化路由最后实现代理的方式一致，而 \u003ccode\u003erouter\u003c/code\u003e 的实现 \u003ccode\u003eapplicationRef.createMiddlewareFactory(method)\u003c/code\u003e 和初始化路由里面的路由方法创建 \u003ccode\u003econst routerMethod = this.routerMethodFactory.get(router, requestMethod).bind(router);\u003c/code\u003e 是一模一样的。\u003c/p\u003e\n\u003cp\u003e于是可以发现中间件的注册，其实和普通路由的注册一样，只是路由的实现是通过对应的 \u003ccode\u003emethod\u003c/code\u003e，而中间是通过 \u003ccode\u003euse\u003c/code\u003e 方法。最后当请求发送过来的时候，先依次通过这些中间件处理，在 \u003ccode\u003enext()\u003c/code\u003e 下流转，最后才到路由处理函数。本质还是用到 \u003ccode\u003eexpress\u003c/code\u003e 中间件的方法。\u003c/p\u003e\n"}},"buildId":"r4Ww0YLm8YL5~6SwciWHH","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" async=""></script></body></html>