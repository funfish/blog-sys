<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">可变字体探索与 require 扫盲记</title><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.587c5e31.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___2dTZ9 "><a class="logo___346dE" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___13XXt" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___29Pln"><h1 class="postTitle___1_m4g">可变字体探索与 require 扫盲记</h1><span class="postTime___1x0_i">March 24, 2021</span></header><article class="postWrapper___3jnNg post-article"><div><p>国庆后一场秋雨一场寒，属于东南季风的台风带来了明显的降温，又到了一个尴尬的温度，长袖短裤都有人穿。这个温度，感觉很舒服，尤其是在海边骑单车的时候，沿着沙河路的时候，城市灯光的点缀，观景台边的海涛声、阵阵袭人的秋意就来了。</p>
<p>本篇是介绍两个琐事，都是工作中遇到的，一个是可变字体探索，一个是 <code>require</code> 扫盲记。</p>
<h2>Variable Fonts</h2>
<p>好像从前几个月开始，就接触了<a href="https://zh.wikipedia.org/zh-hans/%E5%8F%AF%E5%8F%98%E5%AD%97%E4%BD%93" target="_blank">可变字体</a>，以前设计推荐的是使用 5 种字体，你没有看错，在项目里面用到了 5 、种字体，不同的粗细，不同的高瘦，每个字体都基本在 8M 左右，通过不同的字体来展示设计的风格，真是。。。挺好的。今年开始有新的字体，没有以前的 5 种，只用一个可变字体了，通过一个字体来展示之前 5 个的字体，可以说很是优秀，当然对开发而言，统一的字体最是简单，而且一个字体意味着只要加载一种就好了，之前的要加载 5 种字体，虽然一个可变字体的体积是 20 M。</p>
<p>可以通过这个<a href="https://v-fonts.com/" target="_blank">网站</a> 玩一下可变字体。</p>
<p>字体，对于开发者而言，默认基本都是采用系统的字体，比如系统差别、中西文差别，还有最后的衬线字体，比如我们公司就喜欢用 <code>android</code> 的 <code>Roboto</code> 默认字体来显示数字。如果采用自己的字体的话，会把其放在最前面，所以最前面是 <code>OPPOSANS, Roboto, Noto Sans CJK SC, Source Han Sans CN</code> 后面两个是思源字体，毕竟 <code>OPPOSANS</code> 是和思源字体结合的。。。。</p>
<p>通过设置 <code>font-variation-settings: &quot;wght&quot; 550</code> 可以调整字体的粗细，比如 <code>OPPOSANS</code> 字重可以调整到 <code>1000-1000</code> 区间，实现<strong>无极调整</strong>，不像以前的字体，只有一百倍数的 <code>font-weight</code>，而且要一个字体文件就够了。还有其他的比如 <code>wdth</code> <code>ital</code> 这些都可以设置。
比如下图</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/variableFonts.PNG" alt=""></p>
<p>还能在这个基础上用上 <code>font-weight</code>，当然这个就不规范了。目前 <code>font-variation-settings</code> 的兼容性还是比较好的，除了 ie 和部分比较老的浏览器不支持外，其他都没有问题的。</p>
<h3>字体的普通处理</h3>
<p>如果是采用系统的字体那一切都挺好的，但是作为设计，作为一家最求美感的公司，就是要有自己的字体，于是普通字体的 10M 的体积，加载速度就可以劝退大部分人了。为了平滑顺利过渡字体，一般采用的是如下几个方案：</p>
<ol>
<li>**<code>font-face</code> 定义的时，采用 <code>swap</code> 来显示，系统会优先采用已有的字体，避免字体加载导致的阻塞，使得文字无法显示；**当然这种方案会导致字体加载成功时，页面切换会从当前字体切换到自定义字体，导致用户体验稍差。如果自定字体体积小，可以不采用 <code>swap</code> 方式。</li>
<li><strong>字体文件预加载，就是在 <code>link</code> 标签里面采用 <code>preload</code> 的方式，字体资源在浏览器里，属于优先级较低的资源，通过 <code>link</code> 的预加载可以显著的提高优先级，避免字体加载时间过长，导致切换时候带来的不好体验</strong>。</li>
<li>**字体体积，上面更多的是辅助优化，对于中文字体而言，最重要的是体积。中文不同于其他字母语言，有非常多的字，一个字体 10 M 的体积要如何处理呢，正常会对字体文件做提取，只保留可能要用的字，也就是 glyphs。**比如只用到 <code>溜</code> 这个字，那就提取字体包里的 <code>溜</code>，这样字体文件就可以压缩的非常小了</li>
<li>最后是 woff、woff2 这些新格式带来的优化，以及更好的压缩算法带来的帮助。</li>
</ol>
<h3>字体的提取历程</h3>
<p>这里要介绍是可变字体的提取问题，先看看普通字体提取，之前用的是 <code>font-spider</code>，使用下来可以满足字体的压缩，提取需要的子集，用法很方便，如下：</p>
<pre class="hljs"><code><span class="hljs-comment">&lt;!-- test.html --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
  <span class="hljs-keyword">@font-face</span> {
    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">"source"</span>;
    <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">"../font/source.eot"</span>);
    <span class="hljs-attribute">font-style</span>: normal;
  }
  <span class="hljs-selector-tag">body</span> {
    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">"source"</span>;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  溜
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</code></pre>
<p>再通过指令 <code>font-spider ./test.html</code> 就可以从 <code>source.eot</code> 字体包里面压缩出仅仅包含 <code>溜</code> 一个字的字体，当然会有一点小问题，比如垂直方向的行间距变小了，但是总体问题不大，10M 的字体包，最后只剩下几 kb。这个时候如果用软件 FontForge 查看的话，可以看到 <code>溜</code> 保留下来了，其他被移除了。
<img src="https://github.com/funfish/blog/raw/master/images/fontLiuNormal.PNG" alt="">
<img src="https://github.com/funfish/blog/raw/master/images/fontLiuMin.PNG" alt=""></p>
<p>上面左边是正常的字形，右边则是压缩之后的效果，可以看到压缩后周围的小伙伴都被吓跑了。</p>
<p>只是到了可变字体，压缩就不是这样了，简简单单的 <code>font-spider</code> 打包出来的字体就不能用，会出现字体镂空的情况，而且关键是不能调整可变字体的 <code>wght</code>，设置了也不起作用，简直就是和普通字体差不多，不再是可变字体了。</p>
<p>于是翻箱倒柜的，在 <code>font-spider</code> 里面转了一圈，结果发现里面处理字体的内容不多，更多的是对输入文件和样式处理，通过模拟的浏览器环境，自研的 <code>browser-x</code>(大佬自己写的 <code>Node.js</code> 实现的虚拟浏览器) 来获取样式，保证不同的的 <code>font-family</code> 打包出不同的字体，分析输入的参数，文字最后输出四种格式的字体，<code>woff woff2 svg ttf</code> 这些，当然在 <code>WebFont</code> 里面看到了不少冗余的代码，一度让我误解了，比如 <code>weight stretch</code> 这些属性，就不能使用。。。。可能也是大佬弃坑了吧，最后落实到压缩的还是 <code>fontmin</code> 这个库，也有三方压缩的工具都是基于 <code>fontmin</code> 的。</p>
<p><code>fontmin</code> 是一款中间件机制的字体处理工具，比如 <code>glyph</code> 可以用来压缩字体，比如 <code>ttf2woff</code> 可以转换字体。比如下面的官方例子：</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> Fontmin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fontmin"</span>);

<span class="hljs-keyword">var</span> fontmin = <span class="hljs-keyword">new</span> Fontmin().use(
  Fontmin.glyph({
    <span class="hljs-attr">text</span>: <span class="hljs-string">"天地玄黄 宇宙洪荒"</span>,
    <span class="hljs-attr">hinting</span>: <span class="hljs-literal">false</span>,
  })
);
</code></pre>
<p>在 <code>fontmin</code> 代码里面的 <code>glyph</code> 插件代码中可以看到如下形式：</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> TTF = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fonteditor-core"</span>).TTF;
<span class="hljs-keyword">var</span> TTFReader = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fonteditor-core"</span>).TTFReader;
<span class="hljs-keyword">var</span> TTFWriter = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fonteditor-core"</span>).TTFWriter;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minifyTtf</span>(<span class="hljs-params">contents, opts</span>) </span>{
  opts = opts || {};
  <span class="hljs-keyword">var</span> ttfobj = contents;
  <span class="hljs-keyword">if</span> (Buffer.isBuffer(contents)) {
    ttfobj = <span class="hljs-keyword">new</span> TTFReader(opts).read(b2ab(contents));
  }
  <span class="hljs-keyword">var</span> miniObj = minifyFontObject(ttfobj, opts.subset, opts.use);
  <span class="hljs-keyword">var</span> ttfBuffer = ab2b(<span class="hljs-keyword">new</span> TTFWriter(opts).write(miniObj));
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">object</span>: miniObj,
    <span class="hljs-attr">buffer</span>: ttfBuffer,
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minifyFontObject</span>(<span class="hljs-params">ttfObject, subset, plugin</span>) </span>{
  <span class="hljs-keyword">if</span> (subset.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> ttfObject;
  }
  <span class="hljs-keyword">var</span> ttf = <span class="hljs-keyword">new</span> TTF(ttfObject);
  ttf.setGlyf(getSubsetGlyfs(ttf, subset));
  <span class="hljs-keyword">if</span> (_.isFunction(plugin)) {
    plugin(ttf);
  }
  <span class="hljs-keyword">return</span> ttf.get();
}
</code></pre>
<p>敢情 <code>fontmin</code> 也是套娃的。。。最后核心的字体处理还是要跑到 <code>fonteditor-core</code> 里面，怎么说呢， <code>fontmin</code> 是一个优秀的集成商，有字体压缩，还有字体格式转换这些功能，虽然大部分是基于第三方的。而且不管是 <code>fontmin</code> 还是 <code>font-spider</code> 也有四五年没有更新主要内容了，作者也都弃坑了。那对于 16 年底才发布的可变字体，好像不支持也是可以理解的。</p>
<h3>table</h3>
<p>介绍到 <code>fonteditor-core</code> 就要提一下 <code>table</code> 的概念，这个是布局信息表，其包含了字形的位置、对齐、基线等等信息，字体文件则是由这一系列的表构成的，其中有部分表是可选的。</p>
<p><strong>字体目录</strong>是字体文件的指南，提供访问其他表所需的信息，包含两部分：偏移子表（offset subtable）和表目录（table directory）。偏移子表记录了字体文件中 <code>table</code> 的数量，并提供了快速访问表目录的方法。偏移子表后面就是表目录，表目录主要包含了表的 <code>tag</code>、校验、偏移、长度等信息，字体文件中的所有表都在表目录里面有入口。</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/fontTableDirectory.PNG" alt=""></p>
<p>看了不少文档，每个文档对必选的 <code>table</code> 都有自己的解释，综合一下，下面是其中有几个是非常必要的 <code>table</code>:</p>
<ol>
<li>cmap：字符代码到字形索引之间的映射关系，字符代码也就是字符的 <code>Unicode</code>，获得索引也就可以根据索引从字体中加载这个字形。</li>
<li>head：字体的各种基本信息，如版本、创建、修改时间，还包括基本字体数据，如 unitsPerEm、xMin, yMin 等。</li>
<li>hhea：水平排列信息，如 ascender、descender、lineGap 等水平排列时候的布局信息。</li>
<li>hmtx：水平参数，如间距，如果是字形之间是等距的，那只需要一个间距就可以了。</li>
<li>maxp：最大需求表，包含字形数量，表示字形的内存需求情况。</li>
<li>name：命名内容，如字体名，授权信息等等。</li>
<li>post：PostScript 表，用于打印。</li>
<li>glyf：字形数据，也是最重要的一个表了。</li>
<li>loca：偏移和字符索引映射关系表。</li>
</ol>
<p>上面几个表的介绍可能理解不太到位地方，因该差不多大致如此吧。另外，还有一些比如 <code>OS/2</code>: 用于 windows 系统的配置，所以对跨平台的字体就非常需要了，但是若是针对 Mac 这些就不必了。</p>
<p>具体的字形什么的，用 <code>FontForge</code> 软件打开任意一个字体就可以看到了，比如下面的：</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/fontLiuGlyph.PNG" alt=""></p>
<p>你甚至都可以修改字形。。。。</p>
<p>至于字体从加载到渲染出来的流程可以参考一下知乎上的<a href="https://www.zhihu.com/question/23759223/answer/25617486" target="_blank">介绍</a></p>
<blockquote>
<p>加载字体文件
确定要输出的字体大小
输入这个字符的编码值
根据字体文件里面的 Charmap，把编码值转换成字形索引（就是这个字符对应字体文件中的第几个形状）
根据索引从字体中加载这个字形
将这个字形渲染成位图，有可能进行加粗，倾斜等变换。注意这里的倾斜和倾斜字体不同，它只是从算法上对位图进行变换，与专门制作的加粗字体是不一样的。</p>
</blockquote>
<p>上面介绍的是 <code>cmap</code> 根据字符代码拿到字形索引，再从 <code>loca</code> 拿到索引对应的字形偏移，最后到 <code>glyf</code> 加载字形的过程。<code>loca</code> 表可以参考以下图：</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/fontLoca.PNG" alt=""></p>
<p>每个字形都有自己长度，从而形成相对于 <code>0</code> 位置的偏移，而 <code>loca</code> 表则是记录字形索引到字形偏移的映射表。</p>
<p>当然这里面还有很多的表的内容没有谈到，比如和 <code>TrueType</code>、<code>CCF</code>、<code>SVG</code> 以及 <code>BitMap</code> 相关的表，还有一个是高级表，比如 <code>GSUB</code> 是 <code>glyf</code> 的替换表，之前提到的一个字符代码最后可以映射到字形，但是如果是连字的时候，就不一定是简单的字形叠加，例如下面的：</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/fontGSUB.PNG" alt=""></p>
<p>可以看到单独一个字的时候都是好好的，但是一旦结合在一起，就是不是 <code>f + i = fi</code> 了，而是有新的字形。这一点在阿拉伯语中也是的，字形在不同的位置有不同的显示。。。。。（原来阿拉伯语这么神奇，简直就是蝌蚪文）。</p>
<p>除了高级表，还有色彩相关的，其他比较杂的，最后还有一个是 <code>OpenType Font Variations</code> 可变字体，也是 <code>OpenType</code> 规范中，里面有 <code>avar</code>、<code>cvar</code>、<code>fvar</code>、<code>gvar</code>、<code>HVAR</code>、<code>MVAR</code>、<code>STAT</code> 和 <code>VVAR</code> 这几个。</p>
<h4>可变字体的 table</h4>
<p>可变字体，如前面提到的，可以让设计者将多个字体合并为一个字体，下面的示意图很好的介绍了字重和字宽度变化导致字形的变化：</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/variableFontsWidthWeight.PNG" alt=""></p>
<p>这里面看到的 <code>width</code> 和 <code>weight</code> 都是 <code>fvar</code> 表所描述的，用来存储轴的信息，以及命名实例，其中命名实例是可选的字段。轴的信息，比如 <code>wght(100-1000)</code>、<code>width(10-200)</code>，包含了轴名称、最小最大值和默认值等，命名实例则是由轴与轴之间定下的命名的特定坐标，如下面几个:</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/variableFVAR.PNG" alt=""></p>
<p>可以看到轴 <code>wght = 400</code> 以及 <code>wdth = 100</code> 形成的坐标 <code>Regular</code>，也就是命名实例。<code>Regular</code> 是给特定坐标提供的预设名称，也是该子字体的名称，可以让使用者直接使用。使用可变字体的时候，如果没有指定子字体，其采用默认轴值。（css 里面修改 <code>font-variation-settings</code>，也就是实例了）。</p>
<p>对于可变字体，有两个表是必须的：<code>fvar</code> 和 <code>STAT(style attributes)</code>，后者是样式属性，每个在 <code>fvar</code> 里面的每一条轴和子字体都需要在 <code>STAT</code> 里面有对应的信息。<code>STAT</code> 用来区分字体族下面的不同的字体，支持动态属性，比如 <code>fvar</code> 里面的 <code>wght(无极)</code>，也支持静态属性，比如 <code>italic</code> 是否为斜体这些，展示 <code>Variable Font</code> 下的样式名称，比如 <code>Medium</code> 这样的字体。</p>
<p>其他的表则是描述 <code>fvar</code> 里面字体轴变化时字形的变化情况，例如 <code>avar</code>，是非线性的轴变化数据，例如字体的 <code>width</code> 轴，若变化区间是 <code>100-200</code>，线性的时候，则 <code>150</code> 表示字体的字形宽度是两个极值的正中间，但是非线性变化，就使得值不是均匀的变化的，<code>150</code> 可能不是字形宽度上的正中间状态。这种非线性变化也符合用户习惯。还有 <code>gvar</code>，存储字形在轴上的变化信息，描述 <code>glyp</code> 中各个点的变化情况，可以说是非常重要的。</p>
<h3>字体提取工具</h3>
<p>看了上面的 <code>table</code> 介绍，字体的处理，其实就是对 <code>table</code> 的处理，<code>fonteditor-core</code> 对可变字体的处理，看了一下源码的<a href="https://github.com/kekee000/fonteditor-core/tree/master/src/ttf/table" target="_blank">结构</a>，well，根本就没有可变字体的表处理，连 <code>fvar</code> 的踪迹都没有。</p>
<p>于是开启大海捞针的方式，在 <code>github</code> 里面找，最后发现一个 <code>opentypejs/opentype.js</code> 仓库，卧槽，难道是官方的嫡系部队？只是打开到结构目录还是很失望，都是三四年前的代码了，和 <code>fonteditor-core</code> 差不多，虽然有 <code>fvar</code> 表，但是其他可变字体的表一个都没有。抱着试一试的想法，用一下，最后的打包出来的字体，虽然比 <code>fonteditor-core</code> 好不少，但是压根就不可变。。。。毕竟连 <code>gvar</code> 也没有。最后看到了这个<a href="https://github.com/opentypejs/opentype.js/issues/374" target="_blank">roadMap</a>，里面介绍到：</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/variableFontsRoadMap.PNG" alt=""></p>
<p>本来决定要放弃了，毕竟官方也不支持系列，但是总觉得有问题，难道可变字体没有工具？都好几年历史了，没有人造轮子吗。。。。</p>
<p>最后找到了字体处理的重量级库 <code>fonttools</code>，一个 <code>python</code> 库，打开一看密密麻麻的的 <code>table</code> 处理，有 50 个以上的处理，对比一下 <code>fonteditor-core</code> 的 18 个表处理，简直是。。。。。。在 <code>fonttools</code> 里面也找到了各种各样的可变字体处理表，比如 <code>gvar</code>，只是对 <code>python</code> 不是很熟悉，而且一上来就看源码，有点吃力，所以就放弃了（想起了看 esbuild 源码的经历）。</p>
<p><code>fonttools</code> 里面有很多工具，提取字体用的是 <code>pyftsubset</code>，通过指定文件字符来确定要输出的字形，基本上一顿操作下来，从 22M 的字体包，压缩到 300kb。正常来做这就可以了，但是 <strong>原本字体包还包含了斜、高度轴，这些轴，项目用不上，而且 <code>wght</code> 也就用到了 <code>550-1000</code> 的范围，能不能去掉剩下的部分呢？</strong> 这样不就可以完美压缩字体了，甚至 <code>wght</code> 就用了 <code>550</code> 和 <code>1000</code> 两个值，其他的能不能抛弃掉呢？可能这个就要用专业的设计工具了（比如 Adobe Illustrator？），目前在 <code>fonttools</code> 没有看到更多可操作空间，如果有大佬晓得一定要告知。</p>
<p>一般可变字体的体积是要大于单个字体的（字体族里面的单个字体），只有当需要用到同一字体族的多个字体的时候，可变字体收益才很大。当然如果需要艺术字那就另当别论了。另外 <code>font-variation-settings</code> 是属于比较基础的 API 了，如果要设置字重的话，可以使用 <code>font-weight: 550</code> 是不是很熟悉？这个和以前的 CSS 是一致的，只是 <code>CSS Fonts Level 4</code> 做了扩展，当然还有其他几个轴的，比如 <code>font-stretch</code>。</p>
<h2>require</h2>
<p>相比于字体，<code>require</code> 可以说是以前的一个知识盲区。在 <code>Vue</code> 里面，如果需要加载资源可以采用 <code>require</code> 方式引入，但是时不时的总会遇到无法加载资源的问题。直到一次想要把资源路径作为 <code>props</code> 传入组件，再通过 <code>require</code> 来获取，结果是获取到图片了，但是还引发了<strong>另外一个严重的问题，页面的样式错乱？</strong></p>
<p>通过审查打包出现的代码，发现原本完全没有引入的 <code>scss</code> 文件都被打包到样式文件里面，如果去掉 <code>require(urlProp)</code> 则一切正常，这个就很神奇了，而且前者的打出的包还很大。有种奇奇怪怪的感觉。</p>
<p>后面耐心的看 <code>webpack</code> <a href="https://webpack.js.org/guides/dependency-management/#require-with-expression" target="_blank">文档</a>才晓得：</p>
<blockquote>
<p>A context module is generated. <strong>It contains references to all modules in that directory that can be required</strong> with a request matching the regular expression. The context module contains a map which translates requests to module ids.</p>
</blockquote>
<p>如果采用 <code>require('./template/' + name + '.ejs')</code> 的方式，那 <code>template</code> 文件下面的所有 <code>ejs</code> 文件都会被引用，形成一个上下文的 <code>map</code> 对象，<strong>导致该目录下原本不会被使用的文件，也被打包使用上了</strong>，这也就是为什么使用了 <code>require(urlProp)</code> 会加载上错误的资源，可想而知，若 <code>require</code> 里面完全采用传参的方式，会使其无法分析正确的 <code>Directory</code>， 于是从根文件 <code>src</code> 开始查询文件。。。。。</p>
<p>至于要如何破局呢，<code>urlProp</code> 为了可扩展性，是要从外部传入的，而里面要读取资源只能用 <code>require</code> 了，直到看到了下面的 <code>require.context</code> 的方式，表达式如下：</p>
<pre class="hljs"><code><span class="hljs-built_in">require</span>.context(
  directory,
  (useSubdirectories = <span class="hljs-literal">true</span>),
  (regExp = <span class="hljs-regexp">/^\.\/.*$/</span>),
  (mode = <span class="hljs-string">"sync"</span>)
);
</code></pre>
<p>通过在外部指定目录，和正则就能获得正确的资源路径，再传给 <code>urlProp</code> 就完美了。</p>
<p>上面的 <code>mode</code> 配置呢，其实是和 <code>webpackMode</code> 类似的，有 <code>sync</code>、<code>eager</code>、<code>lazy</code>、<code>lazy-once</code>、<code>weak</code>、<code>async-weak</code> 一共六种。其中<code>sync</code> 是默认的，会直接打包到文件里面，而 <code>lazy</code> 则会生成可延迟加载单独的 <code>chunk</code>。</p>
<p>这里我用到的是 <code>lazy-once</code>。为什么呢，因为我需要从 <code>require.context</code> 里面引入的资源非常多，肯定是要拆包的，而 <code>lazy</code> 虽然是懒加载了，但是所有文件都单独形成 <code>chunk</code>，导致增加了很多文件，<code>lazy-once</code> 就很舒服，将所有文件合成一个 <code>chunk</code>，只需要通过 <code>promise</code> 的方式获取正确的路径就可以了，比如 <code>urlProp(oneFileName).then(src =&gt; list.push(src))</code> 这样的方式。</p>
<h2>总结</h2>
<p><code>require</code> 部分算是一个小知识点，至于深入的理解，比如 <code>Directory</code> 目录的获取和分析，感觉有点类似，可能是 <code>@babel/parser</code> 的形式，通过 <code>ast</code> 分析表达式来获取目录？后面的理解就没有去研究了，倒是解决了一直以来使用 <code>require</code> 的困惑（指不定以前有好多写的不太正常的 bug，采用 <code>require</code> 多加载了多余文件。。。。。呵呵呵）。</p>
<p>字体部分，更像是一个新领域的探索，想要不断的优化页面，而新版本的字体就是重中之重了，从开始的通过 <code>node.js</code> 来 <code>debug</code>，到最后定位到 <code>fonteditor-core</code> 再到 <code>fonttools</code>，可以看到前端的字体轮子还是少了（比如参照 <code>fonttools</code> 代码，更新 <code>fontedior-core</code> ？）。更多的是学习字体的结构，看各个 <code>table</code> 的作用，对字体的展示也有初步的理解，但是没有去研究代码层面的实现，没有深入去，更多的是浅尝辄止，可能兴趣就到这里吧，没有更多的想法了，想要深入探索更多的东西，更有价值的吧。</p>
<p>写完的时候又一个台风飞过，今年的台风真是奇怪。</p>
<h2>参考</h2>
<p>技术文档，当然微软的是 Opentype，苹果的是 TrueType 与 AAT。</p>
<ol>
<li><a href="https://docs.microsoft.com/zh-cn/typography/opentype/spec/" target="_blank">microsoft OpenType 1.8.3 specification</a></li>
<li><a href="https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6.html" target="_blank">apple Font Tables</a></li>
<li><a href="https://www.thetype.com/2016/09/10968/" target="_blank">参数化设计与字体战争：从 OpenType 1.8 说起</a> 很有趣的一篇历史介绍，想不到可变字体，出道快 30 年了，结果 16 年才成为统一标准。。。。。。</li>
</ol>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"March 24, 2021","title":"可变字体探索与 require 扫盲记","content":"\u003cp\u003e国庆后一场秋雨一场寒，属于东南季风的台风带来了明显的降温，又到了一个尴尬的温度，长袖短裤都有人穿。这个温度，感觉很舒服，尤其是在海边骑单车的时候，沿着沙河路的时候，城市灯光的点缀，观景台边的海涛声、阵阵袭人的秋意就来了。\u003c/p\u003e\n\u003cp\u003e本篇是介绍两个琐事，都是工作中遇到的，一个是可变字体探索，一个是 \u003ccode\u003erequire\u003c/code\u003e 扫盲记。\u003c/p\u003e\n\u003ch2\u003eVariable Fonts\u003c/h2\u003e\n\u003cp\u003e好像从前几个月开始，就接触了\u003ca href=\"https://zh.wikipedia.org/zh-hans/%E5%8F%AF%E5%8F%98%E5%AD%97%E4%BD%93\" target=\"_blank\"\u003e可变字体\u003c/a\u003e，以前设计推荐的是使用 5 种字体，你没有看错，在项目里面用到了 5 、种字体，不同的粗细，不同的高瘦，每个字体都基本在 8M 左右，通过不同的字体来展示设计的风格，真是。。。挺好的。今年开始有新的字体，没有以前的 5 种，只用一个可变字体了，通过一个字体来展示之前 5 个的字体，可以说很是优秀，当然对开发而言，统一的字体最是简单，而且一个字体意味着只要加载一种就好了，之前的要加载 5 种字体，虽然一个可变字体的体积是 20 M。\u003c/p\u003e\n\u003cp\u003e可以通过这个\u003ca href=\"https://v-fonts.com/\" target=\"_blank\"\u003e网站\u003c/a\u003e 玩一下可变字体。\u003c/p\u003e\n\u003cp\u003e字体，对于开发者而言，默认基本都是采用系统的字体，比如系统差别、中西文差别，还有最后的衬线字体，比如我们公司就喜欢用 \u003ccode\u003eandroid\u003c/code\u003e 的 \u003ccode\u003eRoboto\u003c/code\u003e 默认字体来显示数字。如果采用自己的字体的话，会把其放在最前面，所以最前面是 \u003ccode\u003eOPPOSANS, Roboto, Noto Sans CJK SC, Source Han Sans CN\u003c/code\u003e 后面两个是思源字体，毕竟 \u003ccode\u003eOPPOSANS\u003c/code\u003e 是和思源字体结合的。。。。\u003c/p\u003e\n\u003cp\u003e通过设置 \u003ccode\u003efont-variation-settings: \u0026quot;wght\u0026quot; 550\u003c/code\u003e 可以调整字体的粗细，比如 \u003ccode\u003eOPPOSANS\u003c/code\u003e 字重可以调整到 \u003ccode\u003e1000-1000\u003c/code\u003e 区间，实现\u003cstrong\u003e无极调整\u003c/strong\u003e，不像以前的字体，只有一百倍数的 \u003ccode\u003efont-weight\u003c/code\u003e，而且要一个字体文件就够了。还有其他的比如 \u003ccode\u003ewdth\u003c/code\u003e \u003ccode\u003eital\u003c/code\u003e 这些都可以设置。\n比如下图\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/variableFonts.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e还能在这个基础上用上 \u003ccode\u003efont-weight\u003c/code\u003e，当然这个就不规范了。目前 \u003ccode\u003efont-variation-settings\u003c/code\u003e 的兼容性还是比较好的，除了 ie 和部分比较老的浏览器不支持外，其他都没有问题的。\u003c/p\u003e\n\u003ch3\u003e字体的普通处理\u003c/h3\u003e\n\u003cp\u003e如果是采用系统的字体那一切都挺好的，但是作为设计，作为一家最求美感的公司，就是要有自己的字体，于是普通字体的 10M 的体积，加载速度就可以劝退大部分人了。为了平滑顺利过渡字体，一般采用的是如下几个方案：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e**\u003ccode\u003efont-face\u003c/code\u003e 定义的时，采用 \u003ccode\u003eswap\u003c/code\u003e 来显示，系统会优先采用已有的字体，避免字体加载导致的阻塞，使得文字无法显示；**当然这种方案会导致字体加载成功时，页面切换会从当前字体切换到自定义字体，导致用户体验稍差。如果自定字体体积小，可以不采用 \u003ccode\u003eswap\u003c/code\u003e 方式。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e字体文件预加载，就是在 \u003ccode\u003elink\u003c/code\u003e 标签里面采用 \u003ccode\u003epreload\u003c/code\u003e 的方式，字体资源在浏览器里，属于优先级较低的资源，通过 \u003ccode\u003elink\u003c/code\u003e 的预加载可以显著的提高优先级，避免字体加载时间过长，导致切换时候带来的不好体验\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e**字体体积，上面更多的是辅助优化，对于中文字体而言，最重要的是体积。中文不同于其他字母语言，有非常多的字，一个字体 10 M 的体积要如何处理呢，正常会对字体文件做提取，只保留可能要用的字，也就是 glyphs。**比如只用到 \u003ccode\u003e溜\u003c/code\u003e 这个字，那就提取字体包里的 \u003ccode\u003e溜\u003c/code\u003e，这样字体文件就可以压缩的非常小了\u003c/li\u003e\n\u003cli\u003e最后是 woff、woff2 这些新格式带来的优化，以及更好的压缩算法带来的帮助。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e字体的提取历程\u003c/h3\u003e\n\u003cp\u003e这里要介绍是可变字体的提取问题，先看看普通字体提取，之前用的是 \u003ccode\u003efont-spider\u003c/code\u003e，使用下来可以满足字体的压缩，提取需要的子集，用法很方便，如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- test.html --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003estyle\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"css\"\u003e\n  \u003cspan class=\"hljs-keyword\"\u003e@font-face\u003c/span\u003e {\n    \u003cspan class=\"hljs-attribute\"\u003efont-family\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"source\"\u003c/span\u003e;\n    \u003cspan class=\"hljs-attribute\"\u003esrc\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eurl\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"../font/source.eot\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-attribute\"\u003efont-style\u003c/span\u003e: normal;\n  }\n  \u003cspan class=\"hljs-selector-tag\"\u003ebody\u003c/span\u003e {\n    \u003cspan class=\"hljs-attribute\"\u003efont-family\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"source\"\u003c/span\u003e;\n  }\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003estyle\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  溜\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再通过指令 \u003ccode\u003efont-spider ./test.html\u003c/code\u003e 就可以从 \u003ccode\u003esource.eot\u003c/code\u003e 字体包里面压缩出仅仅包含 \u003ccode\u003e溜\u003c/code\u003e 一个字的字体，当然会有一点小问题，比如垂直方向的行间距变小了，但是总体问题不大，10M 的字体包，最后只剩下几 kb。这个时候如果用软件 FontForge 查看的话，可以看到 \u003ccode\u003e溜\u003c/code\u003e 保留下来了，其他被移除了。\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/fontLiuNormal.PNG\" alt=\"\"\u003e\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/fontLiuMin.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e上面左边是正常的字形，右边则是压缩之后的效果，可以看到压缩后周围的小伙伴都被吓跑了。\u003c/p\u003e\n\u003cp\u003e只是到了可变字体，压缩就不是这样了，简简单单的 \u003ccode\u003efont-spider\u003c/code\u003e 打包出来的字体就不能用，会出现字体镂空的情况，而且关键是不能调整可变字体的 \u003ccode\u003ewght\u003c/code\u003e，设置了也不起作用，简直就是和普通字体差不多，不再是可变字体了。\u003c/p\u003e\n\u003cp\u003e于是翻箱倒柜的，在 \u003ccode\u003efont-spider\u003c/code\u003e 里面转了一圈，结果发现里面处理字体的内容不多，更多的是对输入文件和样式处理，通过模拟的浏览器环境，自研的 \u003ccode\u003ebrowser-x\u003c/code\u003e(大佬自己写的 \u003ccode\u003eNode.js\u003c/code\u003e 实现的虚拟浏览器) 来获取样式，保证不同的的 \u003ccode\u003efont-family\u003c/code\u003e 打包出不同的字体，分析输入的参数，文字最后输出四种格式的字体，\u003ccode\u003ewoff woff2 svg ttf\u003c/code\u003e 这些，当然在 \u003ccode\u003eWebFont\u003c/code\u003e 里面看到了不少冗余的代码，一度让我误解了，比如 \u003ccode\u003eweight stretch\u003c/code\u003e 这些属性，就不能使用。。。。可能也是大佬弃坑了吧，最后落实到压缩的还是 \u003ccode\u003efontmin\u003c/code\u003e 这个库，也有三方压缩的工具都是基于 \u003ccode\u003efontmin\u003c/code\u003e 的。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efontmin\u003c/code\u003e 是一款中间件机制的字体处理工具，比如 \u003ccode\u003eglyph\u003c/code\u003e 可以用来压缩字体，比如 \u003ccode\u003ettf2woff\u003c/code\u003e 可以转换字体。比如下面的官方例子：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e Fontmin = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"fontmin\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e fontmin = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Fontmin().use(\n  Fontmin.glyph({\n    \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"天地玄黄 宇宙洪荒\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ehinting\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n  })\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 \u003ccode\u003efontmin\u003c/code\u003e 代码里面的 \u003ccode\u003eglyph\u003c/code\u003e 插件代码中可以看到如下形式：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e TTF = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"fonteditor-core\"\u003c/span\u003e).TTF;\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e TTFReader = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"fonteditor-core\"\u003c/span\u003e).TTFReader;\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e TTFWriter = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"fonteditor-core\"\u003c/span\u003e).TTFWriter;\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eminifyTtf\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003econtents, opts\u003c/span\u003e) \u003c/span\u003e{\n  opts = opts || {};\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e ttfobj = contents;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (Buffer.isBuffer(contents)) {\n    ttfobj = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e TTFReader(opts).read(b2ab(contents));\n  }\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e miniObj = minifyFontObject(ttfobj, opts.subset, opts.use);\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e ttfBuffer = ab2b(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e TTFWriter(opts).write(miniObj));\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eobject\u003c/span\u003e: miniObj,\n    \u003cspan class=\"hljs-attr\"\u003ebuffer\u003c/span\u003e: ttfBuffer,\n  };\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eminifyFontObject\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ettfObject, subset, plugin\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (subset.length === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e ttfObject;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e ttf = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e TTF(ttfObject);\n  ttf.setGlyf(getSubsetGlyfs(ttf, subset));\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (_.isFunction(plugin)) {\n    plugin(ttf);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e ttf.get();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e敢情 \u003ccode\u003efontmin\u003c/code\u003e 也是套娃的。。。最后核心的字体处理还是要跑到 \u003ccode\u003efonteditor-core\u003c/code\u003e 里面，怎么说呢， \u003ccode\u003efontmin\u003c/code\u003e 是一个优秀的集成商，有字体压缩，还有字体格式转换这些功能，虽然大部分是基于第三方的。而且不管是 \u003ccode\u003efontmin\u003c/code\u003e 还是 \u003ccode\u003efont-spider\u003c/code\u003e 也有四五年没有更新主要内容了，作者也都弃坑了。那对于 16 年底才发布的可变字体，好像不支持也是可以理解的。\u003c/p\u003e\n\u003ch3\u003etable\u003c/h3\u003e\n\u003cp\u003e介绍到 \u003ccode\u003efonteditor-core\u003c/code\u003e 就要提一下 \u003ccode\u003etable\u003c/code\u003e 的概念，这个是布局信息表，其包含了字形的位置、对齐、基线等等信息，字体文件则是由这一系列的表构成的，其中有部分表是可选的。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e字体目录\u003c/strong\u003e是字体文件的指南，提供访问其他表所需的信息，包含两部分：偏移子表（offset subtable）和表目录（table directory）。偏移子表记录了字体文件中 \u003ccode\u003etable\u003c/code\u003e 的数量，并提供了快速访问表目录的方法。偏移子表后面就是表目录，表目录主要包含了表的 \u003ccode\u003etag\u003c/code\u003e、校验、偏移、长度等信息，字体文件中的所有表都在表目录里面有入口。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/fontTableDirectory.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e看了不少文档，每个文档对必选的 \u003ccode\u003etable\u003c/code\u003e 都有自己的解释，综合一下，下面是其中有几个是非常必要的 \u003ccode\u003etable\u003c/code\u003e:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ecmap：字符代码到字形索引之间的映射关系，字符代码也就是字符的 \u003ccode\u003eUnicode\u003c/code\u003e，获得索引也就可以根据索引从字体中加载这个字形。\u003c/li\u003e\n\u003cli\u003ehead：字体的各种基本信息，如版本、创建、修改时间，还包括基本字体数据，如 unitsPerEm、xMin, yMin 等。\u003c/li\u003e\n\u003cli\u003ehhea：水平排列信息，如 ascender、descender、lineGap 等水平排列时候的布局信息。\u003c/li\u003e\n\u003cli\u003ehmtx：水平参数，如间距，如果是字形之间是等距的，那只需要一个间距就可以了。\u003c/li\u003e\n\u003cli\u003emaxp：最大需求表，包含字形数量，表示字形的内存需求情况。\u003c/li\u003e\n\u003cli\u003ename：命名内容，如字体名，授权信息等等。\u003c/li\u003e\n\u003cli\u003epost：PostScript 表，用于打印。\u003c/li\u003e\n\u003cli\u003eglyf：字形数据，也是最重要的一个表了。\u003c/li\u003e\n\u003cli\u003eloca：偏移和字符索引映射关系表。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e上面几个表的介绍可能理解不太到位地方，因该差不多大致如此吧。另外，还有一些比如 \u003ccode\u003eOS/2\u003c/code\u003e: 用于 windows 系统的配置，所以对跨平台的字体就非常需要了，但是若是针对 Mac 这些就不必了。\u003c/p\u003e\n\u003cp\u003e具体的字形什么的，用 \u003ccode\u003eFontForge\u003c/code\u003e 软件打开任意一个字体就可以看到了，比如下面的：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/fontLiuGlyph.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e你甚至都可以修改字形。。。。\u003c/p\u003e\n\u003cp\u003e至于字体从加载到渲染出来的流程可以参考一下知乎上的\u003ca href=\"https://www.zhihu.com/question/23759223/answer/25617486\" target=\"_blank\"\u003e介绍\u003c/a\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e加载字体文件\n确定要输出的字体大小\n输入这个字符的编码值\n根据字体文件里面的 Charmap，把编码值转换成字形索引（就是这个字符对应字体文件中的第几个形状）\n根据索引从字体中加载这个字形\n将这个字形渲染成位图，有可能进行加粗，倾斜等变换。注意这里的倾斜和倾斜字体不同，它只是从算法上对位图进行变换，与专门制作的加粗字体是不一样的。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e上面介绍的是 \u003ccode\u003ecmap\u003c/code\u003e 根据字符代码拿到字形索引，再从 \u003ccode\u003eloca\u003c/code\u003e 拿到索引对应的字形偏移，最后到 \u003ccode\u003eglyf\u003c/code\u003e 加载字形的过程。\u003ccode\u003eloca\u003c/code\u003e 表可以参考以下图：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/fontLoca.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e每个字形都有自己长度，从而形成相对于 \u003ccode\u003e0\u003c/code\u003e 位置的偏移，而 \u003ccode\u003eloca\u003c/code\u003e 表则是记录字形索引到字形偏移的映射表。\u003c/p\u003e\n\u003cp\u003e当然这里面还有很多的表的内容没有谈到，比如和 \u003ccode\u003eTrueType\u003c/code\u003e、\u003ccode\u003eCCF\u003c/code\u003e、\u003ccode\u003eSVG\u003c/code\u003e 以及 \u003ccode\u003eBitMap\u003c/code\u003e 相关的表，还有一个是高级表，比如 \u003ccode\u003eGSUB\u003c/code\u003e 是 \u003ccode\u003eglyf\u003c/code\u003e 的替换表，之前提到的一个字符代码最后可以映射到字形，但是如果是连字的时候，就不一定是简单的字形叠加，例如下面的：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/fontGSUB.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e可以看到单独一个字的时候都是好好的，但是一旦结合在一起，就是不是 \u003ccode\u003ef + i = fi\u003c/code\u003e 了，而是有新的字形。这一点在阿拉伯语中也是的，字形在不同的位置有不同的显示。。。。。（原来阿拉伯语这么神奇，简直就是蝌蚪文）。\u003c/p\u003e\n\u003cp\u003e除了高级表，还有色彩相关的，其他比较杂的，最后还有一个是 \u003ccode\u003eOpenType Font Variations\u003c/code\u003e 可变字体，也是 \u003ccode\u003eOpenType\u003c/code\u003e 规范中，里面有 \u003ccode\u003eavar\u003c/code\u003e、\u003ccode\u003ecvar\u003c/code\u003e、\u003ccode\u003efvar\u003c/code\u003e、\u003ccode\u003egvar\u003c/code\u003e、\u003ccode\u003eHVAR\u003c/code\u003e、\u003ccode\u003eMVAR\u003c/code\u003e、\u003ccode\u003eSTAT\u003c/code\u003e 和 \u003ccode\u003eVVAR\u003c/code\u003e 这几个。\u003c/p\u003e\n\u003ch4\u003e可变字体的 table\u003c/h4\u003e\n\u003cp\u003e可变字体，如前面提到的，可以让设计者将多个字体合并为一个字体，下面的示意图很好的介绍了字重和字宽度变化导致字形的变化：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/variableFontsWidthWeight.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e这里面看到的 \u003ccode\u003ewidth\u003c/code\u003e 和 \u003ccode\u003eweight\u003c/code\u003e 都是 \u003ccode\u003efvar\u003c/code\u003e 表所描述的，用来存储轴的信息，以及命名实例，其中命名实例是可选的字段。轴的信息，比如 \u003ccode\u003ewght(100-1000)\u003c/code\u003e、\u003ccode\u003ewidth(10-200)\u003c/code\u003e，包含了轴名称、最小最大值和默认值等，命名实例则是由轴与轴之间定下的命名的特定坐标，如下面几个:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/variableFVAR.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e可以看到轴 \u003ccode\u003ewght = 400\u003c/code\u003e 以及 \u003ccode\u003ewdth = 100\u003c/code\u003e 形成的坐标 \u003ccode\u003eRegular\u003c/code\u003e，也就是命名实例。\u003ccode\u003eRegular\u003c/code\u003e 是给特定坐标提供的预设名称，也是该子字体的名称，可以让使用者直接使用。使用可变字体的时候，如果没有指定子字体，其采用默认轴值。（css 里面修改 \u003ccode\u003efont-variation-settings\u003c/code\u003e，也就是实例了）。\u003c/p\u003e\n\u003cp\u003e对于可变字体，有两个表是必须的：\u003ccode\u003efvar\u003c/code\u003e 和 \u003ccode\u003eSTAT(style attributes)\u003c/code\u003e，后者是样式属性，每个在 \u003ccode\u003efvar\u003c/code\u003e 里面的每一条轴和子字体都需要在 \u003ccode\u003eSTAT\u003c/code\u003e 里面有对应的信息。\u003ccode\u003eSTAT\u003c/code\u003e 用来区分字体族下面的不同的字体，支持动态属性，比如 \u003ccode\u003efvar\u003c/code\u003e 里面的 \u003ccode\u003ewght(无极)\u003c/code\u003e，也支持静态属性，比如 \u003ccode\u003eitalic\u003c/code\u003e 是否为斜体这些，展示 \u003ccode\u003eVariable Font\u003c/code\u003e 下的样式名称，比如 \u003ccode\u003eMedium\u003c/code\u003e 这样的字体。\u003c/p\u003e\n\u003cp\u003e其他的表则是描述 \u003ccode\u003efvar\u003c/code\u003e 里面字体轴变化时字形的变化情况，例如 \u003ccode\u003eavar\u003c/code\u003e，是非线性的轴变化数据，例如字体的 \u003ccode\u003ewidth\u003c/code\u003e 轴，若变化区间是 \u003ccode\u003e100-200\u003c/code\u003e，线性的时候，则 \u003ccode\u003e150\u003c/code\u003e 表示字体的字形宽度是两个极值的正中间，但是非线性变化，就使得值不是均匀的变化的，\u003ccode\u003e150\u003c/code\u003e 可能不是字形宽度上的正中间状态。这种非线性变化也符合用户习惯。还有 \u003ccode\u003egvar\u003c/code\u003e，存储字形在轴上的变化信息，描述 \u003ccode\u003eglyp\u003c/code\u003e 中各个点的变化情况，可以说是非常重要的。\u003c/p\u003e\n\u003ch3\u003e字体提取工具\u003c/h3\u003e\n\u003cp\u003e看了上面的 \u003ccode\u003etable\u003c/code\u003e 介绍，字体的处理，其实就是对 \u003ccode\u003etable\u003c/code\u003e 的处理，\u003ccode\u003efonteditor-core\u003c/code\u003e 对可变字体的处理，看了一下源码的\u003ca href=\"https://github.com/kekee000/fonteditor-core/tree/master/src/ttf/table\" target=\"_blank\"\u003e结构\u003c/a\u003e，well，根本就没有可变字体的表处理，连 \u003ccode\u003efvar\u003c/code\u003e 的踪迹都没有。\u003c/p\u003e\n\u003cp\u003e于是开启大海捞针的方式，在 \u003ccode\u003egithub\u003c/code\u003e 里面找，最后发现一个 \u003ccode\u003eopentypejs/opentype.js\u003c/code\u003e 仓库，卧槽，难道是官方的嫡系部队？只是打开到结构目录还是很失望，都是三四年前的代码了，和 \u003ccode\u003efonteditor-core\u003c/code\u003e 差不多，虽然有 \u003ccode\u003efvar\u003c/code\u003e 表，但是其他可变字体的表一个都没有。抱着试一试的想法，用一下，最后的打包出来的字体，虽然比 \u003ccode\u003efonteditor-core\u003c/code\u003e 好不少，但是压根就不可变。。。。毕竟连 \u003ccode\u003egvar\u003c/code\u003e 也没有。最后看到了这个\u003ca href=\"https://github.com/opentypejs/opentype.js/issues/374\" target=\"_blank\"\u003eroadMap\u003c/a\u003e，里面介绍到：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/variableFontsRoadMap.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e本来决定要放弃了，毕竟官方也不支持系列，但是总觉得有问题，难道可变字体没有工具？都好几年历史了，没有人造轮子吗。。。。\u003c/p\u003e\n\u003cp\u003e最后找到了字体处理的重量级库 \u003ccode\u003efonttools\u003c/code\u003e，一个 \u003ccode\u003epython\u003c/code\u003e 库，打开一看密密麻麻的的 \u003ccode\u003etable\u003c/code\u003e 处理，有 50 个以上的处理，对比一下 \u003ccode\u003efonteditor-core\u003c/code\u003e 的 18 个表处理，简直是。。。。。。在 \u003ccode\u003efonttools\u003c/code\u003e 里面也找到了各种各样的可变字体处理表，比如 \u003ccode\u003egvar\u003c/code\u003e，只是对 \u003ccode\u003epython\u003c/code\u003e 不是很熟悉，而且一上来就看源码，有点吃力，所以就放弃了（想起了看 esbuild 源码的经历）。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efonttools\u003c/code\u003e 里面有很多工具，提取字体用的是 \u003ccode\u003epyftsubset\u003c/code\u003e，通过指定文件字符来确定要输出的字形，基本上一顿操作下来，从 22M 的字体包，压缩到 300kb。正常来做这就可以了，但是 \u003cstrong\u003e原本字体包还包含了斜、高度轴，这些轴，项目用不上，而且 \u003ccode\u003ewght\u003c/code\u003e 也就用到了 \u003ccode\u003e550-1000\u003c/code\u003e 的范围，能不能去掉剩下的部分呢？\u003c/strong\u003e 这样不就可以完美压缩字体了，甚至 \u003ccode\u003ewght\u003c/code\u003e 就用了 \u003ccode\u003e550\u003c/code\u003e 和 \u003ccode\u003e1000\u003c/code\u003e 两个值，其他的能不能抛弃掉呢？可能这个就要用专业的设计工具了（比如 Adobe Illustrator？），目前在 \u003ccode\u003efonttools\u003c/code\u003e 没有看到更多可操作空间，如果有大佬晓得一定要告知。\u003c/p\u003e\n\u003cp\u003e一般可变字体的体积是要大于单个字体的（字体族里面的单个字体），只有当需要用到同一字体族的多个字体的时候，可变字体收益才很大。当然如果需要艺术字那就另当别论了。另外 \u003ccode\u003efont-variation-settings\u003c/code\u003e 是属于比较基础的 API 了，如果要设置字重的话，可以使用 \u003ccode\u003efont-weight: 550\u003c/code\u003e 是不是很熟悉？这个和以前的 CSS 是一致的，只是 \u003ccode\u003eCSS Fonts Level 4\u003c/code\u003e 做了扩展，当然还有其他几个轴的，比如 \u003ccode\u003efont-stretch\u003c/code\u003e。\u003c/p\u003e\n\u003ch2\u003erequire\u003c/h2\u003e\n\u003cp\u003e相比于字体，\u003ccode\u003erequire\u003c/code\u003e 可以说是以前的一个知识盲区。在 \u003ccode\u003eVue\u003c/code\u003e 里面，如果需要加载资源可以采用 \u003ccode\u003erequire\u003c/code\u003e 方式引入，但是时不时的总会遇到无法加载资源的问题。直到一次想要把资源路径作为 \u003ccode\u003eprops\u003c/code\u003e 传入组件，再通过 \u003ccode\u003erequire\u003c/code\u003e 来获取，结果是获取到图片了，但是还引发了\u003cstrong\u003e另外一个严重的问题，页面的样式错乱？\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e通过审查打包出现的代码，发现原本完全没有引入的 \u003ccode\u003escss\u003c/code\u003e 文件都被打包到样式文件里面，如果去掉 \u003ccode\u003erequire(urlProp)\u003c/code\u003e 则一切正常，这个就很神奇了，而且前者的打出的包还很大。有种奇奇怪怪的感觉。\u003c/p\u003e\n\u003cp\u003e后面耐心的看 \u003ccode\u003ewebpack\u003c/code\u003e \u003ca href=\"https://webpack.js.org/guides/dependency-management/#require-with-expression\" target=\"_blank\"\u003e文档\u003c/a\u003e才晓得：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eA context module is generated. \u003cstrong\u003eIt contains references to all modules in that directory that can be required\u003c/strong\u003e with a request matching the regular expression. The context module contains a map which translates requests to module ids.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e如果采用 \u003ccode\u003erequire('./template/' + name + '.ejs')\u003c/code\u003e 的方式，那 \u003ccode\u003etemplate\u003c/code\u003e 文件下面的所有 \u003ccode\u003eejs\u003c/code\u003e 文件都会被引用，形成一个上下文的 \u003ccode\u003emap\u003c/code\u003e 对象，\u003cstrong\u003e导致该目录下原本不会被使用的文件，也被打包使用上了\u003c/strong\u003e，这也就是为什么使用了 \u003ccode\u003erequire(urlProp)\u003c/code\u003e 会加载上错误的资源，可想而知，若 \u003ccode\u003erequire\u003c/code\u003e 里面完全采用传参的方式，会使其无法分析正确的 \u003ccode\u003eDirectory\u003c/code\u003e， 于是从根文件 \u003ccode\u003esrc\u003c/code\u003e 开始查询文件。。。。。\u003c/p\u003e\n\u003cp\u003e至于要如何破局呢，\u003ccode\u003eurlProp\u003c/code\u003e 为了可扩展性，是要从外部传入的，而里面要读取资源只能用 \u003ccode\u003erequire\u003c/code\u003e 了，直到看到了下面的 \u003ccode\u003erequire.context\u003c/code\u003e 的方式，表达式如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e.context(\n  directory,\n  (useSubdirectories = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e),\n  (regExp = \u003cspan class=\"hljs-regexp\"\u003e/^\\.\\/.*$/\u003c/span\u003e),\n  (mode = \u003cspan class=\"hljs-string\"\u003e\"sync\"\u003c/span\u003e)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过在外部指定目录，和正则就能获得正确的资源路径，再传给 \u003ccode\u003eurlProp\u003c/code\u003e 就完美了。\u003c/p\u003e\n\u003cp\u003e上面的 \u003ccode\u003emode\u003c/code\u003e 配置呢，其实是和 \u003ccode\u003ewebpackMode\u003c/code\u003e 类似的，有 \u003ccode\u003esync\u003c/code\u003e、\u003ccode\u003eeager\u003c/code\u003e、\u003ccode\u003elazy\u003c/code\u003e、\u003ccode\u003elazy-once\u003c/code\u003e、\u003ccode\u003eweak\u003c/code\u003e、\u003ccode\u003easync-weak\u003c/code\u003e 一共六种。其中\u003ccode\u003esync\u003c/code\u003e 是默认的，会直接打包到文件里面，而 \u003ccode\u003elazy\u003c/code\u003e 则会生成可延迟加载单独的 \u003ccode\u003echunk\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e这里我用到的是 \u003ccode\u003elazy-once\u003c/code\u003e。为什么呢，因为我需要从 \u003ccode\u003erequire.context\u003c/code\u003e 里面引入的资源非常多，肯定是要拆包的，而 \u003ccode\u003elazy\u003c/code\u003e 虽然是懒加载了，但是所有文件都单独形成 \u003ccode\u003echunk\u003c/code\u003e，导致增加了很多文件，\u003ccode\u003elazy-once\u003c/code\u003e 就很舒服，将所有文件合成一个 \u003ccode\u003echunk\u003c/code\u003e，只需要通过 \u003ccode\u003epromise\u003c/code\u003e 的方式获取正确的路径就可以了，比如 \u003ccode\u003eurlProp(oneFileName).then(src =\u0026gt; list.push(src))\u003c/code\u003e 这样的方式。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003erequire\u003c/code\u003e 部分算是一个小知识点，至于深入的理解，比如 \u003ccode\u003eDirectory\u003c/code\u003e 目录的获取和分析，感觉有点类似，可能是 \u003ccode\u003e@babel/parser\u003c/code\u003e 的形式，通过 \u003ccode\u003east\u003c/code\u003e 分析表达式来获取目录？后面的理解就没有去研究了，倒是解决了一直以来使用 \u003ccode\u003erequire\u003c/code\u003e 的困惑（指不定以前有好多写的不太正常的 bug，采用 \u003ccode\u003erequire\u003c/code\u003e 多加载了多余文件。。。。。呵呵呵）。\u003c/p\u003e\n\u003cp\u003e字体部分，更像是一个新领域的探索，想要不断的优化页面，而新版本的字体就是重中之重了，从开始的通过 \u003ccode\u003enode.js\u003c/code\u003e 来 \u003ccode\u003edebug\u003c/code\u003e，到最后定位到 \u003ccode\u003efonteditor-core\u003c/code\u003e 再到 \u003ccode\u003efonttools\u003c/code\u003e，可以看到前端的字体轮子还是少了（比如参照 \u003ccode\u003efonttools\u003c/code\u003e 代码，更新 \u003ccode\u003efontedior-core\u003c/code\u003e ？）。更多的是学习字体的结构，看各个 \u003ccode\u003etable\u003c/code\u003e 的作用，对字体的展示也有初步的理解，但是没有去研究代码层面的实现，没有深入去，更多的是浅尝辄止，可能兴趣就到这里吧，没有更多的想法了，想要深入探索更多的东西，更有价值的吧。\u003c/p\u003e\n\u003cp\u003e写完的时候又一个台风飞过，今年的台风真是奇怪。\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003cp\u003e技术文档，当然微软的是 Opentype，苹果的是 TrueType 与 AAT。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/zh-cn/typography/opentype/spec/\" target=\"_blank\"\u003emicrosoft OpenType 1.8.3 specification\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6.html\" target=\"_blank\"\u003eapple Font Tables\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.thetype.com/2016/09/10968/\" target=\"_blank\"\u003e参数化设计与字体战争：从 OpenType 1.8 说起\u003c/a\u003e 很有趣的一篇历史介绍，想不到可变字体，出道快 30 年了，结果 16 年才成为统一标准。。。。。。\u003c/li\u003e\n\u003c/ol\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"March 24, 2021","title":"可变字体探索与 require 扫盲记","content":"\u003cp\u003e国庆后一场秋雨一场寒，属于东南季风的台风带来了明显的降温，又到了一个尴尬的温度，长袖短裤都有人穿。这个温度，感觉很舒服，尤其是在海边骑单车的时候，沿着沙河路的时候，城市灯光的点缀，观景台边的海涛声、阵阵袭人的秋意就来了。\u003c/p\u003e\n\u003cp\u003e本篇是介绍两个琐事，都是工作中遇到的，一个是可变字体探索，一个是 \u003ccode\u003erequire\u003c/code\u003e 扫盲记。\u003c/p\u003e\n\u003ch2\u003eVariable Fonts\u003c/h2\u003e\n\u003cp\u003e好像从前几个月开始，就接触了\u003ca href=\"https://zh.wikipedia.org/zh-hans/%E5%8F%AF%E5%8F%98%E5%AD%97%E4%BD%93\" target=\"_blank\"\u003e可变字体\u003c/a\u003e，以前设计推荐的是使用 5 种字体，你没有看错，在项目里面用到了 5 、种字体，不同的粗细，不同的高瘦，每个字体都基本在 8M 左右，通过不同的字体来展示设计的风格，真是。。。挺好的。今年开始有新的字体，没有以前的 5 种，只用一个可变字体了，通过一个字体来展示之前 5 个的字体，可以说很是优秀，当然对开发而言，统一的字体最是简单，而且一个字体意味着只要加载一种就好了，之前的要加载 5 种字体，虽然一个可变字体的体积是 20 M。\u003c/p\u003e\n\u003cp\u003e可以通过这个\u003ca href=\"https://v-fonts.com/\" target=\"_blank\"\u003e网站\u003c/a\u003e 玩一下可变字体。\u003c/p\u003e\n\u003cp\u003e字体，对于开发者而言，默认基本都是采用系统的字体，比如系统差别、中西文差别，还有最后的衬线字体，比如我们公司就喜欢用 \u003ccode\u003eandroid\u003c/code\u003e 的 \u003ccode\u003eRoboto\u003c/code\u003e 默认字体来显示数字。如果采用自己的字体的话，会把其放在最前面，所以最前面是 \u003ccode\u003eOPPOSANS, Roboto, Noto Sans CJK SC, Source Han Sans CN\u003c/code\u003e 后面两个是思源字体，毕竟 \u003ccode\u003eOPPOSANS\u003c/code\u003e 是和思源字体结合的。。。。\u003c/p\u003e\n\u003cp\u003e通过设置 \u003ccode\u003efont-variation-settings: \u0026quot;wght\u0026quot; 550\u003c/code\u003e 可以调整字体的粗细，比如 \u003ccode\u003eOPPOSANS\u003c/code\u003e 字重可以调整到 \u003ccode\u003e1000-1000\u003c/code\u003e 区间，实现\u003cstrong\u003e无极调整\u003c/strong\u003e，不像以前的字体，只有一百倍数的 \u003ccode\u003efont-weight\u003c/code\u003e，而且要一个字体文件就够了。还有其他的比如 \u003ccode\u003ewdth\u003c/code\u003e \u003ccode\u003eital\u003c/code\u003e 这些都可以设置。\n比如下图\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/variableFonts.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e还能在这个基础上用上 \u003ccode\u003efont-weight\u003c/code\u003e，当然这个就不规范了。目前 \u003ccode\u003efont-variation-settings\u003c/code\u003e 的兼容性还是比较好的，除了 ie 和部分比较老的浏览器不支持外，其他都没有问题的。\u003c/p\u003e\n\u003ch3\u003e字体的普通处理\u003c/h3\u003e\n\u003cp\u003e如果是采用系统的字体那一切都挺好的，但是作为设计，作为一家最求美感的公司，就是要有自己的字体，于是普通字体的 10M 的体积，加载速度就可以劝退大部分人了。为了平滑顺利过渡字体，一般采用的是如下几个方案：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e**\u003ccode\u003efont-face\u003c/code\u003e 定义的时，采用 \u003ccode\u003eswap\u003c/code\u003e 来显示，系统会优先采用已有的字体，避免字体加载导致的阻塞，使得文字无法显示；**当然这种方案会导致字体加载成功时，页面切换会从当前字体切换到自定义字体，导致用户体验稍差。如果自定字体体积小，可以不采用 \u003ccode\u003eswap\u003c/code\u003e 方式。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e字体文件预加载，就是在 \u003ccode\u003elink\u003c/code\u003e 标签里面采用 \u003ccode\u003epreload\u003c/code\u003e 的方式，字体资源在浏览器里，属于优先级较低的资源，通过 \u003ccode\u003elink\u003c/code\u003e 的预加载可以显著的提高优先级，避免字体加载时间过长，导致切换时候带来的不好体验\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e**字体体积，上面更多的是辅助优化，对于中文字体而言，最重要的是体积。中文不同于其他字母语言，有非常多的字，一个字体 10 M 的体积要如何处理呢，正常会对字体文件做提取，只保留可能要用的字，也就是 glyphs。**比如只用到 \u003ccode\u003e溜\u003c/code\u003e 这个字，那就提取字体包里的 \u003ccode\u003e溜\u003c/code\u003e，这样字体文件就可以压缩的非常小了\u003c/li\u003e\n\u003cli\u003e最后是 woff、woff2 这些新格式带来的优化，以及更好的压缩算法带来的帮助。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e字体的提取历程\u003c/h3\u003e\n\u003cp\u003e这里要介绍是可变字体的提取问题，先看看普通字体提取，之前用的是 \u003ccode\u003efont-spider\u003c/code\u003e，使用下来可以满足字体的压缩，提取需要的子集，用法很方便，如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- test.html --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003estyle\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"css\"\u003e\n  \u003cspan class=\"hljs-keyword\"\u003e@font-face\u003c/span\u003e {\n    \u003cspan class=\"hljs-attribute\"\u003efont-family\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"source\"\u003c/span\u003e;\n    \u003cspan class=\"hljs-attribute\"\u003esrc\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eurl\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"../font/source.eot\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-attribute\"\u003efont-style\u003c/span\u003e: normal;\n  }\n  \u003cspan class=\"hljs-selector-tag\"\u003ebody\u003c/span\u003e {\n    \u003cspan class=\"hljs-attribute\"\u003efont-family\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"source\"\u003c/span\u003e;\n  }\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003estyle\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  溜\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再通过指令 \u003ccode\u003efont-spider ./test.html\u003c/code\u003e 就可以从 \u003ccode\u003esource.eot\u003c/code\u003e 字体包里面压缩出仅仅包含 \u003ccode\u003e溜\u003c/code\u003e 一个字的字体，当然会有一点小问题，比如垂直方向的行间距变小了，但是总体问题不大，10M 的字体包，最后只剩下几 kb。这个时候如果用软件 FontForge 查看的话，可以看到 \u003ccode\u003e溜\u003c/code\u003e 保留下来了，其他被移除了。\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/fontLiuNormal.PNG\" alt=\"\"\u003e\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/fontLiuMin.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e上面左边是正常的字形，右边则是压缩之后的效果，可以看到压缩后周围的小伙伴都被吓跑了。\u003c/p\u003e\n\u003cp\u003e只是到了可变字体，压缩就不是这样了，简简单单的 \u003ccode\u003efont-spider\u003c/code\u003e 打包出来的字体就不能用，会出现字体镂空的情况，而且关键是不能调整可变字体的 \u003ccode\u003ewght\u003c/code\u003e，设置了也不起作用，简直就是和普通字体差不多，不再是可变字体了。\u003c/p\u003e\n\u003cp\u003e于是翻箱倒柜的，在 \u003ccode\u003efont-spider\u003c/code\u003e 里面转了一圈，结果发现里面处理字体的内容不多，更多的是对输入文件和样式处理，通过模拟的浏览器环境，自研的 \u003ccode\u003ebrowser-x\u003c/code\u003e(大佬自己写的 \u003ccode\u003eNode.js\u003c/code\u003e 实现的虚拟浏览器) 来获取样式，保证不同的的 \u003ccode\u003efont-family\u003c/code\u003e 打包出不同的字体，分析输入的参数，文字最后输出四种格式的字体，\u003ccode\u003ewoff woff2 svg ttf\u003c/code\u003e 这些，当然在 \u003ccode\u003eWebFont\u003c/code\u003e 里面看到了不少冗余的代码，一度让我误解了，比如 \u003ccode\u003eweight stretch\u003c/code\u003e 这些属性，就不能使用。。。。可能也是大佬弃坑了吧，最后落实到压缩的还是 \u003ccode\u003efontmin\u003c/code\u003e 这个库，也有三方压缩的工具都是基于 \u003ccode\u003efontmin\u003c/code\u003e 的。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efontmin\u003c/code\u003e 是一款中间件机制的字体处理工具，比如 \u003ccode\u003eglyph\u003c/code\u003e 可以用来压缩字体，比如 \u003ccode\u003ettf2woff\u003c/code\u003e 可以转换字体。比如下面的官方例子：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e Fontmin = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"fontmin\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e fontmin = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Fontmin().use(\n  Fontmin.glyph({\n    \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"天地玄黄 宇宙洪荒\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ehinting\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n  })\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 \u003ccode\u003efontmin\u003c/code\u003e 代码里面的 \u003ccode\u003eglyph\u003c/code\u003e 插件代码中可以看到如下形式：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e TTF = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"fonteditor-core\"\u003c/span\u003e).TTF;\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e TTFReader = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"fonteditor-core\"\u003c/span\u003e).TTFReader;\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e TTFWriter = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"fonteditor-core\"\u003c/span\u003e).TTFWriter;\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eminifyTtf\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003econtents, opts\u003c/span\u003e) \u003c/span\u003e{\n  opts = opts || {};\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e ttfobj = contents;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (Buffer.isBuffer(contents)) {\n    ttfobj = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e TTFReader(opts).read(b2ab(contents));\n  }\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e miniObj = minifyFontObject(ttfobj, opts.subset, opts.use);\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e ttfBuffer = ab2b(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e TTFWriter(opts).write(miniObj));\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eobject\u003c/span\u003e: miniObj,\n    \u003cspan class=\"hljs-attr\"\u003ebuffer\u003c/span\u003e: ttfBuffer,\n  };\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eminifyFontObject\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ettfObject, subset, plugin\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (subset.length === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e ttfObject;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e ttf = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e TTF(ttfObject);\n  ttf.setGlyf(getSubsetGlyfs(ttf, subset));\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (_.isFunction(plugin)) {\n    plugin(ttf);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e ttf.get();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e敢情 \u003ccode\u003efontmin\u003c/code\u003e 也是套娃的。。。最后核心的字体处理还是要跑到 \u003ccode\u003efonteditor-core\u003c/code\u003e 里面，怎么说呢， \u003ccode\u003efontmin\u003c/code\u003e 是一个优秀的集成商，有字体压缩，还有字体格式转换这些功能，虽然大部分是基于第三方的。而且不管是 \u003ccode\u003efontmin\u003c/code\u003e 还是 \u003ccode\u003efont-spider\u003c/code\u003e 也有四五年没有更新主要内容了，作者也都弃坑了。那对于 16 年底才发布的可变字体，好像不支持也是可以理解的。\u003c/p\u003e\n\u003ch3\u003etable\u003c/h3\u003e\n\u003cp\u003e介绍到 \u003ccode\u003efonteditor-core\u003c/code\u003e 就要提一下 \u003ccode\u003etable\u003c/code\u003e 的概念，这个是布局信息表，其包含了字形的位置、对齐、基线等等信息，字体文件则是由这一系列的表构成的，其中有部分表是可选的。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e字体目录\u003c/strong\u003e是字体文件的指南，提供访问其他表所需的信息，包含两部分：偏移子表（offset subtable）和表目录（table directory）。偏移子表记录了字体文件中 \u003ccode\u003etable\u003c/code\u003e 的数量，并提供了快速访问表目录的方法。偏移子表后面就是表目录，表目录主要包含了表的 \u003ccode\u003etag\u003c/code\u003e、校验、偏移、长度等信息，字体文件中的所有表都在表目录里面有入口。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/fontTableDirectory.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e看了不少文档，每个文档对必选的 \u003ccode\u003etable\u003c/code\u003e 都有自己的解释，综合一下，下面是其中有几个是非常必要的 \u003ccode\u003etable\u003c/code\u003e:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ecmap：字符代码到字形索引之间的映射关系，字符代码也就是字符的 \u003ccode\u003eUnicode\u003c/code\u003e，获得索引也就可以根据索引从字体中加载这个字形。\u003c/li\u003e\n\u003cli\u003ehead：字体的各种基本信息，如版本、创建、修改时间，还包括基本字体数据，如 unitsPerEm、xMin, yMin 等。\u003c/li\u003e\n\u003cli\u003ehhea：水平排列信息，如 ascender、descender、lineGap 等水平排列时候的布局信息。\u003c/li\u003e\n\u003cli\u003ehmtx：水平参数，如间距，如果是字形之间是等距的，那只需要一个间距就可以了。\u003c/li\u003e\n\u003cli\u003emaxp：最大需求表，包含字形数量，表示字形的内存需求情况。\u003c/li\u003e\n\u003cli\u003ename：命名内容，如字体名，授权信息等等。\u003c/li\u003e\n\u003cli\u003epost：PostScript 表，用于打印。\u003c/li\u003e\n\u003cli\u003eglyf：字形数据，也是最重要的一个表了。\u003c/li\u003e\n\u003cli\u003eloca：偏移和字符索引映射关系表。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e上面几个表的介绍可能理解不太到位地方，因该差不多大致如此吧。另外，还有一些比如 \u003ccode\u003eOS/2\u003c/code\u003e: 用于 windows 系统的配置，所以对跨平台的字体就非常需要了，但是若是针对 Mac 这些就不必了。\u003c/p\u003e\n\u003cp\u003e具体的字形什么的，用 \u003ccode\u003eFontForge\u003c/code\u003e 软件打开任意一个字体就可以看到了，比如下面的：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/fontLiuGlyph.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e你甚至都可以修改字形。。。。\u003c/p\u003e\n\u003cp\u003e至于字体从加载到渲染出来的流程可以参考一下知乎上的\u003ca href=\"https://www.zhihu.com/question/23759223/answer/25617486\" target=\"_blank\"\u003e介绍\u003c/a\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e加载字体文件\n确定要输出的字体大小\n输入这个字符的编码值\n根据字体文件里面的 Charmap，把编码值转换成字形索引（就是这个字符对应字体文件中的第几个形状）\n根据索引从字体中加载这个字形\n将这个字形渲染成位图，有可能进行加粗，倾斜等变换。注意这里的倾斜和倾斜字体不同，它只是从算法上对位图进行变换，与专门制作的加粗字体是不一样的。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e上面介绍的是 \u003ccode\u003ecmap\u003c/code\u003e 根据字符代码拿到字形索引，再从 \u003ccode\u003eloca\u003c/code\u003e 拿到索引对应的字形偏移，最后到 \u003ccode\u003eglyf\u003c/code\u003e 加载字形的过程。\u003ccode\u003eloca\u003c/code\u003e 表可以参考以下图：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/fontLoca.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e每个字形都有自己长度，从而形成相对于 \u003ccode\u003e0\u003c/code\u003e 位置的偏移，而 \u003ccode\u003eloca\u003c/code\u003e 表则是记录字形索引到字形偏移的映射表。\u003c/p\u003e\n\u003cp\u003e当然这里面还有很多的表的内容没有谈到，比如和 \u003ccode\u003eTrueType\u003c/code\u003e、\u003ccode\u003eCCF\u003c/code\u003e、\u003ccode\u003eSVG\u003c/code\u003e 以及 \u003ccode\u003eBitMap\u003c/code\u003e 相关的表，还有一个是高级表，比如 \u003ccode\u003eGSUB\u003c/code\u003e 是 \u003ccode\u003eglyf\u003c/code\u003e 的替换表，之前提到的一个字符代码最后可以映射到字形，但是如果是连字的时候，就不一定是简单的字形叠加，例如下面的：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/fontGSUB.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e可以看到单独一个字的时候都是好好的，但是一旦结合在一起，就是不是 \u003ccode\u003ef + i = fi\u003c/code\u003e 了，而是有新的字形。这一点在阿拉伯语中也是的，字形在不同的位置有不同的显示。。。。。（原来阿拉伯语这么神奇，简直就是蝌蚪文）。\u003c/p\u003e\n\u003cp\u003e除了高级表，还有色彩相关的，其他比较杂的，最后还有一个是 \u003ccode\u003eOpenType Font Variations\u003c/code\u003e 可变字体，也是 \u003ccode\u003eOpenType\u003c/code\u003e 规范中，里面有 \u003ccode\u003eavar\u003c/code\u003e、\u003ccode\u003ecvar\u003c/code\u003e、\u003ccode\u003efvar\u003c/code\u003e、\u003ccode\u003egvar\u003c/code\u003e、\u003ccode\u003eHVAR\u003c/code\u003e、\u003ccode\u003eMVAR\u003c/code\u003e、\u003ccode\u003eSTAT\u003c/code\u003e 和 \u003ccode\u003eVVAR\u003c/code\u003e 这几个。\u003c/p\u003e\n\u003ch4\u003e可变字体的 table\u003c/h4\u003e\n\u003cp\u003e可变字体，如前面提到的，可以让设计者将多个字体合并为一个字体，下面的示意图很好的介绍了字重和字宽度变化导致字形的变化：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/variableFontsWidthWeight.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e这里面看到的 \u003ccode\u003ewidth\u003c/code\u003e 和 \u003ccode\u003eweight\u003c/code\u003e 都是 \u003ccode\u003efvar\u003c/code\u003e 表所描述的，用来存储轴的信息，以及命名实例，其中命名实例是可选的字段。轴的信息，比如 \u003ccode\u003ewght(100-1000)\u003c/code\u003e、\u003ccode\u003ewidth(10-200)\u003c/code\u003e，包含了轴名称、最小最大值和默认值等，命名实例则是由轴与轴之间定下的命名的特定坐标，如下面几个:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/variableFVAR.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e可以看到轴 \u003ccode\u003ewght = 400\u003c/code\u003e 以及 \u003ccode\u003ewdth = 100\u003c/code\u003e 形成的坐标 \u003ccode\u003eRegular\u003c/code\u003e，也就是命名实例。\u003ccode\u003eRegular\u003c/code\u003e 是给特定坐标提供的预设名称，也是该子字体的名称，可以让使用者直接使用。使用可变字体的时候，如果没有指定子字体，其采用默认轴值。（css 里面修改 \u003ccode\u003efont-variation-settings\u003c/code\u003e，也就是实例了）。\u003c/p\u003e\n\u003cp\u003e对于可变字体，有两个表是必须的：\u003ccode\u003efvar\u003c/code\u003e 和 \u003ccode\u003eSTAT(style attributes)\u003c/code\u003e，后者是样式属性，每个在 \u003ccode\u003efvar\u003c/code\u003e 里面的每一条轴和子字体都需要在 \u003ccode\u003eSTAT\u003c/code\u003e 里面有对应的信息。\u003ccode\u003eSTAT\u003c/code\u003e 用来区分字体族下面的不同的字体，支持动态属性，比如 \u003ccode\u003efvar\u003c/code\u003e 里面的 \u003ccode\u003ewght(无极)\u003c/code\u003e，也支持静态属性，比如 \u003ccode\u003eitalic\u003c/code\u003e 是否为斜体这些，展示 \u003ccode\u003eVariable Font\u003c/code\u003e 下的样式名称，比如 \u003ccode\u003eMedium\u003c/code\u003e 这样的字体。\u003c/p\u003e\n\u003cp\u003e其他的表则是描述 \u003ccode\u003efvar\u003c/code\u003e 里面字体轴变化时字形的变化情况，例如 \u003ccode\u003eavar\u003c/code\u003e，是非线性的轴变化数据，例如字体的 \u003ccode\u003ewidth\u003c/code\u003e 轴，若变化区间是 \u003ccode\u003e100-200\u003c/code\u003e，线性的时候，则 \u003ccode\u003e150\u003c/code\u003e 表示字体的字形宽度是两个极值的正中间，但是非线性变化，就使得值不是均匀的变化的，\u003ccode\u003e150\u003c/code\u003e 可能不是字形宽度上的正中间状态。这种非线性变化也符合用户习惯。还有 \u003ccode\u003egvar\u003c/code\u003e，存储字形在轴上的变化信息，描述 \u003ccode\u003eglyp\u003c/code\u003e 中各个点的变化情况，可以说是非常重要的。\u003c/p\u003e\n\u003ch3\u003e字体提取工具\u003c/h3\u003e\n\u003cp\u003e看了上面的 \u003ccode\u003etable\u003c/code\u003e 介绍，字体的处理，其实就是对 \u003ccode\u003etable\u003c/code\u003e 的处理，\u003ccode\u003efonteditor-core\u003c/code\u003e 对可变字体的处理，看了一下源码的\u003ca href=\"https://github.com/kekee000/fonteditor-core/tree/master/src/ttf/table\" target=\"_blank\"\u003e结构\u003c/a\u003e，well，根本就没有可变字体的表处理，连 \u003ccode\u003efvar\u003c/code\u003e 的踪迹都没有。\u003c/p\u003e\n\u003cp\u003e于是开启大海捞针的方式，在 \u003ccode\u003egithub\u003c/code\u003e 里面找，最后发现一个 \u003ccode\u003eopentypejs/opentype.js\u003c/code\u003e 仓库，卧槽，难道是官方的嫡系部队？只是打开到结构目录还是很失望，都是三四年前的代码了，和 \u003ccode\u003efonteditor-core\u003c/code\u003e 差不多，虽然有 \u003ccode\u003efvar\u003c/code\u003e 表，但是其他可变字体的表一个都没有。抱着试一试的想法，用一下，最后的打包出来的字体，虽然比 \u003ccode\u003efonteditor-core\u003c/code\u003e 好不少，但是压根就不可变。。。。毕竟连 \u003ccode\u003egvar\u003c/code\u003e 也没有。最后看到了这个\u003ca href=\"https://github.com/opentypejs/opentype.js/issues/374\" target=\"_blank\"\u003eroadMap\u003c/a\u003e，里面介绍到：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/variableFontsRoadMap.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e本来决定要放弃了，毕竟官方也不支持系列，但是总觉得有问题，难道可变字体没有工具？都好几年历史了，没有人造轮子吗。。。。\u003c/p\u003e\n\u003cp\u003e最后找到了字体处理的重量级库 \u003ccode\u003efonttools\u003c/code\u003e，一个 \u003ccode\u003epython\u003c/code\u003e 库，打开一看密密麻麻的的 \u003ccode\u003etable\u003c/code\u003e 处理，有 50 个以上的处理，对比一下 \u003ccode\u003efonteditor-core\u003c/code\u003e 的 18 个表处理，简直是。。。。。。在 \u003ccode\u003efonttools\u003c/code\u003e 里面也找到了各种各样的可变字体处理表，比如 \u003ccode\u003egvar\u003c/code\u003e，只是对 \u003ccode\u003epython\u003c/code\u003e 不是很熟悉，而且一上来就看源码，有点吃力，所以就放弃了（想起了看 esbuild 源码的经历）。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efonttools\u003c/code\u003e 里面有很多工具，提取字体用的是 \u003ccode\u003epyftsubset\u003c/code\u003e，通过指定文件字符来确定要输出的字形，基本上一顿操作下来，从 22M 的字体包，压缩到 300kb。正常来做这就可以了，但是 \u003cstrong\u003e原本字体包还包含了斜、高度轴，这些轴，项目用不上，而且 \u003ccode\u003ewght\u003c/code\u003e 也就用到了 \u003ccode\u003e550-1000\u003c/code\u003e 的范围，能不能去掉剩下的部分呢？\u003c/strong\u003e 这样不就可以完美压缩字体了，甚至 \u003ccode\u003ewght\u003c/code\u003e 就用了 \u003ccode\u003e550\u003c/code\u003e 和 \u003ccode\u003e1000\u003c/code\u003e 两个值，其他的能不能抛弃掉呢？可能这个就要用专业的设计工具了（比如 Adobe Illustrator？），目前在 \u003ccode\u003efonttools\u003c/code\u003e 没有看到更多可操作空间，如果有大佬晓得一定要告知。\u003c/p\u003e\n\u003cp\u003e一般可变字体的体积是要大于单个字体的（字体族里面的单个字体），只有当需要用到同一字体族的多个字体的时候，可变字体收益才很大。当然如果需要艺术字那就另当别论了。另外 \u003ccode\u003efont-variation-settings\u003c/code\u003e 是属于比较基础的 API 了，如果要设置字重的话，可以使用 \u003ccode\u003efont-weight: 550\u003c/code\u003e 是不是很熟悉？这个和以前的 CSS 是一致的，只是 \u003ccode\u003eCSS Fonts Level 4\u003c/code\u003e 做了扩展，当然还有其他几个轴的，比如 \u003ccode\u003efont-stretch\u003c/code\u003e。\u003c/p\u003e\n\u003ch2\u003erequire\u003c/h2\u003e\n\u003cp\u003e相比于字体，\u003ccode\u003erequire\u003c/code\u003e 可以说是以前的一个知识盲区。在 \u003ccode\u003eVue\u003c/code\u003e 里面，如果需要加载资源可以采用 \u003ccode\u003erequire\u003c/code\u003e 方式引入，但是时不时的总会遇到无法加载资源的问题。直到一次想要把资源路径作为 \u003ccode\u003eprops\u003c/code\u003e 传入组件，再通过 \u003ccode\u003erequire\u003c/code\u003e 来获取，结果是获取到图片了，但是还引发了\u003cstrong\u003e另外一个严重的问题，页面的样式错乱？\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e通过审查打包出现的代码，发现原本完全没有引入的 \u003ccode\u003escss\u003c/code\u003e 文件都被打包到样式文件里面，如果去掉 \u003ccode\u003erequire(urlProp)\u003c/code\u003e 则一切正常，这个就很神奇了，而且前者的打出的包还很大。有种奇奇怪怪的感觉。\u003c/p\u003e\n\u003cp\u003e后面耐心的看 \u003ccode\u003ewebpack\u003c/code\u003e \u003ca href=\"https://webpack.js.org/guides/dependency-management/#require-with-expression\" target=\"_blank\"\u003e文档\u003c/a\u003e才晓得：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eA context module is generated. \u003cstrong\u003eIt contains references to all modules in that directory that can be required\u003c/strong\u003e with a request matching the regular expression. The context module contains a map which translates requests to module ids.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e如果采用 \u003ccode\u003erequire('./template/' + name + '.ejs')\u003c/code\u003e 的方式，那 \u003ccode\u003etemplate\u003c/code\u003e 文件下面的所有 \u003ccode\u003eejs\u003c/code\u003e 文件都会被引用，形成一个上下文的 \u003ccode\u003emap\u003c/code\u003e 对象，\u003cstrong\u003e导致该目录下原本不会被使用的文件，也被打包使用上了\u003c/strong\u003e，这也就是为什么使用了 \u003ccode\u003erequire(urlProp)\u003c/code\u003e 会加载上错误的资源，可想而知，若 \u003ccode\u003erequire\u003c/code\u003e 里面完全采用传参的方式，会使其无法分析正确的 \u003ccode\u003eDirectory\u003c/code\u003e， 于是从根文件 \u003ccode\u003esrc\u003c/code\u003e 开始查询文件。。。。。\u003c/p\u003e\n\u003cp\u003e至于要如何破局呢，\u003ccode\u003eurlProp\u003c/code\u003e 为了可扩展性，是要从外部传入的，而里面要读取资源只能用 \u003ccode\u003erequire\u003c/code\u003e 了，直到看到了下面的 \u003ccode\u003erequire.context\u003c/code\u003e 的方式，表达式如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e.context(\n  directory,\n  (useSubdirectories = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e),\n  (regExp = \u003cspan class=\"hljs-regexp\"\u003e/^\\.\\/.*$/\u003c/span\u003e),\n  (mode = \u003cspan class=\"hljs-string\"\u003e\"sync\"\u003c/span\u003e)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过在外部指定目录，和正则就能获得正确的资源路径，再传给 \u003ccode\u003eurlProp\u003c/code\u003e 就完美了。\u003c/p\u003e\n\u003cp\u003e上面的 \u003ccode\u003emode\u003c/code\u003e 配置呢，其实是和 \u003ccode\u003ewebpackMode\u003c/code\u003e 类似的，有 \u003ccode\u003esync\u003c/code\u003e、\u003ccode\u003eeager\u003c/code\u003e、\u003ccode\u003elazy\u003c/code\u003e、\u003ccode\u003elazy-once\u003c/code\u003e、\u003ccode\u003eweak\u003c/code\u003e、\u003ccode\u003easync-weak\u003c/code\u003e 一共六种。其中\u003ccode\u003esync\u003c/code\u003e 是默认的，会直接打包到文件里面，而 \u003ccode\u003elazy\u003c/code\u003e 则会生成可延迟加载单独的 \u003ccode\u003echunk\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e这里我用到的是 \u003ccode\u003elazy-once\u003c/code\u003e。为什么呢，因为我需要从 \u003ccode\u003erequire.context\u003c/code\u003e 里面引入的资源非常多，肯定是要拆包的，而 \u003ccode\u003elazy\u003c/code\u003e 虽然是懒加载了，但是所有文件都单独形成 \u003ccode\u003echunk\u003c/code\u003e，导致增加了很多文件，\u003ccode\u003elazy-once\u003c/code\u003e 就很舒服，将所有文件合成一个 \u003ccode\u003echunk\u003c/code\u003e，只需要通过 \u003ccode\u003epromise\u003c/code\u003e 的方式获取正确的路径就可以了，比如 \u003ccode\u003eurlProp(oneFileName).then(src =\u0026gt; list.push(src))\u003c/code\u003e 这样的方式。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003erequire\u003c/code\u003e 部分算是一个小知识点，至于深入的理解，比如 \u003ccode\u003eDirectory\u003c/code\u003e 目录的获取和分析，感觉有点类似，可能是 \u003ccode\u003e@babel/parser\u003c/code\u003e 的形式，通过 \u003ccode\u003east\u003c/code\u003e 分析表达式来获取目录？后面的理解就没有去研究了，倒是解决了一直以来使用 \u003ccode\u003erequire\u003c/code\u003e 的困惑（指不定以前有好多写的不太正常的 bug，采用 \u003ccode\u003erequire\u003c/code\u003e 多加载了多余文件。。。。。呵呵呵）。\u003c/p\u003e\n\u003cp\u003e字体部分，更像是一个新领域的探索，想要不断的优化页面，而新版本的字体就是重中之重了，从开始的通过 \u003ccode\u003enode.js\u003c/code\u003e 来 \u003ccode\u003edebug\u003c/code\u003e，到最后定位到 \u003ccode\u003efonteditor-core\u003c/code\u003e 再到 \u003ccode\u003efonttools\u003c/code\u003e，可以看到前端的字体轮子还是少了（比如参照 \u003ccode\u003efonttools\u003c/code\u003e 代码，更新 \u003ccode\u003efontedior-core\u003c/code\u003e ？）。更多的是学习字体的结构，看各个 \u003ccode\u003etable\u003c/code\u003e 的作用，对字体的展示也有初步的理解，但是没有去研究代码层面的实现，没有深入去，更多的是浅尝辄止，可能兴趣就到这里吧，没有更多的想法了，想要深入探索更多的东西，更有价值的吧。\u003c/p\u003e\n\u003cp\u003e写完的时候又一个台风飞过，今年的台风真是奇怪。\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003cp\u003e技术文档，当然微软的是 Opentype，苹果的是 TrueType 与 AAT。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/zh-cn/typography/opentype/spec/\" target=\"_blank\"\u003emicrosoft OpenType 1.8.3 specification\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6.html\" target=\"_blank\"\u003eapple Font Tables\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.thetype.com/2016/09/10968/\" target=\"_blank\"\u003e参数化设计与字体战争：从 OpenType 1.8 说起\u003c/a\u003e 很有趣的一篇历史介绍，想不到可变字体，出道快 30 年了，结果 16 年才成为统一标准。。。。。。\u003c/li\u003e\n\u003c/ol\u003e\n"}},"buildId":"r4Ww0YLm8YL5~6SwciWHH","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" async=""></script></body></html>