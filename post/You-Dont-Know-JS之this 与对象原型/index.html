<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">You-Dont-Know-JS之this 与对象原型</title><link rel="preload" href="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.ce3e8fb7a689beb447ad.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.8d98f9151bcde6fb2a87.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-45be5a1f94c3fe5df8ee.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.bb30b296.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___3Hk0c "><a class="logo___1KD30" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___1qXLb" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___3VKNp"><h1 class="postTitle___26vXM">You-Dont-Know-JS之this 与对象原型</h1><span class="postTime___16Ish">July 7, 2018</span></header><article class="postWrapper___3NXol post-article"><div><h1>前言</h1>
<p>遥记得以前刚开始写JavaScript的时候，起步就是jQuery，用的也简单，后来想学习原生的JavaScript，刚上来就遇到this的问题，每次都要去看阮老师那篇2010年写的博客，再不就去点开那篇一直珍藏着的<a href="http://bonsaiden.github.io/JavaScript-Garden/zh/" target="_blank">JavaScript 秘密花园</a>，每次看完都以为知道，但是后来遇到了总是要再回去一下，直到之前面试，以防万一又看了一遍。。。。。。书中提及的this，在这里更是要总结一下</p>
<h1>谈谈this</h1>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)
}

foo() <span class="hljs-comment">//undefined</span>
</code></pre>
<p>上面的代码简单吧，相信大部分人都会认为打印出来的是2，但是结果却是undefined，难道this不应该指向自己吗？英语白学了不成。。。。。well，讲真，这里的this不是指向foo函数的，而是全局作用域，就是window，咦？为啥？或许你把foo函数的调用点，<code>foo()</code>理解为<code>window.foo()</code>就能豁然开朗了，那a自然是window的a。正如上面所提到的foo，它没有什么乱七八糟的修饰，而且调用点在全局，所以自然是全局的a变量，如果写成一下方式就是：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">this</span>.a = <span class="hljs-number">3</span>; 
    foo()
}

bar() <span class="hljs-comment">//3</span>
</code></pre>
<p>得到的值自然是3，虽然也是<code>window.bar()</code>，但是调用点在bar函数内部呀。</p>
<p>上面提到的就是默认绑定，简单的方法就是查看调用点，根据调用点来判断作用域；一般都是被解析成全局变量；书中提到的this绑定有还有隐含绑定，明确绑定和new绑定</p>
<p>隐含绑定其实上文多少都提到过，如下代码：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a );
}

<span class="hljs-keyword">var</span> obj = {
    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">foo</span>: foo
};

obj.foo(); <span class="hljs-comment">// 2</span>
</code></pre>
<p>这里的调用点使用了obj的环境来引用，so，this自然就指向obj，这个有点类似上文提到过的window.foo()，这一类通过调用点也是可以清晰知道this的指向；</p>
<p>明确绑定，这里就是指显式的设置this了，用apply和call的方法，明确的指出要绑定的上下文
最后一种就是new绑定，这个涉及到new操作，new操作符首先会创建一个对象，并绑定上this，除非放回其他的对象，否则放回new新建的对象，如下文所说：</p>
<blockquote>
<p>只要 new 表达式之后的 constructor 返回（return）一个引用对象（数组，对象，函数等），都将覆盖new创建的匿名对象，如果返回（return）一个原始类型（无 return 时其实为 return 原始类型 undefined），那么就返回 new 创建的匿名对象。<a href="http://www.planabc.net/2008/02/20/javascript_new_function/" target="_blank">链接</a></p>
</blockquote>
<p>讲了这几个this之后你大概就知道怎么用了吧，另外还有箭头函数的this问题，这也是个值得注意的点，箭头函数的this就是定义时候所在的对象，而不是使用时候，并且this的指向是不可变的</p>
<h1>对象</h1>
<p>书中提到了对象，还有defineProperty的使用，以及class的使用，这些都是JSer基本要掌握的，这里就不介绍了，尤其实在ES6出来之后。
但是文中提到用object.create()，使用如下<code>Bar.prototype = Object.create( Foo.prototype )</code>，在原型继承里面一般我们都是用<code>Bar.prototype = new Foo()</code>居多，问题也提到，这样做会出现一些意料之外的副作用，well，有时候我们就是要用到这些副作用呢。。。。</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"July 7, 2018","title":"You-Dont-Know-JS之this 与对象原型","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e遥记得以前刚开始写JavaScript的时候，起步就是jQuery，用的也简单，后来想学习原生的JavaScript，刚上来就遇到this的问题，每次都要去看阮老师那篇2010年写的博客，再不就去点开那篇一直珍藏着的\u003ca href=\"http://bonsaiden.github.io/JavaScript-Garden/zh/\" target=\"_blank\"\u003eJavaScript 秘密花园\u003c/a\u003e，每次看完都以为知道，但是后来遇到了总是要再回去一下，直到之前面试，以防万一又看了一遍。。。。。。书中提及的this，在这里更是要总结一下\u003c/p\u003e\n\u003ch1\u003e谈谈this\u003c/h1\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e a = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.a)\n}\n\nfoo() \u003cspan class=\"hljs-comment\"\u003e//undefined\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面的代码简单吧，相信大部分人都会认为打印出来的是2，但是结果却是undefined，难道this不应该指向自己吗？英语白学了不成。。。。。well，讲真，这里的this不是指向foo函数的，而是全局作用域，就是window，咦？为啥？或许你把foo函数的调用点，\u003ccode\u003efoo()\u003c/code\u003e理解为\u003ccode\u003ewindow.foo()\u003c/code\u003e就能豁然开朗了，那a自然是window的a。正如上面所提到的foo，它没有什么乱七八糟的修饰，而且调用点在全局，所以自然是全局的a变量，如果写成一下方式就是：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e a = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.a)\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e)\u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.a = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e; \n    foo()\n}\n\nbar() \u003cspan class=\"hljs-comment\"\u003e//3\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e得到的值自然是3，虽然也是\u003ccode\u003ewindow.bar()\u003c/code\u003e，但是调用点在bar函数内部呀。\u003c/p\u003e\n\u003cp\u003e上面提到的就是默认绑定，简单的方法就是查看调用点，根据调用点来判断作用域；一般都是被解析成全局变量；书中提到的this绑定有还有隐含绑定，明确绑定和new绑定\u003c/p\u003e\n\u003cp\u003e隐含绑定其实上文多少都提到过，如下代码：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log( \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.a );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e obj = {\n    \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003efoo\u003c/span\u003e: foo\n};\n\nobj.foo(); \u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里的调用点使用了obj的环境来引用，so，this自然就指向obj，这个有点类似上文提到过的window.foo()，这一类通过调用点也是可以清晰知道this的指向；\u003c/p\u003e\n\u003cp\u003e明确绑定，这里就是指显式的设置this了，用apply和call的方法，明确的指出要绑定的上下文\n最后一种就是new绑定，这个涉及到new操作，new操作符首先会创建一个对象，并绑定上this，除非放回其他的对象，否则放回new新建的对象，如下文所说：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e只要 new 表达式之后的 constructor 返回（return）一个引用对象（数组，对象，函数等），都将覆盖new创建的匿名对象，如果返回（return）一个原始类型（无 return 时其实为 return 原始类型 undefined），那么就返回 new 创建的匿名对象。\u003ca href=\"http://www.planabc.net/2008/02/20/javascript_new_function/\" target=\"_blank\"\u003e链接\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e讲了这几个this之后你大概就知道怎么用了吧，另外还有箭头函数的this问题，这也是个值得注意的点，箭头函数的this就是定义时候所在的对象，而不是使用时候，并且this的指向是不可变的\u003c/p\u003e\n\u003ch1\u003e对象\u003c/h1\u003e\n\u003cp\u003e书中提到了对象，还有defineProperty的使用，以及class的使用，这些都是JSer基本要掌握的，这里就不介绍了，尤其实在ES6出来之后。\n但是文中提到用object.create()，使用如下\u003ccode\u003eBar.prototype = Object.create( Foo.prototype )\u003c/code\u003e，在原型继承里面一般我们都是用\u003ccode\u003eBar.prototype = new Foo()\u003c/code\u003e居多，问题也提到，这样做会出现一些意料之外的副作用，well，有时候我们就是要用到这些副作用呢。。。。\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"July 7, 2018","title":"You-Dont-Know-JS之this 与对象原型","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e遥记得以前刚开始写JavaScript的时候，起步就是jQuery，用的也简单，后来想学习原生的JavaScript，刚上来就遇到this的问题，每次都要去看阮老师那篇2010年写的博客，再不就去点开那篇一直珍藏着的\u003ca href=\"http://bonsaiden.github.io/JavaScript-Garden/zh/\" target=\"_blank\"\u003eJavaScript 秘密花园\u003c/a\u003e，每次看完都以为知道，但是后来遇到了总是要再回去一下，直到之前面试，以防万一又看了一遍。。。。。。书中提及的this，在这里更是要总结一下\u003c/p\u003e\n\u003ch1\u003e谈谈this\u003c/h1\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e a = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.a)\n}\n\nfoo() \u003cspan class=\"hljs-comment\"\u003e//undefined\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面的代码简单吧，相信大部分人都会认为打印出来的是2，但是结果却是undefined，难道this不应该指向自己吗？英语白学了不成。。。。。well，讲真，这里的this不是指向foo函数的，而是全局作用域，就是window，咦？为啥？或许你把foo函数的调用点，\u003ccode\u003efoo()\u003c/code\u003e理解为\u003ccode\u003ewindow.foo()\u003c/code\u003e就能豁然开朗了，那a自然是window的a。正如上面所提到的foo，它没有什么乱七八糟的修饰，而且调用点在全局，所以自然是全局的a变量，如果写成一下方式就是：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e a = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.a)\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e)\u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.a = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e; \n    foo()\n}\n\nbar() \u003cspan class=\"hljs-comment\"\u003e//3\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e得到的值自然是3，虽然也是\u003ccode\u003ewindow.bar()\u003c/code\u003e，但是调用点在bar函数内部呀。\u003c/p\u003e\n\u003cp\u003e上面提到的就是默认绑定，简单的方法就是查看调用点，根据调用点来判断作用域；一般都是被解析成全局变量；书中提到的this绑定有还有隐含绑定，明确绑定和new绑定\u003c/p\u003e\n\u003cp\u003e隐含绑定其实上文多少都提到过，如下代码：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log( \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.a );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e obj = {\n    \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003efoo\u003c/span\u003e: foo\n};\n\nobj.foo(); \u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里的调用点使用了obj的环境来引用，so，this自然就指向obj，这个有点类似上文提到过的window.foo()，这一类通过调用点也是可以清晰知道this的指向；\u003c/p\u003e\n\u003cp\u003e明确绑定，这里就是指显式的设置this了，用apply和call的方法，明确的指出要绑定的上下文\n最后一种就是new绑定，这个涉及到new操作，new操作符首先会创建一个对象，并绑定上this，除非放回其他的对象，否则放回new新建的对象，如下文所说：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e只要 new 表达式之后的 constructor 返回（return）一个引用对象（数组，对象，函数等），都将覆盖new创建的匿名对象，如果返回（return）一个原始类型（无 return 时其实为 return 原始类型 undefined），那么就返回 new 创建的匿名对象。\u003ca href=\"http://www.planabc.net/2008/02/20/javascript_new_function/\" target=\"_blank\"\u003e链接\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e讲了这几个this之后你大概就知道怎么用了吧，另外还有箭头函数的this问题，这也是个值得注意的点，箭头函数的this就是定义时候所在的对象，而不是使用时候，并且this的指向是不可变的\u003c/p\u003e\n\u003ch1\u003e对象\u003c/h1\u003e\n\u003cp\u003e书中提到了对象，还有defineProperty的使用，以及class的使用，这些都是JSer基本要掌握的，这里就不介绍了，尤其实在ES6出来之后。\n但是文中提到用object.create()，使用如下\u003ccode\u003eBar.prototype = Object.create( Foo.prototype )\u003c/code\u003e，在原型继承里面一般我们都是用\u003ccode\u003eBar.prototype = new Foo()\u003c/code\u003e居多，问题也提到，这样做会出现一些意料之外的副作用，well，有时候我们就是要用到这些副作用呢。。。。\u003c/p\u003e\n"}},"buildId":"I9XlxpmvFk~lmulxmmsMh","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.ce3e8fb7a689beb447ad.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.8d98f9151bcde6fb2a87.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-45be5a1f94c3fe5df8ee.js" async=""></script></body></html>