<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">Vue 插槽的一个 bug</title><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.587c5e31.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___2dTZ9 "><a class="logo___346dE" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___13XXt" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___29Pln"><h1 class="postTitle___1_m4g">Vue 插槽的一个 bug</h1><span class="postTime___1x0_i">March 24, 2021</span></header><article class="postWrapper___3jnNg post-article"><div><p>最近工作比较忙，有想写的博客，但是一直没有下笔，想来也是有点懒了，还是要拔拔草。正值金三银四的，面试别人也以 <code>Vue</code> 源码居多，想要还是有必要学习一下插槽相关的内容。
这次的 <code>bug</code> 私以为还是 <code>Vue</code> 本身的问题，先看看一下代码：</p>
<pre class="hljs"><code><span class="hljs-comment">// App.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">components</span>: {
    <span class="hljs-attr">ChildContainer</span>: ChildContainer,
  },
  data() {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">slotsData</span>: {
        <span class="hljs-attr">a</span>: [<span class="hljs-string">"a"</span>, <span class="hljs-string">"ab"</span>, <span class="hljs-string">"abc"</span>],
        <span class="hljs-attr">default</span>: [],
      },
    };
  },
  <span class="hljs-attr">computed</span>: {
    slots() {
      <span class="hljs-keyword">const</span> scopedSlots = {};
      <span class="hljs-keyword">const</span> { slotsData } = <span class="hljs-keyword">this</span>;

      scopedSlots.a = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span>
        slotsData.a.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> {<span class="hljs-attr">...props</span>}&gt;</span>{item}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>);
      <span class="hljs-keyword">return</span> scopedSlots;
    },
  },
  render() {
    <span class="hljs-keyword">const</span> { slotsData } = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">child-container</span> <span class="hljs-attr">scopedSlots</span>=<span class="hljs-string">{this.slots}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>default外的默认内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          {slotsData.default.map((item) =&gt; item)}
        <span class="hljs-tag">&lt;/<span class="hljs-name">child-container</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  },
};

<span class="hljs-comment">// ChildContainer.vue</span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"childContainer"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>;
</code></pre>
<p>可以看到上面的 <code>App.js</code> 采用 <code>jsx</code> 的写法，由于 <code>ChildContainer.vue</code> 只有一个默认的 <code>slot</code>，而 <code>App.js</code> 则同时通过 <code>scopedSlots</code> 和 <code>children</code> 的方式传入了插槽内容。首先子组件里面没有使用到 <code>a</code> 插槽，所对应的内容不会渲染出去，最后会渲染出默认的内容为 <code>default外的默认内容</code>。</p>
<p>此时表现一切都是正常的，<code>this.slots</code> 和 <code>slotsData.default</code> 各施其职，而且还充分利用了 <code>computed</code> 的缓存功能，避免重复的计算 <code>slots</code>。而当加载后，修改 <code>slotsData.default</code> 数据的发现，如 <code>this.slotsData.default.push('slotsData的deflaut内容')</code>，可以看到页面没有任何变化，难道是设置的姿势不对？这是再简单不过的，查看 <code>slotsData.default</code> 数据也是对的，只是为什么不渲染出来呢？于是换成 <code>$set</code> 来设置，已经是最完整的了，只是还是没有用。渲染函数确实再次执行了，但是输出的内容还是 <code>default外的默认内容</code>，问题出在哪里呢？</p>
<p>这个时候把 <code>default外的默认内容</code> 这一行代码注释掉，发现再次设置 <code>slotsData.default</code> 的时候，数据生效了，同时页面有渲染 <code>slotsData的deflaut内容</code>，岂不是奇了怪了。之前通过 <code>Vue Dev Tool</code> 还可以看到生成的 <code>this.slots</code> 这个 <code>computed</code> 内容多了个 <code>_normalized</code> 字段，而且其下面还有个 <code>default</code> 函数，当注释 <code>default外的默认内容</code> 这一行的时候，这个 <code>_normalized</code> 也没有了，什么时候多了这个字段呢？看来只能看看 <code>Vue</code> 的源码，之前看的时候一直避开 <code>slot</code> 部分的，完全是个黑盒。</p>
<p>组件输出的渲染函数的 <code>slot</code> 部分为 <code>_vm._t(&quot;default&quot;)</code>, 其中 <code>_t</code> 就是如下函数：</p>
<pre class="hljs"><code><span class="hljs-comment">// 省略部分代码</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderSlot</span>(<span class="hljs-params">name, props</span>) </span>{
  <span class="hljs-keyword">const</span> scopedSlotFn = <span class="hljs-keyword">this</span>.$scopedSlots[name];
  <span class="hljs-keyword">let</span> nodes;
  <span class="hljs-keyword">if</span> (scopedSlotFn) {
    <span class="hljs-comment">// scoped slot</span>
    props = props || {};
    nodes = scopedSlotFn(props);
  } <span class="hljs-keyword">else</span> {
    nodes = <span class="hljs-keyword">this</span>.$slots[name];
  }
  <span class="hljs-keyword">const</span> target = props &amp;&amp; props.slot;
  <span class="hljs-keyword">if</span> (target) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$createElement(<span class="hljs-string">"template"</span>, { <span class="hljs-attr">slot</span>: target }, nodes);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> nodes;
  }
}

<span class="hljs-comment">// _render 函数里面</span>
vm.$scopedSlots = normalizeScopedSlots(
  _parentVnode.data.scopedSlots,
  vm.$slots,
  vm.$scopedSlots
);
</code></pre>
<p>可以看到 <code>renderSlot</code> 的最终输出取决于 <code>vm.$scopedSlots</code>，没有的话再是 <code>vm.$slots</code>，而 <code>$scopedSlots</code> 的生成取决于</p>
<ol>
<li><code>_parentVnode.data.scopedSlots</code> 节点 <code>vnode</code> 数据的 <code>scopedSlots</code> 字段，也就是上文业务中的 <code>this.slots</code>；</li>
<li><code>vm.$slots</code> 实例自身的生成的 <code>$slots</code>，一般是通过 <code>resolveSlots</code> 解析标签来匹配获得实例的 <code>slots</code> 节点;</li>
<li><code>vm.$scopedSlots</code> 前一个 <code>$scopedSlots</code>；</li>
</ol>
<p>在上面例子中，当更新 <code>default</code> 的数据的时候，<code>_parentVnode.data.scopedSlots</code> 和 <code>default</code> 数据没有关系所以不会更新，而 <code>vm.$slots</code> 则是包含了更新了的 <code>default</code> 插槽的数据，也就是包含了 <code>default外的默认内容</code> 以及 <code>slotsData的deflaut内容</code> 两个节点，只是在 debug 过程中发现最后生成的 <code>vm.$scopedSlots</code> 有大大的问题。</p>
<p>先看看 <code>normalizeScopedSlots</code> 方法</p>
<pre class="hljs"><code><span class="hljs-comment">// 省略部分代码</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalizeScopedSlots</span>(<span class="hljs-params">slots, normalSlots, prevSlots</span>) </span>{
  <span class="hljs-keyword">let</span> res;
  <span class="hljs-keyword">const</span> hasNormalSlots = <span class="hljs-built_in">Object</span>.keys(normalSlots).length &gt; <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> isStable = slots ? !!slots.$stable : !hasNormalSlots;
  <span class="hljs-keyword">const</span> key = slots &amp;&amp; slots.$key;
  <span class="hljs-keyword">if</span> (!slots) {
    res = {};
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slots._normalized) {
    <span class="hljs-keyword">return</span> slots._normalized;
  } <span class="hljs-keyword">else</span> {
    res = {};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> slots) {
      <span class="hljs-keyword">if</span> (slots[key] &amp;&amp; key[<span class="hljs-number">0</span>] !== <span class="hljs-string">"$"</span>) {
        res[key] = normalizeScopedSlot(normalSlots, key, slots[key]);
      }
    }
  }
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> normalSlots) {
    <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> res)) {
      res[key] = proxyNormalSlot(normalSlots, key);
    }
  }
  <span class="hljs-keyword">if</span> (slots &amp;&amp; <span class="hljs-built_in">Object</span>.isExtensible(slots)) {
    (slots: any)._normalized = res;
  }
  <span class="hljs-keyword">return</span> res;
}
</code></pre>
<p>首次加载的时候，由于父节点的 <code>scopedSlots</code> 是一个 <code>computed</code> 返回的对象，最后会将生成的 <code>res</code> 赋值给 <code>scopedSlots.__normalized</code>，而这个 <code>res</code> 也包含了 <code>vm.$slots</code> 部分，也就是原本通过 <code>computed</code> 传入的对象是不包含 <code>default</code> 插槽的，但是 <code>res</code> 是全部的内容，也就会包含 <code>default</code> 内容，渲染内容为 <code>default外的默认内容</code> 的节点，最后会被挂载到 <code>computed</code> 输出值的 <code>_normalized</code> 字段。</p>
<p>首次渲染自然是没有问题的，因为 <code>_normalized</code> 也是最新的。当第二次执行 <code>normalizeScopedSlots</code> 的时候，由于 <code>computed</code> 缓存，这个 <code>_normalized</code> 字段也被缓存下来了，由于存在 <code>_normalized</code>，会返回上一次生成的 <code>default</code> 数据，不会包含最新数据的 <code>vm.$slots</code> 的数据返回，在后续的 <code>renderSlot</code> 一直是获取老的数据。</p>
<p>通过测试将 <code>slots</code> 从 <code>computed</code> 变成 <code>methods</code>，问题就解决了，那这应该是算 <code>Vue</code> 的 <code>bug</code> 了，没有设想到传入的 <code>scopedSlots</code> 是一个缓存值。只是要使用的话如何好呢，有两个方法：</p>
<ol>
<li>彻底放弃在 <code>jsx</code> 组件里面嵌套插槽的写法，全部写在 <code>jsx</code> 的 <code>scopedSlots</code> 里面；这样每次更新插槽数据，都会重新触发 <code>computed</code> 从而更新 <code>jsx</code> 的 <code>scopedSlots</code>，只是这样一个插槽更新了，所有的插槽都要计算一次，效果还是稍微差了一点；</li>
<li>子组件为单文件组件，其采用 <code>renderSlot</code> 的渲染，那如果采用 <code>jsx</code> 指定插槽呢。比如 <code>this.$slots.default</code> 这样岂不是快哉，只是上面的还缺了点，还需要 <code>$scopedSlots</code>，所以应该是 <code>this.$scopedSlots.default ? this.$scopedSlots.default(props) : this.$slots.default</code></li>
</ol>
<h2>scopedSlots 与 slots 如何区分？</h2>
<p><code>scopedSlots</code> 与 <code>slots</code> 是两个不同的部分，正如字面意思，前者是作用域插槽，后者是插槽，但是呢，具体区分更多的是按照 2.6 版本来的，比如如下写法：</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">layout</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:name</span>&gt;</span> name <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span>
</code></pre>
<p>表面是是没有看到作用域的，但是采用了 2.6 的新写法，最后通过编译会输出 <code>scopedSlots</code> 到 <code>vnode</code>:</p>
<pre class="hljs"><code><span class="hljs-comment">// compile 阶段的生成AST树过程</span>
<span class="hljs-comment">// 省略部分代码</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processSlotContent</span>(<span class="hljs-params">el</span>) </span>{
  <span class="hljs-comment">// slot="xxx"</span>
  <span class="hljs-keyword">const</span> slotTarget = getBindingAttr(el, <span class="hljs-string">"slot"</span>);
  <span class="hljs-keyword">if</span> (slotTarget) {
    el.slotTarget = slotTarget === <span class="hljs-string">'""'</span> ? <span class="hljs-string">'"default"'</span> : slotTarget;
    el.slotTargetDynamic = !!(
      el.attrsMap[<span class="hljs-string">":slot"</span>] || el.attrsMap[<span class="hljs-string">"v-bind:slot"</span>]
    );
  }
  <span class="hljs-comment">// 2.6 v-slot syntax</span>
  <span class="hljs-keyword">if</span> (el.tag === <span class="hljs-string">"template"</span>) {
    <span class="hljs-comment">// v-slot on &lt;template&gt;</span>
    <span class="hljs-keyword">const</span> slotBinding = getAndRemoveAttrByRegex(el, slotRE);
    <span class="hljs-keyword">if</span> (slotBinding) {
      <span class="hljs-keyword">const</span> { name, dynamic } = getSlotName(slotBinding);
      el.slotTarget = name;
      el.slotTargetDynamic = dynamic;
      el.slotScope = slotBinding.value || emptySlotScopeToken; <span class="hljs-comment">// 新的slot有slotScope</span>
    }
  }
}
<span class="hljs-comment">// compile 阶段的 ast 过程</span>
<span class="hljs-comment">// 省略部分代码</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">closeElement</span>(<span class="hljs-params">element</span>) </span>{
  <span class="hljs-keyword">if</span> (currentParent &amp;&amp; !element.forbidden) {
    <span class="hljs-keyword">if</span> (element.elseif || element.else) {
      processIfConditions(element, currentParent);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (element.slotScope) {
        <span class="hljs-comment">// scoped slot</span>
        <span class="hljs-comment">// keep it in the children list so that v-else(-if) conditions can</span>
        <span class="hljs-comment">// find it as the prev node.</span>
        <span class="hljs-keyword">var</span> name = element.slotTarget || <span class="hljs-string">'"default"'</span>;
        (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[
          name
        ] = element;
      }
      currentParent.children.push(element);
      element.parent = currentParent;
    }
  }
}
<span class="hljs-comment">// compile 阶段的 codegen 过程</span>
<span class="hljs-comment">// 省略部分代码</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genData</span>(<span class="hljs-params">el, state</span>) </span>{
  <span class="hljs-keyword">if</span> (el.slotTarget &amp;&amp; !el.slotScope) {
    data += <span class="hljs-string">`slot:<span class="hljs-subst">${el.slotTarget}</span>,`</span>;
  }
  <span class="hljs-comment">// scoped slots</span>
  <span class="hljs-keyword">if</span> (el.scopedSlots) {
    data += <span class="hljs-string">`<span class="hljs-subst">${genScopedSlots(el, el.scopedSlots, state)}</span>,`</span>;
  }
}
</code></pre>
<p>可以看到 <code>processSlotContent</code> 里面上半部分是对 <code>slot=name</code> 判断，是对老的写法的处理，而下面部分则是对 2.6 版本的新写法 <code>template</code> 与 <code>v-slot</code> 组合的处理，新的部分最后输出包含了 <code>slotScope</code> 字段，而旧的版本没有。由于上面例子没有设置作用域，所以 <code>slotScope</code> 为 <code>emptySlotScopeToken</code> 也就是 <code>_empty_</code> 字符串。在随后的 <code>closeElement</code> 里面，若有 <code>slotScope</code>，则会将其设置到父节点的 <code>scopedSlots</code> 里面，形成一个插槽对象。</p>
<p>到这里都是生成 <code>AST</code> 的过程，后面 <code>codegen</code> 阶段，会根据新老写法的不同，生成 <code>slot</code> 与 <code>scopedSlots</code> 数据，其中 <code>genScopedSlots</code> 返回的是编译好的渲染函数，而 <code>slot</code> 则不同，插槽内容，以 <code>children</code> 的形式存在与父节点中，只是其属性有 <code>slot</code> 而已。</p>
<p>生成的 <code>scopedSlots</code> 数据会传入到 <code>vnode</code> 里面，最后传入上面提到的 <code>normalizeScopedSlots</code> 返回给实例的 <code>$scopedSlots</code>，而 <code>$slot</code> 则会根据前面传入的 <code>vnode</code> 的 <code>slot</code> 数据生成。</p>
<p>上面是父组件里面生成 <code>ChildContainer</code> 的插槽信息，包括生成 <code>scopedSlots</code> 数据这些，而最后在 <code>ChildContainer</code> 编译阶段，会根据 <code>slot</code> 标签名的不同生成对应的 <code>VNode</code>，方法如下：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderSlot</span>(<span class="hljs-params">name, fallback, props, bindObject</span>) </span>{
  <span class="hljs-keyword">const</span> scopedSlotFn = <span class="hljs-keyword">this</span>.$scopedSlots[name];
  <span class="hljs-keyword">let</span> nodes;
  <span class="hljs-keyword">if</span> (scopedSlotFn) {
    <span class="hljs-comment">// scoped slot</span>
    props = props || {};
    <span class="hljs-keyword">if</span> (bindObject) {
      props = extend(extend({}, bindObject), props);
    }
    nodes = scopedSlotFn(props) || fallback;
  } <span class="hljs-keyword">else</span> {
    nodes = <span class="hljs-keyword">this</span>.$slots[name] || fallback;
  }

  <span class="hljs-keyword">const</span> target = props &amp;&amp; props.slot;
  <span class="hljs-keyword">if</span> (target) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$createElement(<span class="hljs-string">"template"</span>, { <span class="hljs-attr">slot</span>: target }, nodes);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> nodes;
  }
}
</code></pre>
<p>可以看到有 <code>$scopedSlots</code> 就会直接输出，没有会出采用 <code>$slots</code> 的数据，<code>fallback</code> 则是默认的插槽内容。最后返回的是 <code>VNode</code> 数据，给到子组件。</p>
<p>最后在 <code>normalizeScopedSlots</code> 可以发现，<code>$slots</code> 的也是会传入 <code>$scopedSlots</code> 里面的，所以项目中直接用 <code>$scopedSlots</code> 就可以了，同时 <code>_parentVnode.data.scopedSlots</code> 数据也会传给 <code>$slots</code> 里面的，某种程度说，是 <code>$scopedSlots</code> 和 <code>$slots</code> 区别不大的。</p>
<h2>总结</h2>
<p>跟着问题学习源码，还是很快的，只是觉得，自己还在看 <code>Vue</code> 源码的，有点不太行，一直想要突破到别的领域的，看来遥遥无期。</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"March 24, 2021","title":"Vue 插槽的一个 bug","content":"\u003cp\u003e最近工作比较忙，有想写的博客，但是一直没有下笔，想来也是有点懒了，还是要拔拔草。正值金三银四的，面试别人也以 \u003ccode\u003eVue\u003c/code\u003e 源码居多，想要还是有必要学习一下插槽相关的内容。\n这次的 \u003ccode\u003ebug\u003c/code\u003e 私以为还是 \u003ccode\u003eVue\u003c/code\u003e 本身的问题，先看看一下代码：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// App.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003ecomponents\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eChildContainer\u003c/span\u003e: ChildContainer,\n  },\n  data() {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n      \u003cspan class=\"hljs-attr\"\u003eslotsData\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"ab\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"abc\"\u003c/span\u003e],\n        \u003cspan class=\"hljs-attr\"\u003edefault\u003c/span\u003e: [],\n      },\n    };\n  },\n  \u003cspan class=\"hljs-attr\"\u003ecomputed\u003c/span\u003e: {\n    slots() {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e scopedSlots = {};\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { slotsData } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n\n      scopedSlots.a = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprops\u003c/span\u003e) =\u0026gt;\u003c/span\u003e\n        slotsData.a.map(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eitem\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e {\u003cspan class=\"hljs-attr\"\u003e...props\u003c/span\u003e}\u0026gt;\u003c/span\u003e{item}\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e scopedSlots;\n    },\n  },\n  render() {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { slotsData } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n      \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"app\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003echild-container\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003escopedSlots\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{this.slots}\u003c/span\u003e\u0026gt;\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003edefault外的默认内容\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n          {slotsData.default.map((item) =\u0026gt; item)}\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003echild-container\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n    );\n  },\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// ChildContainer.vue\u003c/span\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"childContainer\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eslot\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eslot\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到上面的 \u003ccode\u003eApp.js\u003c/code\u003e 采用 \u003ccode\u003ejsx\u003c/code\u003e 的写法，由于 \u003ccode\u003eChildContainer.vue\u003c/code\u003e 只有一个默认的 \u003ccode\u003eslot\u003c/code\u003e，而 \u003ccode\u003eApp.js\u003c/code\u003e 则同时通过 \u003ccode\u003escopedSlots\u003c/code\u003e 和 \u003ccode\u003echildren\u003c/code\u003e 的方式传入了插槽内容。首先子组件里面没有使用到 \u003ccode\u003ea\u003c/code\u003e 插槽，所对应的内容不会渲染出去，最后会渲染出默认的内容为 \u003ccode\u003edefault外的默认内容\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e此时表现一切都是正常的，\u003ccode\u003ethis.slots\u003c/code\u003e 和 \u003ccode\u003eslotsData.default\u003c/code\u003e 各施其职，而且还充分利用了 \u003ccode\u003ecomputed\u003c/code\u003e 的缓存功能，避免重复的计算 \u003ccode\u003eslots\u003c/code\u003e。而当加载后，修改 \u003ccode\u003eslotsData.default\u003c/code\u003e 数据的发现，如 \u003ccode\u003ethis.slotsData.default.push('slotsData的deflaut内容')\u003c/code\u003e，可以看到页面没有任何变化，难道是设置的姿势不对？这是再简单不过的，查看 \u003ccode\u003eslotsData.default\u003c/code\u003e 数据也是对的，只是为什么不渲染出来呢？于是换成 \u003ccode\u003e$set\u003c/code\u003e 来设置，已经是最完整的了，只是还是没有用。渲染函数确实再次执行了，但是输出的内容还是 \u003ccode\u003edefault外的默认内容\u003c/code\u003e，问题出在哪里呢？\u003c/p\u003e\n\u003cp\u003e这个时候把 \u003ccode\u003edefault外的默认内容\u003c/code\u003e 这一行代码注释掉，发现再次设置 \u003ccode\u003eslotsData.default\u003c/code\u003e 的时候，数据生效了，同时页面有渲染 \u003ccode\u003eslotsData的deflaut内容\u003c/code\u003e，岂不是奇了怪了。之前通过 \u003ccode\u003eVue Dev Tool\u003c/code\u003e 还可以看到生成的 \u003ccode\u003ethis.slots\u003c/code\u003e 这个 \u003ccode\u003ecomputed\u003c/code\u003e 内容多了个 \u003ccode\u003e_normalized\u003c/code\u003e 字段，而且其下面还有个 \u003ccode\u003edefault\u003c/code\u003e 函数，当注释 \u003ccode\u003edefault外的默认内容\u003c/code\u003e 这一行的时候，这个 \u003ccode\u003e_normalized\u003c/code\u003e 也没有了，什么时候多了这个字段呢？看来只能看看 \u003ccode\u003eVue\u003c/code\u003e 的源码，之前看的时候一直避开 \u003ccode\u003eslot\u003c/code\u003e 部分的，完全是个黑盒。\u003c/p\u003e\n\u003cp\u003e组件输出的渲染函数的 \u003ccode\u003eslot\u003c/code\u003e 部分为 \u003ccode\u003e_vm._t(\u0026quot;default\u0026quot;)\u003c/code\u003e, 其中 \u003ccode\u003e_t\u003c/code\u003e 就是如下函数：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erenderSlot\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ename, props\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e scopedSlotFn = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$scopedSlots[name];\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e nodes;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (scopedSlotFn) {\n    \u003cspan class=\"hljs-comment\"\u003e// scoped slot\u003c/span\u003e\n    props = props || {};\n    nodes = scopedSlotFn(props);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    nodes = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$slots[name];\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e target = props \u0026amp;\u0026amp; props.slot;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (target) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$createElement(\u003cspan class=\"hljs-string\"\u003e\"template\"\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003eslot\u003c/span\u003e: target }, nodes);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e nodes;\n  }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// _render 函数里面\u003c/span\u003e\nvm.$scopedSlots = normalizeScopedSlots(\n  _parentVnode.data.scopedSlots,\n  vm.$slots,\n  vm.$scopedSlots\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到 \u003ccode\u003erenderSlot\u003c/code\u003e 的最终输出取决于 \u003ccode\u003evm.$scopedSlots\u003c/code\u003e，没有的话再是 \u003ccode\u003evm.$slots\u003c/code\u003e，而 \u003ccode\u003e$scopedSlots\u003c/code\u003e 的生成取决于\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e_parentVnode.data.scopedSlots\u003c/code\u003e 节点 \u003ccode\u003evnode\u003c/code\u003e 数据的 \u003ccode\u003escopedSlots\u003c/code\u003e 字段，也就是上文业务中的 \u003ccode\u003ethis.slots\u003c/code\u003e；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evm.$slots\u003c/code\u003e 实例自身的生成的 \u003ccode\u003e$slots\u003c/code\u003e，一般是通过 \u003ccode\u003eresolveSlots\u003c/code\u003e 解析标签来匹配获得实例的 \u003ccode\u003eslots\u003c/code\u003e 节点;\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evm.$scopedSlots\u003c/code\u003e 前一个 \u003ccode\u003e$scopedSlots\u003c/code\u003e；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在上面例子中，当更新 \u003ccode\u003edefault\u003c/code\u003e 的数据的时候，\u003ccode\u003e_parentVnode.data.scopedSlots\u003c/code\u003e 和 \u003ccode\u003edefault\u003c/code\u003e 数据没有关系所以不会更新，而 \u003ccode\u003evm.$slots\u003c/code\u003e 则是包含了更新了的 \u003ccode\u003edefault\u003c/code\u003e 插槽的数据，也就是包含了 \u003ccode\u003edefault外的默认内容\u003c/code\u003e 以及 \u003ccode\u003eslotsData的deflaut内容\u003c/code\u003e 两个节点，只是在 debug 过程中发现最后生成的 \u003ccode\u003evm.$scopedSlots\u003c/code\u003e 有大大的问题。\u003c/p\u003e\n\u003cp\u003e先看看 \u003ccode\u003enormalizeScopedSlots\u003c/code\u003e 方法\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003enormalizeScopedSlots\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eslots, normalSlots, prevSlots\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e res;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hasNormalSlots = \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.keys(normalSlots).length \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isStable = slots ? !!slots.$stable : !hasNormalSlots;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e key = slots \u0026amp;\u0026amp; slots.$key;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!slots) {\n    res = {};\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (slots._normalized) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e slots._normalized;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    res = {};\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e key \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e slots) {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (slots[key] \u0026amp;\u0026amp; key[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] !== \u003cspan class=\"hljs-string\"\u003e\"$\"\u003c/span\u003e) {\n        res[key] = normalizeScopedSlot(normalSlots, key, slots[key]);\n      }\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e key \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e normalSlots) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!(key \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e res)) {\n      res[key] = proxyNormalSlot(normalSlots, key);\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (slots \u0026amp;\u0026amp; \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.isExtensible(slots)) {\n    (slots: any)._normalized = res;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e首次加载的时候，由于父节点的 \u003ccode\u003escopedSlots\u003c/code\u003e 是一个 \u003ccode\u003ecomputed\u003c/code\u003e 返回的对象，最后会将生成的 \u003ccode\u003eres\u003c/code\u003e 赋值给 \u003ccode\u003escopedSlots.__normalized\u003c/code\u003e，而这个 \u003ccode\u003eres\u003c/code\u003e 也包含了 \u003ccode\u003evm.$slots\u003c/code\u003e 部分，也就是原本通过 \u003ccode\u003ecomputed\u003c/code\u003e 传入的对象是不包含 \u003ccode\u003edefault\u003c/code\u003e 插槽的，但是 \u003ccode\u003eres\u003c/code\u003e 是全部的内容，也就会包含 \u003ccode\u003edefault\u003c/code\u003e 内容，渲染内容为 \u003ccode\u003edefault外的默认内容\u003c/code\u003e 的节点，最后会被挂载到 \u003ccode\u003ecomputed\u003c/code\u003e 输出值的 \u003ccode\u003e_normalized\u003c/code\u003e 字段。\u003c/p\u003e\n\u003cp\u003e首次渲染自然是没有问题的，因为 \u003ccode\u003e_normalized\u003c/code\u003e 也是最新的。当第二次执行 \u003ccode\u003enormalizeScopedSlots\u003c/code\u003e 的时候，由于 \u003ccode\u003ecomputed\u003c/code\u003e 缓存，这个 \u003ccode\u003e_normalized\u003c/code\u003e 字段也被缓存下来了，由于存在 \u003ccode\u003e_normalized\u003c/code\u003e，会返回上一次生成的 \u003ccode\u003edefault\u003c/code\u003e 数据，不会包含最新数据的 \u003ccode\u003evm.$slots\u003c/code\u003e 的数据返回，在后续的 \u003ccode\u003erenderSlot\u003c/code\u003e 一直是获取老的数据。\u003c/p\u003e\n\u003cp\u003e通过测试将 \u003ccode\u003eslots\u003c/code\u003e 从 \u003ccode\u003ecomputed\u003c/code\u003e 变成 \u003ccode\u003emethods\u003c/code\u003e，问题就解决了，那这应该是算 \u003ccode\u003eVue\u003c/code\u003e 的 \u003ccode\u003ebug\u003c/code\u003e 了，没有设想到传入的 \u003ccode\u003escopedSlots\u003c/code\u003e 是一个缓存值。只是要使用的话如何好呢，有两个方法：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e彻底放弃在 \u003ccode\u003ejsx\u003c/code\u003e 组件里面嵌套插槽的写法，全部写在 \u003ccode\u003ejsx\u003c/code\u003e 的 \u003ccode\u003escopedSlots\u003c/code\u003e 里面；这样每次更新插槽数据，都会重新触发 \u003ccode\u003ecomputed\u003c/code\u003e 从而更新 \u003ccode\u003ejsx\u003c/code\u003e 的 \u003ccode\u003escopedSlots\u003c/code\u003e，只是这样一个插槽更新了，所有的插槽都要计算一次，效果还是稍微差了一点；\u003c/li\u003e\n\u003cli\u003e子组件为单文件组件，其采用 \u003ccode\u003erenderSlot\u003c/code\u003e 的渲染，那如果采用 \u003ccode\u003ejsx\u003c/code\u003e 指定插槽呢。比如 \u003ccode\u003ethis.$slots.default\u003c/code\u003e 这样岂不是快哉，只是上面的还缺了点，还需要 \u003ccode\u003e$scopedSlots\u003c/code\u003e，所以应该是 \u003ccode\u003ethis.$scopedSlots.default ? this.$scopedSlots.default(props) : this.$slots.default\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003escopedSlots 与 slots 如何区分？\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003escopedSlots\u003c/code\u003e 与 \u003ccode\u003eslots\u003c/code\u003e 是两个不同的部分，正如字面意思，前者是作用域插槽，后者是插槽，但是呢，具体区分更多的是按照 2.6 版本来的，比如如下写法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003elayout\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ev-slot:name\u003c/span\u003e\u0026gt;\u003c/span\u003e name \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003elayout\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e表面是是没有看到作用域的，但是采用了 2.6 的新写法，最后通过编译会输出 \u003ccode\u003escopedSlots\u003c/code\u003e 到 \u003ccode\u003evnode\u003c/code\u003e:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// compile 阶段的生成AST树过程\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eprocessSlotContent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eel\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// slot=\"xxx\"\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e slotTarget = getBindingAttr(el, \u003cspan class=\"hljs-string\"\u003e\"slot\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (slotTarget) {\n    el.slotTarget = slotTarget === \u003cspan class=\"hljs-string\"\u003e'\"\"'\u003c/span\u003e ? \u003cspan class=\"hljs-string\"\u003e'\"default\"'\u003c/span\u003e : slotTarget;\n    el.slotTargetDynamic = !!(\n      el.attrsMap[\u003cspan class=\"hljs-string\"\u003e\":slot\"\u003c/span\u003e] || el.attrsMap[\u003cspan class=\"hljs-string\"\u003e\"v-bind:slot\"\u003c/span\u003e]\n    );\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 2.6 v-slot syntax\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (el.tag === \u003cspan class=\"hljs-string\"\u003e\"template\"\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// v-slot on \u0026lt;template\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (slotBinding) {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { name, dynamic } = getSlotName(slotBinding);\n      el.slotTarget = name;\n      el.slotTargetDynamic = dynamic;\n      el.slotScope = slotBinding.value || emptySlotScopeToken; \u003cspan class=\"hljs-comment\"\u003e// 新的slot有slotScope\u003c/span\u003e\n    }\n  }\n}\n\u003cspan class=\"hljs-comment\"\u003e// compile 阶段的 ast 过程\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecloseElement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eelement\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (currentParent \u0026amp;\u0026amp; !element.forbidden) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (element.elseif || element.else) {\n      processIfConditions(element, currentParent);\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (element.slotScope) {\n        \u003cspan class=\"hljs-comment\"\u003e// scoped slot\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// keep it in the children list so that v-else(-if) conditions can\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// find it as the prev node.\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e name = element.slotTarget || \u003cspan class=\"hljs-string\"\u003e'\"default\"'\u003c/span\u003e;\n        (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[\n          name\n        ] = element;\n      }\n      currentParent.children.push(element);\n      element.parent = currentParent;\n    }\n  }\n}\n\u003cspan class=\"hljs-comment\"\u003e// compile 阶段的 codegen 过程\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003egenData\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eel, state\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (el.slotTarget \u0026amp;\u0026amp; !el.slotScope) {\n    data += \u003cspan class=\"hljs-string\"\u003e`slot:\u003cspan class=\"hljs-subst\"\u003e${el.slotTarget}\u003c/span\u003e,`\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// scoped slots\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (el.scopedSlots) {\n    data += \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${genScopedSlots(el, el.scopedSlots, state)}\u003c/span\u003e,`\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到 \u003ccode\u003eprocessSlotContent\u003c/code\u003e 里面上半部分是对 \u003ccode\u003eslot=name\u003c/code\u003e 判断，是对老的写法的处理，而下面部分则是对 2.6 版本的新写法 \u003ccode\u003etemplate\u003c/code\u003e 与 \u003ccode\u003ev-slot\u003c/code\u003e 组合的处理，新的部分最后输出包含了 \u003ccode\u003eslotScope\u003c/code\u003e 字段，而旧的版本没有。由于上面例子没有设置作用域，所以 \u003ccode\u003eslotScope\u003c/code\u003e 为 \u003ccode\u003eemptySlotScopeToken\u003c/code\u003e 也就是 \u003ccode\u003e_empty_\u003c/code\u003e 字符串。在随后的 \u003ccode\u003ecloseElement\u003c/code\u003e 里面，若有 \u003ccode\u003eslotScope\u003c/code\u003e，则会将其设置到父节点的 \u003ccode\u003escopedSlots\u003c/code\u003e 里面，形成一个插槽对象。\u003c/p\u003e\n\u003cp\u003e到这里都是生成 \u003ccode\u003eAST\u003c/code\u003e 的过程，后面 \u003ccode\u003ecodegen\u003c/code\u003e 阶段，会根据新老写法的不同，生成 \u003ccode\u003eslot\u003c/code\u003e 与 \u003ccode\u003escopedSlots\u003c/code\u003e 数据，其中 \u003ccode\u003egenScopedSlots\u003c/code\u003e 返回的是编译好的渲染函数，而 \u003ccode\u003eslot\u003c/code\u003e 则不同，插槽内容，以 \u003ccode\u003echildren\u003c/code\u003e 的形式存在与父节点中，只是其属性有 \u003ccode\u003eslot\u003c/code\u003e 而已。\u003c/p\u003e\n\u003cp\u003e生成的 \u003ccode\u003escopedSlots\u003c/code\u003e 数据会传入到 \u003ccode\u003evnode\u003c/code\u003e 里面，最后传入上面提到的 \u003ccode\u003enormalizeScopedSlots\u003c/code\u003e 返回给实例的 \u003ccode\u003e$scopedSlots\u003c/code\u003e，而 \u003ccode\u003e$slot\u003c/code\u003e 则会根据前面传入的 \u003ccode\u003evnode\u003c/code\u003e 的 \u003ccode\u003eslot\u003c/code\u003e 数据生成。\u003c/p\u003e\n\u003cp\u003e上面是父组件里面生成 \u003ccode\u003eChildContainer\u003c/code\u003e 的插槽信息，包括生成 \u003ccode\u003escopedSlots\u003c/code\u003e 数据这些，而最后在 \u003ccode\u003eChildContainer\u003c/code\u003e 编译阶段，会根据 \u003ccode\u003eslot\u003c/code\u003e 标签名的不同生成对应的 \u003ccode\u003eVNode\u003c/code\u003e，方法如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erenderSlot\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ename, fallback, props, bindObject\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e scopedSlotFn = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$scopedSlots[name];\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e nodes;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (scopedSlotFn) {\n    \u003cspan class=\"hljs-comment\"\u003e// scoped slot\u003c/span\u003e\n    props = props || {};\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (bindObject) {\n      props = extend(extend({}, bindObject), props);\n    }\n    nodes = scopedSlotFn(props) || fallback;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    nodes = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$slots[name] || fallback;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e target = props \u0026amp;\u0026amp; props.slot;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (target) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$createElement(\u003cspan class=\"hljs-string\"\u003e\"template\"\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003eslot\u003c/span\u003e: target }, nodes);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e nodes;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到有 \u003ccode\u003e$scopedSlots\u003c/code\u003e 就会直接输出，没有会出采用 \u003ccode\u003e$slots\u003c/code\u003e 的数据，\u003ccode\u003efallback\u003c/code\u003e 则是默认的插槽内容。最后返回的是 \u003ccode\u003eVNode\u003c/code\u003e 数据，给到子组件。\u003c/p\u003e\n\u003cp\u003e最后在 \u003ccode\u003enormalizeScopedSlots\u003c/code\u003e 可以发现，\u003ccode\u003e$slots\u003c/code\u003e 的也是会传入 \u003ccode\u003e$scopedSlots\u003c/code\u003e 里面的，所以项目中直接用 \u003ccode\u003e$scopedSlots\u003c/code\u003e 就可以了，同时 \u003ccode\u003e_parentVnode.data.scopedSlots\u003c/code\u003e 数据也会传给 \u003ccode\u003e$slots\u003c/code\u003e 里面的，某种程度说，是 \u003ccode\u003e$scopedSlots\u003c/code\u003e 和 \u003ccode\u003e$slots\u003c/code\u003e 区别不大的。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e跟着问题学习源码，还是很快的，只是觉得，自己还在看 \u003ccode\u003eVue\u003c/code\u003e 源码的，有点不太行，一直想要突破到别的领域的，看来遥遥无期。\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"March 24, 2021","title":"Vue 插槽的一个 bug","content":"\u003cp\u003e最近工作比较忙，有想写的博客，但是一直没有下笔，想来也是有点懒了，还是要拔拔草。正值金三银四的，面试别人也以 \u003ccode\u003eVue\u003c/code\u003e 源码居多，想要还是有必要学习一下插槽相关的内容。\n这次的 \u003ccode\u003ebug\u003c/code\u003e 私以为还是 \u003ccode\u003eVue\u003c/code\u003e 本身的问题，先看看一下代码：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// App.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003ecomponents\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eChildContainer\u003c/span\u003e: ChildContainer,\n  },\n  data() {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n      \u003cspan class=\"hljs-attr\"\u003eslotsData\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"ab\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"abc\"\u003c/span\u003e],\n        \u003cspan class=\"hljs-attr\"\u003edefault\u003c/span\u003e: [],\n      },\n    };\n  },\n  \u003cspan class=\"hljs-attr\"\u003ecomputed\u003c/span\u003e: {\n    slots() {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e scopedSlots = {};\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { slotsData } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n\n      scopedSlots.a = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprops\u003c/span\u003e) =\u0026gt;\u003c/span\u003e\n        slotsData.a.map(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eitem\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e {\u003cspan class=\"hljs-attr\"\u003e...props\u003c/span\u003e}\u0026gt;\u003c/span\u003e{item}\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e scopedSlots;\n    },\n  },\n  render() {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { slotsData } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n      \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"app\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003echild-container\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003escopedSlots\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{this.slots}\u003c/span\u003e\u0026gt;\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003edefault外的默认内容\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n          {slotsData.default.map((item) =\u0026gt; item)}\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003echild-container\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n    );\n  },\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// ChildContainer.vue\u003c/span\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"childContainer\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eslot\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eslot\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到上面的 \u003ccode\u003eApp.js\u003c/code\u003e 采用 \u003ccode\u003ejsx\u003c/code\u003e 的写法，由于 \u003ccode\u003eChildContainer.vue\u003c/code\u003e 只有一个默认的 \u003ccode\u003eslot\u003c/code\u003e，而 \u003ccode\u003eApp.js\u003c/code\u003e 则同时通过 \u003ccode\u003escopedSlots\u003c/code\u003e 和 \u003ccode\u003echildren\u003c/code\u003e 的方式传入了插槽内容。首先子组件里面没有使用到 \u003ccode\u003ea\u003c/code\u003e 插槽，所对应的内容不会渲染出去，最后会渲染出默认的内容为 \u003ccode\u003edefault外的默认内容\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e此时表现一切都是正常的，\u003ccode\u003ethis.slots\u003c/code\u003e 和 \u003ccode\u003eslotsData.default\u003c/code\u003e 各施其职，而且还充分利用了 \u003ccode\u003ecomputed\u003c/code\u003e 的缓存功能，避免重复的计算 \u003ccode\u003eslots\u003c/code\u003e。而当加载后，修改 \u003ccode\u003eslotsData.default\u003c/code\u003e 数据的发现，如 \u003ccode\u003ethis.slotsData.default.push('slotsData的deflaut内容')\u003c/code\u003e，可以看到页面没有任何变化，难道是设置的姿势不对？这是再简单不过的，查看 \u003ccode\u003eslotsData.default\u003c/code\u003e 数据也是对的，只是为什么不渲染出来呢？于是换成 \u003ccode\u003e$set\u003c/code\u003e 来设置，已经是最完整的了，只是还是没有用。渲染函数确实再次执行了，但是输出的内容还是 \u003ccode\u003edefault外的默认内容\u003c/code\u003e，问题出在哪里呢？\u003c/p\u003e\n\u003cp\u003e这个时候把 \u003ccode\u003edefault外的默认内容\u003c/code\u003e 这一行代码注释掉，发现再次设置 \u003ccode\u003eslotsData.default\u003c/code\u003e 的时候，数据生效了，同时页面有渲染 \u003ccode\u003eslotsData的deflaut内容\u003c/code\u003e，岂不是奇了怪了。之前通过 \u003ccode\u003eVue Dev Tool\u003c/code\u003e 还可以看到生成的 \u003ccode\u003ethis.slots\u003c/code\u003e 这个 \u003ccode\u003ecomputed\u003c/code\u003e 内容多了个 \u003ccode\u003e_normalized\u003c/code\u003e 字段，而且其下面还有个 \u003ccode\u003edefault\u003c/code\u003e 函数，当注释 \u003ccode\u003edefault外的默认内容\u003c/code\u003e 这一行的时候，这个 \u003ccode\u003e_normalized\u003c/code\u003e 也没有了，什么时候多了这个字段呢？看来只能看看 \u003ccode\u003eVue\u003c/code\u003e 的源码，之前看的时候一直避开 \u003ccode\u003eslot\u003c/code\u003e 部分的，完全是个黑盒。\u003c/p\u003e\n\u003cp\u003e组件输出的渲染函数的 \u003ccode\u003eslot\u003c/code\u003e 部分为 \u003ccode\u003e_vm._t(\u0026quot;default\u0026quot;)\u003c/code\u003e, 其中 \u003ccode\u003e_t\u003c/code\u003e 就是如下函数：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erenderSlot\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ename, props\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e scopedSlotFn = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$scopedSlots[name];\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e nodes;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (scopedSlotFn) {\n    \u003cspan class=\"hljs-comment\"\u003e// scoped slot\u003c/span\u003e\n    props = props || {};\n    nodes = scopedSlotFn(props);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    nodes = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$slots[name];\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e target = props \u0026amp;\u0026amp; props.slot;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (target) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$createElement(\u003cspan class=\"hljs-string\"\u003e\"template\"\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003eslot\u003c/span\u003e: target }, nodes);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e nodes;\n  }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// _render 函数里面\u003c/span\u003e\nvm.$scopedSlots = normalizeScopedSlots(\n  _parentVnode.data.scopedSlots,\n  vm.$slots,\n  vm.$scopedSlots\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到 \u003ccode\u003erenderSlot\u003c/code\u003e 的最终输出取决于 \u003ccode\u003evm.$scopedSlots\u003c/code\u003e，没有的话再是 \u003ccode\u003evm.$slots\u003c/code\u003e，而 \u003ccode\u003e$scopedSlots\u003c/code\u003e 的生成取决于\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e_parentVnode.data.scopedSlots\u003c/code\u003e 节点 \u003ccode\u003evnode\u003c/code\u003e 数据的 \u003ccode\u003escopedSlots\u003c/code\u003e 字段，也就是上文业务中的 \u003ccode\u003ethis.slots\u003c/code\u003e；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evm.$slots\u003c/code\u003e 实例自身的生成的 \u003ccode\u003e$slots\u003c/code\u003e，一般是通过 \u003ccode\u003eresolveSlots\u003c/code\u003e 解析标签来匹配获得实例的 \u003ccode\u003eslots\u003c/code\u003e 节点;\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evm.$scopedSlots\u003c/code\u003e 前一个 \u003ccode\u003e$scopedSlots\u003c/code\u003e；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在上面例子中，当更新 \u003ccode\u003edefault\u003c/code\u003e 的数据的时候，\u003ccode\u003e_parentVnode.data.scopedSlots\u003c/code\u003e 和 \u003ccode\u003edefault\u003c/code\u003e 数据没有关系所以不会更新，而 \u003ccode\u003evm.$slots\u003c/code\u003e 则是包含了更新了的 \u003ccode\u003edefault\u003c/code\u003e 插槽的数据，也就是包含了 \u003ccode\u003edefault外的默认内容\u003c/code\u003e 以及 \u003ccode\u003eslotsData的deflaut内容\u003c/code\u003e 两个节点，只是在 debug 过程中发现最后生成的 \u003ccode\u003evm.$scopedSlots\u003c/code\u003e 有大大的问题。\u003c/p\u003e\n\u003cp\u003e先看看 \u003ccode\u003enormalizeScopedSlots\u003c/code\u003e 方法\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003enormalizeScopedSlots\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eslots, normalSlots, prevSlots\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e res;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hasNormalSlots = \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.keys(normalSlots).length \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isStable = slots ? !!slots.$stable : !hasNormalSlots;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e key = slots \u0026amp;\u0026amp; slots.$key;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!slots) {\n    res = {};\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (slots._normalized) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e slots._normalized;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    res = {};\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e key \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e slots) {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (slots[key] \u0026amp;\u0026amp; key[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] !== \u003cspan class=\"hljs-string\"\u003e\"$\"\u003c/span\u003e) {\n        res[key] = normalizeScopedSlot(normalSlots, key, slots[key]);\n      }\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e key \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e normalSlots) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!(key \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e res)) {\n      res[key] = proxyNormalSlot(normalSlots, key);\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (slots \u0026amp;\u0026amp; \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.isExtensible(slots)) {\n    (slots: any)._normalized = res;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e首次加载的时候，由于父节点的 \u003ccode\u003escopedSlots\u003c/code\u003e 是一个 \u003ccode\u003ecomputed\u003c/code\u003e 返回的对象，最后会将生成的 \u003ccode\u003eres\u003c/code\u003e 赋值给 \u003ccode\u003escopedSlots.__normalized\u003c/code\u003e，而这个 \u003ccode\u003eres\u003c/code\u003e 也包含了 \u003ccode\u003evm.$slots\u003c/code\u003e 部分，也就是原本通过 \u003ccode\u003ecomputed\u003c/code\u003e 传入的对象是不包含 \u003ccode\u003edefault\u003c/code\u003e 插槽的，但是 \u003ccode\u003eres\u003c/code\u003e 是全部的内容，也就会包含 \u003ccode\u003edefault\u003c/code\u003e 内容，渲染内容为 \u003ccode\u003edefault外的默认内容\u003c/code\u003e 的节点，最后会被挂载到 \u003ccode\u003ecomputed\u003c/code\u003e 输出值的 \u003ccode\u003e_normalized\u003c/code\u003e 字段。\u003c/p\u003e\n\u003cp\u003e首次渲染自然是没有问题的，因为 \u003ccode\u003e_normalized\u003c/code\u003e 也是最新的。当第二次执行 \u003ccode\u003enormalizeScopedSlots\u003c/code\u003e 的时候，由于 \u003ccode\u003ecomputed\u003c/code\u003e 缓存，这个 \u003ccode\u003e_normalized\u003c/code\u003e 字段也被缓存下来了，由于存在 \u003ccode\u003e_normalized\u003c/code\u003e，会返回上一次生成的 \u003ccode\u003edefault\u003c/code\u003e 数据，不会包含最新数据的 \u003ccode\u003evm.$slots\u003c/code\u003e 的数据返回，在后续的 \u003ccode\u003erenderSlot\u003c/code\u003e 一直是获取老的数据。\u003c/p\u003e\n\u003cp\u003e通过测试将 \u003ccode\u003eslots\u003c/code\u003e 从 \u003ccode\u003ecomputed\u003c/code\u003e 变成 \u003ccode\u003emethods\u003c/code\u003e，问题就解决了，那这应该是算 \u003ccode\u003eVue\u003c/code\u003e 的 \u003ccode\u003ebug\u003c/code\u003e 了，没有设想到传入的 \u003ccode\u003escopedSlots\u003c/code\u003e 是一个缓存值。只是要使用的话如何好呢，有两个方法：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e彻底放弃在 \u003ccode\u003ejsx\u003c/code\u003e 组件里面嵌套插槽的写法，全部写在 \u003ccode\u003ejsx\u003c/code\u003e 的 \u003ccode\u003escopedSlots\u003c/code\u003e 里面；这样每次更新插槽数据，都会重新触发 \u003ccode\u003ecomputed\u003c/code\u003e 从而更新 \u003ccode\u003ejsx\u003c/code\u003e 的 \u003ccode\u003escopedSlots\u003c/code\u003e，只是这样一个插槽更新了，所有的插槽都要计算一次，效果还是稍微差了一点；\u003c/li\u003e\n\u003cli\u003e子组件为单文件组件，其采用 \u003ccode\u003erenderSlot\u003c/code\u003e 的渲染，那如果采用 \u003ccode\u003ejsx\u003c/code\u003e 指定插槽呢。比如 \u003ccode\u003ethis.$slots.default\u003c/code\u003e 这样岂不是快哉，只是上面的还缺了点，还需要 \u003ccode\u003e$scopedSlots\u003c/code\u003e，所以应该是 \u003ccode\u003ethis.$scopedSlots.default ? this.$scopedSlots.default(props) : this.$slots.default\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003escopedSlots 与 slots 如何区分？\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003escopedSlots\u003c/code\u003e 与 \u003ccode\u003eslots\u003c/code\u003e 是两个不同的部分，正如字面意思，前者是作用域插槽，后者是插槽，但是呢，具体区分更多的是按照 2.6 版本来的，比如如下写法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003elayout\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ev-slot:name\u003c/span\u003e\u0026gt;\u003c/span\u003e name \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003elayout\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e表面是是没有看到作用域的，但是采用了 2.6 的新写法，最后通过编译会输出 \u003ccode\u003escopedSlots\u003c/code\u003e 到 \u003ccode\u003evnode\u003c/code\u003e:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// compile 阶段的生成AST树过程\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eprocessSlotContent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eel\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// slot=\"xxx\"\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e slotTarget = getBindingAttr(el, \u003cspan class=\"hljs-string\"\u003e\"slot\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (slotTarget) {\n    el.slotTarget = slotTarget === \u003cspan class=\"hljs-string\"\u003e'\"\"'\u003c/span\u003e ? \u003cspan class=\"hljs-string\"\u003e'\"default\"'\u003c/span\u003e : slotTarget;\n    el.slotTargetDynamic = !!(\n      el.attrsMap[\u003cspan class=\"hljs-string\"\u003e\":slot\"\u003c/span\u003e] || el.attrsMap[\u003cspan class=\"hljs-string\"\u003e\"v-bind:slot\"\u003c/span\u003e]\n    );\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 2.6 v-slot syntax\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (el.tag === \u003cspan class=\"hljs-string\"\u003e\"template\"\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// v-slot on \u0026lt;template\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (slotBinding) {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { name, dynamic } = getSlotName(slotBinding);\n      el.slotTarget = name;\n      el.slotTargetDynamic = dynamic;\n      el.slotScope = slotBinding.value || emptySlotScopeToken; \u003cspan class=\"hljs-comment\"\u003e// 新的slot有slotScope\u003c/span\u003e\n    }\n  }\n}\n\u003cspan class=\"hljs-comment\"\u003e// compile 阶段的 ast 过程\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecloseElement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eelement\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (currentParent \u0026amp;\u0026amp; !element.forbidden) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (element.elseif || element.else) {\n      processIfConditions(element, currentParent);\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (element.slotScope) {\n        \u003cspan class=\"hljs-comment\"\u003e// scoped slot\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// keep it in the children list so that v-else(-if) conditions can\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// find it as the prev node.\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e name = element.slotTarget || \u003cspan class=\"hljs-string\"\u003e'\"default\"'\u003c/span\u003e;\n        (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[\n          name\n        ] = element;\n      }\n      currentParent.children.push(element);\n      element.parent = currentParent;\n    }\n  }\n}\n\u003cspan class=\"hljs-comment\"\u003e// compile 阶段的 codegen 过程\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003egenData\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eel, state\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (el.slotTarget \u0026amp;\u0026amp; !el.slotScope) {\n    data += \u003cspan class=\"hljs-string\"\u003e`slot:\u003cspan class=\"hljs-subst\"\u003e${el.slotTarget}\u003c/span\u003e,`\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// scoped slots\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (el.scopedSlots) {\n    data += \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${genScopedSlots(el, el.scopedSlots, state)}\u003c/span\u003e,`\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到 \u003ccode\u003eprocessSlotContent\u003c/code\u003e 里面上半部分是对 \u003ccode\u003eslot=name\u003c/code\u003e 判断，是对老的写法的处理，而下面部分则是对 2.6 版本的新写法 \u003ccode\u003etemplate\u003c/code\u003e 与 \u003ccode\u003ev-slot\u003c/code\u003e 组合的处理，新的部分最后输出包含了 \u003ccode\u003eslotScope\u003c/code\u003e 字段，而旧的版本没有。由于上面例子没有设置作用域，所以 \u003ccode\u003eslotScope\u003c/code\u003e 为 \u003ccode\u003eemptySlotScopeToken\u003c/code\u003e 也就是 \u003ccode\u003e_empty_\u003c/code\u003e 字符串。在随后的 \u003ccode\u003ecloseElement\u003c/code\u003e 里面，若有 \u003ccode\u003eslotScope\u003c/code\u003e，则会将其设置到父节点的 \u003ccode\u003escopedSlots\u003c/code\u003e 里面，形成一个插槽对象。\u003c/p\u003e\n\u003cp\u003e到这里都是生成 \u003ccode\u003eAST\u003c/code\u003e 的过程，后面 \u003ccode\u003ecodegen\u003c/code\u003e 阶段，会根据新老写法的不同，生成 \u003ccode\u003eslot\u003c/code\u003e 与 \u003ccode\u003escopedSlots\u003c/code\u003e 数据，其中 \u003ccode\u003egenScopedSlots\u003c/code\u003e 返回的是编译好的渲染函数，而 \u003ccode\u003eslot\u003c/code\u003e 则不同，插槽内容，以 \u003ccode\u003echildren\u003c/code\u003e 的形式存在与父节点中，只是其属性有 \u003ccode\u003eslot\u003c/code\u003e 而已。\u003c/p\u003e\n\u003cp\u003e生成的 \u003ccode\u003escopedSlots\u003c/code\u003e 数据会传入到 \u003ccode\u003evnode\u003c/code\u003e 里面，最后传入上面提到的 \u003ccode\u003enormalizeScopedSlots\u003c/code\u003e 返回给实例的 \u003ccode\u003e$scopedSlots\u003c/code\u003e，而 \u003ccode\u003e$slot\u003c/code\u003e 则会根据前面传入的 \u003ccode\u003evnode\u003c/code\u003e 的 \u003ccode\u003eslot\u003c/code\u003e 数据生成。\u003c/p\u003e\n\u003cp\u003e上面是父组件里面生成 \u003ccode\u003eChildContainer\u003c/code\u003e 的插槽信息，包括生成 \u003ccode\u003escopedSlots\u003c/code\u003e 数据这些，而最后在 \u003ccode\u003eChildContainer\u003c/code\u003e 编译阶段，会根据 \u003ccode\u003eslot\u003c/code\u003e 标签名的不同生成对应的 \u003ccode\u003eVNode\u003c/code\u003e，方法如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erenderSlot\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ename, fallback, props, bindObject\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e scopedSlotFn = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$scopedSlots[name];\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e nodes;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (scopedSlotFn) {\n    \u003cspan class=\"hljs-comment\"\u003e// scoped slot\u003c/span\u003e\n    props = props || {};\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (bindObject) {\n      props = extend(extend({}, bindObject), props);\n    }\n    nodes = scopedSlotFn(props) || fallback;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    nodes = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$slots[name] || fallback;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e target = props \u0026amp;\u0026amp; props.slot;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (target) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$createElement(\u003cspan class=\"hljs-string\"\u003e\"template\"\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003eslot\u003c/span\u003e: target }, nodes);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e nodes;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到有 \u003ccode\u003e$scopedSlots\u003c/code\u003e 就会直接输出，没有会出采用 \u003ccode\u003e$slots\u003c/code\u003e 的数据，\u003ccode\u003efallback\u003c/code\u003e 则是默认的插槽内容。最后返回的是 \u003ccode\u003eVNode\u003c/code\u003e 数据，给到子组件。\u003c/p\u003e\n\u003cp\u003e最后在 \u003ccode\u003enormalizeScopedSlots\u003c/code\u003e 可以发现，\u003ccode\u003e$slots\u003c/code\u003e 的也是会传入 \u003ccode\u003e$scopedSlots\u003c/code\u003e 里面的，所以项目中直接用 \u003ccode\u003e$scopedSlots\u003c/code\u003e 就可以了，同时 \u003ccode\u003e_parentVnode.data.scopedSlots\u003c/code\u003e 数据也会传给 \u003ccode\u003e$slots\u003c/code\u003e 里面的，某种程度说，是 \u003ccode\u003e$scopedSlots\u003c/code\u003e 和 \u003ccode\u003e$slots\u003c/code\u003e 区别不大的。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e跟着问题学习源码，还是很快的，只是觉得，自己还在看 \u003ccode\u003eVue\u003c/code\u003e 源码的，有点不太行，一直想要突破到别的领域的，看来遥遥无期。\u003c/p\u003e\n"}},"buildId":"r4Ww0YLm8YL5~6SwciWHH","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" async=""></script></body></html>