<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">webpack-dev-middleware主要源码理解</title><link rel="preload" href="/blog-sys/_next/static/sIsd3fYQzJCXbU_Js9qRI/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/sIsd3fYQzJCXbU_Js9qRI/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/sIsd3fYQzJCXbU_Js9qRI/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.491f56ba.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___3Hk0c "><a class="logo___1KD30" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___1qXLb" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___3VKNp"><h1 class="postTitle___26vXM">webpack-dev-middleware主要源码理解</h1><span class="postTime___16Ish">July 7, 2018</span></header><article class="postWrapper___3NXol post-article"><div><h1>前言</h1>
<p>每次用Vue-cli的时候，都会觉得配置的nodejs服务器很是让人省心，几个项目下来，都只用关心工程前端部分，用久了便想探其究竟。后来才发现原理用了express框架，代码也挺简单的，但是里面用的一个中间件webpack-dev-middleware，刚开始看的时候却不知有何用处？既然是express框架，又用的是SPA，路由不需要express来分发，那webpack-dev-middleware有何用处？抱着这样的疑问，看源码去吧</p>
<h1>思路</h1>
<p>一般express中间件的结构如下所示：</p>
<pre class="hljs"><code>App.use(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (nextNeeded) {
    <span class="hljs-comment">// 根据不同的请求处理，并传递到下一个next()，形成处理流</span>
    next();
  } <span class="hljs-keyword">else</span> { 
    <span class="hljs-comment">// 根据不同的请求处理</span>
  }
});
</code></pre>
<p>而webpackDevMiddleware也大体如此，只是返回一个Promise对象
在webpackDevMiddleware中的返回Promise前，有这两句：</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> filename = getFilenameFromUrl(context.options.publicPath, context.compiler, req.url);
<span class="hljs-keyword">if</span>(filename === <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> goNext();
</code></pre>
<p>getFilenameFromUrl这个名字就可以知道这是个返回匹配url路径文件名字，若不存在这个filename则goNext，而goNext里面若在webpackDevMiddleware中没有配置serverSideRender这个选项，则next进入下一个中间件。getFilenameFromUrl这个看源码就知道了，那问题的关键在于返回的Promise如何才能满足webpage开发和express框架？
Promisel里面的try出现了下面一句：</p>
<pre class="hljs"><code>res.statusCode = res.statusCode || <span class="hljs-number">200</span>;
<span class="hljs-keyword">if</span>(res.send) res.send(content);
<span class="hljs-keyword">else</span> res.end(content);
resolve();
</code></pre>
<p>咦？这不就是最普通不过的res.send/end方法吗？那为何要大费周章的写个Promise呢？
用的确实是send和end方法，但是里面的content，却大有文章，一般用response返回的时候，直接返回本地文件就好了，用webpack的时候，部分文件却是自动生成的内存文件如index.html, app.js之类的，这些文件是不能直接本地读取并获得的。在processRequest里面的try里面有如下:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> stat = context.fs.statSync(filename);
</code></pre>
<p>这个context.fs是在Share.js里面的生成的</p>
<pre class="hljs"><code>fs = compiler.outputFileSystem = <span class="hljs-keyword">new</span> MemoryFileSystem();
</code></pre>
<p>MemoryFileSystem用的是memory-fs npm模块，这个模块就是一个内存文件模块，而这里用到的statSync方法，则是返回一个是否是文件/目录的对象，若都不是就抛出MemoryFileSystemError，所以思路就清楚了，当不存在内存文件的时候，如直接在html里面引用到的文件js/css/picture，就直接抛出Error，进入goNext，从而进入下一个中间件。若不抛出Error，则在try外部通过 <code>context.fs.readFileSync(filename)</code> 读取内存文件，如webpack生成的内存文件app.js等，从而选择性发送content。
至于剩下的响应头设置和webpackDevMiddleware的其他方法，聪明的你，自己挖掘吧</p>
<h1>疑问</h1>
<p>在返回的Promise里面，先是进行了<code>shared.handleRequest</code>，这里面会有若filename是文件才进行processRequest，而在processRequest的try里面，若filename不是文件，是路径才进行里面的改写filename，这样的逻辑设计是为何？是文件，又不是文件的，如何进入里面呢？</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"July 7, 2018","title":"webpack-dev-middleware主要源码理解","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e每次用Vue-cli的时候，都会觉得配置的nodejs服务器很是让人省心，几个项目下来，都只用关心工程前端部分，用久了便想探其究竟。后来才发现原理用了express框架，代码也挺简单的，但是里面用的一个中间件webpack-dev-middleware，刚开始看的时候却不知有何用处？既然是express框架，又用的是SPA，路由不需要express来分发，那webpack-dev-middleware有何用处？抱着这样的疑问，看源码去吧\u003c/p\u003e\n\u003ch1\u003e思路\u003c/h1\u003e\n\u003cp\u003e一般express中间件的结构如下所示：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eApp.use(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res, next\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (nextNeeded) {\n    \u003cspan class=\"hljs-comment\"\u003e// 根据不同的请求处理，并传递到下一个next()，形成处理流\u003c/span\u003e\n    next();\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e { \n    \u003cspan class=\"hljs-comment\"\u003e// 根据不同的请求处理\u003c/span\u003e\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e而webpackDevMiddleware也大体如此，只是返回一个Promise对象\n在webpackDevMiddleware中的返回Promise前，有这两句：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e filename = getFilenameFromUrl(context.options.publicPath, context.compiler, req.url);\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(filename === \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e goNext();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003egetFilenameFromUrl这个名字就可以知道这是个返回匹配url路径文件名字，若不存在这个filename则goNext，而goNext里面若在webpackDevMiddleware中没有配置serverSideRender这个选项，则next进入下一个中间件。getFilenameFromUrl这个看源码就知道了，那问题的关键在于返回的Promise如何才能满足webpage开发和express框架？\nPromisel里面的try出现了下面一句：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eres.statusCode = res.statusCode || \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(res.send) res.send(content);\n\u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e res.end(content);\nresolve();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e咦？这不就是最普通不过的res.send/end方法吗？那为何要大费周章的写个Promise呢？\n用的确实是send和end方法，但是里面的content，却大有文章，一般用response返回的时候，直接返回本地文件就好了，用webpack的时候，部分文件却是自动生成的内存文件如index.html, app.js之类的，这些文件是不能直接本地读取并获得的。在processRequest里面的try里面有如下:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e stat = context.fs.statSync(filename);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个context.fs是在Share.js里面的生成的\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003efs = compiler.outputFileSystem = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e MemoryFileSystem();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMemoryFileSystem用的是memory-fs npm模块，这个模块就是一个内存文件模块，而这里用到的statSync方法，则是返回一个是否是文件/目录的对象，若都不是就抛出MemoryFileSystemError，所以思路就清楚了，当不存在内存文件的时候，如直接在html里面引用到的文件js/css/picture，就直接抛出Error，进入goNext，从而进入下一个中间件。若不抛出Error，则在try外部通过 \u003ccode\u003econtext.fs.readFileSync(filename)\u003c/code\u003e 读取内存文件，如webpack生成的内存文件app.js等，从而选择性发送content。\n至于剩下的响应头设置和webpackDevMiddleware的其他方法，聪明的你，自己挖掘吧\u003c/p\u003e\n\u003ch1\u003e疑问\u003c/h1\u003e\n\u003cp\u003e在返回的Promise里面，先是进行了\u003ccode\u003eshared.handleRequest\u003c/code\u003e，这里面会有若filename是文件才进行processRequest，而在processRequest的try里面，若filename不是文件，是路径才进行里面的改写filename，这样的逻辑设计是为何？是文件，又不是文件的，如何进入里面呢？\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"July 7, 2018","title":"webpack-dev-middleware主要源码理解","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e每次用Vue-cli的时候，都会觉得配置的nodejs服务器很是让人省心，几个项目下来，都只用关心工程前端部分，用久了便想探其究竟。后来才发现原理用了express框架，代码也挺简单的，但是里面用的一个中间件webpack-dev-middleware，刚开始看的时候却不知有何用处？既然是express框架，又用的是SPA，路由不需要express来分发，那webpack-dev-middleware有何用处？抱着这样的疑问，看源码去吧\u003c/p\u003e\n\u003ch1\u003e思路\u003c/h1\u003e\n\u003cp\u003e一般express中间件的结构如下所示：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eApp.use(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res, next\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (nextNeeded) {\n    \u003cspan class=\"hljs-comment\"\u003e// 根据不同的请求处理，并传递到下一个next()，形成处理流\u003c/span\u003e\n    next();\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e { \n    \u003cspan class=\"hljs-comment\"\u003e// 根据不同的请求处理\u003c/span\u003e\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e而webpackDevMiddleware也大体如此，只是返回一个Promise对象\n在webpackDevMiddleware中的返回Promise前，有这两句：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e filename = getFilenameFromUrl(context.options.publicPath, context.compiler, req.url);\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(filename === \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e goNext();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003egetFilenameFromUrl这个名字就可以知道这是个返回匹配url路径文件名字，若不存在这个filename则goNext，而goNext里面若在webpackDevMiddleware中没有配置serverSideRender这个选项，则next进入下一个中间件。getFilenameFromUrl这个看源码就知道了，那问题的关键在于返回的Promise如何才能满足webpage开发和express框架？\nPromisel里面的try出现了下面一句：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eres.statusCode = res.statusCode || \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(res.send) res.send(content);\n\u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e res.end(content);\nresolve();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e咦？这不就是最普通不过的res.send/end方法吗？那为何要大费周章的写个Promise呢？\n用的确实是send和end方法，但是里面的content，却大有文章，一般用response返回的时候，直接返回本地文件就好了，用webpack的时候，部分文件却是自动生成的内存文件如index.html, app.js之类的，这些文件是不能直接本地读取并获得的。在processRequest里面的try里面有如下:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e stat = context.fs.statSync(filename);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个context.fs是在Share.js里面的生成的\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003efs = compiler.outputFileSystem = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e MemoryFileSystem();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMemoryFileSystem用的是memory-fs npm模块，这个模块就是一个内存文件模块，而这里用到的statSync方法，则是返回一个是否是文件/目录的对象，若都不是就抛出MemoryFileSystemError，所以思路就清楚了，当不存在内存文件的时候，如直接在html里面引用到的文件js/css/picture，就直接抛出Error，进入goNext，从而进入下一个中间件。若不抛出Error，则在try外部通过 \u003ccode\u003econtext.fs.readFileSync(filename)\u003c/code\u003e 读取内存文件，如webpack生成的内存文件app.js等，从而选择性发送content。\n至于剩下的响应头设置和webpackDevMiddleware的其他方法，聪明的你，自己挖掘吧\u003c/p\u003e\n\u003ch1\u003e疑问\u003c/h1\u003e\n\u003cp\u003e在返回的Promise里面，先是进行了\u003ccode\u003eshared.handleRequest\u003c/code\u003e，这里面会有若filename是文件才进行processRequest，而在processRequest的try里面，若filename不是文件，是路径才进行里面的改写filename，这样的逻辑设计是为何？是文件，又不是文件的，如何进入里面呢？\u003c/p\u003e\n"}},"buildId":"sIsd3fYQzJCXbU_Js9qRI","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/sIsd3fYQzJCXbU_Js9qRI/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/sIsd3fYQzJCXbU_Js9qRI/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/sIsd3fYQzJCXbU_Js9qRI/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" async=""></script></body></html>