<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">react 源码开始的那一步</title><link rel="preload" href="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.ce3e8fb7a689beb447ad.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.8d98f9151bcde6fb2a87.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-45be5a1f94c3fe5df8ee.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.bb30b296.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___3Hk0c "><a class="logo___1KD30" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___1qXLb" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___3VKNp"><h1 class="postTitle___26vXM">react 源码开始的那一步</h1><span class="postTime___16Ish">November 12, 2018</span></header><article class="postWrapper___3NXol post-article"><div><h2>前言</h2>
<p>本来想着学习路径是从 react 周围生态开始的，比如之前的 preact，react-router，再到后面 immutable.js，读懂这些源码，接着可以看 dva，rematch，亦或则是 redux，甚至是 ant-design 都可以看看的，到了最后再吃大餐，react 源码。只是不知道为什么想要挑战一下自己，不想这么循循渐进。想要试试自己的实力。于是便有了这次的 react 源码的阅读。</p>
<p>刚开始读的时候觉得看 react 源码是一种享受，就像在读一本小说一样，惊险刺激，停不下来。只是后面到了 fiber 的阶段，就有点懵逼了，这绝对是烧脑侦探片，而我是里面的路人甲，看几行代码都觉得费劲。这个时候遇到了<a href="https://zhuanlan.zhihu.com/p/36996225" target="_blank">如何阅读大型前端开源项目的源码</a>，文章写得极好，根据上面的内容开始去看 react 文档里面的 Contribution Guide 里面的指导，随后又读了读 Blog 部分，简直是 amazing，尤其是<a href="https://www.youtube.com/watch?v=v6iR3Zk4oDY" target="_blank">Beyond React 16 by Dan Abramov</a>，以及<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs&amp;list=PLb0IAmt7-GS3fZ46IGFirdqKTIxlws7e0&amp;index=5" target="_blank">A Cartoon Intro to Fiber </a>。看得内心澎湃，觉得为何自己不能早点入坑呢？随后有看了<a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank">正妹</a>，以及<a href="https://zhuanlan.zhihu.com/p/37098539" target="_blank">方大神</a>的介绍，顿时有了不少底气。</p>
<h2>学习方式</h2>
<p>想要完整的学习，于是最简单的从 ReactDom.render 开始一步一步往下走，后面遇到看不懂的地方，则开始用 debug 的方式，打断点看代码。按照 Contribution 里面的意思，先安装包，然后构建项目，生成对应的 core、dome 文件。这里需要注意的是，构建 React 项目居然要安装 Java，而且只能用 yarn，嗯，还是自己家的东西好是吧。构建好文件后，复制并打开fixtures/packaging/babel-standalone/dev.htm 文件，就可以是愉快的调试了（后期看代码看的心烦都是靠 debug 走下来的）。由于还有很多地方没有去读或者没有读懂，这里只是作为学习的记录，记录的是上面 dev.htm 里面这个例子的加载而已。</p>
<pre class="hljs"><code>ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>,
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'container'</span>)
);
</code></pre>
<p>就是从上面的例子，一步一步走下去，直到没有下一步。就是本文介绍的内容。由于涉及到的步骤内容较多，所以采用思维导图的方式来介绍。</p>
<h2>前部分</h2>
<p>这里是初始化以及 Reconciler 和 Scheduler 的前部分。</p>
<p>从 ReactDom.render 里面过来时，会先创建 <code>new ReactRoot()</code>，该对象也就是下图左侧的 root。同时 root.current 为 fiber 对象。而 fiber.stateNode 指回 root。在 updateContainer 函数里面会计算出超时时间 expirationTime，这个时间常数在后面经常用上。
<img src="https://github.com/funfish/blog/raw/master/images/reactInit.png" alt=""></p>
<p>前面这部分主要功能是以建立 root 对象，并创建第一个 fiber，HostRoot，也就是 tag 为 3 的情况。这个 HostRoot 有点类似于上文中的 container，将会包含的子 fiber，并且以后的 dom 节点的操作都少不了 HostRoot。</p>
<p>fiber 就是一个普通的对象，对于这个对象而言，最重要的字段是下面这几个：</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> fiber = {
  <span class="hljs-attr">stateNode</span>: root,
  <span class="hljs-attr">return</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">child</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">sibling</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">tag</span>: HostRoot,
  <span class="hljs-attr">effectTag</span>: Callback,
  <span class="hljs-attr">expirationTime</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">updateQueue</span>: updateQueue,
  <span class="hljs-attr">alternate</span>: workInProgress,
}
</code></pre>
<p>stateNode 在本文中就是 dom 节点，或者是 root；return 和 child 分别指向 父 Fiber 以及子 fiber，sibling 则是兄弟 fiber 了，这四个字段构成了 fiber 间最直接的关系；</p>
<p>tag 代表当前 fiber 类型，目前有 17 个值；effectTag 有 14 个类型，按照 bitmap 的结构，表示的是 dom 操作类型。</p>
<p>上图中 performWork 之前会构建一个 updateQueue，正如其名一个更新队列。在图中可以看到，root.containerInfo 为 container 这个 dom 元素，而传入 ReactDOM.render 的第一个元素，则在 update 对象的 payload 上。这里有两个重要函数 scheduleWork 和 performWork，可以说是开始 react 工作的第一步，其简化大致如下：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleWork</span>(<span class="hljs-params">fiber, expirationTime</span>) </span>{
  <span class="hljs-keyword">let</span> node = fiber;
  <span class="hljs-keyword">while</span>(node !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">if</span>(node.return === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">const</span> root = node.stateNode;
      <span class="hljs-keyword">const</span> rootExpirationTime = root.expirationTime;
      requestWork(root, rootExpirationTime);
    }
    node = node.return;
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestWork</span>(<span class="hljs-params">root, expirationTime</span>) </span>{
  <span class="hljs-keyword">if</span> (expirationTime === Sync) {
    performWork(Sync, <span class="hljs-literal">null</span>);
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performWork</span>(<span class="hljs-params">minExpirationTime, dl</span>) </span>{
  findHighestPriorityRoot();
  <span class="hljs-keyword">while</span>(nextFlushedRoot !== <span class="hljs-literal">null</span>) {
    performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, <span class="hljs-literal">false</span>);
    findHighestPriorityRoot();
  }
}
</code></pre>
<p>代码中的 <code>Sync = 1</code>，也就是本文中 expirationTime 的值。这里面 scheduleWork 是更新的开始，通过循环找到，也就是 return 字段，沿着父 fiber 的路径一直到根节点。最后在根 root 开始工作啦。而 performWork ，这名字取得真好，先是 findHighestPriorityRoot，获取当前的最高优先的 root，再 <code>nextFlushedRoot = root</code>，执行 performWorkOnRoot 函数，再循环 findHighestPriorityRoot 函数会更新 nextFlushedRoot，但是本文中，只会发生一次循环，只有一个 root 呀。。至于其他情况，还不晓得，当然好像不重要。performWorkOnRoot 函数如下：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performWorkOnRoot</span>(<span class="hljs-params">root, expirationTime, isYieldy</span>) </span>{
  <span class="hljs-keyword">if</span> (!isYieldy) {
    <span class="hljs-keyword">let</span> finishedWork = root.finishedWork;
    <span class="hljs-keyword">if</span>(finishedWork === <span class="hljs-literal">null</span>) {
      root.finishedWork = <span class="hljs-literal">null</span>;
      renderRoot(root, <span class="hljs-literal">false</span>);
      finishedWork = root.finishedWork;
      <span class="hljs-keyword">if</span> (finishedWork !== <span class="hljs-literal">null</span>) {
        completeRoot(root, finishedWork, expirationTime);
      }
    }
  }
}
</code></pre>
<p>performWorkOnRoot 函数主要是通过是否异步 isYield，有的话就进入 commit 阶段，上面的代码自然是没有的部分，没有就进入 renderRoot，等 renderRoot 结束了再判断有没有完成，完成就进入 completeRoot 函数，也就是 commit 阶段咯。下文中的大部分步骤都是在 renderRoot 里面执行的。</p>
<h2>workInProgress tree</h2>
<p>上面的过程更多只是准备以及刚进入更新的过程，下面则是 reconciler 的核心部分。
fiber 是有两个阶段，Phase 1 render/reconcilation，在这个阶段是生成更新 fiber，更新虚拟 DOM 的过程，这个过程是可以被打断的。第二个阶段是 commit 阶段，这个阶段里面会把元素插入更新删除到 dom 树里面，无法被打断。本段落以及前面段落都是在 Phase 1 里面。</p>
<p>该阶段最重要的一个特征是会创建一个 workInProgress tree。在之前已经创建了一个父子兄关联的 fiber tree 了，而本次过程里面会再次创建一个类似的 tree。如下图所示：</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/workInProgressTree.png" alt=""></p>
<p>可以看出来在上图的 root 下面，current fiber 下面有两个 fiber 构成父子关系。先看看进入 renderRoot 的大致写法：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderRoot</span>(<span class="hljs-params">root, isYieldy</span>) </span>{
  nextUnitOfWork = createWorkInProgress(
    nextRoot.current,
    <span class="hljs-literal">null</span>,
    nextRenderExpirationTime,
  );
  <span class="hljs-keyword">do</span> {
    workLoop(isYieldy);
    <span class="hljs-keyword">break</span>;
  } <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">workLoop</span>(<span class="hljs-params">isYieldy</span>) </span>{
  <span class="hljs-keyword">if</span> (!isYieldy) {
    <span class="hljs-keyword">while</span> (nextUnitOfWork !== <span class="hljs-literal">null</span>) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    }
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performUnitOfWork</span>(<span class="hljs-params">workInProgress</span>) </span>{
  <span class="hljs-keyword">const</span> current = workInProgress.alternate;
  <span class="hljs-keyword">let</span> next;
  next = beginWork(current, workInProgress, nextRenderExpirationTime);
  <span class="hljs-keyword">if</span>(next == <span class="hljs-literal">null</span>) {
    next = completeUnitOfWork(workInProgress);
  }
  <span class="hljs-keyword">return</span> next;
}
</code></pre>
<p>上面可以看到是由两个循环组成的，而在进入循环之前，会 <strong>创建一个 fiber，也就是 workInProgress tree 的 root fiber，即 HostRoot</strong>。这个 HostRoot 与 root.current 的关系更像是一个浅复制的关系，共享一个 stateNode，tag 都为 HostRoot。 workLoop 里面的 nextUnitOfWork 全局变量指的是下次要处理的 fiber 单元，自然首次是 workInProgress tree 的根元素，而下次则是该根 fiber 的子 fiber，也就是 child，不断下来从而实现 tree 的迭代。在工作单元 performUnitOfWork 函数里面，有个至关重要的函数 beginWork，顾名思义要开始工作了，前面函数更多的只是一个展开迭代，beginWork 才是阶段一里面最为重要的部分。</p>
<h3>beginWork</h3>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beginWork</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
  <span class="hljs-keyword">switch</span> (workInProgress.tag) {
    <span class="hljs-keyword">case</span> HostRoot:
      <span class="hljs-keyword">return</span> updateHostRoot(current, workInProgress, renderExpirationTime);
    <span class="hljs-keyword">case</span> HostComponent:
      <span class="hljs-keyword">return</span> updateHostComponent(current, workInProgress, renderExpirationTime);
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateHostRoot</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
  <span class="hljs-keyword">let</span> updateQueue = workInProgress.updateQueue;
  processUpdateQueue(
    workInProgress,
    updateQueue,
    nextProps,
    <span class="hljs-literal">null</span>,
    renderExpirationTime,
  );
  reconcileChildren(current, workInProgress, nextChildren);
  <span class="hljs-keyword">return</span> workInProgress.child;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileChildren</span>(<span class="hljs-params">current, workInProgress, nextChildren, renderExpirationTime</span>) </span>{
  workInProgress.child = reconcileChildFibers(
    workInProgress,
    current.child,
    nextChildren,
    renderExpirationTime,
  );
}
</code></pre>
<p>beginWork 里面根据不同的 fiber 类型来选定更新函数。updateHostRoot 则是更新 HostRoot，其先是浅复制了 current.updateQueue，再修改当前 <code>workInProgress.effectTag = 32</code>。更新队列的时候会把之前的 firstUpdate/lastUpdate 置为 null，同时 firstEffect/lastEffect 指向 update。</p>
<p>这里的 nextChildren 是就是 update 里面的 payload 的 element，也就是传入 ReactDom.render 的 element。<strong>通过 reconcileChildren，会直接的创建一个子 fiber，并返回到 workInProgress.child</strong>。由于 element 的 type 为 'h1'，所以该 child 的 tag 为 HostComponent，<code>child.effectTag = Placement</code>，<strong>是一个需要插入元素的 fiber</strong>。这个 effectTag 在后面也会用到。</p>
<p>生成 child 返回给到 workInProgress.child，也就是下一轮的 nextUnitOfWork。child 也就是下一个工作单元 fiber 了。updateHostComponent 函数同样也会进入 reconcileChildren 里面，只是并不会生成一个 fiber 传给 child.child，因为该 child fiber 没有任何的子元素，所以直接结束，</p>
<h3>completeWork</h3>
<p>上面结束后，会继续在 performUnitOfWork 执行 completeUnitOfWork，上一段的工作主要是建立 workInProgress tree，而这一段的工作将是生成 DOM。先看看 completeUnitOfWork：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">completeUnitOfWork</span>(<span class="hljs-params">workInProgress</span>) </span>{
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">const</span> returnFiber = workInProgress.return;
    <span class="hljs-keyword">const</span> siblingFiber = workInProgress.sibling;
    <span class="hljs-keyword">if</span> ((workInProgress.effectTag &amp; Incomplete) === NoEffect) {
      <span class="hljs-comment">// 这个fiber 已经完成</span>
      <span class="hljs-keyword">let</span> next = completeWork(
        current,
        workInProgress,
        nextRenderExpirationTime,
      );
      <span class="hljs-comment">// 修改 firstEffect/lastEffect 为当前 workInProgress 也就是 child fiber</span>
      <span class="hljs-keyword">if</span> (siblingFiber !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> siblingFiber;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (returnFiber !== <span class="hljs-literal">null</span>) {
        workInProgress = returnFiber;
        <span class="hljs-keyword">continue</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 到达根部</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
    }
  }
}
</code></pre>
<p>这里 completeUnitOfWork 的传参是 child fiber，先是执行 completeWork 函数，随后开始循环，如果有兄弟 siblingFiber 则用，否之则为父 fiber，如果都没有则 <code>return null</code>。可想而知结束该循环的方式就是循环执行到 workInProgress tree 的根部。值得注意的是这里的 <strong>子 fiber 的 effects 会通过链表的形式被添加到父 fiber 的 effects 上面</strong>：</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (returnFiber.firstEffect === <span class="hljs-literal">null</span>) {
  returnFiber.firstEffect = workInProgress.firstEffect;
}
<span class="hljs-keyword">if</span> (workInProgress.lastEffect !== <span class="hljs-literal">null</span>) {
  <span class="hljs-keyword">if</span> (returnFiber.lastEffect !== <span class="hljs-literal">null</span>) {
    returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
  }
  returnFiber.lastEffect = workInProgress.lastEffect;
}
</code></pre>
<p>传递方式如上面所示，returnFiber 就是父 fiber，如果有 returnFiber.lastEffect 以及 workInProgress.lastEffect，<strong>则通过 nextEffect 这个字段来传递</strong>，当然啦这里的 lastEffect/nextEffect 都是 fiber 元素哦。</p>
<p>接下来看看重点 completeWork</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">completeWork</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
  <span class="hljs-keyword">const</span> newProps = workInProgress.pendingProps;
  <span class="hljs-keyword">const</span> type = workInProgress.type;
  <span class="hljs-keyword">switch</span> (workInProgress.tag) {
    <span class="hljs-keyword">case</span> HostComponent: {
      <span class="hljs-keyword">if</span>(current === <span class="hljs-literal">null</span> || workInProgress.stateNode === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">let</span> instance = createInstance(
          type,
          newProps,
          <span class="hljs-comment">// div#container 元素</span>
          rootContainerInstance,
          currentHostContext,
          workInProgress,
        );
        appendAllChildren(instance, workInProgress);
        workInProgress.stateNode = instance;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
    }
  }
}
</code></pre>
<p>在 completeWork 里会通过 createInstance 创建 dom 元素，这里的 instance 就是 <code>&lt;h1&gt;&lt;/h1&gt;</code> 随后会进一步添加 Dom 属性，最后成为 <code>&lt;h1&gt;Hello World!&lt;h1&gt;</code>。传递到 workInProgress 也就是 child fiber 的 stateNode。如上图所示。返回 null， completeUnitOfWork 里面会继续 completeWork 循环，此时 <code>workInProgress.tag = HostRoot</code>，进入不一样的 case，但是好像没有什么执行的。。。继续返回 null，同时和第一轮一样也会清空 fiber.expirationTime。</p>
<p>到了这一步基本就完成 completeUnitOfWork 的工作，接着会退出 performUnitOfWork 循环回到上文的第一个图的 performWorkOnRoot 里面，执行后面 performWorkOnRoot 函数。也就是 commit 阶段。</p>
<h2>commit</h2>
<p><img src="https://github.com/funfish/blog/raw/master/images/commitPhase.png" alt=""></p>
<p>commit 阶段主要有三大循环，每个循环都有不同的作用，其简化如下所示</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitRoot</span>(<span class="hljs-params">root, finishedWork</span>) </span>{
  <span class="hljs-keyword">let</span> firstEffect;
  finishedWork.lastEffect.nextEffect = finishedWork;
  firstEffect = finishedWork.firstEffect;

  nextEffect = firstEffect;
  <span class="hljs-keyword">while</span>(nextEffect !== <span class="hljs-literal">null</span>) {
    commitBeforeMutationLifecycles()
  }

  nextEffect = firstEffect;
  <span class="hljs-keyword">while</span>(nextEffect !== <span class="hljs-literal">null</span>) {
    commitAllHostEffects()
  }

  nextEffect = firstEffect;
  <span class="hljs-keyword">while</span>(nextEffect !== <span class="hljs-literal">null</span>) {
    commitAllLifeCycles(root, currentTime, committedExpirationTime);
  }
}

</code></pre>
<p>第一个 commitBeforeMutationLifecycles 函数，主要是执行组件的 getSnapshotBeforeUpdate 方法，这也是 react 新增加的一个生命钩子，该函数的返回值 snapshot，将是 componentDidUpdate 的第三个传参，commitBeforeMutationLifecycles 的主要作用也就在于此。</p>
<p>第二个 commitAllHostEffects 函数。这里面会将之前的插入，更新，删除和 ref 卸载的操作都执行到真实 DOM 上面。</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitAllHostEffects</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> effectTag = nextEffect.effectTag;
  <span class="hljs-keyword">if</span> (effectTag &amp; ContentReset) {
    <span class="hljs-comment">// ...</span>
  }
  <span class="hljs-keyword">if</span> (effectTag &amp; Ref) {
    <span class="hljs-comment">// ...</span>
  }
  <span class="hljs-keyword">let</span> primaryEffectTag = effectTag &amp; (Placement | Update | Deletion);
  <span class="hljs-keyword">switch</span> (primaryEffectTag) {
      <span class="hljs-keyword">case</span> Placement: {
        commitPlacement(nextEffect);
        nextEffect.effectTag &amp;= ~Placement;
        <span class="hljs-keyword">break</span>;
      }
  }
  nextEffect = nextEffect.nextEffect;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitPlacement</span>(<span class="hljs-params">finishedWork</span>) </span>{
  <span class="hljs-keyword">const</span> parentFiber = getHostParentFiber(finishedWork);
  <span class="hljs-keyword">switch</span> (parentFiber.tag) {
    <span class="hljs-keyword">case</span> HostRoot:
      parent = parentFiber.stateNode.containerInfo;
      isContainer = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">break</span>;
  }
  <span class="hljs-keyword">let</span> node = finishedWork;
  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">if</span> (node.tag === HostComponent || node.tag === HostText) {
      <span class="hljs-keyword">if</span> (isContainer) {
        appendChildToContainer(parent, node.stateNode);
      }
    }
    <span class="hljs-keyword">if</span> (node === finishedWork) {
      <span class="hljs-keyword">return</span>;
    }
  }
}
</code></pre>
<p>可知当前的 nextEffect 是 child， 在 commitAllHostEffects 里面根据不同的场景处理，由于都是 bitmap，所以流程下来很简单。最终由于 child 的 effectTag 为 Placement，从而 <strong>找到 root 的 containerInfo，将 child 的 stateNode 添加到 containerInfo 里面</strong>，并随后清楚掉 child.effectTag 的 Placement 位置。这样就从肉眼上可以看到的真实的 DOM 结构被改变了。第二轮 commitAllHostEffects 循环的时候，由于父 fiber 的 effectTag 为 Callback，不存在任何进一步的操作，最后会退出本次循环。</p>
<p>第三个循环 commitAllLifeCycles 函数，如下</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitAllLifeCycles</span>(<span class="hljs-params">finishedRoot, currentTime, committedExpirationTime</span>) </span>{
  <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">const</span> effectTag = nextEffect.effectTag;
    <span class="hljs-keyword">if</span> (effectTag &amp; (Update | Callback)) {
      <span class="hljs-keyword">const</span> current = nextEffect.alternate;
      commitLifeCycles(
        finishedRoot,
        current,
        nextEffect,
        currentTime,
        committedExpirationTime,
      );
    }
    <span class="hljs-keyword">if</span> (effectTag &amp; Ref) {
      <span class="hljs-comment">// .. 处理 ref 相关</span>
    }
    <span class="hljs-keyword">const</span> next = nextEffect.nextEffect;
    nextEffect.nextEffect = <span class="hljs-literal">null</span>;
    nextEffect = next;
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitLifeCycles</span>(<span class="hljs-params">
  finishedRoot, 
  current, 
  finishedWork, 
  currentTime, 
  committedExpirationTime
</span>) </span>{
  <span class="hljs-keyword">switch</span> (finishedWork.tag) {
    <span class="hljs-keyword">case</span> ClassComponent: {
      <span class="hljs-comment">// 执行生命钩子，componentDidMount与componentDidUpdate</span>
    }
    <span class="hljs-keyword">case</span> HostRoot: {

    }
    <span class="hljs-keyword">case</span> HostComponent: {

    }
  }
}
</code></pre>
<p>在上面的 commitAllLifeCycles 函数中，通过 commitLifeCycles 方法，执行生命钩子 componentDidMount 与 componentDidUpdate 的调用，同时会处理 updateQueue。这两点应该就是该循环的主要作用了。</p>
<p>通过上面的三个循环，而不是递归的方式实现了 commit 阶段。最后执行回归到 performWorkOnRoot，并结束前面两个循环。到此结束了。</p>
<h2>总结</h2>
<p>本文更多的只是从一个非常非常简单的例子来摸索 react 的首次渲染，能够清晰的看到其生成的 workInProgress tree，以及 reconciliation 与 commit 两个阶段的存在。一切的真实的 DOM 操作都发生在 commit 阶段，同时也会执行相关的生命钩子。但是对于 react 而言以上的探索是远远不够的。后面还会继续其他研究如：</p>
<ol>
<li>后台调度机制 requestIdleCallback 的 ployfill 实现，以及现场保护等等运用。</li>
<li>diff 机制，原则。</li>
<li>组件更新过程。</li>
<li>其他生命周期过程。</li>
</ol>
<h2>参考</h2>
<p>开头文章列出的部分</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/36996225" target="_blank">如何阅读大型前端开源项目的源码</a></li>
<li><a href="https://www.youtube.com/watch?v=v6iR3Zk4oDY" target="_blank">Beyond React 16 by Dan Abramov</a></li>
<li><a href="https://www.youtube.com/watch?v=ZCuYPiUIONs&amp;list=PLb0IAmt7-GS3fZ46IGFirdqKTIxlws7e0&amp;index=5" target="_blank">A Cartoon Intro to Fiber </a></li>
<li><a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank">React Fiber架构</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/37098539" target="_blank">为 Luy 实现 React Fiber 架构</a></li>
</ol>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"November 12, 2018","title":"react 源码开始的那一步","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e本来想着学习路径是从 react 周围生态开始的，比如之前的 preact，react-router，再到后面 immutable.js，读懂这些源码，接着可以看 dva，rematch，亦或则是 redux，甚至是 ant-design 都可以看看的，到了最后再吃大餐，react 源码。只是不知道为什么想要挑战一下自己，不想这么循循渐进。想要试试自己的实力。于是便有了这次的 react 源码的阅读。\u003c/p\u003e\n\u003cp\u003e刚开始读的时候觉得看 react 源码是一种享受，就像在读一本小说一样，惊险刺激，停不下来。只是后面到了 fiber 的阶段，就有点懵逼了，这绝对是烧脑侦探片，而我是里面的路人甲，看几行代码都觉得费劲。这个时候遇到了\u003ca href=\"https://zhuanlan.zhihu.com/p/36996225\" target=\"_blank\"\u003e如何阅读大型前端开源项目的源码\u003c/a\u003e，文章写得极好，根据上面的内容开始去看 react 文档里面的 Contribution Guide 里面的指导，随后又读了读 Blog 部分，简直是 amazing，尤其是\u003ca href=\"https://www.youtube.com/watch?v=v6iR3Zk4oDY\" target=\"_blank\"\u003eBeyond React 16 by Dan Abramov\u003c/a\u003e，以及\u003ca href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs\u0026amp;list=PLb0IAmt7-GS3fZ46IGFirdqKTIxlws7e0\u0026amp;index=5\" target=\"_blank\"\u003eA Cartoon Intro to Fiber \u003c/a\u003e。看得内心澎湃，觉得为何自己不能早点入坑呢？随后有看了\u003ca href=\"https://zhuanlan.zhihu.com/p/37095662\" target=\"_blank\"\u003e正妹\u003c/a\u003e，以及\u003ca href=\"https://zhuanlan.zhihu.com/p/37098539\" target=\"_blank\"\u003e方大神\u003c/a\u003e的介绍，顿时有了不少底气。\u003c/p\u003e\n\u003ch2\u003e学习方式\u003c/h2\u003e\n\u003cp\u003e想要完整的学习，于是最简单的从 ReactDom.render 开始一步一步往下走，后面遇到看不懂的地方，则开始用 debug 的方式，打断点看代码。按照 Contribution 里面的意思，先安装包，然后构建项目，生成对应的 core、dome 文件。这里需要注意的是，构建 React 项目居然要安装 Java，而且只能用 yarn，嗯，还是自己家的东西好是吧。构建好文件后，复制并打开fixtures/packaging/babel-standalone/dev.htm 文件，就可以是愉快的调试了（后期看代码看的心烦都是靠 debug 走下来的）。由于还有很多地方没有去读或者没有读懂，这里只是作为学习的记录，记录的是上面 dev.htm 里面这个例子的加载而已。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eReactDOM.render(\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003eHello World!\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e,\n  \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.getElementById(\u003cspan class=\"hljs-string\"\u003e'container'\u003c/span\u003e)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e就是从上面的例子，一步一步走下去，直到没有下一步。就是本文介绍的内容。由于涉及到的步骤内容较多，所以采用思维导图的方式来介绍。\u003c/p\u003e\n\u003ch2\u003e前部分\u003c/h2\u003e\n\u003cp\u003e这里是初始化以及 Reconciler 和 Scheduler 的前部分。\u003c/p\u003e\n\u003cp\u003e从 ReactDom.render 里面过来时，会先创建 \u003ccode\u003enew ReactRoot()\u003c/code\u003e，该对象也就是下图左侧的 root。同时 root.current 为 fiber 对象。而 fiber.stateNode 指回 root。在 updateContainer 函数里面会计算出超时时间 expirationTime，这个时间常数在后面经常用上。\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/reactInit.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e前面这部分主要功能是以建立 root 对象，并创建第一个 fiber，HostRoot，也就是 tag 为 3 的情况。这个 HostRoot 有点类似于上文中的 container，将会包含的子 fiber，并且以后的 dom 节点的操作都少不了 HostRoot。\u003c/p\u003e\n\u003cp\u003efiber 就是一个普通的对象，对于这个对象而言，最重要的字段是下面这几个：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fiber = {\n  \u003cspan class=\"hljs-attr\"\u003estateNode\u003c/span\u003e: root,\n  \u003cspan class=\"hljs-attr\"\u003ereturn\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003esibling\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etag\u003c/span\u003e: HostRoot,\n  \u003cspan class=\"hljs-attr\"\u003eeffectTag\u003c/span\u003e: Callback,\n  \u003cspan class=\"hljs-attr\"\u003eexpirationTime\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eupdateQueue\u003c/span\u003e: updateQueue,\n  \u003cspan class=\"hljs-attr\"\u003ealternate\u003c/span\u003e: workInProgress,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003estateNode 在本文中就是 dom 节点，或者是 root；return 和 child 分别指向 父 Fiber 以及子 fiber，sibling 则是兄弟 fiber 了，这四个字段构成了 fiber 间最直接的关系；\u003c/p\u003e\n\u003cp\u003etag 代表当前 fiber 类型，目前有 17 个值；effectTag 有 14 个类型，按照 bitmap 的结构，表示的是 dom 操作类型。\u003c/p\u003e\n\u003cp\u003e上图中 performWork 之前会构建一个 updateQueue，正如其名一个更新队列。在图中可以看到，root.containerInfo 为 container 这个 dom 元素，而传入 ReactDOM.render 的第一个元素，则在 update 对象的 payload 上。这里有两个重要函数 scheduleWork 和 performWork，可以说是开始 react 工作的第一步，其简化大致如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003escheduleWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efiber, expirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e node = fiber;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(node !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(node.return === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e root = node.stateNode;\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e rootExpirationTime = root.expirationTime;\n      requestWork(root, rootExpirationTime);\n    }\n    node = node.return;\n  }\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erequestWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eroot, expirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (expirationTime === Sync) {\n    performWork(Sync, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n  }\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eperformWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eminExpirationTime, dl\u003c/span\u003e) \u003c/span\u003e{\n  findHighestPriorityRoot();\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(nextFlushedRoot !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n    findHighestPriorityRoot();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e代码中的 \u003ccode\u003eSync = 1\u003c/code\u003e，也就是本文中 expirationTime 的值。这里面 scheduleWork 是更新的开始，通过循环找到，也就是 return 字段，沿着父 fiber 的路径一直到根节点。最后在根 root 开始工作啦。而 performWork ，这名字取得真好，先是 findHighestPriorityRoot，获取当前的最高优先的 root，再 \u003ccode\u003enextFlushedRoot = root\u003c/code\u003e，执行 performWorkOnRoot 函数，再循环 findHighestPriorityRoot 函数会更新 nextFlushedRoot，但是本文中，只会发生一次循环，只有一个 root 呀。。至于其他情况，还不晓得，当然好像不重要。performWorkOnRoot 函数如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eperformWorkOnRoot\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eroot, expirationTime, isYieldy\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isYieldy) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e finishedWork = root.finishedWork;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(finishedWork === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n      root.finishedWork = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n      renderRoot(root, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n      finishedWork = root.finishedWork;\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (finishedWork !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n        completeRoot(root, finishedWork, expirationTime);\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eperformWorkOnRoot 函数主要是通过是否异步 isYield，有的话就进入 commit 阶段，上面的代码自然是没有的部分，没有就进入 renderRoot，等 renderRoot 结束了再判断有没有完成，完成就进入 completeRoot 函数，也就是 commit 阶段咯。下文中的大部分步骤都是在 renderRoot 里面执行的。\u003c/p\u003e\n\u003ch2\u003eworkInProgress tree\u003c/h2\u003e\n\u003cp\u003e上面的过程更多只是准备以及刚进入更新的过程，下面则是 reconciler 的核心部分。\nfiber 是有两个阶段，Phase 1 render/reconcilation，在这个阶段是生成更新 fiber，更新虚拟 DOM 的过程，这个过程是可以被打断的。第二个阶段是 commit 阶段，这个阶段里面会把元素插入更新删除到 dom 树里面，无法被打断。本段落以及前面段落都是在 Phase 1 里面。\u003c/p\u003e\n\u003cp\u003e该阶段最重要的一个特征是会创建一个 workInProgress tree。在之前已经创建了一个父子兄关联的 fiber tree 了，而本次过程里面会再次创建一个类似的 tree。如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/workInProgressTree.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e可以看出来在上图的 root 下面，current fiber 下面有两个 fiber 构成父子关系。先看看进入 renderRoot 的大致写法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erenderRoot\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eroot, isYieldy\u003c/span\u003e) \u003c/span\u003e{\n  nextUnitOfWork = createWorkInProgress(\n    nextRoot.current,\n    \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    nextRenderExpirationTime,\n  );\n  \u003cspan class=\"hljs-keyword\"\u003edo\u003c/span\u003e {\n    workLoop(isYieldy);\n    \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n  } \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e)\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eworkLoop\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eisYieldy\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isYieldy) {\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (nextUnitOfWork !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n  }\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eperformUnitOfWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eworkInProgress\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e current = workInProgress.alternate;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e next;\n  next = beginWork(current, workInProgress, nextRenderExpirationTime);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(next == \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    next = completeUnitOfWork(workInProgress);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e next;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面可以看到是由两个循环组成的，而在进入循环之前，会 \u003cstrong\u003e创建一个 fiber，也就是 workInProgress tree 的 root fiber，即 HostRoot\u003c/strong\u003e。这个 HostRoot 与 root.current 的关系更像是一个浅复制的关系，共享一个 stateNode，tag 都为 HostRoot。 workLoop 里面的 nextUnitOfWork 全局变量指的是下次要处理的 fiber 单元，自然首次是 workInProgress tree 的根元素，而下次则是该根 fiber 的子 fiber，也就是 child，不断下来从而实现 tree 的迭代。在工作单元 performUnitOfWork 函数里面，有个至关重要的函数 beginWork，顾名思义要开始工作了，前面函数更多的只是一个展开迭代，beginWork 才是阶段一里面最为重要的部分。\u003c/p\u003e\n\u003ch3\u003ebeginWork\u003c/h3\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ebeginWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, workInProgress, renderExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (workInProgress.tag) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e HostRoot:\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e updateHostRoot(current, workInProgress, renderExpirationTime);\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e HostComponent:\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e updateHostComponent(current, workInProgress, renderExpirationTime);\n  }\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eupdateHostRoot\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, workInProgress, renderExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e updateQueue = workInProgress.updateQueue;\n  processUpdateQueue(\n    workInProgress,\n    updateQueue,\n    nextProps,\n    \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    renderExpirationTime,\n  );\n  reconcileChildren(current, workInProgress, nextChildren);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e workInProgress.child;\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ereconcileChildren\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, workInProgress, nextChildren, renderExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  workInProgress.child = reconcileChildFibers(\n    workInProgress,\n    current.child,\n    nextChildren,\n    renderExpirationTime,\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebeginWork 里面根据不同的 fiber 类型来选定更新函数。updateHostRoot 则是更新 HostRoot，其先是浅复制了 current.updateQueue，再修改当前 \u003ccode\u003eworkInProgress.effectTag = 32\u003c/code\u003e。更新队列的时候会把之前的 firstUpdate/lastUpdate 置为 null，同时 firstEffect/lastEffect 指向 update。\u003c/p\u003e\n\u003cp\u003e这里的 nextChildren 是就是 update 里面的 payload 的 element，也就是传入 ReactDom.render 的 element。\u003cstrong\u003e通过 reconcileChildren，会直接的创建一个子 fiber，并返回到 workInProgress.child\u003c/strong\u003e。由于 element 的 type 为 'h1'，所以该 child 的 tag 为 HostComponent，\u003ccode\u003echild.effectTag = Placement\u003c/code\u003e，\u003cstrong\u003e是一个需要插入元素的 fiber\u003c/strong\u003e。这个 effectTag 在后面也会用到。\u003c/p\u003e\n\u003cp\u003e生成 child 返回给到 workInProgress.child，也就是下一轮的 nextUnitOfWork。child 也就是下一个工作单元 fiber 了。updateHostComponent 函数同样也会进入 reconcileChildren 里面，只是并不会生成一个 fiber 传给 child.child，因为该 child fiber 没有任何的子元素，所以直接结束，\u003c/p\u003e\n\u003ch3\u003ecompleteWork\u003c/h3\u003e\n\u003cp\u003e上面结束后，会继续在 performUnitOfWork 执行 completeUnitOfWork，上一段的工作主要是建立 workInProgress tree，而这一段的工作将是生成 DOM。先看看 completeUnitOfWork：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecompleteUnitOfWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eworkInProgress\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e returnFiber = workInProgress.return;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e siblingFiber = workInProgress.sibling;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ((workInProgress.effectTag \u0026amp; Incomplete) === NoEffect) {\n      \u003cspan class=\"hljs-comment\"\u003e// 这个fiber 已经完成\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e next = completeWork(\n        current,\n        workInProgress,\n        nextRenderExpirationTime,\n      );\n      \u003cspan class=\"hljs-comment\"\u003e// 修改 firstEffect/lastEffect 为当前 workInProgress 也就是 child fiber\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (siblingFiber !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e siblingFiber;\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (returnFiber !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n        workInProgress = returnFiber;\n        \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e;\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// 到达根部\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里 completeUnitOfWork 的传参是 child fiber，先是执行 completeWork 函数，随后开始循环，如果有兄弟 siblingFiber 则用，否之则为父 fiber，如果都没有则 \u003ccode\u003ereturn null\u003c/code\u003e。可想而知结束该循环的方式就是循环执行到 workInProgress tree 的根部。值得注意的是这里的 \u003cstrong\u003e子 fiber 的 effects 会通过链表的形式被添加到父 fiber 的 effects 上面\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (returnFiber.firstEffect === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n  returnFiber.firstEffect = workInProgress.firstEffect;\n}\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (workInProgress.lastEffect !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (returnFiber.lastEffect !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n  }\n  returnFiber.lastEffect = workInProgress.lastEffect;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e传递方式如上面所示，returnFiber 就是父 fiber，如果有 returnFiber.lastEffect 以及 workInProgress.lastEffect，\u003cstrong\u003e则通过 nextEffect 这个字段来传递\u003c/strong\u003e，当然啦这里的 lastEffect/nextEffect 都是 fiber 元素哦。\u003c/p\u003e\n\u003cp\u003e接下来看看重点 completeWork\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecompleteWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, workInProgress, renderExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newProps = workInProgress.pendingProps;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e type = workInProgress.type;\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (workInProgress.tag) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e HostComponent: {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(current === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e || workInProgress.stateNode === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e instance = createInstance(\n          type,\n          newProps,\n          \u003cspan class=\"hljs-comment\"\u003e// div#container 元素\u003c/span\u003e\n          rootContainerInstance,\n          currentHostContext,\n          workInProgress,\n        );\n        appendAllChildren(instance, workInProgress);\n        workInProgress.stateNode = instance;\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 completeWork 里会通过 createInstance 创建 dom 元素，这里的 instance 就是 \u003ccode\u003e\u0026lt;h1\u0026gt;\u0026lt;/h1\u0026gt;\u003c/code\u003e 随后会进一步添加 Dom 属性，最后成为 \u003ccode\u003e\u0026lt;h1\u0026gt;Hello World!\u0026lt;h1\u0026gt;\u003c/code\u003e。传递到 workInProgress 也就是 child fiber 的 stateNode。如上图所示。返回 null， completeUnitOfWork 里面会继续 completeWork 循环，此时 \u003ccode\u003eworkInProgress.tag = HostRoot\u003c/code\u003e，进入不一样的 case，但是好像没有什么执行的。。。继续返回 null，同时和第一轮一样也会清空 fiber.expirationTime。\u003c/p\u003e\n\u003cp\u003e到了这一步基本就完成 completeUnitOfWork 的工作，接着会退出 performUnitOfWork 循环回到上文的第一个图的 performWorkOnRoot 里面，执行后面 performWorkOnRoot 函数。也就是 commit 阶段。\u003c/p\u003e\n\u003ch2\u003ecommit\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/commitPhase.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003ecommit 阶段主要有三大循环，每个循环都有不同的作用，其简化如下所示\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecommitRoot\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eroot, finishedWork\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e firstEffect;\n  finishedWork.lastEffect.nextEffect = finishedWork;\n  firstEffect = finishedWork.firstEffect;\n\n  nextEffect = firstEffect;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(nextEffect !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    commitBeforeMutationLifecycles()\n  }\n\n  nextEffect = firstEffect;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(nextEffect !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    commitAllHostEffects()\n  }\n\n  nextEffect = firstEffect;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(nextEffect !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    commitAllLifeCycles(root, currentTime, committedExpirationTime);\n  }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e第一个 commitBeforeMutationLifecycles 函数，主要是执行组件的 getSnapshotBeforeUpdate 方法，这也是 react 新增加的一个生命钩子，该函数的返回值 snapshot，将是 componentDidUpdate 的第三个传参，commitBeforeMutationLifecycles 的主要作用也就在于此。\u003c/p\u003e\n\u003cp\u003e第二个 commitAllHostEffects 函数。这里面会将之前的插入，更新，删除和 ref 卸载的操作都执行到真实 DOM 上面。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecommitAllHostEffects\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e effectTag = nextEffect.effectTag;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (effectTag \u0026amp; ContentReset) {\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (effectTag \u0026amp; Ref) {\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  }\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e primaryEffectTag = effectTag \u0026amp; (Placement | Update | Deletion);\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (primaryEffectTag) {\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e Placement: {\n        commitPlacement(nextEffect);\n        nextEffect.effectTag \u0026amp;= ~Placement;\n        \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n      }\n  }\n  nextEffect = nextEffect.nextEffect;\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecommitPlacement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efinishedWork\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e parentFiber = getHostParentFiber(finishedWork);\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (parentFiber.tag) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e HostRoot:\n      parent = parentFiber.stateNode.containerInfo;\n      isContainer = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e node = finishedWork;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (node.tag === HostComponent || node.tag === HostText) {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isContainer) {\n        appendChildToContainer(parent, node.stateNode);\n      }\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (node === finishedWork) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可知当前的 nextEffect 是 child， 在 commitAllHostEffects 里面根据不同的场景处理，由于都是 bitmap，所以流程下来很简单。最终由于 child 的 effectTag 为 Placement，从而 \u003cstrong\u003e找到 root 的 containerInfo，将 child 的 stateNode 添加到 containerInfo 里面\u003c/strong\u003e，并随后清楚掉 child.effectTag 的 Placement 位置。这样就从肉眼上可以看到的真实的 DOM 结构被改变了。第二轮 commitAllHostEffects 循环的时候，由于父 fiber 的 effectTag 为 Callback，不存在任何进一步的操作，最后会退出本次循环。\u003c/p\u003e\n\u003cp\u003e第三个循环 commitAllLifeCycles 函数，如下\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecommitAllLifeCycles\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efinishedRoot, currentTime, committedExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (nextEffect !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e effectTag = nextEffect.effectTag;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (effectTag \u0026amp; (Update | Callback)) {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e current = nextEffect.alternate;\n      commitLifeCycles(\n        finishedRoot,\n        current,\n        nextEffect,\n        currentTime,\n        committedExpirationTime,\n      );\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (effectTag \u0026amp; Ref) {\n      \u003cspan class=\"hljs-comment\"\u003e// .. 处理 ref 相关\u003c/span\u003e\n    }\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e next = nextEffect.nextEffect;\n    nextEffect.nextEffect = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n    nextEffect = next;\n  }\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecommitLifeCycles\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n  finishedRoot, \n  current, \n  finishedWork, \n  currentTime, \n  committedExpirationTime\n\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (finishedWork.tag) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e ClassComponent: {\n      \u003cspan class=\"hljs-comment\"\u003e// 执行生命钩子，componentDidMount与componentDidUpdate\u003c/span\u003e\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e HostRoot: {\n\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e HostComponent: {\n\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在上面的 commitAllLifeCycles 函数中，通过 commitLifeCycles 方法，执行生命钩子 componentDidMount 与 componentDidUpdate 的调用，同时会处理 updateQueue。这两点应该就是该循环的主要作用了。\u003c/p\u003e\n\u003cp\u003e通过上面的三个循环，而不是递归的方式实现了 commit 阶段。最后执行回归到 performWorkOnRoot，并结束前面两个循环。到此结束了。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e本文更多的只是从一个非常非常简单的例子来摸索 react 的首次渲染，能够清晰的看到其生成的 workInProgress tree，以及 reconciliation 与 commit 两个阶段的存在。一切的真实的 DOM 操作都发生在 commit 阶段，同时也会执行相关的生命钩子。但是对于 react 而言以上的探索是远远不够的。后面还会继续其他研究如：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e后台调度机制 requestIdleCallback 的 ployfill 实现，以及现场保护等等运用。\u003c/li\u003e\n\u003cli\u003ediff 机制，原则。\u003c/li\u003e\n\u003cli\u003e组件更新过程。\u003c/li\u003e\n\u003cli\u003e其他生命周期过程。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003cp\u003e开头文章列出的部分\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/36996225\" target=\"_blank\"\u003e如何阅读大型前端开源项目的源码\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=v6iR3Zk4oDY\" target=\"_blank\"\u003eBeyond React 16 by Dan Abramov\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs\u0026amp;list=PLb0IAmt7-GS3fZ46IGFirdqKTIxlws7e0\u0026amp;index=5\" target=\"_blank\"\u003eA Cartoon Intro to Fiber \u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/37095662\" target=\"_blank\"\u003eReact Fiber架构\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/37098539\" target=\"_blank\"\u003e为 Luy 实现 React Fiber 架构\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"November 12, 2018","title":"react 源码开始的那一步","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e本来想着学习路径是从 react 周围生态开始的，比如之前的 preact，react-router，再到后面 immutable.js，读懂这些源码，接着可以看 dva，rematch，亦或则是 redux，甚至是 ant-design 都可以看看的，到了最后再吃大餐，react 源码。只是不知道为什么想要挑战一下自己，不想这么循循渐进。想要试试自己的实力。于是便有了这次的 react 源码的阅读。\u003c/p\u003e\n\u003cp\u003e刚开始读的时候觉得看 react 源码是一种享受，就像在读一本小说一样，惊险刺激，停不下来。只是后面到了 fiber 的阶段，就有点懵逼了，这绝对是烧脑侦探片，而我是里面的路人甲，看几行代码都觉得费劲。这个时候遇到了\u003ca href=\"https://zhuanlan.zhihu.com/p/36996225\" target=\"_blank\"\u003e如何阅读大型前端开源项目的源码\u003c/a\u003e，文章写得极好，根据上面的内容开始去看 react 文档里面的 Contribution Guide 里面的指导，随后又读了读 Blog 部分，简直是 amazing，尤其是\u003ca href=\"https://www.youtube.com/watch?v=v6iR3Zk4oDY\" target=\"_blank\"\u003eBeyond React 16 by Dan Abramov\u003c/a\u003e，以及\u003ca href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs\u0026amp;list=PLb0IAmt7-GS3fZ46IGFirdqKTIxlws7e0\u0026amp;index=5\" target=\"_blank\"\u003eA Cartoon Intro to Fiber \u003c/a\u003e。看得内心澎湃，觉得为何自己不能早点入坑呢？随后有看了\u003ca href=\"https://zhuanlan.zhihu.com/p/37095662\" target=\"_blank\"\u003e正妹\u003c/a\u003e，以及\u003ca href=\"https://zhuanlan.zhihu.com/p/37098539\" target=\"_blank\"\u003e方大神\u003c/a\u003e的介绍，顿时有了不少底气。\u003c/p\u003e\n\u003ch2\u003e学习方式\u003c/h2\u003e\n\u003cp\u003e想要完整的学习，于是最简单的从 ReactDom.render 开始一步一步往下走，后面遇到看不懂的地方，则开始用 debug 的方式，打断点看代码。按照 Contribution 里面的意思，先安装包，然后构建项目，生成对应的 core、dome 文件。这里需要注意的是，构建 React 项目居然要安装 Java，而且只能用 yarn，嗯，还是自己家的东西好是吧。构建好文件后，复制并打开fixtures/packaging/babel-standalone/dev.htm 文件，就可以是愉快的调试了（后期看代码看的心烦都是靠 debug 走下来的）。由于还有很多地方没有去读或者没有读懂，这里只是作为学习的记录，记录的是上面 dev.htm 里面这个例子的加载而已。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eReactDOM.render(\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003eHello World!\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e,\n  \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.getElementById(\u003cspan class=\"hljs-string\"\u003e'container'\u003c/span\u003e)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e就是从上面的例子，一步一步走下去，直到没有下一步。就是本文介绍的内容。由于涉及到的步骤内容较多，所以采用思维导图的方式来介绍。\u003c/p\u003e\n\u003ch2\u003e前部分\u003c/h2\u003e\n\u003cp\u003e这里是初始化以及 Reconciler 和 Scheduler 的前部分。\u003c/p\u003e\n\u003cp\u003e从 ReactDom.render 里面过来时，会先创建 \u003ccode\u003enew ReactRoot()\u003c/code\u003e，该对象也就是下图左侧的 root。同时 root.current 为 fiber 对象。而 fiber.stateNode 指回 root。在 updateContainer 函数里面会计算出超时时间 expirationTime，这个时间常数在后面经常用上。\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/reactInit.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e前面这部分主要功能是以建立 root 对象，并创建第一个 fiber，HostRoot，也就是 tag 为 3 的情况。这个 HostRoot 有点类似于上文中的 container，将会包含的子 fiber，并且以后的 dom 节点的操作都少不了 HostRoot。\u003c/p\u003e\n\u003cp\u003efiber 就是一个普通的对象，对于这个对象而言，最重要的字段是下面这几个：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fiber = {\n  \u003cspan class=\"hljs-attr\"\u003estateNode\u003c/span\u003e: root,\n  \u003cspan class=\"hljs-attr\"\u003ereturn\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003esibling\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etag\u003c/span\u003e: HostRoot,\n  \u003cspan class=\"hljs-attr\"\u003eeffectTag\u003c/span\u003e: Callback,\n  \u003cspan class=\"hljs-attr\"\u003eexpirationTime\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eupdateQueue\u003c/span\u003e: updateQueue,\n  \u003cspan class=\"hljs-attr\"\u003ealternate\u003c/span\u003e: workInProgress,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003estateNode 在本文中就是 dom 节点，或者是 root；return 和 child 分别指向 父 Fiber 以及子 fiber，sibling 则是兄弟 fiber 了，这四个字段构成了 fiber 间最直接的关系；\u003c/p\u003e\n\u003cp\u003etag 代表当前 fiber 类型，目前有 17 个值；effectTag 有 14 个类型，按照 bitmap 的结构，表示的是 dom 操作类型。\u003c/p\u003e\n\u003cp\u003e上图中 performWork 之前会构建一个 updateQueue，正如其名一个更新队列。在图中可以看到，root.containerInfo 为 container 这个 dom 元素，而传入 ReactDOM.render 的第一个元素，则在 update 对象的 payload 上。这里有两个重要函数 scheduleWork 和 performWork，可以说是开始 react 工作的第一步，其简化大致如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003escheduleWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efiber, expirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e node = fiber;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(node !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(node.return === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e root = node.stateNode;\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e rootExpirationTime = root.expirationTime;\n      requestWork(root, rootExpirationTime);\n    }\n    node = node.return;\n  }\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erequestWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eroot, expirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (expirationTime === Sync) {\n    performWork(Sync, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n  }\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eperformWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eminExpirationTime, dl\u003c/span\u003e) \u003c/span\u003e{\n  findHighestPriorityRoot();\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(nextFlushedRoot !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n    findHighestPriorityRoot();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e代码中的 \u003ccode\u003eSync = 1\u003c/code\u003e，也就是本文中 expirationTime 的值。这里面 scheduleWork 是更新的开始，通过循环找到，也就是 return 字段，沿着父 fiber 的路径一直到根节点。最后在根 root 开始工作啦。而 performWork ，这名字取得真好，先是 findHighestPriorityRoot，获取当前的最高优先的 root，再 \u003ccode\u003enextFlushedRoot = root\u003c/code\u003e，执行 performWorkOnRoot 函数，再循环 findHighestPriorityRoot 函数会更新 nextFlushedRoot，但是本文中，只会发生一次循环，只有一个 root 呀。。至于其他情况，还不晓得，当然好像不重要。performWorkOnRoot 函数如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eperformWorkOnRoot\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eroot, expirationTime, isYieldy\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isYieldy) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e finishedWork = root.finishedWork;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(finishedWork === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n      root.finishedWork = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n      renderRoot(root, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n      finishedWork = root.finishedWork;\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (finishedWork !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n        completeRoot(root, finishedWork, expirationTime);\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eperformWorkOnRoot 函数主要是通过是否异步 isYield，有的话就进入 commit 阶段，上面的代码自然是没有的部分，没有就进入 renderRoot，等 renderRoot 结束了再判断有没有完成，完成就进入 completeRoot 函数，也就是 commit 阶段咯。下文中的大部分步骤都是在 renderRoot 里面执行的。\u003c/p\u003e\n\u003ch2\u003eworkInProgress tree\u003c/h2\u003e\n\u003cp\u003e上面的过程更多只是准备以及刚进入更新的过程，下面则是 reconciler 的核心部分。\nfiber 是有两个阶段，Phase 1 render/reconcilation，在这个阶段是生成更新 fiber，更新虚拟 DOM 的过程，这个过程是可以被打断的。第二个阶段是 commit 阶段，这个阶段里面会把元素插入更新删除到 dom 树里面，无法被打断。本段落以及前面段落都是在 Phase 1 里面。\u003c/p\u003e\n\u003cp\u003e该阶段最重要的一个特征是会创建一个 workInProgress tree。在之前已经创建了一个父子兄关联的 fiber tree 了，而本次过程里面会再次创建一个类似的 tree。如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/workInProgressTree.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e可以看出来在上图的 root 下面，current fiber 下面有两个 fiber 构成父子关系。先看看进入 renderRoot 的大致写法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erenderRoot\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eroot, isYieldy\u003c/span\u003e) \u003c/span\u003e{\n  nextUnitOfWork = createWorkInProgress(\n    nextRoot.current,\n    \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    nextRenderExpirationTime,\n  );\n  \u003cspan class=\"hljs-keyword\"\u003edo\u003c/span\u003e {\n    workLoop(isYieldy);\n    \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n  } \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e)\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eworkLoop\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eisYieldy\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isYieldy) {\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (nextUnitOfWork !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n  }\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eperformUnitOfWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eworkInProgress\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e current = workInProgress.alternate;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e next;\n  next = beginWork(current, workInProgress, nextRenderExpirationTime);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(next == \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    next = completeUnitOfWork(workInProgress);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e next;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面可以看到是由两个循环组成的，而在进入循环之前，会 \u003cstrong\u003e创建一个 fiber，也就是 workInProgress tree 的 root fiber，即 HostRoot\u003c/strong\u003e。这个 HostRoot 与 root.current 的关系更像是一个浅复制的关系，共享一个 stateNode，tag 都为 HostRoot。 workLoop 里面的 nextUnitOfWork 全局变量指的是下次要处理的 fiber 单元，自然首次是 workInProgress tree 的根元素，而下次则是该根 fiber 的子 fiber，也就是 child，不断下来从而实现 tree 的迭代。在工作单元 performUnitOfWork 函数里面，有个至关重要的函数 beginWork，顾名思义要开始工作了，前面函数更多的只是一个展开迭代，beginWork 才是阶段一里面最为重要的部分。\u003c/p\u003e\n\u003ch3\u003ebeginWork\u003c/h3\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ebeginWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, workInProgress, renderExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (workInProgress.tag) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e HostRoot:\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e updateHostRoot(current, workInProgress, renderExpirationTime);\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e HostComponent:\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e updateHostComponent(current, workInProgress, renderExpirationTime);\n  }\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eupdateHostRoot\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, workInProgress, renderExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e updateQueue = workInProgress.updateQueue;\n  processUpdateQueue(\n    workInProgress,\n    updateQueue,\n    nextProps,\n    \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    renderExpirationTime,\n  );\n  reconcileChildren(current, workInProgress, nextChildren);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e workInProgress.child;\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ereconcileChildren\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, workInProgress, nextChildren, renderExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  workInProgress.child = reconcileChildFibers(\n    workInProgress,\n    current.child,\n    nextChildren,\n    renderExpirationTime,\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebeginWork 里面根据不同的 fiber 类型来选定更新函数。updateHostRoot 则是更新 HostRoot，其先是浅复制了 current.updateQueue，再修改当前 \u003ccode\u003eworkInProgress.effectTag = 32\u003c/code\u003e。更新队列的时候会把之前的 firstUpdate/lastUpdate 置为 null，同时 firstEffect/lastEffect 指向 update。\u003c/p\u003e\n\u003cp\u003e这里的 nextChildren 是就是 update 里面的 payload 的 element，也就是传入 ReactDom.render 的 element。\u003cstrong\u003e通过 reconcileChildren，会直接的创建一个子 fiber，并返回到 workInProgress.child\u003c/strong\u003e。由于 element 的 type 为 'h1'，所以该 child 的 tag 为 HostComponent，\u003ccode\u003echild.effectTag = Placement\u003c/code\u003e，\u003cstrong\u003e是一个需要插入元素的 fiber\u003c/strong\u003e。这个 effectTag 在后面也会用到。\u003c/p\u003e\n\u003cp\u003e生成 child 返回给到 workInProgress.child，也就是下一轮的 nextUnitOfWork。child 也就是下一个工作单元 fiber 了。updateHostComponent 函数同样也会进入 reconcileChildren 里面，只是并不会生成一个 fiber 传给 child.child，因为该 child fiber 没有任何的子元素，所以直接结束，\u003c/p\u003e\n\u003ch3\u003ecompleteWork\u003c/h3\u003e\n\u003cp\u003e上面结束后，会继续在 performUnitOfWork 执行 completeUnitOfWork，上一段的工作主要是建立 workInProgress tree，而这一段的工作将是生成 DOM。先看看 completeUnitOfWork：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecompleteUnitOfWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eworkInProgress\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e returnFiber = workInProgress.return;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e siblingFiber = workInProgress.sibling;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ((workInProgress.effectTag \u0026amp; Incomplete) === NoEffect) {\n      \u003cspan class=\"hljs-comment\"\u003e// 这个fiber 已经完成\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e next = completeWork(\n        current,\n        workInProgress,\n        nextRenderExpirationTime,\n      );\n      \u003cspan class=\"hljs-comment\"\u003e// 修改 firstEffect/lastEffect 为当前 workInProgress 也就是 child fiber\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (siblingFiber !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e siblingFiber;\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (returnFiber !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n        workInProgress = returnFiber;\n        \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e;\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// 到达根部\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里 completeUnitOfWork 的传参是 child fiber，先是执行 completeWork 函数，随后开始循环，如果有兄弟 siblingFiber 则用，否之则为父 fiber，如果都没有则 \u003ccode\u003ereturn null\u003c/code\u003e。可想而知结束该循环的方式就是循环执行到 workInProgress tree 的根部。值得注意的是这里的 \u003cstrong\u003e子 fiber 的 effects 会通过链表的形式被添加到父 fiber 的 effects 上面\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (returnFiber.firstEffect === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n  returnFiber.firstEffect = workInProgress.firstEffect;\n}\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (workInProgress.lastEffect !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (returnFiber.lastEffect !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n  }\n  returnFiber.lastEffect = workInProgress.lastEffect;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e传递方式如上面所示，returnFiber 就是父 fiber，如果有 returnFiber.lastEffect 以及 workInProgress.lastEffect，\u003cstrong\u003e则通过 nextEffect 这个字段来传递\u003c/strong\u003e，当然啦这里的 lastEffect/nextEffect 都是 fiber 元素哦。\u003c/p\u003e\n\u003cp\u003e接下来看看重点 completeWork\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecompleteWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, workInProgress, renderExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newProps = workInProgress.pendingProps;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e type = workInProgress.type;\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (workInProgress.tag) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e HostComponent: {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(current === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e || workInProgress.stateNode === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e instance = createInstance(\n          type,\n          newProps,\n          \u003cspan class=\"hljs-comment\"\u003e// div#container 元素\u003c/span\u003e\n          rootContainerInstance,\n          currentHostContext,\n          workInProgress,\n        );\n        appendAllChildren(instance, workInProgress);\n        workInProgress.stateNode = instance;\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 completeWork 里会通过 createInstance 创建 dom 元素，这里的 instance 就是 \u003ccode\u003e\u0026lt;h1\u0026gt;\u0026lt;/h1\u0026gt;\u003c/code\u003e 随后会进一步添加 Dom 属性，最后成为 \u003ccode\u003e\u0026lt;h1\u0026gt;Hello World!\u0026lt;h1\u0026gt;\u003c/code\u003e。传递到 workInProgress 也就是 child fiber 的 stateNode。如上图所示。返回 null， completeUnitOfWork 里面会继续 completeWork 循环，此时 \u003ccode\u003eworkInProgress.tag = HostRoot\u003c/code\u003e，进入不一样的 case，但是好像没有什么执行的。。。继续返回 null，同时和第一轮一样也会清空 fiber.expirationTime。\u003c/p\u003e\n\u003cp\u003e到了这一步基本就完成 completeUnitOfWork 的工作，接着会退出 performUnitOfWork 循环回到上文的第一个图的 performWorkOnRoot 里面，执行后面 performWorkOnRoot 函数。也就是 commit 阶段。\u003c/p\u003e\n\u003ch2\u003ecommit\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/commitPhase.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003ecommit 阶段主要有三大循环，每个循环都有不同的作用，其简化如下所示\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecommitRoot\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eroot, finishedWork\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e firstEffect;\n  finishedWork.lastEffect.nextEffect = finishedWork;\n  firstEffect = finishedWork.firstEffect;\n\n  nextEffect = firstEffect;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(nextEffect !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    commitBeforeMutationLifecycles()\n  }\n\n  nextEffect = firstEffect;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(nextEffect !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    commitAllHostEffects()\n  }\n\n  nextEffect = firstEffect;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(nextEffect !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    commitAllLifeCycles(root, currentTime, committedExpirationTime);\n  }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e第一个 commitBeforeMutationLifecycles 函数，主要是执行组件的 getSnapshotBeforeUpdate 方法，这也是 react 新增加的一个生命钩子，该函数的返回值 snapshot，将是 componentDidUpdate 的第三个传参，commitBeforeMutationLifecycles 的主要作用也就在于此。\u003c/p\u003e\n\u003cp\u003e第二个 commitAllHostEffects 函数。这里面会将之前的插入，更新，删除和 ref 卸载的操作都执行到真实 DOM 上面。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecommitAllHostEffects\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e effectTag = nextEffect.effectTag;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (effectTag \u0026amp; ContentReset) {\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (effectTag \u0026amp; Ref) {\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  }\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e primaryEffectTag = effectTag \u0026amp; (Placement | Update | Deletion);\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (primaryEffectTag) {\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e Placement: {\n        commitPlacement(nextEffect);\n        nextEffect.effectTag \u0026amp;= ~Placement;\n        \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n      }\n  }\n  nextEffect = nextEffect.nextEffect;\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecommitPlacement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efinishedWork\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e parentFiber = getHostParentFiber(finishedWork);\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (parentFiber.tag) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e HostRoot:\n      parent = parentFiber.stateNode.containerInfo;\n      isContainer = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e node = finishedWork;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (node.tag === HostComponent || node.tag === HostText) {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isContainer) {\n        appendChildToContainer(parent, node.stateNode);\n      }\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (node === finishedWork) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可知当前的 nextEffect 是 child， 在 commitAllHostEffects 里面根据不同的场景处理，由于都是 bitmap，所以流程下来很简单。最终由于 child 的 effectTag 为 Placement，从而 \u003cstrong\u003e找到 root 的 containerInfo，将 child 的 stateNode 添加到 containerInfo 里面\u003c/strong\u003e，并随后清楚掉 child.effectTag 的 Placement 位置。这样就从肉眼上可以看到的真实的 DOM 结构被改变了。第二轮 commitAllHostEffects 循环的时候，由于父 fiber 的 effectTag 为 Callback，不存在任何进一步的操作，最后会退出本次循环。\u003c/p\u003e\n\u003cp\u003e第三个循环 commitAllLifeCycles 函数，如下\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecommitAllLifeCycles\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efinishedRoot, currentTime, committedExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (nextEffect !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e effectTag = nextEffect.effectTag;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (effectTag \u0026amp; (Update | Callback)) {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e current = nextEffect.alternate;\n      commitLifeCycles(\n        finishedRoot,\n        current,\n        nextEffect,\n        currentTime,\n        committedExpirationTime,\n      );\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (effectTag \u0026amp; Ref) {\n      \u003cspan class=\"hljs-comment\"\u003e// .. 处理 ref 相关\u003c/span\u003e\n    }\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e next = nextEffect.nextEffect;\n    nextEffect.nextEffect = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n    nextEffect = next;\n  }\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecommitLifeCycles\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n  finishedRoot, \n  current, \n  finishedWork, \n  currentTime, \n  committedExpirationTime\n\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (finishedWork.tag) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e ClassComponent: {\n      \u003cspan class=\"hljs-comment\"\u003e// 执行生命钩子，componentDidMount与componentDidUpdate\u003c/span\u003e\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e HostRoot: {\n\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e HostComponent: {\n\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在上面的 commitAllLifeCycles 函数中，通过 commitLifeCycles 方法，执行生命钩子 componentDidMount 与 componentDidUpdate 的调用，同时会处理 updateQueue。这两点应该就是该循环的主要作用了。\u003c/p\u003e\n\u003cp\u003e通过上面的三个循环，而不是递归的方式实现了 commit 阶段。最后执行回归到 performWorkOnRoot，并结束前面两个循环。到此结束了。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e本文更多的只是从一个非常非常简单的例子来摸索 react 的首次渲染，能够清晰的看到其生成的 workInProgress tree，以及 reconciliation 与 commit 两个阶段的存在。一切的真实的 DOM 操作都发生在 commit 阶段，同时也会执行相关的生命钩子。但是对于 react 而言以上的探索是远远不够的。后面还会继续其他研究如：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e后台调度机制 requestIdleCallback 的 ployfill 实现，以及现场保护等等运用。\u003c/li\u003e\n\u003cli\u003ediff 机制，原则。\u003c/li\u003e\n\u003cli\u003e组件更新过程。\u003c/li\u003e\n\u003cli\u003e其他生命周期过程。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003cp\u003e开头文章列出的部分\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/36996225\" target=\"_blank\"\u003e如何阅读大型前端开源项目的源码\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=v6iR3Zk4oDY\" target=\"_blank\"\u003eBeyond React 16 by Dan Abramov\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs\u0026amp;list=PLb0IAmt7-GS3fZ46IGFirdqKTIxlws7e0\u0026amp;index=5\" target=\"_blank\"\u003eA Cartoon Intro to Fiber \u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/37095662\" target=\"_blank\"\u003eReact Fiber架构\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/37098539\" target=\"_blank\"\u003e为 Luy 实现 React Fiber 架构\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n"}},"buildId":"I9XlxpmvFk~lmulxmmsMh","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.ce3e8fb7a689beb447ad.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.8d98f9151bcde6fb2a87.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-45be5a1f94c3fe5df8ee.js" async=""></script></body></html>