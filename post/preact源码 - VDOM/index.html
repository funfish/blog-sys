<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">preact源码 - VDOM</title><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.587c5e31.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___2dTZ9 "><a class="logo___346dE" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___13XXt" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___29Pln"><h1 class="postTitle___1_m4g">preact源码 - VDOM</h1><span class="postTime___1x0_i">March 24, 2021</span></header><article class="postWrapper___3jnNg post-article"><div><h2>前言</h2>
<p>在工作上开始用 React 开发已经有四个多月了，不禁想看看 React 和 Vue 本质上有什么区别。当然一个是 jsx 文件，一个是 vue 文件，两个处理起来肯定是不一样的。想了想以后项目发展越来越大，肯定是要以 React 为主体的，深入了解 React 是必须的，尤其是 React 已经发展到 React 16 了，新特性都不晓得怎么用呢。为了减少初学习 React 源码的陡度，想着还是从 Preact 开始好了，毕竟后者声称兼容 React 而且，关键是体积小！</p>
<h2>Babel 与 JSX</h2>
<p>在进入 Preact 的介绍前，又必须要说说虚拟 DOM，这虚拟 Dom 听着神奇，在 Vue 里面也主角。所以必要介绍一下。</p>
<p>在 React 官网的开始学习教程上有下面这段代码</p>
<pre class="hljs"><code>ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>,
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)
);
</code></pre>
<p>刚看到时候可以很明显的发现这是给 <code>ReactDOM.render</code> 传入两个参数，一个是 H1 标签，一个是 DOM 节点，后者很好理解，就是最平常的获取一个 id 为 root 的 DOM 节点，可是前者又是什么？在 Javascript 的所有类型里面是没有这种东西的，难不成是自己落后了？于是在 Chrome 的控制台里面打印，看一下，来一发 <code>console.log(&lt;div&gt;&lt;/div&gt;)</code>，结果立马返回 <code>Uncaught SyntaxError: Unexpected token &lt;</code> 这就提示说语法错误了，那是那里出错了呢？试试了试在 Preact 的 index 页面打印 <code>console.log(&lt;div&gt;&lt;/div&gt;)</code>，代码却能够正常跑起来，而且 <code>console.log(typeof &lt;div&gt;&lt;/div&gt;)</code> 居然是 <code>'object'</code> 奇了怪了？</p>
<p>难道两处代码是不一样的？难不成 Preact 做了什么特别处理？随查看 Preact 的源码，但是没有任何迹象，传入的参数根本就没有做什么处理，而且传进来马上就会语法错误了，怎么可能执行呢？</p>
<p>最后打开控制台，查看 Sources 的打包文件，发现原来 <code>console.log(typeof &lt;div&gt;&lt;/div&gt;)</code> 变成了下面：</p>
<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(_typeof((<span class="hljs-number">0</span>, _preact.h)(<span class="hljs-string">'div'</span>, <span class="hljs-literal">null</span>)));

<span class="hljs-comment">// 转变一下结果就是</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> preact.h(<span class="hljs-string">'div'</span>, <span class="hljs-literal">null</span>));
</code></pre>
<p>这。。。。。又是为什么呢？中间怎么这么多变化呢？在生成的代码阶段就不是简单的 <code>div</code> 了，那是哪里发生的呢？忽然想起以前讲 webpack 介绍的 Babel 降级问题，难道这里也是？查看 Babel 的配置文件 .babelrc，如下：</p>
<pre class="hljs"><code>{
  <span class="hljs-string">"presets"</span>: [<span class="hljs-string">"es2015"</span>, <span class="hljs-string">"stage-0"</span>],
  <span class="hljs-string">"plugins"</span>: [
  [<span class="hljs-string">"transform-react-jsx"</span>, { <span class="hljs-string">"pragma"</span>: <span class="hljs-string">"h"</span> }]
  ]
}
</code></pre>
<p>看看下面的配置，在看看转义的那句话，这不就是将 jsx 用 h 程序转变的意思吗？在 package.json 里面也看到了 <code>babel-plugin-transform-react-jsx</code>，这个包是用于将 JSX 转换为 React 函数，用法则是在 <code>.babelrc</code> 里面设置 <code>&quot;pragma&quot;: &quot;dom&quot;</code>，后者是替换的函数名字，默认是 <code>React.createElement</code>，而在 Preact 中则需要设置为 h 函数。官网里面也有介绍到对于 Babel 5 和 Babel 6 的设置。</p>
<h2>h 函数</h2>
<p>上文中的 <code>div</code> 变成了 h 函数的实现，h 函数在 Vue 里面也经常可以看到，更不要提 React，那 <code>h</code> 函数是什么呢？</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">h</span>(<span class="hljs-params">nodeName, attributes</span>) </span>{
  <span class="hljs-keyword">let</span> children=EMPTY_CHILDREN, lastSimple, child, simple, i;
  <span class="hljs-keyword">for</span> (i=<span class="hljs-built_in">arguments</span>.length; i-- &gt; <span class="hljs-number">2</span>; ) {
    stack.push(<span class="hljs-built_in">arguments</span>[i]);
  }
  <span class="hljs-keyword">if</span> (attributes &amp;&amp; attributes.children!=<span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">if</span> (!stack.length) stack.push(attributes.children);
    <span class="hljs-keyword">delete</span> attributes.children;
  }
  <span class="hljs-comment">// 存在子节点，如text节点或者其他h函数</span>
  <span class="hljs-keyword">while</span> (stack.length) {
    <span class="hljs-keyword">if</span> ((child = stack.pop()) &amp;&amp; child.pop!==<span class="hljs-literal">undefined</span>) {
      <span class="hljs-keyword">for</span> (i=child.length; i--; ) stack.push(child[i]);
    }
    <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> child===<span class="hljs-string">'boolean'</span>) child = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> ((simple = <span class="hljs-keyword">typeof</span> nodeName!==<span class="hljs-string">'function'</span>)) {
        <span class="hljs-keyword">if</span> (child==<span class="hljs-literal">null</span>) child = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> child===<span class="hljs-string">'number'</span>) child = <span class="hljs-built_in">String</span>(child);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> child!==<span class="hljs-string">'string'</span>) simple = <span class="hljs-literal">false</span>;
      }
    <span class="hljs-comment">// 最终子节点都会推入children里面</span>
    <span class="hljs-comment">// 而对于简单节点则直接相加就好了</span>
      <span class="hljs-keyword">if</span> (simple &amp;&amp; lastSimple) {
        children[children.length<span class="hljs-number">-1</span>] += child;
      }
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (children===EMPTY_CHILDREN) {
        children = [child];
      }
      <span class="hljs-keyword">else</span> {
        children.push(child);
      }

      lastSimple = simple;
    }
  }
  <span class="hljs-comment">// p就是最终生成的 Vnode</span>
  <span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> VNode();
  p.nodeName = nodeName;
  p.children = children;
  p.attributes = attributes==<span class="hljs-literal">null</span> ? <span class="hljs-literal">undefined</span> : attributes;
  p.key = attributes==<span class="hljs-literal">null</span> ? <span class="hljs-literal">undefined</span> : attributes.key;
  <span class="hljs-comment">// 对生成的Vnode，都用options的vnode方法来处理</span>
  <span class="hljs-comment">// if a "vnode hook" is defined, pass every created VNode to it</span>
  <span class="hljs-keyword">if</span> (options.vnode!==<span class="hljs-literal">undefined</span>) options.vnode(p);

  <span class="hljs-keyword">return</span> p;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">VNode</span>(<span class="hljs-params"></span>) </span>{}
</code></pre>
<p>上面代码还是很好理解的，下面举个简单例子，对于 <code>h('DIV', {id: 'abc'}, h('SPAN', null))</code> 怎会被转换为以下 Vnode：</p>
<pre class="hljs"><code>{
  <span class="hljs-attr">nodeName</span>: <span class="hljs-string">'DIV'</span>,
  <span class="hljs-attr">attributes</span>: {<span class="hljs-attr">id</span>: <span class="hljs-string">'abc'</span>},
  <span class="hljs-attr">children</span>: [
  {
    <span class="hljs-attr">nodeName</span>: <span class="hljs-string">'SPAN'</span>,
    <span class="hljs-attr">attributes</span>: <span class="hljs-literal">undefined</span>,
    <span class="hljs-attr">children</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">key</span>: <span class="hljs-literal">undefined</span>,
  }
  ]
  <span class="hljs-attr">key</span> : <span class="hljs-literal">undefined</span>,
}
</code></pre>
<p>在 <code>h</code> 函数里面的 <code>while</code> 循环里面做了一件很特别的事情，本来只要将子节点统统 push 到 children 里面就好了，但这里通过相邻节点是否是简单方式 <code>simple/lastSimple</code>，若果是数字，字符串等，则直接合并在一起。这样有什么好处呢？减少要 diff 的节点，就是减少计算量，毕竟虚拟 Vnode 里面主要内容也是字符串等简单类型。而 <code>VNode</code> 构造函数，则是简单的一个实例而已。</p>
<h2>总结</h2>
<p>这里介绍了 VNode 的一些入门东西，但是这是后面学习 diff 机制的基础，也能够清晰知道 Preact 的操作对象不是 Document 上面的节点，而是一个个虚拟的 VNode，</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"March 24, 2021","title":"preact源码 - VDOM","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e在工作上开始用 React 开发已经有四个多月了，不禁想看看 React 和 Vue 本质上有什么区别。当然一个是 jsx 文件，一个是 vue 文件，两个处理起来肯定是不一样的。想了想以后项目发展越来越大，肯定是要以 React 为主体的，深入了解 React 是必须的，尤其是 React 已经发展到 React 16 了，新特性都不晓得怎么用呢。为了减少初学习 React 源码的陡度，想着还是从 Preact 开始好了，毕竟后者声称兼容 React 而且，关键是体积小！\u003c/p\u003e\n\u003ch2\u003eBabel 与 JSX\u003c/h2\u003e\n\u003cp\u003e在进入 Preact 的介绍前，又必须要说说虚拟 DOM，这虚拟 Dom 听着神奇，在 Vue 里面也主角。所以必要介绍一下。\u003c/p\u003e\n\u003cp\u003e在 React 官网的开始学习教程上有下面这段代码\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eReactDOM.render(\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003eHello, world!\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e,\n  \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.getElementById(\u003cspan class=\"hljs-string\"\u003e'root'\u003c/span\u003e)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e刚看到时候可以很明显的发现这是给 \u003ccode\u003eReactDOM.render\u003c/code\u003e 传入两个参数，一个是 H1 标签，一个是 DOM 节点，后者很好理解，就是最平常的获取一个 id 为 root 的 DOM 节点，可是前者又是什么？在 Javascript 的所有类型里面是没有这种东西的，难不成是自己落后了？于是在 Chrome 的控制台里面打印，看一下，来一发 \u003ccode\u003econsole.log(\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;)\u003c/code\u003e，结果立马返回 \u003ccode\u003eUncaught SyntaxError: Unexpected token \u0026lt;\u003c/code\u003e 这就提示说语法错误了，那是那里出错了呢？试试了试在 Preact 的 index 页面打印 \u003ccode\u003econsole.log(\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;)\u003c/code\u003e，代码却能够正常跑起来，而且 \u003ccode\u003econsole.log(typeof \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;)\u003c/code\u003e 居然是 \u003ccode\u003e'object'\u003c/code\u003e 奇了怪了？\u003c/p\u003e\n\u003cp\u003e难道两处代码是不一样的？难不成 Preact 做了什么特别处理？随查看 Preact 的源码，但是没有任何迹象，传入的参数根本就没有做什么处理，而且传进来马上就会语法错误了，怎么可能执行呢？\u003c/p\u003e\n\u003cp\u003e最后打开控制台，查看 Sources 的打包文件，发现原来 \u003ccode\u003econsole.log(typeof \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;)\u003c/code\u003e 变成了下面：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(_typeof((\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, _preact.h)(\u003cspan class=\"hljs-string\"\u003e'div'\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e)));\n\n\u003cspan class=\"hljs-comment\"\u003e// 转变一下结果就是\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e preact.h(\u003cspan class=\"hljs-string\"\u003e'div'\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这。。。。。又是为什么呢？中间怎么这么多变化呢？在生成的代码阶段就不是简单的 \u003ccode\u003ediv\u003c/code\u003e 了，那是哪里发生的呢？忽然想起以前讲 webpack 介绍的 Babel 降级问题，难道这里也是？查看 Babel 的配置文件 .babelrc，如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e{\n  \u003cspan class=\"hljs-string\"\u003e\"presets\"\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"es2015\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"stage-0\"\u003c/span\u003e],\n  \u003cspan class=\"hljs-string\"\u003e\"plugins\"\u003c/span\u003e: [\n  [\u003cspan class=\"hljs-string\"\u003e\"transform-react-jsx\"\u003c/span\u003e, { \u003cspan class=\"hljs-string\"\u003e\"pragma\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"h\"\u003c/span\u003e }]\n  ]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e看看下面的配置，在看看转义的那句话，这不就是将 jsx 用 h 程序转变的意思吗？在 package.json 里面也看到了 \u003ccode\u003ebabel-plugin-transform-react-jsx\u003c/code\u003e，这个包是用于将 JSX 转换为 React 函数，用法则是在 \u003ccode\u003e.babelrc\u003c/code\u003e 里面设置 \u003ccode\u003e\u0026quot;pragma\u0026quot;: \u0026quot;dom\u0026quot;\u003c/code\u003e，后者是替换的函数名字，默认是 \u003ccode\u003eReact.createElement\u003c/code\u003e，而在 Preact 中则需要设置为 h 函数。官网里面也有介绍到对于 Babel 5 和 Babel 6 的设置。\u003c/p\u003e\n\u003ch2\u003eh 函数\u003c/h2\u003e\n\u003cp\u003e上文中的 \u003ccode\u003ediv\u003c/code\u003e 变成了 h 函数的实现，h 函数在 Vue 里面也经常可以看到，更不要提 React，那 \u003ccode\u003eh\u003c/code\u003e 函数是什么呢？\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eh\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enodeName, attributes\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e children=EMPTY_CHILDREN, lastSimple, child, simple, i;\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (i=\u003cspan class=\"hljs-built_in\"\u003earguments\u003c/span\u003e.length; i-- \u0026gt; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e; ) {\n    stack.push(\u003cspan class=\"hljs-built_in\"\u003earguments\u003c/span\u003e[i]);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (attributes \u0026amp;\u0026amp; attributes.children!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!stack.length) stack.push(attributes.children);\n    \u003cspan class=\"hljs-keyword\"\u003edelete\u003c/span\u003e attributes.children;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 存在子节点，如text节点或者其他h函数\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (stack.length) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ((child = stack.pop()) \u0026amp;\u0026amp; child.pop!==\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (i=child.length; i--; ) stack.push(child[i]);\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e child===\u003cspan class=\"hljs-string\"\u003e'boolean'\u003c/span\u003e) child = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ((simple = \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e nodeName!==\u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e)) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (child==\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) child = \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e;\n        \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e child===\u003cspan class=\"hljs-string\"\u003e'number'\u003c/span\u003e) child = \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e(child);\n        \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e child!==\u003cspan class=\"hljs-string\"\u003e'string'\u003c/span\u003e) simple = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n      }\n    \u003cspan class=\"hljs-comment\"\u003e// 最终子节点都会推入children里面\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 而对于简单节点则直接相加就好了\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (simple \u0026amp;\u0026amp; lastSimple) {\n        children[children.length\u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e] += child;\n      }\n      \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (children===EMPTY_CHILDREN) {\n        children = [child];\n      }\n      \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        children.push(child);\n      }\n\n      lastSimple = simple;\n    }\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// p就是最终生成的 Vnode\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e p = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e VNode();\n  p.nodeName = nodeName;\n  p.children = children;\n  p.attributes = attributes==\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e ? \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e : attributes;\n  p.key = attributes==\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e ? \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e : attributes.key;\n  \u003cspan class=\"hljs-comment\"\u003e// 对生成的Vnode，都用options的vnode方法来处理\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// if a \"vnode hook\" is defined, pass every created VNode to it\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (options.vnode!==\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e) options.vnode(p);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e p;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eVNode\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码还是很好理解的，下面举个简单例子，对于 \u003ccode\u003eh('DIV', {id: 'abc'}, h('SPAN', null))\u003c/code\u003e 怎会被转换为以下 Vnode：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e{\n  \u003cspan class=\"hljs-attr\"\u003enodeName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'DIV'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eattributes\u003c/span\u003e: {\u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'abc'\u003c/span\u003e},\n  \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: [\n  {\n    \u003cspan class=\"hljs-attr\"\u003enodeName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'SPAN'\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eattributes\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e,\n  }\n  ]\n  \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e : \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 \u003ccode\u003eh\u003c/code\u003e 函数里面的 \u003ccode\u003ewhile\u003c/code\u003e 循环里面做了一件很特别的事情，本来只要将子节点统统 push 到 children 里面就好了，但这里通过相邻节点是否是简单方式 \u003ccode\u003esimple/lastSimple\u003c/code\u003e，若果是数字，字符串等，则直接合并在一起。这样有什么好处呢？减少要 diff 的节点，就是减少计算量，毕竟虚拟 Vnode 里面主要内容也是字符串等简单类型。而 \u003ccode\u003eVNode\u003c/code\u003e 构造函数，则是简单的一个实例而已。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e这里介绍了 VNode 的一些入门东西，但是这是后面学习 diff 机制的基础，也能够清晰知道 Preact 的操作对象不是 Document 上面的节点，而是一个个虚拟的 VNode，\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"March 24, 2021","title":"preact源码 - VDOM","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e在工作上开始用 React 开发已经有四个多月了，不禁想看看 React 和 Vue 本质上有什么区别。当然一个是 jsx 文件，一个是 vue 文件，两个处理起来肯定是不一样的。想了想以后项目发展越来越大，肯定是要以 React 为主体的，深入了解 React 是必须的，尤其是 React 已经发展到 React 16 了，新特性都不晓得怎么用呢。为了减少初学习 React 源码的陡度，想着还是从 Preact 开始好了，毕竟后者声称兼容 React 而且，关键是体积小！\u003c/p\u003e\n\u003ch2\u003eBabel 与 JSX\u003c/h2\u003e\n\u003cp\u003e在进入 Preact 的介绍前，又必须要说说虚拟 DOM，这虚拟 Dom 听着神奇，在 Vue 里面也主角。所以必要介绍一下。\u003c/p\u003e\n\u003cp\u003e在 React 官网的开始学习教程上有下面这段代码\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eReactDOM.render(\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003eHello, world!\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e,\n  \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.getElementById(\u003cspan class=\"hljs-string\"\u003e'root'\u003c/span\u003e)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e刚看到时候可以很明显的发现这是给 \u003ccode\u003eReactDOM.render\u003c/code\u003e 传入两个参数，一个是 H1 标签，一个是 DOM 节点，后者很好理解，就是最平常的获取一个 id 为 root 的 DOM 节点，可是前者又是什么？在 Javascript 的所有类型里面是没有这种东西的，难不成是自己落后了？于是在 Chrome 的控制台里面打印，看一下，来一发 \u003ccode\u003econsole.log(\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;)\u003c/code\u003e，结果立马返回 \u003ccode\u003eUncaught SyntaxError: Unexpected token \u0026lt;\u003c/code\u003e 这就提示说语法错误了，那是那里出错了呢？试试了试在 Preact 的 index 页面打印 \u003ccode\u003econsole.log(\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;)\u003c/code\u003e，代码却能够正常跑起来，而且 \u003ccode\u003econsole.log(typeof \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;)\u003c/code\u003e 居然是 \u003ccode\u003e'object'\u003c/code\u003e 奇了怪了？\u003c/p\u003e\n\u003cp\u003e难道两处代码是不一样的？难不成 Preact 做了什么特别处理？随查看 Preact 的源码，但是没有任何迹象，传入的参数根本就没有做什么处理，而且传进来马上就会语法错误了，怎么可能执行呢？\u003c/p\u003e\n\u003cp\u003e最后打开控制台，查看 Sources 的打包文件，发现原来 \u003ccode\u003econsole.log(typeof \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;)\u003c/code\u003e 变成了下面：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(_typeof((\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, _preact.h)(\u003cspan class=\"hljs-string\"\u003e'div'\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e)));\n\n\u003cspan class=\"hljs-comment\"\u003e// 转变一下结果就是\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e preact.h(\u003cspan class=\"hljs-string\"\u003e'div'\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这。。。。。又是为什么呢？中间怎么这么多变化呢？在生成的代码阶段就不是简单的 \u003ccode\u003ediv\u003c/code\u003e 了，那是哪里发生的呢？忽然想起以前讲 webpack 介绍的 Babel 降级问题，难道这里也是？查看 Babel 的配置文件 .babelrc，如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e{\n  \u003cspan class=\"hljs-string\"\u003e\"presets\"\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"es2015\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"stage-0\"\u003c/span\u003e],\n  \u003cspan class=\"hljs-string\"\u003e\"plugins\"\u003c/span\u003e: [\n  [\u003cspan class=\"hljs-string\"\u003e\"transform-react-jsx\"\u003c/span\u003e, { \u003cspan class=\"hljs-string\"\u003e\"pragma\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"h\"\u003c/span\u003e }]\n  ]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e看看下面的配置，在看看转义的那句话，这不就是将 jsx 用 h 程序转变的意思吗？在 package.json 里面也看到了 \u003ccode\u003ebabel-plugin-transform-react-jsx\u003c/code\u003e，这个包是用于将 JSX 转换为 React 函数，用法则是在 \u003ccode\u003e.babelrc\u003c/code\u003e 里面设置 \u003ccode\u003e\u0026quot;pragma\u0026quot;: \u0026quot;dom\u0026quot;\u003c/code\u003e，后者是替换的函数名字，默认是 \u003ccode\u003eReact.createElement\u003c/code\u003e，而在 Preact 中则需要设置为 h 函数。官网里面也有介绍到对于 Babel 5 和 Babel 6 的设置。\u003c/p\u003e\n\u003ch2\u003eh 函数\u003c/h2\u003e\n\u003cp\u003e上文中的 \u003ccode\u003ediv\u003c/code\u003e 变成了 h 函数的实现，h 函数在 Vue 里面也经常可以看到，更不要提 React，那 \u003ccode\u003eh\u003c/code\u003e 函数是什么呢？\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eh\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enodeName, attributes\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e children=EMPTY_CHILDREN, lastSimple, child, simple, i;\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (i=\u003cspan class=\"hljs-built_in\"\u003earguments\u003c/span\u003e.length; i-- \u0026gt; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e; ) {\n    stack.push(\u003cspan class=\"hljs-built_in\"\u003earguments\u003c/span\u003e[i]);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (attributes \u0026amp;\u0026amp; attributes.children!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!stack.length) stack.push(attributes.children);\n    \u003cspan class=\"hljs-keyword\"\u003edelete\u003c/span\u003e attributes.children;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 存在子节点，如text节点或者其他h函数\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (stack.length) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ((child = stack.pop()) \u0026amp;\u0026amp; child.pop!==\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (i=child.length; i--; ) stack.push(child[i]);\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e child===\u003cspan class=\"hljs-string\"\u003e'boolean'\u003c/span\u003e) child = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ((simple = \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e nodeName!==\u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e)) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (child==\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) child = \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e;\n        \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e child===\u003cspan class=\"hljs-string\"\u003e'number'\u003c/span\u003e) child = \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e(child);\n        \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e child!==\u003cspan class=\"hljs-string\"\u003e'string'\u003c/span\u003e) simple = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n      }\n    \u003cspan class=\"hljs-comment\"\u003e// 最终子节点都会推入children里面\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 而对于简单节点则直接相加就好了\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (simple \u0026amp;\u0026amp; lastSimple) {\n        children[children.length\u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e] += child;\n      }\n      \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (children===EMPTY_CHILDREN) {\n        children = [child];\n      }\n      \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        children.push(child);\n      }\n\n      lastSimple = simple;\n    }\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// p就是最终生成的 Vnode\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e p = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e VNode();\n  p.nodeName = nodeName;\n  p.children = children;\n  p.attributes = attributes==\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e ? \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e : attributes;\n  p.key = attributes==\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e ? \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e : attributes.key;\n  \u003cspan class=\"hljs-comment\"\u003e// 对生成的Vnode，都用options的vnode方法来处理\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// if a \"vnode hook\" is defined, pass every created VNode to it\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (options.vnode!==\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e) options.vnode(p);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e p;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eVNode\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码还是很好理解的，下面举个简单例子，对于 \u003ccode\u003eh('DIV', {id: 'abc'}, h('SPAN', null))\u003c/code\u003e 怎会被转换为以下 Vnode：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e{\n  \u003cspan class=\"hljs-attr\"\u003enodeName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'DIV'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eattributes\u003c/span\u003e: {\u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'abc'\u003c/span\u003e},\n  \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: [\n  {\n    \u003cspan class=\"hljs-attr\"\u003enodeName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'SPAN'\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eattributes\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e,\n  }\n  ]\n  \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e : \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 \u003ccode\u003eh\u003c/code\u003e 函数里面的 \u003ccode\u003ewhile\u003c/code\u003e 循环里面做了一件很特别的事情，本来只要将子节点统统 push 到 children 里面就好了，但这里通过相邻节点是否是简单方式 \u003ccode\u003esimple/lastSimple\u003c/code\u003e，若果是数字，字符串等，则直接合并在一起。这样有什么好处呢？减少要 diff 的节点，就是减少计算量，毕竟虚拟 Vnode 里面主要内容也是字符串等简单类型。而 \u003ccode\u003eVNode\u003c/code\u003e 构造函数，则是简单的一个实例而已。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e这里介绍了 VNode 的一些入门东西，但是这是后面学习 diff 机制的基础，也能够清晰知道 Preact 的操作对象不是 Document 上面的节点，而是一个个虚拟的 VNode，\u003c/p\u003e\n"}},"buildId":"r4Ww0YLm8YL5~6SwciWHH","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" async=""></script></body></html>