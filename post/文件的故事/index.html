<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">文件的故事</title><link rel="preload" href="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.ce3e8fb7a689beb447ad.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.8d98f9151bcde6fb2a87.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-45be5a1f94c3fe5df8ee.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.bb30b296.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___3Hk0c "><a class="logo___1KD30" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___1qXLb" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___3VKNp"><h1 class="postTitle___26vXM">文件的故事</h1><span class="postTime___16Ish">July 7, 2018</span></header><article class="postWrapper___3NXol post-article"><div><h2>前言</h2>
<p>项目中遇到的文件下载，上传基本上最常见的事情了。大概半年前，需要实现某表单的查询下载功能，查询还好，只要后端返回数据，我负责展示就好了，但是下载要如何实现呢？用axios的GET请求返回的数据，不忍直视，根本就下载不了。一顿百度谷歌之后，哦，原来这么简单，只要一个<code>window.location.href=url</code>就搞定了，是不是很简单~</p>
<h2>文件下载</h2>
<p>后来的文件下载我都统统用这种方式，只是下载提示不够明显，后来改为<code>window.open</code>打开个新的tag页，然后自动关闭，明显点下载。好像到这里就已经很完美，一切交给浏览器解决。</p>
<p>直到开始node.js中间层搭建。中间层的功能负责连接前后端，接口还是由后端提供的，具体可以参考<a href="http://2014.jsconf.cn/slides/herman-taobaoweb/index.html#/" target="_blank">淘宝前后端分离实践</a>，以及天猪大神的<a href="https://github.com/atian25/blog/blob/master/assets/files/egg%20-%20JSConf%20China%202016.pdf" target="_blank">egg - JSConf China 2016</a>。node.js端用的是egg.js，小公司用它还是很顺心的。平常的API接口还好，只用转发到对应的后端接口就好了，但是文件下载怎么办？难不成我也要在node.js里面写个<code>window.open</code>？滑稽可笑。</p>
<p>这个时候又回到了请求上面，客户端自然还是用<code>window.open</code>，而nodejs端获得文件流再返回给客户端，这样<code>window.open</code>才能用。于是在本地测试了一下，用<code>fs.readFile</code>以及<code>fs.createReadStream</code>的方式都可以返回给客户端，但是下载文件类型却是没有的，几经波折后才发现没有设置<code>Content-disposition</code>，<code>Content-Disposition</code>消息头指示回复的内容该以何种形式展示，是以内联的形式（即网页或者页面的一部分），还是以附件的形式下载并保存到本地，用上koa2的<code>attachment(fileName)</code>方法更是简单，那这个不就迎刃而解了？
这里测试的只是本地的文件流，那后端接口上的文件流呢？这里还是用<code>ctx.curl</code>方法来请求获取数据，只是需要注意的是curl的设置响应数据格式，不是之前的RESTful的API接口-json交流方式了，而是文件流，所以默认不设置dataType就好了。代码如下：</p>
<pre class="hljs"><code><span class="hljs-keyword">async</span> download() {
  <span class="hljs-keyword">const</span> { ctx, app } = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">let</span> data = {};
  <span class="hljs-keyword">try</span> {
    data = <span class="hljs-keyword">await</span> ctx.curl(url, {
      <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
      <span class="hljs-attr">headers</span>: {},
      <span class="hljs-attr">timeout</span>: <span class="hljs-number">8000</span>,
    });
  } <span class="hljs-keyword">catch</span>(e) {
    data = {
      <span class="hljs-attr">status</span>: <span class="hljs-number">404</span>,
      <span class="hljs-attr">data</span>: {<span class="hljs-attr">msg</span>:<span class="hljs-string">'服务访问出错'</span>}
    }
  }    
  ctx.status = data.status || <span class="hljs-number">404</span>;
  ctx.set(data.headers || {});
  ctx.body = data.data;
}
</code></pre>
<h3>客户端的文件下载</h3>
<p>之前在客户端表格导出不是用<code>window.location.href=url</code>就是用<code>window.open(url)</code>，这个方法感觉很土，当然还有更土的就是用a标签，动态修改里面的href，<code>&lt;a href=&quot;url&quot; target=&quot;_blank&quot;&gt;导出&lt;/a&gt;</code>一般这种才是最常见的吧，可惜url需要一直修改。那有没有正常的用请求接口的方式来下载文件呢？
答案是有的，</p>
<pre class="hljs"><code>fetch(<span class="hljs-string">'/download'</span>).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> { 
  <span class="hljs-keyword">return</span> response.blob().then(<span class="hljs-function">(<span class="hljs-params">blob</span>) =&gt;</span> {
    <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'a'</span>);
    <span class="hljs-keyword">var</span> url = <span class="hljs-built_in">window</span>.URL.createObjectURL(blob);
    <span class="hljs-keyword">var</span> filename = response.headers.get(<span class="hljs-string">'Content-Disposition'</span>);
    a.href = url;
    a.download = filename;
    a.click();
    <span class="hljs-built_in">window</span>.URL.revokeObjectURL(url);       
  })
});
</code></pre>
<p>这个好像那里看到过，不就是创建了个a标签，再点击下载嘛。。。。还不如直接用a标签方便的多！！而且这里还用到了HTML5的download属性，还有blob对象，实在是麻烦。另外如果接口返回的不是文本流，而是json的话，就不用blob，直接用返回的url作为href，来click就好了。
这么看来用接口的形式来下载文件似乎很笨吧，当然从另外一个角度讲，请求<code>/download</code>接口后可以用js控制很多东西，比如客户端权限认证，而不是一股脑丢给浏览器。</p>
<h2>文件上传</h2>
<p>文件上传也是软肋，毕竟多年来一直没有接触过。。。。以前知道的范围领域也就是input标签可以设置type属性为file，这样就能上传文件了。后来在项目中还真的遇到文件上传的，但是这个时候已经有各种组件了，上来直接是饿了吗element的组件库，又或则是Ant Design的组件，样式又漂亮，根本不需要自己去开发嘛。。。。但是这样真的好吗，之前忙一直没有时间去看，直到了用上了node.js中间层，需要自己来做中转维护。</p>
<h3>客户端实现</h3>
<p>想想只是用<code>&lt;input type=&quot;file&quot; /&gt;</code>要如何实现上传呢，明明这都没有和后端联系上。。。。于是乎只能从饿了吗的代码里面找起来，其实饿了吗和ant design的实现大同小异，只是语言不同罢了。代码如下：</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> upLoad = <span class="hljs-function">(<span class="hljs-params">ev</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> files = <span class="hljs-built_in">Array</span>.prototype.slice.call(ev.target.files);
  <span class="hljs-keyword">let</span> rawFile = files[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> FormData();
  <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();

  formData.append(<span class="hljs-string">'file'</span>, rawFile);
  <span class="hljs-keyword">if</span> (xhr.upload) {
    xhr.upload.onprogress = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">progress</span>(<span class="hljs-params">e</span>) </span>{
      <span class="hljs-keyword">if</span> (e.total &gt; <span class="hljs-number">0</span>) {
        e.percent = e.loaded / e.total * <span class="hljs-number">100</span>;
      }
    };
  }
  xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onload</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (xhr.status &lt; <span class="hljs-number">200</span> || xhr.status &gt;= <span class="hljs-number">300</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'wrong'</span>);
    }

    <span class="hljs-comment">// onSuccess(getBody(xhr));</span>
  }
  xhr.open(<span class="hljs-string">'post'</span>, <span class="hljs-string">'/action?_csrf=VNPzCPKhQRs4eYhoCjFQgwQh'</span>, <span class="hljs-literal">true</span>);  
  xhr.send(formData);
}
</code></pre>
<p>上传的文件到哪里了？<code>ev.target.files</code>里面就是上传的文件数组，获取到上传文件的对象，再添加到<code>FormData</code>里面。<code>FormData</code>又是何物？带着一脸懵逼又去一顿百度谷歌，<code>FormData</code>是用XMLHttpRequest发送请求的键/值对，当然这也意味着是表单传输<code>multipart/form-data</code>的形式。如果你想要传入参数，只需要<code>formData.append(key, value)</code>就可以了。上面代码中自然是用<code>formData.append('file', rawFile)</code>，紧接着用了<code>xhr.open</code>和<code>xhr.send</code>方法，开眼界了，原来<code>xhr.send</code>里面可以带参数的。。。。文件的键名是<code>file</code>。
可以看出上面的处理方式直接用的是XMLHttpRequest 2.0，那为什么不用fetch呢？fetch不应该是未来趋势吗？想来这里有兼容问题，另外一点fetch上传文件好像没有进度条一说，只是<code>Response.body</code>有getReader方法用于读取原始字节流，如此来解决进度条问题<a href="http://louiszhai.github.io/2016/11/02/fetch/#progress" target="_blank">Fetch进阶指南</a>，以及XMLHttpRequestabort方法取消对象，也是fetch不能媲美的。</p>
<h3>node.js端实现</h3>
<p>node.js端的实现就曲折多了，为了获得上传的文件，用了官方的示例里面的方法<code>ctx.getFileStream()</code>，获得了文件流之后，再在官网介绍的<code>httpclient</code>里面有示例，用到了苏大神的<code>formstream</code>模块，生成可以被<code>httpclient</code>消费的stream对象，如下：</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> fileStream = <span class="hljs-keyword">await</span> ctx.getFileStream();
<span class="hljs-keyword">const</span> form = <span class="hljs-keyword">new</span> FormStream();
form.stream(<span class="hljs-string">'file'</span>, fileStream, fileStream.filename);
data = <span class="hljs-keyword">await</span> ctx.curl(url, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
  <span class="hljs-attr">headers</span>: form.headers({
      <span class="hljs-attr">Cookie</span>: <span class="hljs-string">'cookieHere'</span>,
  }),
  <span class="hljs-comment">// contentType: 'multipart/form-data',</span>
  stream: form,
  <span class="hljs-attr">dataType</span>: <span class="hljs-string">'json'</span>,
}) 
</code></pre>
<p>看着简单，但是刚开始弄的时候却一脸懵逼，不知道如何是好，尤其是添加cookie的时候，由于没有用到<code>form.headers</code>，文件上传一直有问题，没有依据rfc1867, <code>multipart/form-data</code>是必须的，同时最重要的是分隔符！！<code>boundary=</code>这个在headers中是一定要加上的。
看了苏大神的<code>FormStream</code>里面，才发现原来这是模拟浏览器文件上传的动作，添加<code>leading</code>再添加stream/buffer，是个不错的npm模块，值得学习。
知道<code>FormStream</code>了，那<code>ctx.getFileStream()</code>又是如何获得stream对象呢，一开始以为是egg中ctx自带的方法，后来查了api指南才知道是egg-multipart模块引入的。但是egg-multipart核心部分其实是基于Busboy模块的。Busboy是个好东西，其安装量也是杠杠的。Busboy是用来解析node.js里接受到的<code>form-data</code>请求，这里egg-multipart用到的代码大致如下；</p>
<pre class="hljs"><code>busboy.on(<span class="hljs-string">'file'</span>, onFile)
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onFile</span>(<span class="hljs-params">fieldname, file, filename, encoding, mimetype</span>) </span>{
  <span class="hljs-keyword">if</span> (checkFile) {
    <span class="hljs-keyword">var</span> err = checkFile(fieldname, file, filename, encoding, mimetype)
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-comment">// make sure request stream's data has been read</span>
      <span class="hljs-keyword">var</span> blackHoleStream = <span class="hljs-keyword">new</span> BlackHoleStream()
      file.pipe(blackHoleStream)
      <span class="hljs-keyword">return</span> onError(err)
    }
  }

  <span class="hljs-comment">// opinionated, but 5 arguments is ridiculous</span>
  file.fieldname = fieldname
  file.filename = filename
  file.transferEncoding = file.encoding = encoding
  file.mimeType = file.mime = mimetype
  ch(file)
}
request.pipe(busboy)
</code></pre>
<p>通过pipe，busboy会触发file事件，同时传入file参数，也就是一个可读流<code>ReadableStream.call(this, opts)</code>。对于这个可读流，可以直接<code>file.pipe(fs.createWriteStream(saveTo))</code>将文件保存到本地磁盘，也可以再度转手如<code>ctx.getFileStream()</code>。关于busboy模块还是自己多玩玩比较好。</p>
<h2>总结</h2>
<p>文件下载上传对于大多数JSer可能都不陌生，但是于我却是刚刚开始，犹如打开了新技能，同时也知道了postman里面的文件上传key值是file，所以想梳理api，总结一下文件相关部分。</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"July 7, 2018","title":"文件的故事","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e项目中遇到的文件下载，上传基本上最常见的事情了。大概半年前，需要实现某表单的查询下载功能，查询还好，只要后端返回数据，我负责展示就好了，但是下载要如何实现呢？用axios的GET请求返回的数据，不忍直视，根本就下载不了。一顿百度谷歌之后，哦，原来这么简单，只要一个\u003ccode\u003ewindow.location.href=url\u003c/code\u003e就搞定了，是不是很简单~\u003c/p\u003e\n\u003ch2\u003e文件下载\u003c/h2\u003e\n\u003cp\u003e后来的文件下载我都统统用这种方式，只是下载提示不够明显，后来改为\u003ccode\u003ewindow.open\u003c/code\u003e打开个新的tag页，然后自动关闭，明显点下载。好像到这里就已经很完美，一切交给浏览器解决。\u003c/p\u003e\n\u003cp\u003e直到开始node.js中间层搭建。中间层的功能负责连接前后端，接口还是由后端提供的，具体可以参考\u003ca href=\"http://2014.jsconf.cn/slides/herman-taobaoweb/index.html#/\" target=\"_blank\"\u003e淘宝前后端分离实践\u003c/a\u003e，以及天猪大神的\u003ca href=\"https://github.com/atian25/blog/blob/master/assets/files/egg%20-%20JSConf%20China%202016.pdf\" target=\"_blank\"\u003eegg - JSConf China 2016\u003c/a\u003e。node.js端用的是egg.js，小公司用它还是很顺心的。平常的API接口还好，只用转发到对应的后端接口就好了，但是文件下载怎么办？难不成我也要在node.js里面写个\u003ccode\u003ewindow.open\u003c/code\u003e？滑稽可笑。\u003c/p\u003e\n\u003cp\u003e这个时候又回到了请求上面，客户端自然还是用\u003ccode\u003ewindow.open\u003c/code\u003e，而nodejs端获得文件流再返回给客户端，这样\u003ccode\u003ewindow.open\u003c/code\u003e才能用。于是在本地测试了一下，用\u003ccode\u003efs.readFile\u003c/code\u003e以及\u003ccode\u003efs.createReadStream\u003c/code\u003e的方式都可以返回给客户端，但是下载文件类型却是没有的，几经波折后才发现没有设置\u003ccode\u003eContent-disposition\u003c/code\u003e，\u003ccode\u003eContent-Disposition\u003c/code\u003e消息头指示回复的内容该以何种形式展示，是以内联的形式（即网页或者页面的一部分），还是以附件的形式下载并保存到本地，用上koa2的\u003ccode\u003eattachment(fileName)\u003c/code\u003e方法更是简单，那这个不就迎刃而解了？\n这里测试的只是本地的文件流，那后端接口上的文件流呢？这里还是用\u003ccode\u003ectx.curl\u003c/code\u003e方法来请求获取数据，只是需要注意的是curl的设置响应数据格式，不是之前的RESTful的API接口-json交流方式了，而是文件流，所以默认不设置dataType就好了。代码如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e download() {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { ctx, app } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e data = {};\n  \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n    data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e ctx.curl(url, {\n      \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'GET'\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: {},\n      \u003cspan class=\"hljs-attr\"\u003etimeout\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e8000\u003c/span\u003e,\n    });\n  } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e(e) {\n    data = {\n      \u003cspan class=\"hljs-attr\"\u003estatus\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e404\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: {\u003cspan class=\"hljs-attr\"\u003emsg\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e'服务访问出错'\u003c/span\u003e}\n    }\n  }    \n  ctx.status = data.status || \u003cspan class=\"hljs-number\"\u003e404\u003c/span\u003e;\n  ctx.set(data.headers || {});\n  ctx.body = data.data;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e客户端的文件下载\u003c/h3\u003e\n\u003cp\u003e之前在客户端表格导出不是用\u003ccode\u003ewindow.location.href=url\u003c/code\u003e就是用\u003ccode\u003ewindow.open(url)\u003c/code\u003e，这个方法感觉很土，当然还有更土的就是用a标签，动态修改里面的href，\u003ccode\u003e\u0026lt;a href=\u0026quot;url\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;导出\u0026lt;/a\u0026gt;\u003c/code\u003e一般这种才是最常见的吧，可惜url需要一直修改。那有没有正常的用请求接口的方式来下载文件呢？\n答案是有的，\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003efetch(\u003cspan class=\"hljs-string\"\u003e'/download'\u003c/span\u003e).then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e) =\u0026gt;\u003c/span\u003e { \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response.blob().then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eblob\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e a = \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.createElement(\u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e url = \u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e.URL.createObjectURL(blob);\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e filename = response.headers.get(\u003cspan class=\"hljs-string\"\u003e'Content-Disposition'\u003c/span\u003e);\n    a.href = url;\n    a.download = filename;\n    a.click();\n    \u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e.URL.revokeObjectURL(url);       \n  })\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个好像那里看到过，不就是创建了个a标签，再点击下载嘛。。。。还不如直接用a标签方便的多！！而且这里还用到了HTML5的download属性，还有blob对象，实在是麻烦。另外如果接口返回的不是文本流，而是json的话，就不用blob，直接用返回的url作为href，来click就好了。\n这么看来用接口的形式来下载文件似乎很笨吧，当然从另外一个角度讲，请求\u003ccode\u003e/download\u003c/code\u003e接口后可以用js控制很多东西，比如客户端权限认证，而不是一股脑丢给浏览器。\u003c/p\u003e\n\u003ch2\u003e文件上传\u003c/h2\u003e\n\u003cp\u003e文件上传也是软肋，毕竟多年来一直没有接触过。。。。以前知道的范围领域也就是input标签可以设置type属性为file，这样就能上传文件了。后来在项目中还真的遇到文件上传的，但是这个时候已经有各种组件了，上来直接是饿了吗element的组件库，又或则是Ant Design的组件，样式又漂亮，根本不需要自己去开发嘛。。。。但是这样真的好吗，之前忙一直没有时间去看，直到了用上了node.js中间层，需要自己来做中转维护。\u003c/p\u003e\n\u003ch3\u003e客户端实现\u003c/h3\u003e\n\u003cp\u003e想想只是用\u003ccode\u003e\u0026lt;input type=\u0026quot;file\u0026quot; /\u0026gt;\u003c/code\u003e要如何实现上传呢，明明这都没有和后端联系上。。。。于是乎只能从饿了吗的代码里面找起来，其实饿了吗和ant design的实现大同小异，只是语言不同罢了。代码如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e upLoad = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eev\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e files = \u003cspan class=\"hljs-built_in\"\u003eArray\u003c/span\u003e.prototype.slice.call(ev.target.files);\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e rawFile = files[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e];\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e formData = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e FormData();\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e xhr = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e XMLHttpRequest();\n\n  formData.append(\u003cspan class=\"hljs-string\"\u003e'file'\u003c/span\u003e, rawFile);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (xhr.upload) {\n    xhr.upload.onprogress = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eprogress\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) \u003c/span\u003e{\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (e.total \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n        e.percent = e.loaded / e.total * \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e;\n      }\n    };\n  }\n  xhr.onload = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eonload\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (xhr.status \u0026lt; \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e || xhr.status \u0026gt;= \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'wrong'\u003c/span\u003e);\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// onSuccess(getBody(xhr));\u003c/span\u003e\n  }\n  xhr.open(\u003cspan class=\"hljs-string\"\u003e'post'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'/action?_csrf=VNPzCPKhQRs4eYhoCjFQgwQh'\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);  \n  xhr.send(formData);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上传的文件到哪里了？\u003ccode\u003eev.target.files\u003c/code\u003e里面就是上传的文件数组，获取到上传文件的对象，再添加到\u003ccode\u003eFormData\u003c/code\u003e里面。\u003ccode\u003eFormData\u003c/code\u003e又是何物？带着一脸懵逼又去一顿百度谷歌，\u003ccode\u003eFormData\u003c/code\u003e是用XMLHttpRequest发送请求的键/值对，当然这也意味着是表单传输\u003ccode\u003emultipart/form-data\u003c/code\u003e的形式。如果你想要传入参数，只需要\u003ccode\u003eformData.append(key, value)\u003c/code\u003e就可以了。上面代码中自然是用\u003ccode\u003eformData.append('file', rawFile)\u003c/code\u003e，紧接着用了\u003ccode\u003exhr.open\u003c/code\u003e和\u003ccode\u003exhr.send\u003c/code\u003e方法，开眼界了，原来\u003ccode\u003exhr.send\u003c/code\u003e里面可以带参数的。。。。文件的键名是\u003ccode\u003efile\u003c/code\u003e。\n可以看出上面的处理方式直接用的是XMLHttpRequest 2.0，那为什么不用fetch呢？fetch不应该是未来趋势吗？想来这里有兼容问题，另外一点fetch上传文件好像没有进度条一说，只是\u003ccode\u003eResponse.body\u003c/code\u003e有getReader方法用于读取原始字节流，如此来解决进度条问题\u003ca href=\"http://louiszhai.github.io/2016/11/02/fetch/#progress\" target=\"_blank\"\u003eFetch进阶指南\u003c/a\u003e，以及XMLHttpRequestabort方法取消对象，也是fetch不能媲美的。\u003c/p\u003e\n\u003ch3\u003enode.js端实现\u003c/h3\u003e\n\u003cp\u003enode.js端的实现就曲折多了，为了获得上传的文件，用了官方的示例里面的方法\u003ccode\u003ectx.getFileStream()\u003c/code\u003e，获得了文件流之后，再在官网介绍的\u003ccode\u003ehttpclient\u003c/code\u003e里面有示例，用到了苏大神的\u003ccode\u003eformstream\u003c/code\u003e模块，生成可以被\u003ccode\u003ehttpclient\u003c/code\u003e消费的stream对象，如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fileStream = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e ctx.getFileStream();\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e form = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e FormStream();\nform.stream(\u003cspan class=\"hljs-string\"\u003e'file'\u003c/span\u003e, fileStream, fileStream.filename);\ndata = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e ctx.curl(url, {\n  \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: form.headers({\n      \u003cspan class=\"hljs-attr\"\u003eCookie\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'cookieHere'\u003c/span\u003e,\n  }),\n  \u003cspan class=\"hljs-comment\"\u003e// contentType: 'multipart/form-data',\u003c/span\u003e\n  stream: form,\n  \u003cspan class=\"hljs-attr\"\u003edataType\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'json'\u003c/span\u003e,\n}) \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e看着简单，但是刚开始弄的时候却一脸懵逼，不知道如何是好，尤其是添加cookie的时候，由于没有用到\u003ccode\u003eform.headers\u003c/code\u003e，文件上传一直有问题，没有依据rfc1867, \u003ccode\u003emultipart/form-data\u003c/code\u003e是必须的，同时最重要的是分隔符！！\u003ccode\u003eboundary=\u003c/code\u003e这个在headers中是一定要加上的。\n看了苏大神的\u003ccode\u003eFormStream\u003c/code\u003e里面，才发现原来这是模拟浏览器文件上传的动作，添加\u003ccode\u003eleading\u003c/code\u003e再添加stream/buffer，是个不错的npm模块，值得学习。\n知道\u003ccode\u003eFormStream\u003c/code\u003e了，那\u003ccode\u003ectx.getFileStream()\u003c/code\u003e又是如何获得stream对象呢，一开始以为是egg中ctx自带的方法，后来查了api指南才知道是egg-multipart模块引入的。但是egg-multipart核心部分其实是基于Busboy模块的。Busboy是个好东西，其安装量也是杠杠的。Busboy是用来解析node.js里接受到的\u003ccode\u003eform-data\u003c/code\u003e请求，这里egg-multipart用到的代码大致如下；\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003ebusboy.on(\u003cspan class=\"hljs-string\"\u003e'file'\u003c/span\u003e, onFile)\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eonFile\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efieldname, file, filename, encoding, mimetype\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (checkFile) {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e err = checkFile(fieldname, file, filename, encoding, mimetype)\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (err) {\n      \u003cspan class=\"hljs-comment\"\u003e// make sure request stream's data has been read\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e blackHoleStream = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e BlackHoleStream()\n      file.pipe(blackHoleStream)\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e onError(err)\n    }\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// opinionated, but 5 arguments is ridiculous\u003c/span\u003e\n  file.fieldname = fieldname\n  file.filename = filename\n  file.transferEncoding = file.encoding = encoding\n  file.mimeType = file.mime = mimetype\n  ch(file)\n}\nrequest.pipe(busboy)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过pipe，busboy会触发file事件，同时传入file参数，也就是一个可读流\u003ccode\u003eReadableStream.call(this, opts)\u003c/code\u003e。对于这个可读流，可以直接\u003ccode\u003efile.pipe(fs.createWriteStream(saveTo))\u003c/code\u003e将文件保存到本地磁盘，也可以再度转手如\u003ccode\u003ectx.getFileStream()\u003c/code\u003e。关于busboy模块还是自己多玩玩比较好。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e文件下载上传对于大多数JSer可能都不陌生，但是于我却是刚刚开始，犹如打开了新技能，同时也知道了postman里面的文件上传key值是file，所以想梳理api，总结一下文件相关部分。\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"July 7, 2018","title":"文件的故事","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e项目中遇到的文件下载，上传基本上最常见的事情了。大概半年前，需要实现某表单的查询下载功能，查询还好，只要后端返回数据，我负责展示就好了，但是下载要如何实现呢？用axios的GET请求返回的数据，不忍直视，根本就下载不了。一顿百度谷歌之后，哦，原来这么简单，只要一个\u003ccode\u003ewindow.location.href=url\u003c/code\u003e就搞定了，是不是很简单~\u003c/p\u003e\n\u003ch2\u003e文件下载\u003c/h2\u003e\n\u003cp\u003e后来的文件下载我都统统用这种方式，只是下载提示不够明显，后来改为\u003ccode\u003ewindow.open\u003c/code\u003e打开个新的tag页，然后自动关闭，明显点下载。好像到这里就已经很完美，一切交给浏览器解决。\u003c/p\u003e\n\u003cp\u003e直到开始node.js中间层搭建。中间层的功能负责连接前后端，接口还是由后端提供的，具体可以参考\u003ca href=\"http://2014.jsconf.cn/slides/herman-taobaoweb/index.html#/\" target=\"_blank\"\u003e淘宝前后端分离实践\u003c/a\u003e，以及天猪大神的\u003ca href=\"https://github.com/atian25/blog/blob/master/assets/files/egg%20-%20JSConf%20China%202016.pdf\" target=\"_blank\"\u003eegg - JSConf China 2016\u003c/a\u003e。node.js端用的是egg.js，小公司用它还是很顺心的。平常的API接口还好，只用转发到对应的后端接口就好了，但是文件下载怎么办？难不成我也要在node.js里面写个\u003ccode\u003ewindow.open\u003c/code\u003e？滑稽可笑。\u003c/p\u003e\n\u003cp\u003e这个时候又回到了请求上面，客户端自然还是用\u003ccode\u003ewindow.open\u003c/code\u003e，而nodejs端获得文件流再返回给客户端，这样\u003ccode\u003ewindow.open\u003c/code\u003e才能用。于是在本地测试了一下，用\u003ccode\u003efs.readFile\u003c/code\u003e以及\u003ccode\u003efs.createReadStream\u003c/code\u003e的方式都可以返回给客户端，但是下载文件类型却是没有的，几经波折后才发现没有设置\u003ccode\u003eContent-disposition\u003c/code\u003e，\u003ccode\u003eContent-Disposition\u003c/code\u003e消息头指示回复的内容该以何种形式展示，是以内联的形式（即网页或者页面的一部分），还是以附件的形式下载并保存到本地，用上koa2的\u003ccode\u003eattachment(fileName)\u003c/code\u003e方法更是简单，那这个不就迎刃而解了？\n这里测试的只是本地的文件流，那后端接口上的文件流呢？这里还是用\u003ccode\u003ectx.curl\u003c/code\u003e方法来请求获取数据，只是需要注意的是curl的设置响应数据格式，不是之前的RESTful的API接口-json交流方式了，而是文件流，所以默认不设置dataType就好了。代码如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e download() {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { ctx, app } = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e data = {};\n  \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n    data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e ctx.curl(url, {\n      \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'GET'\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: {},\n      \u003cspan class=\"hljs-attr\"\u003etimeout\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e8000\u003c/span\u003e,\n    });\n  } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e(e) {\n    data = {\n      \u003cspan class=\"hljs-attr\"\u003estatus\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e404\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: {\u003cspan class=\"hljs-attr\"\u003emsg\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e'服务访问出错'\u003c/span\u003e}\n    }\n  }    \n  ctx.status = data.status || \u003cspan class=\"hljs-number\"\u003e404\u003c/span\u003e;\n  ctx.set(data.headers || {});\n  ctx.body = data.data;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e客户端的文件下载\u003c/h3\u003e\n\u003cp\u003e之前在客户端表格导出不是用\u003ccode\u003ewindow.location.href=url\u003c/code\u003e就是用\u003ccode\u003ewindow.open(url)\u003c/code\u003e，这个方法感觉很土，当然还有更土的就是用a标签，动态修改里面的href，\u003ccode\u003e\u0026lt;a href=\u0026quot;url\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;导出\u0026lt;/a\u0026gt;\u003c/code\u003e一般这种才是最常见的吧，可惜url需要一直修改。那有没有正常的用请求接口的方式来下载文件呢？\n答案是有的，\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003efetch(\u003cspan class=\"hljs-string\"\u003e'/download'\u003c/span\u003e).then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e) =\u0026gt;\u003c/span\u003e { \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response.blob().then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eblob\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e a = \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.createElement(\u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e url = \u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e.URL.createObjectURL(blob);\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e filename = response.headers.get(\u003cspan class=\"hljs-string\"\u003e'Content-Disposition'\u003c/span\u003e);\n    a.href = url;\n    a.download = filename;\n    a.click();\n    \u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e.URL.revokeObjectURL(url);       \n  })\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个好像那里看到过，不就是创建了个a标签，再点击下载嘛。。。。还不如直接用a标签方便的多！！而且这里还用到了HTML5的download属性，还有blob对象，实在是麻烦。另外如果接口返回的不是文本流，而是json的话，就不用blob，直接用返回的url作为href，来click就好了。\n这么看来用接口的形式来下载文件似乎很笨吧，当然从另外一个角度讲，请求\u003ccode\u003e/download\u003c/code\u003e接口后可以用js控制很多东西，比如客户端权限认证，而不是一股脑丢给浏览器。\u003c/p\u003e\n\u003ch2\u003e文件上传\u003c/h2\u003e\n\u003cp\u003e文件上传也是软肋，毕竟多年来一直没有接触过。。。。以前知道的范围领域也就是input标签可以设置type属性为file，这样就能上传文件了。后来在项目中还真的遇到文件上传的，但是这个时候已经有各种组件了，上来直接是饿了吗element的组件库，又或则是Ant Design的组件，样式又漂亮，根本不需要自己去开发嘛。。。。但是这样真的好吗，之前忙一直没有时间去看，直到了用上了node.js中间层，需要自己来做中转维护。\u003c/p\u003e\n\u003ch3\u003e客户端实现\u003c/h3\u003e\n\u003cp\u003e想想只是用\u003ccode\u003e\u0026lt;input type=\u0026quot;file\u0026quot; /\u0026gt;\u003c/code\u003e要如何实现上传呢，明明这都没有和后端联系上。。。。于是乎只能从饿了吗的代码里面找起来，其实饿了吗和ant design的实现大同小异，只是语言不同罢了。代码如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e upLoad = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eev\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e files = \u003cspan class=\"hljs-built_in\"\u003eArray\u003c/span\u003e.prototype.slice.call(ev.target.files);\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e rawFile = files[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e];\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e formData = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e FormData();\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e xhr = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e XMLHttpRequest();\n\n  formData.append(\u003cspan class=\"hljs-string\"\u003e'file'\u003c/span\u003e, rawFile);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (xhr.upload) {\n    xhr.upload.onprogress = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eprogress\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) \u003c/span\u003e{\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (e.total \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n        e.percent = e.loaded / e.total * \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e;\n      }\n    };\n  }\n  xhr.onload = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eonload\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (xhr.status \u0026lt; \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e || xhr.status \u0026gt;= \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'wrong'\u003c/span\u003e);\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// onSuccess(getBody(xhr));\u003c/span\u003e\n  }\n  xhr.open(\u003cspan class=\"hljs-string\"\u003e'post'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'/action?_csrf=VNPzCPKhQRs4eYhoCjFQgwQh'\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);  \n  xhr.send(formData);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上传的文件到哪里了？\u003ccode\u003eev.target.files\u003c/code\u003e里面就是上传的文件数组，获取到上传文件的对象，再添加到\u003ccode\u003eFormData\u003c/code\u003e里面。\u003ccode\u003eFormData\u003c/code\u003e又是何物？带着一脸懵逼又去一顿百度谷歌，\u003ccode\u003eFormData\u003c/code\u003e是用XMLHttpRequest发送请求的键/值对，当然这也意味着是表单传输\u003ccode\u003emultipart/form-data\u003c/code\u003e的形式。如果你想要传入参数，只需要\u003ccode\u003eformData.append(key, value)\u003c/code\u003e就可以了。上面代码中自然是用\u003ccode\u003eformData.append('file', rawFile)\u003c/code\u003e，紧接着用了\u003ccode\u003exhr.open\u003c/code\u003e和\u003ccode\u003exhr.send\u003c/code\u003e方法，开眼界了，原来\u003ccode\u003exhr.send\u003c/code\u003e里面可以带参数的。。。。文件的键名是\u003ccode\u003efile\u003c/code\u003e。\n可以看出上面的处理方式直接用的是XMLHttpRequest 2.0，那为什么不用fetch呢？fetch不应该是未来趋势吗？想来这里有兼容问题，另外一点fetch上传文件好像没有进度条一说，只是\u003ccode\u003eResponse.body\u003c/code\u003e有getReader方法用于读取原始字节流，如此来解决进度条问题\u003ca href=\"http://louiszhai.github.io/2016/11/02/fetch/#progress\" target=\"_blank\"\u003eFetch进阶指南\u003c/a\u003e，以及XMLHttpRequestabort方法取消对象，也是fetch不能媲美的。\u003c/p\u003e\n\u003ch3\u003enode.js端实现\u003c/h3\u003e\n\u003cp\u003enode.js端的实现就曲折多了，为了获得上传的文件，用了官方的示例里面的方法\u003ccode\u003ectx.getFileStream()\u003c/code\u003e，获得了文件流之后，再在官网介绍的\u003ccode\u003ehttpclient\u003c/code\u003e里面有示例，用到了苏大神的\u003ccode\u003eformstream\u003c/code\u003e模块，生成可以被\u003ccode\u003ehttpclient\u003c/code\u003e消费的stream对象，如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fileStream = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e ctx.getFileStream();\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e form = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e FormStream();\nform.stream(\u003cspan class=\"hljs-string\"\u003e'file'\u003c/span\u003e, fileStream, fileStream.filename);\ndata = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e ctx.curl(url, {\n  \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: form.headers({\n      \u003cspan class=\"hljs-attr\"\u003eCookie\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'cookieHere'\u003c/span\u003e,\n  }),\n  \u003cspan class=\"hljs-comment\"\u003e// contentType: 'multipart/form-data',\u003c/span\u003e\n  stream: form,\n  \u003cspan class=\"hljs-attr\"\u003edataType\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'json'\u003c/span\u003e,\n}) \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e看着简单，但是刚开始弄的时候却一脸懵逼，不知道如何是好，尤其是添加cookie的时候，由于没有用到\u003ccode\u003eform.headers\u003c/code\u003e，文件上传一直有问题，没有依据rfc1867, \u003ccode\u003emultipart/form-data\u003c/code\u003e是必须的，同时最重要的是分隔符！！\u003ccode\u003eboundary=\u003c/code\u003e这个在headers中是一定要加上的。\n看了苏大神的\u003ccode\u003eFormStream\u003c/code\u003e里面，才发现原来这是模拟浏览器文件上传的动作，添加\u003ccode\u003eleading\u003c/code\u003e再添加stream/buffer，是个不错的npm模块，值得学习。\n知道\u003ccode\u003eFormStream\u003c/code\u003e了，那\u003ccode\u003ectx.getFileStream()\u003c/code\u003e又是如何获得stream对象呢，一开始以为是egg中ctx自带的方法，后来查了api指南才知道是egg-multipart模块引入的。但是egg-multipart核心部分其实是基于Busboy模块的。Busboy是个好东西，其安装量也是杠杠的。Busboy是用来解析node.js里接受到的\u003ccode\u003eform-data\u003c/code\u003e请求，这里egg-multipart用到的代码大致如下；\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003ebusboy.on(\u003cspan class=\"hljs-string\"\u003e'file'\u003c/span\u003e, onFile)\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eonFile\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efieldname, file, filename, encoding, mimetype\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (checkFile) {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e err = checkFile(fieldname, file, filename, encoding, mimetype)\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (err) {\n      \u003cspan class=\"hljs-comment\"\u003e// make sure request stream's data has been read\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e blackHoleStream = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e BlackHoleStream()\n      file.pipe(blackHoleStream)\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e onError(err)\n    }\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// opinionated, but 5 arguments is ridiculous\u003c/span\u003e\n  file.fieldname = fieldname\n  file.filename = filename\n  file.transferEncoding = file.encoding = encoding\n  file.mimeType = file.mime = mimetype\n  ch(file)\n}\nrequest.pipe(busboy)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过pipe，busboy会触发file事件，同时传入file参数，也就是一个可读流\u003ccode\u003eReadableStream.call(this, opts)\u003c/code\u003e。对于这个可读流，可以直接\u003ccode\u003efile.pipe(fs.createWriteStream(saveTo))\u003c/code\u003e将文件保存到本地磁盘，也可以再度转手如\u003ccode\u003ectx.getFileStream()\u003c/code\u003e。关于busboy模块还是自己多玩玩比较好。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e文件下载上传对于大多数JSer可能都不陌生，但是于我却是刚刚开始，犹如打开了新技能，同时也知道了postman里面的文件上传key值是file，所以想梳理api，总结一下文件相关部分。\u003c/p\u003e\n"}},"buildId":"I9XlxpmvFk~lmulxmmsMh","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.ce3e8fb7a689beb447ad.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.8d98f9151bcde6fb2a87.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-45be5a1f94c3fe5df8ee.js" async=""></script></body></html>