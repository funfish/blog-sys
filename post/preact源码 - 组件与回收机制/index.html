<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">preact源码 - 组件与回收机制</title><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.587c5e31.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___2dTZ9 "><a class="logo___346dE" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___13XXt" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___29Pln"><h1 class="postTitle___1_m4g">preact源码 - 组件与回收机制</h1><span class="postTime___1x0_i">March 24, 2021</span></header><article class="postWrapper___3jnNg post-article"><div><h3>前言</h3>
<p>前面介绍到 diff 方法，但是我们只是从简单的例子开始的，并没有用到组件，而组件才是最重要的部分，毕竟一切的一切可以是组件。</p>
<h3>组件 Component</h3>
<p>先看看 Preact 输出的 Component 长什么样子：</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component</span>(<span class="hljs-params">props, context</span>) </span>{
  <span class="hljs-keyword">this</span>._dirty = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">this</span>.context = context;
  <span class="hljs-keyword">this</span>.props = props;
  <span class="hljs-keyword">this</span>.state = <span class="hljs-keyword">this</span>.state || {};
}

extend(Component.prototype, {
  setState(state, callback) {
    <span class="hljs-keyword">let</span> s = <span class="hljs-keyword">this</span>.state;
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.prevState) <span class="hljs-keyword">this</span>.prevState = extend({}, s);
    extend(s, <span class="hljs-keyword">typeof</span> state===<span class="hljs-string">'function'</span> ? state(s, <span class="hljs-keyword">this</span>.props) : state);
    <span class="hljs-keyword">if</span> (callback) (<span class="hljs-keyword">this</span>._renderCallbacks = (<span class="hljs-keyword">this</span>._renderCallbacks || [])).push(callback);
    enqueueRender(<span class="hljs-keyword">this</span>);
  },
  forceUpdate(callback) {
    <span class="hljs-keyword">if</span> (callback) (<span class="hljs-keyword">this</span>._renderCallbacks = (<span class="hljs-keyword">this</span>._renderCallbacks || [])).push(callback);
    renderComponent(<span class="hljs-keyword">this</span>, FORCE_RENDER);
  },
  render() {}
});
</code></pre>
<p>平时使用组件的时候，大致都是这样 <code>class Clockwarp extends Component</code> 通过 <code>extends</code> 来实现继承 <code>Component</code>，有点 <code>prototype</code> 的意思。在 <code>Component</code> 类里面有 <code>state/props/setState/render</code>，其中 <code>setState</code> 方法先判断 <code>state</code> 是不是函数，也就是这种写法：<code>this.setSate((preState, props) =&gt; {})</code> 这个时候才会会执行 <code>state</code> 方法，如果有回调，会被 push 到 <code>_renderCallbacks</code> 里面。在看看 <code>enqueueRender</code>:</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> items = [];
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enqueueRender</span>(<span class="hljs-params">component</span>) </span>{
  <span class="hljs-keyword">if</span> (!component._dirty &amp;&amp; (component._dirty = <span class="hljs-literal">true</span>) &amp;&amp; items.push(component)==<span class="hljs-number">1</span>) {
    (options.debounceRendering || defer)(rerender);
  }
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rerender</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> p, list = items;
  items = [];
  <span class="hljs-keyword">while</span> ( (p = list.pop()) ) {
    <span class="hljs-keyword">if</span> (p._dirty) renderComponent(p);
  }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> defer = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Promise</span>==<span class="hljs-string">'function'</span> ? <span class="hljs-built_in">Promise</span>.resolve().then.bind(<span class="hljs-built_in">Promise</span>.resolve()) : setTimeout;
</code></pre>
<p><code>enqueueRender</code> 方法是为了延迟当前的组件的再渲染，采用的是 Promise方法，如果没有就用 <code>setTimeout</code> 代替，当然 <code>Promise.resolve()</code> 之后调用的 <code>then</code> 实现上是要优先于  <code>setTimeout</code> 的。</p>
<h3>组件 diff 机制</h3>
<p>上面代码可以看到 <code>setState/forceUpdate</code> 最后都会调用 <code>renderComponent</code> 方法，看名字就知道是渲染组件的意思，但是在介绍 <code>renderComponent</code> 之前，先看看上篇博客里面介绍的，<code>diff</code> 过程里面，对于组件的处理：</p>
<blockquote>
<ol start="2">
<li>vnode 是 Component的形式，调用 buildComponentFromVNode 方法，最后会返回处理过的 dom 节点。
如若是组件，则会调用 <code>buildComponentFromVNode</code> 方法，而实际上， <code>buildComponentFromVNode</code> 最后也是会调用 <code>renderComponent</code> 方法，所以先看看 <code>buildComponentFromVNode</code> 的实现：</li>
</ol>
</blockquote>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildComponentFromVNode</span>(<span class="hljs-params">dom, vnode, context, mountAll</span>) </span>{
  <span class="hljs-keyword">let</span> c = dom &amp;&amp; dom._component,
    originalComponent = c,
    oldDom = dom,
    isDirectOwner = c &amp;&amp; dom._componentConstructor===vnode.nodeName,
    isOwner = isDirectOwner,
    <span class="hljs-comment">// props就是vnode的attribute/children/nodename.defaultProps</span>
    <span class="hljs-comment">// 传递最新鲜的porps，常见的子组件更新，都是依赖于props变化</span>
    props = getNodeProps(vnode);
  <span class="hljs-keyword">while</span> (c &amp;&amp; !isOwner &amp;&amp; (c=c._parentComponent)) {
    isOwner = c.constructor===vnode.nodeName;
  }
  <span class="hljs-comment">// 如果vnode 和 dom 是由同类的组件生成则直接 setComponentProps，当然还需要!mountAll || c._component 成立。</span>
  <span class="hljs-keyword">if</span> (c &amp;&amp; isOwner &amp;&amp; (!mountAll || c._component)) {
    setComponentProps(c, props, ASYNC_RENDER, context, mountAll);
    dom = c.base;
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// dom由组件生成，而vnode和生成dom的组件实例不是同一构造器生成的。则说明要卸载当前组件，替换上新的。</span>
    <span class="hljs-keyword">if</span> (originalComponent &amp;&amp; !isDirectOwner) {
      unmountComponent(originalComponent);
      dom = oldDom = <span class="hljs-literal">null</span>;
  }
  <span class="hljs-comment">// 根据nodeName生成新的组件 c。</span>
  c = createComponent(vnode.nodeName, props, context);
  <span class="hljs-comment">// 如果该类组件没有卸载过，而存在dom来diff，则将c.nextBase指向dom，后面做diff用</span>
    <span class="hljs-keyword">if</span> (dom &amp;&amp; !c.nextBase) {
      c.nextBase = dom;
      oldDom = <span class="hljs-literal">null</span>;
    }
    setComponentProps(c, props, SYNC_RENDER, context, mountAll);
    dom = c.base;
    <span class="hljs-keyword">if</span> (oldDom &amp;&amp; dom!==oldDom) {
      oldDom._component = <span class="hljs-literal">null</span>;
      recollectNodeTree(oldDom, <span class="hljs-literal">false</span>);
    }
  }
  <span class="hljs-keyword">return</span> dom;
}
</code></pre>
<p><code>buildComponentFromVNode</code> 有几个概念是要分清楚的，如果 <code>dom</code> 是由一个组件生成渲染的，则 <code>dom._component</code> 是指向渲染出 <code>dom</code> 的组件实例。而生成的组件实例的 <code>base</code> 属性又会指向 <code>dom</code> 节点。初次渲染时候会直接是进入下面的 <code>else</code> 语句。对于不同的组件则先卸载之前的组件，让后生成新的组件 <code>c</code>，<code>nextBase</code> 指的是卸载的同类组件的 <code>base</code> 属性，也就是上个该类组件生成的 dom 节点。为什么要这样做呢？答案是提高效率。假设组件替换是这样的 <code>A -&gt; B -&gt;A</code>，在 A 组件卸载的时候，就会将 A 生成的 dom 节点缓存下来，当 B 组件卸载，A 组件再次渲染的时候，这个时候就会用上之前 A 组件生成的 dom 节点，与这次 A 组件渲染出的做 diff对比，这样看是不是很高效？可以看看 <code>createComponnet</code>:</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createComponent</span>(<span class="hljs-params">Ctor, props, context</span>) </span>{
  <span class="hljs-keyword">let</span> list = components[Ctor.name],
    inst;
  <span class="hljs-keyword">if</span> (Ctor.prototype &amp;&amp; Ctor.prototype.render) {
    inst = <span class="hljs-keyword">new</span> Ctor(props, context);
    Component.call(inst, props, context);
  }
  <span class="hljs-keyword">else</span> {
    inst = <span class="hljs-keyword">new</span> Component(props, context);
    inst.constructor = Ctor;
    inst.render = doRender;
  }
  <span class="hljs-keyword">if</span> (list) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=list.length; i--; ) {
      <span class="hljs-keyword">if</span> (list[i].constructor===Ctor) {
        inst.nextBase = list[i].nextBase;
        list.splice(i, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">break</span>;
      }
    }
  }
  <span class="hljs-keyword">return</span> inst;
}
</code></pre>
<p>这里的 <code>components</code> 是缓存的卸载的组件集合。通过简单的判定，将生成的新组件的 <code>nextBase</code> 指向卸载的同类组件的 <code>nextBase</code>，其实也是后者 'base'了。</p>
<p>在创建组件之后是 <code>setComponentProps</code>:</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setComponentProps</span>(<span class="hljs-params">component, props, opts, context, mountAll</span>) </span>{
  <span class="hljs-keyword">if</span> (component._disable) <span class="hljs-keyword">return</span>;
  component._disable = <span class="hljs-literal">true</span>;
  <span class="hljs-comment">// 将vnode传入的attribute/children/nodename.defaultProps里面的ref/key传给组件。</span>
  <span class="hljs-keyword">if</span> ((component.__ref = props.ref)) <span class="hljs-keyword">delete</span> props.ref;
  <span class="hljs-keyword">if</span> ((component.__key = props.key)) <span class="hljs-keyword">delete</span> props.key;

  <span class="hljs-keyword">if</span> (!component.base || mountAll) {
    <span class="hljs-keyword">if</span> (component.componentWillMount) component.componentWillMount();
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (component.componentWillReceiveProps) {
    component.componentWillReceiveProps(props, context);
  }

  <span class="hljs-keyword">if</span> (context &amp;&amp; context!==component.context) {
    <span class="hljs-keyword">if</span> (!component.prevContext) component.prevContext = component.context;
    component.context = context;
  }

  <span class="hljs-keyword">if</span> (!component.prevProps) component.prevProps = component.props;
  component.props = props;
  component._disable = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">if</span> (opts!==NO_RENDER) {
    <span class="hljs-keyword">if</span> (opts===SYNC_RENDER || options.syncComponentUpdates!==<span class="hljs-literal">false</span> || !component.base) {
      renderComponent(component, SYNC_RENDER, mountAll);
    }
    <span class="hljs-keyword">else</span> {
      enqueueRender(component);
    }
  }
  <span class="hljs-keyword">if</span> (component.__ref) component.__ref(component);
}
</code></pre>
<p><code>setComponentProps</code> 里面现实执行组件的 <code>componentWillMount/componentWillReceiveProps</code> 方法。将 <code>props</code> 传给组件的 <code>props</code>。接着是进行 <code>renderComponent</code> 方法，这个时候传参已经是 <code>component, opts, mountAll, isChild</code>，没有<code>vnode</code> 了。<code>renderComponent</code> 方法在 <code>setState</code> 也有提到，是更新组件的最重要的步骤，而 <code>renderComponent</code> 关键点就是会修改组件的 <code>base</code> 也就是 dom，接下来看看 <code>renderComponent</code> 方法实现：</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderComponent</span>(<span class="hljs-params">component, opts, mountAll, isChild</span>) </span>{
  <span class="hljs-keyword">if</span> (component._disable) <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">let</span> props = component.props,
    state = component.state,
    context = component.context,
    previousProps = component.prevProps || props,
    previousState = component.prevState || state,
  previousContext = component.prevContext || context,
  <span class="hljs-comment">// base和nextBase是 dom，或者undefined/null</span>
    isUpdate = component.base,
    nextBase = component.nextBase,
    initialBase = isUpdate || nextBase,
    initialChildComponent = component._component,
    skip = <span class="hljs-literal">false</span>,
  rendered, inst, cbase;
  
  <span class="hljs-keyword">if</span> (isUpdate) {
    component.props = previousProps;
    component.state = previousState;
    component.context = previousContext;
    <span class="hljs-comment">// 通过shouldComponentUpdate判断是不是要执行更新</span>
    <span class="hljs-keyword">if</span> (opts!==FORCE_RENDER
      &amp;&amp; component.shouldComponentUpdate
      &amp;&amp; component.shouldComponentUpdate(props, state, context) === <span class="hljs-literal">false</span>) {
      skip = <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (component.componentWillUpdate) {
      component.componentWillUpdate(props, state, context);
    }
    component.props = props;
    component.state = state;
    component.context = context;
  }

  component.prevProps = component.prevState = component.prevContext = component.nextBase = <span class="hljs-literal">null</span>;
  component._dirty = <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">if</span> (!skip) {
    <span class="hljs-comment">// 渲染结果先。传入poprs，state。</span>
    rendered = component.render(props, state, context);

    <span class="hljs-keyword">if</span> (component.getChildContext) {
      context = extend(extend({}, context), component.getChildContext());
    }

    <span class="hljs-keyword">let</span> childComponent = rendered &amp;&amp; rendered.nodeName,
      toUnmount, base;
    <span class="hljs-comment">// 如果render结果还是组件的话，继续render就好了，但是首次render要建立父组件和子组件关系。</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> childComponent===<span class="hljs-string">'function'</span>) {
      <span class="hljs-keyword">let</span> childProps = getNodeProps(rendered);
      inst = initialChildComponent;
      <span class="hljs-comment">// 说明执行过了，和上次渲染一样，inst是rendered的实例class。为再次进入的时候，要求是同一组件，key也要一样。</span>
      <span class="hljs-keyword">if</span> (inst &amp;&amp; inst.constructor===childComponent &amp;&amp; childProps.key==inst.__key) {
        <span class="hljs-comment">// 对于组件更新，则重新获取其props，再来就好了</span>
        setComponentProps(inst, childProps, SYNC_RENDER, context, <span class="hljs-literal">false</span>);
      }
      <span class="hljs-comment">// 第一次进来的时候/不相同的时候</span>
      <span class="hljs-keyword">else</span> {
        toUnmount = inst;

    component._component = inst = createComponent(childComponent, childProps, context);
    <span class="hljs-comment">// nextBase 的传递</span>
        inst.nextBase = inst.nextBase || nextBase;
        inst._parentComponent = component;
        setComponentProps(inst, childProps, NO_RENDER, context, <span class="hljs-literal">false</span>);
        <span class="hljs-comment">// 指明inst是子关系，不用重复继承和执行钩子函数与componentDidMount，因为已经可以了</span>
        renderComponent(inst, SYNC_RENDER, mountAll, <span class="hljs-literal">true</span>);
      }

      base = inst.base;
    }
    <span class="hljs-keyword">else</span> {
      cbase = initialBase;
      <span class="hljs-comment">// 如果有component._component，说明上次里面生成的rendered是function，而cbase是该function生成的节点，</span>
      <span class="hljs-comment">// 在本轮中rendered已经不是function了，故需要设置子组件_component为null。</span>
      toUnmount = initialChildComponent;
      <span class="hljs-keyword">if</span> (toUnmount) {
        cbase = component._component = <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">if</span> (initialBase || opts===SYNC_RENDER) {
        <span class="hljs-comment">// 需要先置为null，在重新指向</span>
        <span class="hljs-keyword">if</span> (cbase) cbase._component = <span class="hljs-literal">null</span>;
        base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase &amp;&amp; initialBase.parentNode, <span class="hljs-literal">true</span>);
      }
    }
  <span class="hljs-comment">// 生成的dom和原本的dom不一样，并且子组件也不一样的情况下</span>
    <span class="hljs-keyword">if</span> (initialBase &amp;&amp; base!==initialBase &amp;&amp; inst!==initialChildComponent) {
      <span class="hljs-keyword">let</span> baseParent = initialBase.parentNode;
      <span class="hljs-comment">// 如果执行了上面else里的diff，那diff中initialBase，已经被rendered替代了，initialBase没有挂载在任何节点上了，并且parentNode为null了。</span>
      <span class="hljs-comment">// 所以下面的命令是针对上面typeof childComponent==='function'的情况的？但是在该情况的renderCompnent里面也会进入diff，</span>
      <span class="hljs-comment">// 所以是根本进不来的？</span>
      <span class="hljs-keyword">if</span> (baseParent &amp;&amp; base!==baseParent) {
        <span class="hljs-comment">// 这里是用本轮的base 替换掉上轮的base</span>
        baseParent.replaceChild(base, initialBase);
        <span class="hljs-comment">// 如果没有_component，为何要清理base？有base/nextbase，自然应该是要有_component的。</span>
        <span class="hljs-comment">// 已经replace了，为何还要remove base呢？</span>
        <span class="hljs-keyword">if</span> (!toUnmount) {
          <span class="hljs-comment">// 防止在recollectNodeTree过程里面_component被unMounted，而是直接remove节点就好了</span>
          initialBase._component = <span class="hljs-literal">null</span>;
          recollectNodeTree(initialBase, <span class="hljs-literal">false</span>);
        }
      }
    }
    <span class="hljs-comment">// 发生的情况只能是rendered从组件变为普通vnode或者其他组件，所以要卸载掉子组件。</span>
    <span class="hljs-keyword">if</span> (toUnmount) {
      unmountComponent(toUnmount);
    }

    component.base = base;
    <span class="hljs-keyword">if</span> (base &amp;&amp; !isChild) {
      <span class="hljs-keyword">let</span> componentRef = component,
        t = component;
      <span class="hljs-keyword">while</span> ((t=t._parentComponent)) {
        (componentRef = t).base = base;
    }
    <span class="hljs-comment">// 指明dom的_component 指向组件，而_componentConstructor指向组件的构造器</span>
      base._component = componentRef;
      base._componentConstructor = componentRef.constructor;
    }
  }
  <span class="hljs-keyword">if</span> (!isUpdate || mountAll) {
    mounts.unshift(component);
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!skip) {
    <span class="hljs-keyword">if</span> (component.componentDidUpdate) {
      component.componentDidUpdate(previousProps, previousState, previousContext);
    }
    <span class="hljs-keyword">if</span> (options.afterUpdate) options.afterUpdate(component);
  }
  <span class="hljs-keyword">if</span> (component._renderCallbacks!=<span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">while</span> (component._renderCallbacks.length) component._renderCallbacks.pop().call(component);
  }

  <span class="hljs-keyword">if</span> (!diffLevel &amp;&amp; !isChild) flushMounts();
}
</code></pre>
<p><code>renderComponent</code> 函数比较长。首先是第一个 if 语句里面，判断是否是 <code>isUpdate</code>，判断依据是有无 <code>component.base</code>，初次加载组件的时候，组件本身是没有 <code>base</code> 属性，最多才有 'nextBase' 属性，所以 <code>isUpdate</code> 用来区分是否是更新组件，如果是的话，执行组件的 <code>shouldComponentUpdate</code> 与 <code>componentWillUpdate</code> 方法，并判断是否执行后面一长串的渲染。</p>
<p><code>rendered = component.render(props, state, context)</code> 先是得出要渲染的 VNode，如果 <code>rendered</code> 还是组件，则还要进行判断是否前后两次渲染子组件不一样或则是初次渲染。如果不是组件则主要是执行 <code>diff</code> 函数，生成新的 dom 节点 <code>base</code>。 最后由于自组件变更或则消失，则卸载子组件。将生成的 <code>base</code> dom 节点指向组件的 <code>base</code> 属性，而 dom 节点还要新增 <code>_component/_componentConstructor</code> 属性。最后如果是初次加载则将组件放入初次加载组件的队列里面，准备执行 <code>componentDidUpdate afterUpdate</code>。底部的 <code>flushMounts</code> 则是，当是最顶部的一次 diff 递归进入尾声了，就执行 <code>options.afterMount</code> 和所有初次加载组件的 <code>componentDidMount</code> 方法。另外还有 <code>component._renderCallbacks</code>，在组件状态变化，也就是在用 <code>setState</code> 的时候，如果存在第二个参数 <code>callback</code>， 则会在这个时候执行 <code>callback</code>。</p>
<h3>回收机制</h3>
<p>之前最早遇到回收问题是出现在 diff 函数上面，经常可以看到 <code>recollectNodeTree(dom, true)</code> 这句话，看看 <code>recollectNodeTree</code> 方法：</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recollectNodeTree</span>(<span class="hljs-params">node, unmountOnly</span>) </span>{
  <span class="hljs-keyword">let</span> component = node._component;
  <span class="hljs-keyword">if</span> (component) {
    unmountComponent(component);
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (node[ATTR_KEY]!=<span class="hljs-literal">null</span> &amp;&amp; node[ATTR_KEY].ref) node[ATTR_KEY].ref(<span class="hljs-literal">null</span>);
    <span class="hljs-comment">// 移除node节点</span>
    <span class="hljs-keyword">if</span> (unmountOnly===<span class="hljs-literal">false</span> || node[ATTR_KEY]==<span class="hljs-literal">null</span>) {
      removeNode(node);
    }
    <span class="hljs-comment">// 再来一次遍历</span>
    removeChildren(node);
  }
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeChildren</span>(<span class="hljs-params">node</span>) </span>{
  node = node.lastChild;
  <span class="hljs-keyword">while</span> (node) {
    <span class="hljs-keyword">let</span> next = node.previousSibling;
    recollectNodeTree(node, <span class="hljs-literal">true</span>);
    node = next;
  }
}
</code></pre>
<p>这里可以看到，对于非组件，则可以要先执行节点的 ref，这个 ref是什么？在组件 <code>setComponentProps</code> 最后一行代码还有个 <code>component.__ref</code>。其实这两个都是一样的，都是节点 <code>attribute</code> 里面的 <code>ref</code> 属性，也就是说组件初次加载的时候，或则回收组件/Dom 的时候都会执行，如果不仅仅是卸载还会在父节点上移除 <code>node</code>。从而实现回收。最后的 <code>removeChildren</code> 只是遍历用的。基本上只要涉及到老节点的回收都会用到 <code>recollectNodeTree</code> 里面。在 <code>innerDiffNode</code> 最后也会对没有用的节点回收。除了节点 diff 的问题外，还有组件卸载的时候，也会调用 <code>removeChildren</code> 方法：</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unmountComponent</span>(<span class="hljs-params">component</span>) </span>{
  <span class="hljs-keyword">if</span> (options.beforeUnmount) options.beforeUnmount(component);
  <span class="hljs-keyword">let</span> base = component.base;
  component._disable = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">if</span> (component.componentWillUnmount) component.componentWillUnmount();
  component.base = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">let</span> inner = component._component;
  <span class="hljs-keyword">if</span> (inner) {
    unmountComponent(inner);
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (base) {
    <span class="hljs-keyword">if</span> (base[ATTR_KEY] &amp;&amp; base[ATTR_KEY].ref) base[ATTR_KEY].ref(<span class="hljs-literal">null</span>);
    component.nextBase = base;
    removeNode(base);
    collectComponent(component);
    removeChildren(base);
  }
  <span class="hljs-keyword">if</span> (component.__ref) component.__ref(<span class="hljs-literal">null</span>);
}
</code></pre>
<p>上面可以看出卸载组件的时候，会调用 <code>componentWillUnmount</code> 方法，接着执行 ref ，将卸载的组件生成的节点转移到 <code>nextBase</code> 上面，再执行 <code>removeChildren</code>。</p>
<p>最后还有一个贯穿所有 diff 机制的传参 <code>mountAll</code>，具体作用就算是组件更新，也将其作为初次加载，就是能执行 <code>componentWillMount 与 componentDidMount</code> 方法。</p>
<h3>总结</h3>
<p>这次的 Preact 之旅就到这里，代码虽少，但是还是活灵活现的展示了 diff 功能。源码里面有着无数行空行，以及代码解释，然而整体大小才 1000 行多点，min 之后更是只有 10kb 大小，相当袖珍。大家有机会还是去接触一下。</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"March 24, 2021","title":"preact源码 - 组件与回收机制","content":"\u003ch3\u003e前言\u003c/h3\u003e\n\u003cp\u003e前面介绍到 diff 方法，但是我们只是从简单的例子开始的，并没有用到组件，而组件才是最重要的部分，毕竟一切的一切可以是组件。\u003c/p\u003e\n\u003ch3\u003e组件 Component\u003c/h3\u003e\n\u003cp\u003e先看看 Preact 输出的 Component 长什么样子：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprops, context\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._dirty = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.context = context;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props = props;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state || {};\n}\n\nextend(Component.prototype, {\n  setState(state, callback) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e s = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.prevState) \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.prevState = extend({}, s);\n    extend(s, \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e state===\u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e ? state(s, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props) : state);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (callback) (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._renderCallbacks = (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._renderCallbacks || [])).push(callback);\n    enqueueRender(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e);\n  },\n  forceUpdate(callback) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (callback) (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._renderCallbacks = (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._renderCallbacks || [])).push(callback);\n    renderComponent(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, FORCE_RENDER);\n  },\n  render() {}\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e平时使用组件的时候，大致都是这样 \u003ccode\u003eclass Clockwarp extends Component\u003c/code\u003e 通过 \u003ccode\u003eextends\u003c/code\u003e 来实现继承 \u003ccode\u003eComponent\u003c/code\u003e，有点 \u003ccode\u003eprototype\u003c/code\u003e 的意思。在 \u003ccode\u003eComponent\u003c/code\u003e 类里面有 \u003ccode\u003estate/props/setState/render\u003c/code\u003e，其中 \u003ccode\u003esetState\u003c/code\u003e 方法先判断 \u003ccode\u003estate\u003c/code\u003e 是不是函数，也就是这种写法：\u003ccode\u003ethis.setSate((preState, props) =\u0026gt; {})\u003c/code\u003e 这个时候才会会执行 \u003ccode\u003estate\u003c/code\u003e 方法，如果有回调，会被 push 到 \u003ccode\u003e_renderCallbacks\u003c/code\u003e 里面。在看看 \u003ccode\u003eenqueueRender\u003c/code\u003e:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e items = [];\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eenqueueRender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecomponent\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!component._dirty \u0026amp;\u0026amp; (component._dirty = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e) \u0026amp;\u0026amp; items.push(component)==\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n    (options.debounceRendering || defer)(rerender);\n  }\n}\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ererender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e p, list = items;\n  items = [];\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e ( (p = list.pop()) ) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (p._dirty) renderComponent(p);\n  }\n}\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e defer = \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e==\u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e ? \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.resolve().then.bind(\u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.resolve()) : setTimeout;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eenqueueRender\u003c/code\u003e 方法是为了延迟当前的组件的再渲染，采用的是 Promise方法，如果没有就用 \u003ccode\u003esetTimeout\u003c/code\u003e 代替，当然 \u003ccode\u003ePromise.resolve()\u003c/code\u003e 之后调用的 \u003ccode\u003ethen\u003c/code\u003e 实现上是要优先于  \u003ccode\u003esetTimeout\u003c/code\u003e 的。\u003c/p\u003e\n\u003ch3\u003e组件 diff 机制\u003c/h3\u003e\n\u003cp\u003e上面代码可以看到 \u003ccode\u003esetState/forceUpdate\u003c/code\u003e 最后都会调用 \u003ccode\u003erenderComponent\u003c/code\u003e 方法，看名字就知道是渲染组件的意思，但是在介绍 \u003ccode\u003erenderComponent\u003c/code\u003e 之前，先看看上篇博客里面介绍的，\u003ccode\u003ediff\u003c/code\u003e 过程里面，对于组件的处理：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003evnode 是 Component的形式，调用 buildComponentFromVNode 方法，最后会返回处理过的 dom 节点。\n如若是组件，则会调用 \u003ccode\u003ebuildComponentFromVNode\u003c/code\u003e 方法，而实际上， \u003ccode\u003ebuildComponentFromVNode\u003c/code\u003e 最后也是会调用 \u003ccode\u003erenderComponent\u003c/code\u003e 方法，所以先看看 \u003ccode\u003ebuildComponentFromVNode\u003c/code\u003e 的实现：\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/blockquote\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ebuildComponentFromVNode\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edom, vnode, context, mountAll\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e c = dom \u0026amp;\u0026amp; dom._component,\n    originalComponent = c,\n    oldDom = dom,\n    isDirectOwner = c \u0026amp;\u0026amp; dom._componentConstructor===vnode.nodeName,\n    isOwner = isDirectOwner,\n    \u003cspan class=\"hljs-comment\"\u003e// props就是vnode的attribute/children/nodename.defaultProps\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 传递最新鲜的porps，常见的子组件更新，都是依赖于props变化\u003c/span\u003e\n    props = getNodeProps(vnode);\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (c \u0026amp;\u0026amp; !isOwner \u0026amp;\u0026amp; (c=c._parentComponent)) {\n    isOwner = c.constructor===vnode.nodeName;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 如果vnode 和 dom 是由同类的组件生成则直接 setComponentProps，当然还需要!mountAll || c._component 成立。\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (c \u0026amp;\u0026amp; isOwner \u0026amp;\u0026amp; (!mountAll || c._component)) {\n    setComponentProps(c, props, ASYNC_RENDER, context, mountAll);\n    dom = c.base;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// dom由组件生成，而vnode和生成dom的组件实例不是同一构造器生成的。则说明要卸载当前组件，替换上新的。\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (originalComponent \u0026amp;\u0026amp; !isDirectOwner) {\n      unmountComponent(originalComponent);\n      dom = oldDom = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 根据nodeName生成新的组件 c。\u003c/span\u003e\n  c = createComponent(vnode.nodeName, props, context);\n  \u003cspan class=\"hljs-comment\"\u003e// 如果该类组件没有卸载过，而存在dom来diff，则将c.nextBase指向dom，后面做diff用\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (dom \u0026amp;\u0026amp; !c.nextBase) {\n      c.nextBase = dom;\n      oldDom = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n    }\n    setComponentProps(c, props, SYNC_RENDER, context, mountAll);\n    dom = c.base;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (oldDom \u0026amp;\u0026amp; dom!==oldDom) {\n      oldDom._component = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n      recollectNodeTree(oldDom, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e dom;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ebuildComponentFromVNode\u003c/code\u003e 有几个概念是要分清楚的，如果 \u003ccode\u003edom\u003c/code\u003e 是由一个组件生成渲染的，则 \u003ccode\u003edom._component\u003c/code\u003e 是指向渲染出 \u003ccode\u003edom\u003c/code\u003e 的组件实例。而生成的组件实例的 \u003ccode\u003ebase\u003c/code\u003e 属性又会指向 \u003ccode\u003edom\u003c/code\u003e 节点。初次渲染时候会直接是进入下面的 \u003ccode\u003eelse\u003c/code\u003e 语句。对于不同的组件则先卸载之前的组件，让后生成新的组件 \u003ccode\u003ec\u003c/code\u003e，\u003ccode\u003enextBase\u003c/code\u003e 指的是卸载的同类组件的 \u003ccode\u003ebase\u003c/code\u003e 属性，也就是上个该类组件生成的 dom 节点。为什么要这样做呢？答案是提高效率。假设组件替换是这样的 \u003ccode\u003eA -\u0026gt; B -\u0026gt;A\u003c/code\u003e，在 A 组件卸载的时候，就会将 A 生成的 dom 节点缓存下来，当 B 组件卸载，A 组件再次渲染的时候，这个时候就会用上之前 A 组件生成的 dom 节点，与这次 A 组件渲染出的做 diff对比，这样看是不是很高效？可以看看 \u003ccode\u003ecreateComponnet\u003c/code\u003e:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecreateComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eCtor, props, context\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e list = components[Ctor.name],\n    inst;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (Ctor.prototype \u0026amp;\u0026amp; Ctor.prototype.render) {\n    inst = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Ctor(props, context);\n    Component.call(inst, props, context);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    inst = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Component(props, context);\n    inst.constructor = Ctor;\n    inst.render = doRender;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (list) {\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i=list.length; i--; ) {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (list[i].constructor===Ctor) {\n        inst.nextBase = list[i].nextBase;\n        list.splice(i, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n      }\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e inst;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里的 \u003ccode\u003ecomponents\u003c/code\u003e 是缓存的卸载的组件集合。通过简单的判定，将生成的新组件的 \u003ccode\u003enextBase\u003c/code\u003e 指向卸载的同类组件的 \u003ccode\u003enextBase\u003c/code\u003e，其实也是后者 'base'了。\u003c/p\u003e\n\u003cp\u003e在创建组件之后是 \u003ccode\u003esetComponentProps\u003c/code\u003e:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003esetComponentProps\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecomponent, props, opts, context, mountAll\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component._disable) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n  component._disable = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// 将vnode传入的attribute/children/nodename.defaultProps里面的ref/key传给组件。\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ((component.__ref = props.ref)) \u003cspan class=\"hljs-keyword\"\u003edelete\u003c/span\u003e props.ref;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ((component.__key = props.key)) \u003cspan class=\"hljs-keyword\"\u003edelete\u003c/span\u003e props.key;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!component.base || mountAll) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component.componentWillMount) component.componentWillMount();\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component.componentWillReceiveProps) {\n    component.componentWillReceiveProps(props, context);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (context \u0026amp;\u0026amp; context!==component.context) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!component.prevContext) component.prevContext = component.context;\n    component.context = context;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!component.prevProps) component.prevProps = component.props;\n  component.props = props;\n  component._disable = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (opts!==NO_RENDER) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (opts===SYNC_RENDER || options.syncComponentUpdates!==\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e || !component.base) {\n      renderComponent(component, SYNC_RENDER, mountAll);\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      enqueueRender(component);\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component.__ref) component.__ref(component);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003esetComponentProps\u003c/code\u003e 里面现实执行组件的 \u003ccode\u003ecomponentWillMount/componentWillReceiveProps\u003c/code\u003e 方法。将 \u003ccode\u003eprops\u003c/code\u003e 传给组件的 \u003ccode\u003eprops\u003c/code\u003e。接着是进行 \u003ccode\u003erenderComponent\u003c/code\u003e 方法，这个时候传参已经是 \u003ccode\u003ecomponent, opts, mountAll, isChild\u003c/code\u003e，没有\u003ccode\u003evnode\u003c/code\u003e 了。\u003ccode\u003erenderComponent\u003c/code\u003e 方法在 \u003ccode\u003esetState\u003c/code\u003e 也有提到，是更新组件的最重要的步骤，而 \u003ccode\u003erenderComponent\u003c/code\u003e 关键点就是会修改组件的 \u003ccode\u003ebase\u003c/code\u003e 也就是 dom，接下来看看 \u003ccode\u003erenderComponent\u003c/code\u003e 方法实现：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erenderComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecomponent, opts, mountAll, isChild\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component._disable) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e props = component.props,\n    state = component.state,\n    context = component.context,\n    previousProps = component.prevProps || props,\n    previousState = component.prevState || state,\n  previousContext = component.prevContext || context,\n  \u003cspan class=\"hljs-comment\"\u003e// base和nextBase是 dom，或者undefined/null\u003c/span\u003e\n    isUpdate = component.base,\n    nextBase = component.nextBase,\n    initialBase = isUpdate || nextBase,\n    initialChildComponent = component._component,\n    skip = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n  rendered, inst, cbase;\n  \n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isUpdate) {\n    component.props = previousProps;\n    component.state = previousState;\n    component.context = previousContext;\n    \u003cspan class=\"hljs-comment\"\u003e// 通过shouldComponentUpdate判断是不是要执行更新\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (opts!==FORCE_RENDER\n      \u0026amp;\u0026amp; component.shouldComponentUpdate\n      \u0026amp;\u0026amp; component.shouldComponentUpdate(props, state, context) === \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e) {\n      skip = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component.componentWillUpdate) {\n      component.componentWillUpdate(props, state, context);\n    }\n    component.props = props;\n    component.state = state;\n    component.context = context;\n  }\n\n  component.prevProps = component.prevState = component.prevContext = component.nextBase = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  component._dirty = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!skip) {\n    \u003cspan class=\"hljs-comment\"\u003e// 渲染结果先。传入poprs，state。\u003c/span\u003e\n    rendered = component.render(props, state, context);\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component.getChildContext) {\n      context = extend(extend({}, context), component.getChildContext());\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e childComponent = rendered \u0026amp;\u0026amp; rendered.nodeName,\n      toUnmount, base;\n    \u003cspan class=\"hljs-comment\"\u003e// 如果render结果还是组件的话，继续render就好了，但是首次render要建立父组件和子组件关系。\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e childComponent===\u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e childProps = getNodeProps(rendered);\n      inst = initialChildComponent;\n      \u003cspan class=\"hljs-comment\"\u003e// 说明执行过了，和上次渲染一样，inst是rendered的实例class。为再次进入的时候，要求是同一组件，key也要一样。\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (inst \u0026amp;\u0026amp; inst.constructor===childComponent \u0026amp;\u0026amp; childProps.key==inst.__key) {\n        \u003cspan class=\"hljs-comment\"\u003e// 对于组件更新，则重新获取其props，再来就好了\u003c/span\u003e\n        setComponentProps(inst, childProps, SYNC_RENDER, context, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n      }\n      \u003cspan class=\"hljs-comment\"\u003e// 第一次进来的时候/不相同的时候\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        toUnmount = inst;\n\n    component._component = inst = createComponent(childComponent, childProps, context);\n    \u003cspan class=\"hljs-comment\"\u003e// nextBase 的传递\u003c/span\u003e\n        inst.nextBase = inst.nextBase || nextBase;\n        inst._parentComponent = component;\n        setComponentProps(inst, childProps, NO_RENDER, context, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n        \u003cspan class=\"hljs-comment\"\u003e// 指明inst是子关系，不用重复继承和执行钩子函数与componentDidMount，因为已经可以了\u003c/span\u003e\n        renderComponent(inst, SYNC_RENDER, mountAll, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n      }\n\n      base = inst.base;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      cbase = initialBase;\n      \u003cspan class=\"hljs-comment\"\u003e// 如果有component._component，说明上次里面生成的rendered是function，而cbase是该function生成的节点，\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e// 在本轮中rendered已经不是function了，故需要设置子组件_component为null。\u003c/span\u003e\n      toUnmount = initialChildComponent;\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (toUnmount) {\n        cbase = component._component = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n      }\n\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (initialBase || opts===SYNC_RENDER) {\n        \u003cspan class=\"hljs-comment\"\u003e// 需要先置为null，在重新指向\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (cbase) cbase._component = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n        base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase \u0026amp;\u0026amp; initialBase.parentNode, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n      }\n    }\n  \u003cspan class=\"hljs-comment\"\u003e// 生成的dom和原本的dom不一样，并且子组件也不一样的情况下\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (initialBase \u0026amp;\u0026amp; base!==initialBase \u0026amp;\u0026amp; inst!==initialChildComponent) {\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e baseParent = initialBase.parentNode;\n      \u003cspan class=\"hljs-comment\"\u003e// 如果执行了上面else里的diff，那diff中initialBase，已经被rendered替代了，initialBase没有挂载在任何节点上了，并且parentNode为null了。\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e// 所以下面的命令是针对上面typeof childComponent==='function'的情况的？但是在该情况的renderCompnent里面也会进入diff，\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e// 所以是根本进不来的？\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (baseParent \u0026amp;\u0026amp; base!==baseParent) {\n        \u003cspan class=\"hljs-comment\"\u003e// 这里是用本轮的base 替换掉上轮的base\u003c/span\u003e\n        baseParent.replaceChild(base, initialBase);\n        \u003cspan class=\"hljs-comment\"\u003e// 如果没有_component，为何要清理base？有base/nextbase，自然应该是要有_component的。\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// 已经replace了，为何还要remove base呢？\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!toUnmount) {\n          \u003cspan class=\"hljs-comment\"\u003e// 防止在recollectNodeTree过程里面_component被unMounted，而是直接remove节点就好了\u003c/span\u003e\n          initialBase._component = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n          recollectNodeTree(initialBase, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n        }\n      }\n    }\n    \u003cspan class=\"hljs-comment\"\u003e// 发生的情况只能是rendered从组件变为普通vnode或者其他组件，所以要卸载掉子组件。\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (toUnmount) {\n      unmountComponent(toUnmount);\n    }\n\n    component.base = base;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (base \u0026amp;\u0026amp; !isChild) {\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e componentRef = component,\n        t = component;\n      \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e ((t=t._parentComponent)) {\n        (componentRef = t).base = base;\n    }\n    \u003cspan class=\"hljs-comment\"\u003e// 指明dom的_component 指向组件，而_componentConstructor指向组件的构造器\u003c/span\u003e\n      base._component = componentRef;\n      base._componentConstructor = componentRef.constructor;\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isUpdate || mountAll) {\n    mounts.unshift(component);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!skip) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component.componentDidUpdate) {\n      component.componentDidUpdate(previousProps, previousState, previousContext);\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (options.afterUpdate) options.afterUpdate(component);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component._renderCallbacks!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (component._renderCallbacks.length) component._renderCallbacks.pop().call(component);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!diffLevel \u0026amp;\u0026amp; !isChild) flushMounts();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003erenderComponent\u003c/code\u003e 函数比较长。首先是第一个 if 语句里面，判断是否是 \u003ccode\u003eisUpdate\u003c/code\u003e，判断依据是有无 \u003ccode\u003ecomponent.base\u003c/code\u003e，初次加载组件的时候，组件本身是没有 \u003ccode\u003ebase\u003c/code\u003e 属性，最多才有 'nextBase' 属性，所以 \u003ccode\u003eisUpdate\u003c/code\u003e 用来区分是否是更新组件，如果是的话，执行组件的 \u003ccode\u003eshouldComponentUpdate\u003c/code\u003e 与 \u003ccode\u003ecomponentWillUpdate\u003c/code\u003e 方法，并判断是否执行后面一长串的渲染。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003erendered = component.render(props, state, context)\u003c/code\u003e 先是得出要渲染的 VNode，如果 \u003ccode\u003erendered\u003c/code\u003e 还是组件，则还要进行判断是否前后两次渲染子组件不一样或则是初次渲染。如果不是组件则主要是执行 \u003ccode\u003ediff\u003c/code\u003e 函数，生成新的 dom 节点 \u003ccode\u003ebase\u003c/code\u003e。 最后由于自组件变更或则消失，则卸载子组件。将生成的 \u003ccode\u003ebase\u003c/code\u003e dom 节点指向组件的 \u003ccode\u003ebase\u003c/code\u003e 属性，而 dom 节点还要新增 \u003ccode\u003e_component/_componentConstructor\u003c/code\u003e 属性。最后如果是初次加载则将组件放入初次加载组件的队列里面，准备执行 \u003ccode\u003ecomponentDidUpdate afterUpdate\u003c/code\u003e。底部的 \u003ccode\u003eflushMounts\u003c/code\u003e 则是，当是最顶部的一次 diff 递归进入尾声了，就执行 \u003ccode\u003eoptions.afterMount\u003c/code\u003e 和所有初次加载组件的 \u003ccode\u003ecomponentDidMount\u003c/code\u003e 方法。另外还有 \u003ccode\u003ecomponent._renderCallbacks\u003c/code\u003e，在组件状态变化，也就是在用 \u003ccode\u003esetState\u003c/code\u003e 的时候，如果存在第二个参数 \u003ccode\u003ecallback\u003c/code\u003e， 则会在这个时候执行 \u003ccode\u003ecallback\u003c/code\u003e。\u003c/p\u003e\n\u003ch3\u003e回收机制\u003c/h3\u003e\n\u003cp\u003e之前最早遇到回收问题是出现在 diff 函数上面，经常可以看到 \u003ccode\u003erecollectNodeTree(dom, true)\u003c/code\u003e 这句话，看看 \u003ccode\u003erecollectNodeTree\u003c/code\u003e 方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erecollectNodeTree\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enode, unmountOnly\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e component = node._component;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component) {\n    unmountComponent(component);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (node[ATTR_KEY]!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026amp;\u0026amp; node[ATTR_KEY].ref) node[ATTR_KEY].ref(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n    \u003cspan class=\"hljs-comment\"\u003e// 移除node节点\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (unmountOnly===\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e || node[ATTR_KEY]==\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n      removeNode(node);\n    }\n    \u003cspan class=\"hljs-comment\"\u003e// 再来一次遍历\u003c/span\u003e\n    removeChildren(node);\n  }\n}\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eremoveChildren\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enode\u003c/span\u003e) \u003c/span\u003e{\n  node = node.lastChild;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (node) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e next = node.previousSibling;\n    recollectNodeTree(node, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n    node = next;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里可以看到，对于非组件，则可以要先执行节点的 ref，这个 ref是什么？在组件 \u003ccode\u003esetComponentProps\u003c/code\u003e 最后一行代码还有个 \u003ccode\u003ecomponent.__ref\u003c/code\u003e。其实这两个都是一样的，都是节点 \u003ccode\u003eattribute\u003c/code\u003e 里面的 \u003ccode\u003eref\u003c/code\u003e 属性，也就是说组件初次加载的时候，或则回收组件/Dom 的时候都会执行，如果不仅仅是卸载还会在父节点上移除 \u003ccode\u003enode\u003c/code\u003e。从而实现回收。最后的 \u003ccode\u003eremoveChildren\u003c/code\u003e 只是遍历用的。基本上只要涉及到老节点的回收都会用到 \u003ccode\u003erecollectNodeTree\u003c/code\u003e 里面。在 \u003ccode\u003einnerDiffNode\u003c/code\u003e 最后也会对没有用的节点回收。除了节点 diff 的问题外，还有组件卸载的时候，也会调用 \u003ccode\u003eremoveChildren\u003c/code\u003e 方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eunmountComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecomponent\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (options.beforeUnmount) options.beforeUnmount(component);\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e base = component.base;\n  component._disable = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component.componentWillUnmount) component.componentWillUnmount();\n  component.base = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e inner = component._component;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (inner) {\n    unmountComponent(inner);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (base) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (base[ATTR_KEY] \u0026amp;\u0026amp; base[ATTR_KEY].ref) base[ATTR_KEY].ref(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n    component.nextBase = base;\n    removeNode(base);\n    collectComponent(component);\n    removeChildren(base);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component.__ref) component.__ref(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面可以看出卸载组件的时候，会调用 \u003ccode\u003ecomponentWillUnmount\u003c/code\u003e 方法，接着执行 ref ，将卸载的组件生成的节点转移到 \u003ccode\u003enextBase\u003c/code\u003e 上面，再执行 \u003ccode\u003eremoveChildren\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e最后还有一个贯穿所有 diff 机制的传参 \u003ccode\u003emountAll\u003c/code\u003e，具体作用就算是组件更新，也将其作为初次加载，就是能执行 \u003ccode\u003ecomponentWillMount 与 componentDidMount\u003c/code\u003e 方法。\u003c/p\u003e\n\u003ch3\u003e总结\u003c/h3\u003e\n\u003cp\u003e这次的 Preact 之旅就到这里，代码虽少，但是还是活灵活现的展示了 diff 功能。源码里面有着无数行空行，以及代码解释，然而整体大小才 1000 行多点，min 之后更是只有 10kb 大小，相当袖珍。大家有机会还是去接触一下。\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"March 24, 2021","title":"preact源码 - 组件与回收机制","content":"\u003ch3\u003e前言\u003c/h3\u003e\n\u003cp\u003e前面介绍到 diff 方法，但是我们只是从简单的例子开始的，并没有用到组件，而组件才是最重要的部分，毕竟一切的一切可以是组件。\u003c/p\u003e\n\u003ch3\u003e组件 Component\u003c/h3\u003e\n\u003cp\u003e先看看 Preact 输出的 Component 长什么样子：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprops, context\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._dirty = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.context = context;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props = props;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state || {};\n}\n\nextend(Component.prototype, {\n  setState(state, callback) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e s = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.prevState) \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.prevState = extend({}, s);\n    extend(s, \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e state===\u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e ? state(s, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props) : state);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (callback) (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._renderCallbacks = (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._renderCallbacks || [])).push(callback);\n    enqueueRender(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e);\n  },\n  forceUpdate(callback) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (callback) (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._renderCallbacks = (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._renderCallbacks || [])).push(callback);\n    renderComponent(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, FORCE_RENDER);\n  },\n  render() {}\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e平时使用组件的时候，大致都是这样 \u003ccode\u003eclass Clockwarp extends Component\u003c/code\u003e 通过 \u003ccode\u003eextends\u003c/code\u003e 来实现继承 \u003ccode\u003eComponent\u003c/code\u003e，有点 \u003ccode\u003eprototype\u003c/code\u003e 的意思。在 \u003ccode\u003eComponent\u003c/code\u003e 类里面有 \u003ccode\u003estate/props/setState/render\u003c/code\u003e，其中 \u003ccode\u003esetState\u003c/code\u003e 方法先判断 \u003ccode\u003estate\u003c/code\u003e 是不是函数，也就是这种写法：\u003ccode\u003ethis.setSate((preState, props) =\u0026gt; {})\u003c/code\u003e 这个时候才会会执行 \u003ccode\u003estate\u003c/code\u003e 方法，如果有回调，会被 push 到 \u003ccode\u003e_renderCallbacks\u003c/code\u003e 里面。在看看 \u003ccode\u003eenqueueRender\u003c/code\u003e:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e items = [];\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eenqueueRender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecomponent\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!component._dirty \u0026amp;\u0026amp; (component._dirty = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e) \u0026amp;\u0026amp; items.push(component)==\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n    (options.debounceRendering || defer)(rerender);\n  }\n}\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ererender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e p, list = items;\n  items = [];\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e ( (p = list.pop()) ) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (p._dirty) renderComponent(p);\n  }\n}\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e defer = \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e==\u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e ? \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.resolve().then.bind(\u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.resolve()) : setTimeout;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eenqueueRender\u003c/code\u003e 方法是为了延迟当前的组件的再渲染，采用的是 Promise方法，如果没有就用 \u003ccode\u003esetTimeout\u003c/code\u003e 代替，当然 \u003ccode\u003ePromise.resolve()\u003c/code\u003e 之后调用的 \u003ccode\u003ethen\u003c/code\u003e 实现上是要优先于  \u003ccode\u003esetTimeout\u003c/code\u003e 的。\u003c/p\u003e\n\u003ch3\u003e组件 diff 机制\u003c/h3\u003e\n\u003cp\u003e上面代码可以看到 \u003ccode\u003esetState/forceUpdate\u003c/code\u003e 最后都会调用 \u003ccode\u003erenderComponent\u003c/code\u003e 方法，看名字就知道是渲染组件的意思，但是在介绍 \u003ccode\u003erenderComponent\u003c/code\u003e 之前，先看看上篇博客里面介绍的，\u003ccode\u003ediff\u003c/code\u003e 过程里面，对于组件的处理：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003evnode 是 Component的形式，调用 buildComponentFromVNode 方法，最后会返回处理过的 dom 节点。\n如若是组件，则会调用 \u003ccode\u003ebuildComponentFromVNode\u003c/code\u003e 方法，而实际上， \u003ccode\u003ebuildComponentFromVNode\u003c/code\u003e 最后也是会调用 \u003ccode\u003erenderComponent\u003c/code\u003e 方法，所以先看看 \u003ccode\u003ebuildComponentFromVNode\u003c/code\u003e 的实现：\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/blockquote\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ebuildComponentFromVNode\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edom, vnode, context, mountAll\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e c = dom \u0026amp;\u0026amp; dom._component,\n    originalComponent = c,\n    oldDom = dom,\n    isDirectOwner = c \u0026amp;\u0026amp; dom._componentConstructor===vnode.nodeName,\n    isOwner = isDirectOwner,\n    \u003cspan class=\"hljs-comment\"\u003e// props就是vnode的attribute/children/nodename.defaultProps\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 传递最新鲜的porps，常见的子组件更新，都是依赖于props变化\u003c/span\u003e\n    props = getNodeProps(vnode);\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (c \u0026amp;\u0026amp; !isOwner \u0026amp;\u0026amp; (c=c._parentComponent)) {\n    isOwner = c.constructor===vnode.nodeName;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 如果vnode 和 dom 是由同类的组件生成则直接 setComponentProps，当然还需要!mountAll || c._component 成立。\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (c \u0026amp;\u0026amp; isOwner \u0026amp;\u0026amp; (!mountAll || c._component)) {\n    setComponentProps(c, props, ASYNC_RENDER, context, mountAll);\n    dom = c.base;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// dom由组件生成，而vnode和生成dom的组件实例不是同一构造器生成的。则说明要卸载当前组件，替换上新的。\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (originalComponent \u0026amp;\u0026amp; !isDirectOwner) {\n      unmountComponent(originalComponent);\n      dom = oldDom = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 根据nodeName生成新的组件 c。\u003c/span\u003e\n  c = createComponent(vnode.nodeName, props, context);\n  \u003cspan class=\"hljs-comment\"\u003e// 如果该类组件没有卸载过，而存在dom来diff，则将c.nextBase指向dom，后面做diff用\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (dom \u0026amp;\u0026amp; !c.nextBase) {\n      c.nextBase = dom;\n      oldDom = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n    }\n    setComponentProps(c, props, SYNC_RENDER, context, mountAll);\n    dom = c.base;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (oldDom \u0026amp;\u0026amp; dom!==oldDom) {\n      oldDom._component = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n      recollectNodeTree(oldDom, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e dom;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ebuildComponentFromVNode\u003c/code\u003e 有几个概念是要分清楚的，如果 \u003ccode\u003edom\u003c/code\u003e 是由一个组件生成渲染的，则 \u003ccode\u003edom._component\u003c/code\u003e 是指向渲染出 \u003ccode\u003edom\u003c/code\u003e 的组件实例。而生成的组件实例的 \u003ccode\u003ebase\u003c/code\u003e 属性又会指向 \u003ccode\u003edom\u003c/code\u003e 节点。初次渲染时候会直接是进入下面的 \u003ccode\u003eelse\u003c/code\u003e 语句。对于不同的组件则先卸载之前的组件，让后生成新的组件 \u003ccode\u003ec\u003c/code\u003e，\u003ccode\u003enextBase\u003c/code\u003e 指的是卸载的同类组件的 \u003ccode\u003ebase\u003c/code\u003e 属性，也就是上个该类组件生成的 dom 节点。为什么要这样做呢？答案是提高效率。假设组件替换是这样的 \u003ccode\u003eA -\u0026gt; B -\u0026gt;A\u003c/code\u003e，在 A 组件卸载的时候，就会将 A 生成的 dom 节点缓存下来，当 B 组件卸载，A 组件再次渲染的时候，这个时候就会用上之前 A 组件生成的 dom 节点，与这次 A 组件渲染出的做 diff对比，这样看是不是很高效？可以看看 \u003ccode\u003ecreateComponnet\u003c/code\u003e:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecreateComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eCtor, props, context\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e list = components[Ctor.name],\n    inst;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (Ctor.prototype \u0026amp;\u0026amp; Ctor.prototype.render) {\n    inst = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Ctor(props, context);\n    Component.call(inst, props, context);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    inst = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Component(props, context);\n    inst.constructor = Ctor;\n    inst.render = doRender;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (list) {\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i=list.length; i--; ) {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (list[i].constructor===Ctor) {\n        inst.nextBase = list[i].nextBase;\n        list.splice(i, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n      }\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e inst;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里的 \u003ccode\u003ecomponents\u003c/code\u003e 是缓存的卸载的组件集合。通过简单的判定，将生成的新组件的 \u003ccode\u003enextBase\u003c/code\u003e 指向卸载的同类组件的 \u003ccode\u003enextBase\u003c/code\u003e，其实也是后者 'base'了。\u003c/p\u003e\n\u003cp\u003e在创建组件之后是 \u003ccode\u003esetComponentProps\u003c/code\u003e:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003esetComponentProps\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecomponent, props, opts, context, mountAll\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component._disable) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n  component._disable = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// 将vnode传入的attribute/children/nodename.defaultProps里面的ref/key传给组件。\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ((component.__ref = props.ref)) \u003cspan class=\"hljs-keyword\"\u003edelete\u003c/span\u003e props.ref;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ((component.__key = props.key)) \u003cspan class=\"hljs-keyword\"\u003edelete\u003c/span\u003e props.key;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!component.base || mountAll) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component.componentWillMount) component.componentWillMount();\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component.componentWillReceiveProps) {\n    component.componentWillReceiveProps(props, context);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (context \u0026amp;\u0026amp; context!==component.context) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!component.prevContext) component.prevContext = component.context;\n    component.context = context;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!component.prevProps) component.prevProps = component.props;\n  component.props = props;\n  component._disable = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (opts!==NO_RENDER) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (opts===SYNC_RENDER || options.syncComponentUpdates!==\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e || !component.base) {\n      renderComponent(component, SYNC_RENDER, mountAll);\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      enqueueRender(component);\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component.__ref) component.__ref(component);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003esetComponentProps\u003c/code\u003e 里面现实执行组件的 \u003ccode\u003ecomponentWillMount/componentWillReceiveProps\u003c/code\u003e 方法。将 \u003ccode\u003eprops\u003c/code\u003e 传给组件的 \u003ccode\u003eprops\u003c/code\u003e。接着是进行 \u003ccode\u003erenderComponent\u003c/code\u003e 方法，这个时候传参已经是 \u003ccode\u003ecomponent, opts, mountAll, isChild\u003c/code\u003e，没有\u003ccode\u003evnode\u003c/code\u003e 了。\u003ccode\u003erenderComponent\u003c/code\u003e 方法在 \u003ccode\u003esetState\u003c/code\u003e 也有提到，是更新组件的最重要的步骤，而 \u003ccode\u003erenderComponent\u003c/code\u003e 关键点就是会修改组件的 \u003ccode\u003ebase\u003c/code\u003e 也就是 dom，接下来看看 \u003ccode\u003erenderComponent\u003c/code\u003e 方法实现：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erenderComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecomponent, opts, mountAll, isChild\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component._disable) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e props = component.props,\n    state = component.state,\n    context = component.context,\n    previousProps = component.prevProps || props,\n    previousState = component.prevState || state,\n  previousContext = component.prevContext || context,\n  \u003cspan class=\"hljs-comment\"\u003e// base和nextBase是 dom，或者undefined/null\u003c/span\u003e\n    isUpdate = component.base,\n    nextBase = component.nextBase,\n    initialBase = isUpdate || nextBase,\n    initialChildComponent = component._component,\n    skip = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n  rendered, inst, cbase;\n  \n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isUpdate) {\n    component.props = previousProps;\n    component.state = previousState;\n    component.context = previousContext;\n    \u003cspan class=\"hljs-comment\"\u003e// 通过shouldComponentUpdate判断是不是要执行更新\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (opts!==FORCE_RENDER\n      \u0026amp;\u0026amp; component.shouldComponentUpdate\n      \u0026amp;\u0026amp; component.shouldComponentUpdate(props, state, context) === \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e) {\n      skip = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component.componentWillUpdate) {\n      component.componentWillUpdate(props, state, context);\n    }\n    component.props = props;\n    component.state = state;\n    component.context = context;\n  }\n\n  component.prevProps = component.prevState = component.prevContext = component.nextBase = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  component._dirty = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!skip) {\n    \u003cspan class=\"hljs-comment\"\u003e// 渲染结果先。传入poprs，state。\u003c/span\u003e\n    rendered = component.render(props, state, context);\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component.getChildContext) {\n      context = extend(extend({}, context), component.getChildContext());\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e childComponent = rendered \u0026amp;\u0026amp; rendered.nodeName,\n      toUnmount, base;\n    \u003cspan class=\"hljs-comment\"\u003e// 如果render结果还是组件的话，继续render就好了，但是首次render要建立父组件和子组件关系。\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e childComponent===\u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e childProps = getNodeProps(rendered);\n      inst = initialChildComponent;\n      \u003cspan class=\"hljs-comment\"\u003e// 说明执行过了，和上次渲染一样，inst是rendered的实例class。为再次进入的时候，要求是同一组件，key也要一样。\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (inst \u0026amp;\u0026amp; inst.constructor===childComponent \u0026amp;\u0026amp; childProps.key==inst.__key) {\n        \u003cspan class=\"hljs-comment\"\u003e// 对于组件更新，则重新获取其props，再来就好了\u003c/span\u003e\n        setComponentProps(inst, childProps, SYNC_RENDER, context, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n      }\n      \u003cspan class=\"hljs-comment\"\u003e// 第一次进来的时候/不相同的时候\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        toUnmount = inst;\n\n    component._component = inst = createComponent(childComponent, childProps, context);\n    \u003cspan class=\"hljs-comment\"\u003e// nextBase 的传递\u003c/span\u003e\n        inst.nextBase = inst.nextBase || nextBase;\n        inst._parentComponent = component;\n        setComponentProps(inst, childProps, NO_RENDER, context, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n        \u003cspan class=\"hljs-comment\"\u003e// 指明inst是子关系，不用重复继承和执行钩子函数与componentDidMount，因为已经可以了\u003c/span\u003e\n        renderComponent(inst, SYNC_RENDER, mountAll, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n      }\n\n      base = inst.base;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      cbase = initialBase;\n      \u003cspan class=\"hljs-comment\"\u003e// 如果有component._component，说明上次里面生成的rendered是function，而cbase是该function生成的节点，\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e// 在本轮中rendered已经不是function了，故需要设置子组件_component为null。\u003c/span\u003e\n      toUnmount = initialChildComponent;\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (toUnmount) {\n        cbase = component._component = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n      }\n\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (initialBase || opts===SYNC_RENDER) {\n        \u003cspan class=\"hljs-comment\"\u003e// 需要先置为null，在重新指向\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (cbase) cbase._component = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n        base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase \u0026amp;\u0026amp; initialBase.parentNode, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n      }\n    }\n  \u003cspan class=\"hljs-comment\"\u003e// 生成的dom和原本的dom不一样，并且子组件也不一样的情况下\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (initialBase \u0026amp;\u0026amp; base!==initialBase \u0026amp;\u0026amp; inst!==initialChildComponent) {\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e baseParent = initialBase.parentNode;\n      \u003cspan class=\"hljs-comment\"\u003e// 如果执行了上面else里的diff，那diff中initialBase，已经被rendered替代了，initialBase没有挂载在任何节点上了，并且parentNode为null了。\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e// 所以下面的命令是针对上面typeof childComponent==='function'的情况的？但是在该情况的renderCompnent里面也会进入diff，\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e// 所以是根本进不来的？\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (baseParent \u0026amp;\u0026amp; base!==baseParent) {\n        \u003cspan class=\"hljs-comment\"\u003e// 这里是用本轮的base 替换掉上轮的base\u003c/span\u003e\n        baseParent.replaceChild(base, initialBase);\n        \u003cspan class=\"hljs-comment\"\u003e// 如果没有_component，为何要清理base？有base/nextbase，自然应该是要有_component的。\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// 已经replace了，为何还要remove base呢？\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!toUnmount) {\n          \u003cspan class=\"hljs-comment\"\u003e// 防止在recollectNodeTree过程里面_component被unMounted，而是直接remove节点就好了\u003c/span\u003e\n          initialBase._component = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n          recollectNodeTree(initialBase, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n        }\n      }\n    }\n    \u003cspan class=\"hljs-comment\"\u003e// 发生的情况只能是rendered从组件变为普通vnode或者其他组件，所以要卸载掉子组件。\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (toUnmount) {\n      unmountComponent(toUnmount);\n    }\n\n    component.base = base;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (base \u0026amp;\u0026amp; !isChild) {\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e componentRef = component,\n        t = component;\n      \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e ((t=t._parentComponent)) {\n        (componentRef = t).base = base;\n    }\n    \u003cspan class=\"hljs-comment\"\u003e// 指明dom的_component 指向组件，而_componentConstructor指向组件的构造器\u003c/span\u003e\n      base._component = componentRef;\n      base._componentConstructor = componentRef.constructor;\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isUpdate || mountAll) {\n    mounts.unshift(component);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!skip) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component.componentDidUpdate) {\n      component.componentDidUpdate(previousProps, previousState, previousContext);\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (options.afterUpdate) options.afterUpdate(component);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component._renderCallbacks!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (component._renderCallbacks.length) component._renderCallbacks.pop().call(component);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!diffLevel \u0026amp;\u0026amp; !isChild) flushMounts();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003erenderComponent\u003c/code\u003e 函数比较长。首先是第一个 if 语句里面，判断是否是 \u003ccode\u003eisUpdate\u003c/code\u003e，判断依据是有无 \u003ccode\u003ecomponent.base\u003c/code\u003e，初次加载组件的时候，组件本身是没有 \u003ccode\u003ebase\u003c/code\u003e 属性，最多才有 'nextBase' 属性，所以 \u003ccode\u003eisUpdate\u003c/code\u003e 用来区分是否是更新组件，如果是的话，执行组件的 \u003ccode\u003eshouldComponentUpdate\u003c/code\u003e 与 \u003ccode\u003ecomponentWillUpdate\u003c/code\u003e 方法，并判断是否执行后面一长串的渲染。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003erendered = component.render(props, state, context)\u003c/code\u003e 先是得出要渲染的 VNode，如果 \u003ccode\u003erendered\u003c/code\u003e 还是组件，则还要进行判断是否前后两次渲染子组件不一样或则是初次渲染。如果不是组件则主要是执行 \u003ccode\u003ediff\u003c/code\u003e 函数，生成新的 dom 节点 \u003ccode\u003ebase\u003c/code\u003e。 最后由于自组件变更或则消失，则卸载子组件。将生成的 \u003ccode\u003ebase\u003c/code\u003e dom 节点指向组件的 \u003ccode\u003ebase\u003c/code\u003e 属性，而 dom 节点还要新增 \u003ccode\u003e_component/_componentConstructor\u003c/code\u003e 属性。最后如果是初次加载则将组件放入初次加载组件的队列里面，准备执行 \u003ccode\u003ecomponentDidUpdate afterUpdate\u003c/code\u003e。底部的 \u003ccode\u003eflushMounts\u003c/code\u003e 则是，当是最顶部的一次 diff 递归进入尾声了，就执行 \u003ccode\u003eoptions.afterMount\u003c/code\u003e 和所有初次加载组件的 \u003ccode\u003ecomponentDidMount\u003c/code\u003e 方法。另外还有 \u003ccode\u003ecomponent._renderCallbacks\u003c/code\u003e，在组件状态变化，也就是在用 \u003ccode\u003esetState\u003c/code\u003e 的时候，如果存在第二个参数 \u003ccode\u003ecallback\u003c/code\u003e， 则会在这个时候执行 \u003ccode\u003ecallback\u003c/code\u003e。\u003c/p\u003e\n\u003ch3\u003e回收机制\u003c/h3\u003e\n\u003cp\u003e之前最早遇到回收问题是出现在 diff 函数上面，经常可以看到 \u003ccode\u003erecollectNodeTree(dom, true)\u003c/code\u003e 这句话，看看 \u003ccode\u003erecollectNodeTree\u003c/code\u003e 方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erecollectNodeTree\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enode, unmountOnly\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e component = node._component;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component) {\n    unmountComponent(component);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (node[ATTR_KEY]!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026amp;\u0026amp; node[ATTR_KEY].ref) node[ATTR_KEY].ref(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n    \u003cspan class=\"hljs-comment\"\u003e// 移除node节点\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (unmountOnly===\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e || node[ATTR_KEY]==\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n      removeNode(node);\n    }\n    \u003cspan class=\"hljs-comment\"\u003e// 再来一次遍历\u003c/span\u003e\n    removeChildren(node);\n  }\n}\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eremoveChildren\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enode\u003c/span\u003e) \u003c/span\u003e{\n  node = node.lastChild;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (node) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e next = node.previousSibling;\n    recollectNodeTree(node, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n    node = next;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里可以看到，对于非组件，则可以要先执行节点的 ref，这个 ref是什么？在组件 \u003ccode\u003esetComponentProps\u003c/code\u003e 最后一行代码还有个 \u003ccode\u003ecomponent.__ref\u003c/code\u003e。其实这两个都是一样的，都是节点 \u003ccode\u003eattribute\u003c/code\u003e 里面的 \u003ccode\u003eref\u003c/code\u003e 属性，也就是说组件初次加载的时候，或则回收组件/Dom 的时候都会执行，如果不仅仅是卸载还会在父节点上移除 \u003ccode\u003enode\u003c/code\u003e。从而实现回收。最后的 \u003ccode\u003eremoveChildren\u003c/code\u003e 只是遍历用的。基本上只要涉及到老节点的回收都会用到 \u003ccode\u003erecollectNodeTree\u003c/code\u003e 里面。在 \u003ccode\u003einnerDiffNode\u003c/code\u003e 最后也会对没有用的节点回收。除了节点 diff 的问题外，还有组件卸载的时候，也会调用 \u003ccode\u003eremoveChildren\u003c/code\u003e 方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eunmountComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecomponent\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (options.beforeUnmount) options.beforeUnmount(component);\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e base = component.base;\n  component._disable = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component.componentWillUnmount) component.componentWillUnmount();\n  component.base = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e inner = component._component;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (inner) {\n    unmountComponent(inner);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (base) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (base[ATTR_KEY] \u0026amp;\u0026amp; base[ATTR_KEY].ref) base[ATTR_KEY].ref(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n    component.nextBase = base;\n    removeNode(base);\n    collectComponent(component);\n    removeChildren(base);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (component.__ref) component.__ref(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面可以看出卸载组件的时候，会调用 \u003ccode\u003ecomponentWillUnmount\u003c/code\u003e 方法，接着执行 ref ，将卸载的组件生成的节点转移到 \u003ccode\u003enextBase\u003c/code\u003e 上面，再执行 \u003ccode\u003eremoveChildren\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e最后还有一个贯穿所有 diff 机制的传参 \u003ccode\u003emountAll\u003c/code\u003e，具体作用就算是组件更新，也将其作为初次加载，就是能执行 \u003ccode\u003ecomponentWillMount 与 componentDidMount\u003c/code\u003e 方法。\u003c/p\u003e\n\u003ch3\u003e总结\u003c/h3\u003e\n\u003cp\u003e这次的 Preact 之旅就到这里，代码虽少，但是还是活灵活现的展示了 diff 功能。源码里面有着无数行空行，以及代码解释，然而整体大小才 1000 行多点，min 之后更是只有 10kb 大小，相当袖珍。大家有机会还是去接触一下。\u003c/p\u003e\n"}},"buildId":"r4Ww0YLm8YL5~6SwciWHH","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" async=""></script></body></html>