<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">preact源码 - diff机制</title><link rel="preload" href="/blog-sys/_next/static/_P3qZyp8~kfTSPLoPskhF/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/_P3qZyp8~kfTSPLoPskhF/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/_P3qZyp8~kfTSPLoPskhF/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.491f56ba.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___3Hk0c "><a class="logo___1KD30" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___1qXLb" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___3VKNp"><h1 class="postTitle___26vXM">preact源码 - diff机制</h1><span class="postTime___16Ish">July 7, 2018</span></header><article class="postWrapper___3NXol post-article"><div><h3>前言</h3>
<p>每次看到有人谈起 React 的 diff 机制的时候，总觉得很厉害的样子，所以自然这里也是立马就想介绍 diff 机制。</p>
<h3>diff 机制</h3>
<p>以下面为例子来介绍：</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { h, render } <span class="hljs-keyword">from</span> <span class="hljs-string">'preact'</span>;

render((
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"foo"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> <span class="hljs-attr">e</span> =&gt;</span> alert("hi!") }&gt;Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
), <span class="hljs-built_in">document</span>.body);
</code></pre>
<p>render 方法的实现如下：</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { diff } <span class="hljs-keyword">from</span> <span class="hljs-string">'./vdom/diff'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">vnode, parent, merge</span>) </span>{
  <span class="hljs-keyword">return</span> diff(merge, vnode, {}, <span class="hljs-literal">false</span>, parent, <span class="hljs-literal">false</span>);
}
</code></pre>
<p>这里面 <code>merge</code> 是需要对比的 <code>VNode</code> 节点，<code>vnode</code> 就是传入节点，<code>parent</code> 则是挂载的节点。可以发现传入到 <code>render</code> 方法里面，最终还是会调用 <code>diff</code> 方法。看看 <code>diff</code> 的实现：</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">diff</span>(<span class="hljs-params">dom, vnode, context, mountAll, parent, componentRoot</span>) </span>{
  <span class="hljs-comment">// 初始化的时候才进入，每次进入diff函数都会自增，递归的level</span>
  <span class="hljs-keyword">if</span> (!diffLevel++) {
  <span class="hljs-comment">// SVG处理，判断是否是在SVG里面diff。</span>
    isSvgMode = parent!=<span class="hljs-literal">null</span> &amp;&amp; parent.ownerSVGElement!==<span class="hljs-literal">undefined</span>;
    <span class="hljs-comment">// 只有dom存在，且DOM没有__preactattr_属性，才为true；一般也就是初次进来的时候</span>
    hydrating = dom!=<span class="hljs-literal">null</span> &amp;&amp; !(ATTR_KEY <span class="hljs-keyword">in</span> dom);
  }

  <span class="hljs-keyword">let</span> ret = idiff(dom, vnode, context, mountAll, componentRoot);
  <span class="hljs-comment">// 挂载生成ret到parent去，也就是document.body</span>
  <span class="hljs-keyword">if</span> (parent &amp;&amp; ret.parentNode!==parent) parent.appendChild(ret);

  <span class="hljs-keyword">if</span> (!--diffLevel) {
    hydrating = <span class="hljs-literal">false</span>;
    <span class="hljs-comment">// 执行options.afterMount方法，和所有初次挂载的组件的componentDidMount方法</span>
    <span class="hljs-keyword">if</span> (!componentRoot) flushMounts();
  }

  <span class="hljs-keyword">return</span> ret;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushMounts</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> c;
  <span class="hljs-keyword">while</span> ((c=mounts.pop())) {
    <span class="hljs-keyword">if</span> (options.afterMount) options.afterMount(c);
    <span class="hljs-keyword">if</span> (c.componentDidMount) c.componentDidMount();
  }
}
</code></pre>
<p>**<code>render</code> 传参 <code>merge</code>，也就是 <code>diff</code> 方法传参 <code>dom</code>，是用来和 <code>vnode</code> 做 <code>diff</code> 的前节点。**可以看到上面 <code>diff</code> 方法主要作用是生成 <code>ret</code>，并将其挂载到 <code>parent</code> 上面去，并在最顶部的递归层，一般 <code>componentRoot</code> 是 <code>undefined/false</code>，可以执行所有已经加载的组件的 <code>componentDidMount</code> 方法。 <code>idiff</code> 的实现如下：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">idiff</span>(<span class="hljs-params">dom, vnode, context, mountAll, componentRoot</span>) </span>{
  <span class="hljs-keyword">let</span> out = dom,
    prevSvgMode = isSvgMode;
  <span class="hljs-comment">// 如果vnode是空，直接处理为''</span>
  <span class="hljs-keyword">if</span> (vnode==<span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> vnode===<span class="hljs-string">'boolean'</span>) vnode = <span class="hljs-string">''</span>;
  <span class="hljs-comment">// 若果vnode是字符串或则数字，便捷方式</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vnode===<span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> vnode===<span class="hljs-string">'number'</span>) {
    <span class="hljs-comment">// 通过splitText方法来判断是不是文本节点。若果dom是文本，就直接直接dom的nodeValue替换为 vnode</span>
    <span class="hljs-keyword">if</span> (dom &amp;&amp; dom.splitText!==<span class="hljs-literal">undefined</span> &amp;&amp; dom.parentNode &amp;&amp; (!dom._component || componentRoot)) {
      <span class="hljs-keyword">if</span> (dom.nodeValue!=vnode) {
        dom.nodeValue = vnode;
      }
    }
    <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 如果dom不是文本节点，就创建vnode的文本节点，并在dom的parent上替换掉dom。</span>
      out = <span class="hljs-built_in">document</span>.createTextNode(vnode);
      <span class="hljs-keyword">if</span> (dom) {
        <span class="hljs-keyword">if</span> (dom.parentNode) dom.parentNode.replaceChild(out, dom);
        recollectNodeTree(dom, <span class="hljs-literal">true</span>);
      }
    }
  out[ATTR_KEY] = <span class="hljs-literal">true</span>;
  <span class="hljs-comment">// 这里的out是个dom节点，而不是VNode</span>
    <span class="hljs-keyword">return</span> out;
  }
  <span class="hljs-comment">// 如果传入的 vnode 是函数，也就是class实例，是个组件，就返回buildComponentFromVNode的执行结果</span>
  <span class="hljs-keyword">let</span> vnodeName = vnode.nodeName;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vnodeName===<span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">return</span> buildComponentFromVNode(dom, vnode, context, mountAll);
  }
  isSvgMode = vnodeName===<span class="hljs-string">'svg'</span> ? <span class="hljs-literal">true</span> : vnodeName===<span class="hljs-string">'foreignObject'</span> ? <span class="hljs-literal">false</span> : isSvgMode;
  vnodeName = <span class="hljs-built_in">String</span>(vnodeName);
  <span class="hljs-comment">// 将vnode里面填充上dom的子元素,只有dom存在且为文本的时候才不进入。</span>
  <span class="hljs-keyword">if</span> (!dom || !isNamedNode(dom, vnodeName)) {
    <span class="hljs-comment">// 生成 vnodeName 的元素节点</span>
    out = createNode(vnodeName, isSvgMode);
    <span class="hljs-keyword">if</span> (dom) {
      <span class="hljs-comment">// 将dom里面的节点都添加到out里面</span>
      <span class="hljs-keyword">while</span> (dom.firstChild) out.appendChild(dom.firstChild);
      <span class="hljs-comment">// 最后直接用out替换掉dom</span>
      <span class="hljs-keyword">if</span> (dom.parentNode) dom.parentNode.replaceChild(out, dom);
      recollectNodeTree(dom, <span class="hljs-literal">true</span>);
    }
  }

  <span class="hljs-keyword">let</span> fc = out.firstChild,
    props = out[ATTR_KEY],
    vchildren = vnode.children;
  <span class="hljs-comment">// 给dome节点，将attributes属性添加到__preactattr_属性里面</span>
  <span class="hljs-keyword">if</span> (props==<span class="hljs-literal">null</span>) {
    props = out[ATTR_KEY] = {};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a=out.attributes, i=a.length; i--; ) props[a[i].name] = a[i].value;
  }
  <span class="hljs-comment">// hydrating为false的时候，若vnode只有一个节点string就直接替换掉out的第一个子节点。自然out后面的其他节点都会被除去</span>
  <span class="hljs-keyword">if</span> (!hydrating &amp;&amp; vchildren &amp;&amp; vchildren.length===<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-keyword">typeof</span> vchildren[<span class="hljs-number">0</span>]===<span class="hljs-string">'string'</span> &amp;&amp; fc!=<span class="hljs-literal">null</span> &amp;&amp; fc.splitText!==<span class="hljs-literal">undefined</span> &amp;&amp; fc.nextSibling==<span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">if</span> (fc.nodeValue!=vchildren[<span class="hljs-number">0</span>]) {
      fc.nodeValue = vchildren[<span class="hljs-number">0</span>];
    }
  }
  <span class="hljs-comment">// 只要有vchildren和out有子节点就来innerDiffNode，</span>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vchildren &amp;&amp; vchildren.length || fc!=<span class="hljs-literal">null</span>) {
    innerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML!=<span class="hljs-literal">null</span>);
  }
  <span class="hljs-comment">//把vnode的属性都传到out，还有props吧。</span>
  diffAttributes(out, vnode.attributes, props);
  <span class="hljs-comment">//还原之前的isSvgMode值</span>
  isSvgMode = prevSvgMode;

  <span class="hljs-keyword">return</span> out;
}
</code></pre>
<p>这里的 <code>idiff</code> 方法，看着比较复杂，实际上还是对传参 vnode 进行分类判断，分为下面几种情况：</p>
<ol>
<li>简单的类型 string/number 之类的，直接用 vnode 替换掉 dom 元素，返回 vnode 的文本节点。</li>
<li>vnode 是 Component的形式，调用 buildComponentFromVNode 方法，最后会返回处理过的 dom 节点。</li>
<li>vnode 只有一个节点，且为文本，并且 dom 情况也是一样的，就替换掉 nodeValue。如若不是则调用 innerDiffNode 方法，来 diff dom 和 vnode。</li>
</ol>
<p>这里面第一种情况是最基础的，<code>vnode</code> 是文本，就要替换掉对应的 <code>dom</code>，第二种情况是组件的方式，这里先不谈。第三种比较麻烦，是多个子节点情况，如若 <code>dom</code> 存在并且为文本节点，<code>out</code> 变量就是 <code>dom</code> 这个文本节点，否则 <code>out</code> 会是 <code>vnodeName</code> 的元素空节点，随后将<code>dom</code> 子节点转移到 <code>out</code>下面。接着设置 <code>out</code> 的 <code>__preactattr_</code> 属性。</p>
<p>在第三种情况时，对于前一种简答情况，如果 <code>dom</code> 是 <code>&lt;div&gt;123&lt;/div&gt;</code>，而 vnode 的 children 属性为文本的话，例如：<code>vnode = {nodeName: 'SPAN', Children: ['sb'].....}</code>，则生成的 <code>out</code> 为 <code>&lt;span&gt;sb&lt;/span&gt;</code>，这种是简单的情况。复杂情况下需要调用到 <code>innerDiffNode</code> 方法。在介绍 <code>innerDiffNode</code> 之前，先看看 <code>idiff</code> 方法最下面的 <code>diffAttributes</code> 方法：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">diffAttributes</span>(<span class="hljs-params">dom, attrs, old</span>) </span>{
  <span class="hljs-keyword">let</span> name;
  <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> old) {
    <span class="hljs-keyword">if</span> (!(attrs &amp;&amp; attrs[name]!=<span class="hljs-literal">null</span>) &amp;&amp; old[name]!=<span class="hljs-literal">null</span>) {
      setAccessor(dom, name, old[name], old[name] = <span class="hljs-literal">undefined</span>, isSvgMode);
    }
  }
  <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> attrs) {
    <span class="hljs-keyword">if</span> (name!==<span class="hljs-string">'children'</span> &amp;&amp; name!==<span class="hljs-string">'innerHTML'</span> &amp;&amp; (!(name <span class="hljs-keyword">in</span> old) || attrs[name]!==(name===<span class="hljs-string">'value'</span> || name===<span class="hljs-string">'checked'</span> ? dom[name] : old[name]))) {
      setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);
    }
  }
}
</code></pre>
<p><code>diffAttributes</code> 方法就是将 <code>vnode</code> 里面 <code>attribute</code> 和 <code>props</code> 属性添加到 <code>out</code> 里面，最后返回的是 <code>out</code> 元素而不是 vnode！<code>setAccessor</code> 基本就是些条件语句，根据出入的属性名，来分类处理，看看就好了。就这样<strong>将 vnode 里面的 <code>attribute</code> 属性添加到 <code>out</code> 里面</strong>。</p>
<h3>innerDiffNode</h3>
<p><code>idiff</code> 第三种情况的复杂情况下下会调用 <code>innerDiffNode</code> 方法，实际上就是对 <code>vnode</code> 的子元素和 <code>out</code> 的子元素进行递归对比。先看看 <code>innerDiffNode</code> 的实现：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerDiffNode</span>(<span class="hljs-params">dom, vchildren, context, mountAll, isHydrating</span>) </span>{
  <span class="hljs-keyword">let</span> originalChildren = dom.childNodes,
    children = [],
    keyed = {},
    keyedLen = <span class="hljs-number">0</span>,
    min = <span class="hljs-number">0</span>,
    len = originalChildren.length,
    childrenLen = <span class="hljs-number">0</span>,
    vlen = vchildren ? vchildren.length : <span class="hljs-number">0</span>,
    j, c, f, vchild, child;
  <span class="hljs-comment">// 对比的dom有children的时候</span>
  <span class="hljs-keyword">if</span> (len!==<span class="hljs-number">0</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;len; i++) {
      <span class="hljs-keyword">let</span> child = originalChildren[i],
        props = child[ATTR_KEY],
        <span class="hljs-comment">// key就是指平时写map循环的时候，数组里面的子vnode用来区分的key。如果child由component生成，则用component的__key。否则用props传入的key，如&lt;div key={1}&gt;&lt;/div&gt;这里面的key。</span>
        key = vlen &amp;&amp; props ? child._component ? child._component.__key : props.key : <span class="hljs-literal">null</span>;
      <span class="hljs-comment">// child有__preactattr_属性，也就是之前有添加过__preactattr_属性，可以看idff方法里面的第三种。</span>
      <span class="hljs-keyword">if</span> (key!=<span class="hljs-literal">null</span>) {
        keyedLen++;
        keyed[key] = child;
      }
      <span class="hljs-comment">// 如果child存在__preactattr_，或则child为文本，就将Dom的child缓存到children里面</span>
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (props || (child.splitText!==<span class="hljs-literal">undefined</span> ? (isHydrating ? child.nodeValue.trim() : <span class="hljs-literal">true</span>) : isHydrating)) {
        children[childrenLen++] = child;
      }
    }
  }
  <span class="hljs-comment">// vnode子节点长度不0</span>
  <span class="hljs-keyword">if</span> (vlen!==<span class="hljs-number">0</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;vlen; i++) {
      vchild = vchildren[i];
      child = <span class="hljs-literal">null</span>;
      <span class="hljs-comment">// 试着去寻找vchild和keyed里面保存的相同之处，也就是key，如果vnode的子节点的key值，在out里面能找到的话，说明他们是应该一一对应的，child就是out里面对应的节点。</span>
      <span class="hljs-keyword">let</span> key = vchild.key;
      <span class="hljs-keyword">if</span> (key!=<span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (keyedLen &amp;&amp; keyed[key]!==<span class="hljs-literal">undefined</span>) {
          child = keyed[key];
          keyed[key] = <span class="hljs-literal">undefined</span>;
          keyedLen--;
        }
      }
      <span class="hljs-comment">// 按out里面存在的子节点，依次和vnode里面的子节点排排坐对比。依次来，如果是相同的node类型，就找到了对应的out节点。并且后面的undefined设置和自加自减操作都是为了优化循环；</span>
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!child &amp;&amp; min&lt;childrenLen) {
        <span class="hljs-keyword">for</span> (j=min; j&lt;childrenLen; j++) {
          <span class="hljs-keyword">if</span> (children[j]!==<span class="hljs-literal">undefined</span> &amp;&amp; isSameNodeType(c = children[j], vchild, isHydrating)) {
            child = c;
            children[j] = <span class="hljs-literal">undefined</span>;
            <span class="hljs-keyword">if</span> (j===childrenLen<span class="hljs-number">-1</span>) childrenLen--;
            <span class="hljs-keyword">if</span> (j===min) min++;
            <span class="hljs-keyword">break</span>;
          }
        }
      }
      <span class="hljs-comment">// 对比生成新的child</span>
      child = idiff(child, vchild, context, mountAll);

      f = originalChildren[i];
      <span class="hljs-keyword">if</span> (child &amp;&amp; child!==dom &amp;&amp; child!==f) {
        <span class="hljs-keyword">if</span> (f==<span class="hljs-literal">null</span>) {
          dom.appendChild(child);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child===f.nextSibling) {
          removeNode(f);
        }
        <span class="hljs-keyword">else</span> {
          dom.insertBefore(child, f);
        }
      }
    }
  }
  <span class="hljs-comment">// 下面两个步骤都是移除节点</span>
  <span class="hljs-keyword">if</span> (keyedLen) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> keyed) <span class="hljs-keyword">if</span> (keyed[i]!==<span class="hljs-literal">undefined</span>) recollectNodeTree(keyed[i], <span class="hljs-literal">false</span>);
  }
  <span class="hljs-keyword">while</span> (min&lt;=childrenLen) {
    <span class="hljs-keyword">if</span> ((child = children[childrenLen--])!==<span class="hljs-literal">undefined</span>) recollectNodeTree(child, <span class="hljs-literal">false</span>);
  }
}
</code></pre>
<p><code>innerDiffNode</code> 的目的就是要 <code>vnode</code> 的每个 <code>vchild</code> 和能与其对应上的 <code>out</code> 下面的 <code>child</code> 进行对比，也就是调用 <code>diff</code> 方法，从而实现子节点之间的对比。在 <code>innerDiffNode</code> 里面对比找出 <code>child</code> 的过程，看上面代码中的解释就好了。在通过 <code>idiff</code> 方法生成新的 <code>child</code> 后，<code>child</code> 会被加入到 <code>out</code> 里面。从而一步步将 <code>vnode</code> 的 <code>children</code> 移入作为 <code>out</code> 的节点。在遍历了所有的 <code>vnode</code> 的 <code>children</code> 之后，还需要对下面两种 <code>out</code> 的子节点移除：</p>
<ol>
<li>out 子节点里面带 <code>key</code> 属性的节点，如果没有匹配上 vnode 的 children ，需要移除；</li>
<li>再次进入循环的 child 节点或则是首次进入非空字符串的文本节点，如果没有匹配上 vnode 的 children 也会被移除掉。</li>
</ol>
<h3>总结</h3>
<p>diff 机制基本就是不断的遍历子节点和 vnode，来实现对比不同。将 vnode 里面的内容添加到 dom 里面，而将 dom 里面不需要的多余的子节点移除掉。所以这里还需要理解整体的移除机制，以及组件生成对比的机制，将在下篇文章里面介绍到。</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"July 7, 2018","title":"preact源码 - diff机制","content":"\u003ch3\u003e前言\u003c/h3\u003e\n\u003cp\u003e每次看到有人谈起 React 的 diff 机制的时候，总觉得很厉害的样子，所以自然这里也是立马就想介绍 diff 机制。\u003c/p\u003e\n\u003ch3\u003ediff 机制\u003c/h3\u003e\n\u003cp\u003e以下面为例子来介绍：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { h, render } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'preact'\u003c/span\u003e;\n\nrender((\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"foo\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u0026gt;\u003c/span\u003eHello, world!\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ee\u003c/span\u003e =\u0026gt;\u003c/span\u003e alert(\"hi!\") }\u0026gt;Click Me\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n), \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.body);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003erender 方法的实现如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { diff } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./vdom/diff'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003evnode, parent, merge\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e diff(merge, vnode, {}, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, parent, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里面 \u003ccode\u003emerge\u003c/code\u003e 是需要对比的 \u003ccode\u003eVNode\u003c/code\u003e 节点，\u003ccode\u003evnode\u003c/code\u003e 就是传入节点，\u003ccode\u003eparent\u003c/code\u003e 则是挂载的节点。可以发现传入到 \u003ccode\u003erender\u003c/code\u003e 方法里面，最终还是会调用 \u003ccode\u003ediff\u003c/code\u003e 方法。看看 \u003ccode\u003ediff\u003c/code\u003e 的实现：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ediff\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edom, vnode, context, mountAll, parent, componentRoot\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 初始化的时候才进入，每次进入diff函数都会自增，递归的level\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!diffLevel++) {\n  \u003cspan class=\"hljs-comment\"\u003e// SVG处理，判断是否是在SVG里面diff。\u003c/span\u003e\n    isSvgMode = parent!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026amp;\u0026amp; parent.ownerSVGElement!==\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n    \u003cspan class=\"hljs-comment\"\u003e// 只有dom存在，且DOM没有__preactattr_属性，才为true；一般也就是初次进来的时候\u003c/span\u003e\n    hydrating = dom!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026amp;\u0026amp; !(ATTR_KEY \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e dom);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e ret = idiff(dom, vnode, context, mountAll, componentRoot);\n  \u003cspan class=\"hljs-comment\"\u003e// 挂载生成ret到parent去，也就是document.body\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (parent \u0026amp;\u0026amp; ret.parentNode!==parent) parent.appendChild(ret);\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!--diffLevel) {\n    hydrating = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    \u003cspan class=\"hljs-comment\"\u003e// 执行options.afterMount方法，和所有初次挂载的组件的componentDidMount方法\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!componentRoot) flushMounts();\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e ret;\n}\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eflushMounts\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e c;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e ((c=mounts.pop())) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (options.afterMount) options.afterMount(c);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (c.componentDidMount) c.componentDidMount();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e**\u003ccode\u003erender\u003c/code\u003e 传参 \u003ccode\u003emerge\u003c/code\u003e，也就是 \u003ccode\u003ediff\u003c/code\u003e 方法传参 \u003ccode\u003edom\u003c/code\u003e，是用来和 \u003ccode\u003evnode\u003c/code\u003e 做 \u003ccode\u003ediff\u003c/code\u003e 的前节点。**可以看到上面 \u003ccode\u003ediff\u003c/code\u003e 方法主要作用是生成 \u003ccode\u003eret\u003c/code\u003e，并将其挂载到 \u003ccode\u003eparent\u003c/code\u003e 上面去，并在最顶部的递归层，一般 \u003ccode\u003ecomponentRoot\u003c/code\u003e 是 \u003ccode\u003eundefined/false\u003c/code\u003e，可以执行所有已经加载的组件的 \u003ccode\u003ecomponentDidMount\u003c/code\u003e 方法。 \u003ccode\u003eidiff\u003c/code\u003e 的实现如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eidiff\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edom, vnode, context, mountAll, componentRoot\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e out = dom,\n    prevSvgMode = isSvgMode;\n  \u003cspan class=\"hljs-comment\"\u003e// 如果vnode是空，直接处理为''\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (vnode==\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e || \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e vnode===\u003cspan class=\"hljs-string\"\u003e'boolean'\u003c/span\u003e) vnode = \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// 若果vnode是字符串或则数字，便捷方式\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e vnode===\u003cspan class=\"hljs-string\"\u003e'string'\u003c/span\u003e || \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e vnode===\u003cspan class=\"hljs-string\"\u003e'number'\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 通过splitText方法来判断是不是文本节点。若果dom是文本，就直接直接dom的nodeValue替换为 vnode\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (dom \u0026amp;\u0026amp; dom.splitText!==\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e \u0026amp;\u0026amp; dom.parentNode \u0026amp;\u0026amp; (!dom._component || componentRoot)) {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (dom.nodeValue!=vnode) {\n        dom.nodeValue = vnode;\n      }\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// 如果dom不是文本节点，就创建vnode的文本节点，并在dom的parent上替换掉dom。\u003c/span\u003e\n      out = \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.createTextNode(vnode);\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (dom) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n        recollectNodeTree(dom, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n      }\n    }\n  out[ATTR_KEY] = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// 这里的out是个dom节点，而不是VNode\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e out;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 如果传入的 vnode 是函数，也就是class实例，是个组件，就返回buildComponentFromVNode的执行结果\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e vnodeName = vnode.nodeName;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e vnodeName===\u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e buildComponentFromVNode(dom, vnode, context, mountAll);\n  }\n  isSvgMode = vnodeName===\u003cspan class=\"hljs-string\"\u003e'svg'\u003c/span\u003e ? \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e : vnodeName===\u003cspan class=\"hljs-string\"\u003e'foreignObject'\u003c/span\u003e ? \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e : isSvgMode;\n  vnodeName = \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e(vnodeName);\n  \u003cspan class=\"hljs-comment\"\u003e// 将vnode里面填充上dom的子元素,只有dom存在且为文本的时候才不进入。\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!dom || !isNamedNode(dom, vnodeName)) {\n    \u003cspan class=\"hljs-comment\"\u003e// 生成 vnodeName 的元素节点\u003c/span\u003e\n    out = createNode(vnodeName, isSvgMode);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (dom) {\n      \u003cspan class=\"hljs-comment\"\u003e// 将dom里面的节点都添加到out里面\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (dom.firstChild) out.appendChild(dom.firstChild);\n      \u003cspan class=\"hljs-comment\"\u003e// 最后直接用out替换掉dom\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n      recollectNodeTree(dom, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n    }\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e fc = out.firstChild,\n    props = out[ATTR_KEY],\n    vchildren = vnode.children;\n  \u003cspan class=\"hljs-comment\"\u003e// 给dome节点，将attributes属性添加到__preactattr_属性里面\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (props==\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    props = out[ATTR_KEY] = {};\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e a=out.attributes, i=a.length; i--; ) props[a[i].name] = a[i].value;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// hydrating为false的时候，若vnode只有一个节点string就直接替换掉out的第一个子节点。自然out后面的其他节点都会被除去\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!hydrating \u0026amp;\u0026amp; vchildren \u0026amp;\u0026amp; vchildren.length===\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u0026amp;\u0026amp; \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e vchildren[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]===\u003cspan class=\"hljs-string\"\u003e'string'\u003c/span\u003e \u0026amp;\u0026amp; fc!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026amp;\u0026amp; fc.splitText!==\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e \u0026amp;\u0026amp; fc.nextSibling==\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (fc.nodeValue!=vchildren[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]) {\n      fc.nodeValue = vchildren[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e];\n    }\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 只要有vchildren和out有子节点就来innerDiffNode，\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (vchildren \u0026amp;\u0026amp; vchildren.length || fc!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    innerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n  }\n  \u003cspan class=\"hljs-comment\"\u003e//把vnode的属性都传到out，还有props吧。\u003c/span\u003e\n  diffAttributes(out, vnode.attributes, props);\n  \u003cspan class=\"hljs-comment\"\u003e//还原之前的isSvgMode值\u003c/span\u003e\n  isSvgMode = prevSvgMode;\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e out;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里的 \u003ccode\u003eidiff\u003c/code\u003e 方法，看着比较复杂，实际上还是对传参 vnode 进行分类判断，分为下面几种情况：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e简单的类型 string/number 之类的，直接用 vnode 替换掉 dom 元素，返回 vnode 的文本节点。\u003c/li\u003e\n\u003cli\u003evnode 是 Component的形式，调用 buildComponentFromVNode 方法，最后会返回处理过的 dom 节点。\u003c/li\u003e\n\u003cli\u003evnode 只有一个节点，且为文本，并且 dom 情况也是一样的，就替换掉 nodeValue。如若不是则调用 innerDiffNode 方法，来 diff dom 和 vnode。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这里面第一种情况是最基础的，\u003ccode\u003evnode\u003c/code\u003e 是文本，就要替换掉对应的 \u003ccode\u003edom\u003c/code\u003e，第二种情况是组件的方式，这里先不谈。第三种比较麻烦，是多个子节点情况，如若 \u003ccode\u003edom\u003c/code\u003e 存在并且为文本节点，\u003ccode\u003eout\u003c/code\u003e 变量就是 \u003ccode\u003edom\u003c/code\u003e 这个文本节点，否则 \u003ccode\u003eout\u003c/code\u003e 会是 \u003ccode\u003evnodeName\u003c/code\u003e 的元素空节点，随后将\u003ccode\u003edom\u003c/code\u003e 子节点转移到 \u003ccode\u003eout\u003c/code\u003e下面。接着设置 \u003ccode\u003eout\u003c/code\u003e 的 \u003ccode\u003e__preactattr_\u003c/code\u003e 属性。\u003c/p\u003e\n\u003cp\u003e在第三种情况时，对于前一种简答情况，如果 \u003ccode\u003edom\u003c/code\u003e 是 \u003ccode\u003e\u0026lt;div\u0026gt;123\u0026lt;/div\u0026gt;\u003c/code\u003e，而 vnode 的 children 属性为文本的话，例如：\u003ccode\u003evnode = {nodeName: 'SPAN', Children: ['sb'].....}\u003c/code\u003e，则生成的 \u003ccode\u003eout\u003c/code\u003e 为 \u003ccode\u003e\u0026lt;span\u0026gt;sb\u0026lt;/span\u0026gt;\u003c/code\u003e，这种是简单的情况。复杂情况下需要调用到 \u003ccode\u003einnerDiffNode\u003c/code\u003e 方法。在介绍 \u003ccode\u003einnerDiffNode\u003c/code\u003e 之前，先看看 \u003ccode\u003eidiff\u003c/code\u003e 方法最下面的 \u003ccode\u003ediffAttributes\u003c/code\u003e 方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ediffAttributes\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edom, attrs, old\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e name;\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (name \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e old) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!(attrs \u0026amp;\u0026amp; attrs[name]!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) \u0026amp;\u0026amp; old[name]!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n      setAccessor(dom, name, old[name], old[name] = \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e, isSvgMode);\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (name \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e attrs) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (name!==\u003cspan class=\"hljs-string\"\u003e'children'\u003c/span\u003e \u0026amp;\u0026amp; name!==\u003cspan class=\"hljs-string\"\u003e'innerHTML'\u003c/span\u003e \u0026amp;\u0026amp; (!(name \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e old) || attrs[name]!==(name===\u003cspan class=\"hljs-string\"\u003e'value'\u003c/span\u003e || name===\u003cspan class=\"hljs-string\"\u003e'checked'\u003c/span\u003e ? dom[name] : old[name]))) {\n      setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ediffAttributes\u003c/code\u003e 方法就是将 \u003ccode\u003evnode\u003c/code\u003e 里面 \u003ccode\u003eattribute\u003c/code\u003e 和 \u003ccode\u003eprops\u003c/code\u003e 属性添加到 \u003ccode\u003eout\u003c/code\u003e 里面，最后返回的是 \u003ccode\u003eout\u003c/code\u003e 元素而不是 vnode！\u003ccode\u003esetAccessor\u003c/code\u003e 基本就是些条件语句，根据出入的属性名，来分类处理，看看就好了。就这样\u003cstrong\u003e将 vnode 里面的 \u003ccode\u003eattribute\u003c/code\u003e 属性添加到 \u003ccode\u003eout\u003c/code\u003e 里面\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3\u003einnerDiffNode\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eidiff\u003c/code\u003e 第三种情况的复杂情况下下会调用 \u003ccode\u003einnerDiffNode\u003c/code\u003e 方法，实际上就是对 \u003ccode\u003evnode\u003c/code\u003e 的子元素和 \u003ccode\u003eout\u003c/code\u003e 的子元素进行递归对比。先看看 \u003ccode\u003einnerDiffNode\u003c/code\u003e 的实现：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003einnerDiffNode\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edom, vchildren, context, mountAll, isHydrating\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e originalChildren = dom.childNodes,\n    children = [],\n    keyed = {},\n    keyedLen = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n    min = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n    len = originalChildren.length,\n    childrenLen = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n    vlen = vchildren ? vchildren.length : \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n    j, c, f, vchild, child;\n  \u003cspan class=\"hljs-comment\"\u003e// 对比的dom有children的时候\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (len!==\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i\u0026lt;len; i++) {\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e child = originalChildren[i],\n        props = child[ATTR_KEY],\n        \u003cspan class=\"hljs-comment\"\u003e// key就是指平时写map循环的时候，数组里面的子vnode用来区分的key。如果child由component生成，则用component的__key。否则用props传入的key，如\u0026lt;div key={1}\u0026gt;\u0026lt;/div\u0026gt;这里面的key。\u003c/span\u003e\n        key = vlen \u0026amp;\u0026amp; props ? child._component ? child._component.__key : props.key : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n      \u003cspan class=\"hljs-comment\"\u003e// child有__preactattr_属性，也就是之前有添加过__preactattr_属性，可以看idff方法里面的第三种。\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (key!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n        keyedLen++;\n        keyed[key] = child;\n      }\n      \u003cspan class=\"hljs-comment\"\u003e// 如果child存在__preactattr_，或则child为文本，就将Dom的child缓存到children里面\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (props || (child.splitText!==\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e ? (isHydrating ? child.nodeValue.trim() : \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e) : isHydrating)) {\n        children[childrenLen++] = child;\n      }\n    }\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// vnode子节点长度不0\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (vlen!==\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i\u0026lt;vlen; i++) {\n      vchild = vchildren[i];\n      child = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n      \u003cspan class=\"hljs-comment\"\u003e// 试着去寻找vchild和keyed里面保存的相同之处，也就是key，如果vnode的子节点的key值，在out里面能找到的话，说明他们是应该一一对应的，child就是out里面对应的节点。\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e key = vchild.key;\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (key!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (keyedLen \u0026amp;\u0026amp; keyed[key]!==\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e) {\n          child = keyed[key];\n          keyed[key] = \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n          keyedLen--;\n        }\n      }\n      \u003cspan class=\"hljs-comment\"\u003e// 按out里面存在的子节点，依次和vnode里面的子节点排排坐对比。依次来，如果是相同的node类型，就找到了对应的out节点。并且后面的undefined设置和自加自减操作都是为了优化循环；\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!child \u0026amp;\u0026amp; min\u0026lt;childrenLen) {\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (j=min; j\u0026lt;childrenLen; j++) {\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (children[j]!==\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e \u0026amp;\u0026amp; isSameNodeType(c = children[j], vchild, isHydrating)) {\n            child = c;\n            children[j] = \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (j===childrenLen\u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e) childrenLen--;\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (j===min) min++;\n            \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n          }\n        }\n      }\n      \u003cspan class=\"hljs-comment\"\u003e// 对比生成新的child\u003c/span\u003e\n      child = idiff(child, vchild, context, mountAll);\n\n      f = originalChildren[i];\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (child \u0026amp;\u0026amp; child!==dom \u0026amp;\u0026amp; child!==f) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (f==\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n          dom.appendChild(child);\n        }\n        \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (child===f.nextSibling) {\n          removeNode(f);\n        }\n        \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n          dom.insertBefore(child, f);\n        }\n      }\n    }\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 下面两个步骤都是移除节点\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (keyedLen) {\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e keyed) \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (keyed[i]!==\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e) recollectNodeTree(keyed[i], \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (min\u0026lt;=childrenLen) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ((child = children[childrenLen--])!==\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e) recollectNodeTree(child, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003einnerDiffNode\u003c/code\u003e 的目的就是要 \u003ccode\u003evnode\u003c/code\u003e 的每个 \u003ccode\u003evchild\u003c/code\u003e 和能与其对应上的 \u003ccode\u003eout\u003c/code\u003e 下面的 \u003ccode\u003echild\u003c/code\u003e 进行对比，也就是调用 \u003ccode\u003ediff\u003c/code\u003e 方法，从而实现子节点之间的对比。在 \u003ccode\u003einnerDiffNode\u003c/code\u003e 里面对比找出 \u003ccode\u003echild\u003c/code\u003e 的过程，看上面代码中的解释就好了。在通过 \u003ccode\u003eidiff\u003c/code\u003e 方法生成新的 \u003ccode\u003echild\u003c/code\u003e 后，\u003ccode\u003echild\u003c/code\u003e 会被加入到 \u003ccode\u003eout\u003c/code\u003e 里面。从而一步步将 \u003ccode\u003evnode\u003c/code\u003e 的 \u003ccode\u003echildren\u003c/code\u003e 移入作为 \u003ccode\u003eout\u003c/code\u003e 的节点。在遍历了所有的 \u003ccode\u003evnode\u003c/code\u003e 的 \u003ccode\u003echildren\u003c/code\u003e 之后，还需要对下面两种 \u003ccode\u003eout\u003c/code\u003e 的子节点移除：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eout 子节点里面带 \u003ccode\u003ekey\u003c/code\u003e 属性的节点，如果没有匹配上 vnode 的 children ，需要移除；\u003c/li\u003e\n\u003cli\u003e再次进入循环的 child 节点或则是首次进入非空字符串的文本节点，如果没有匹配上 vnode 的 children 也会被移除掉。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e总结\u003c/h3\u003e\n\u003cp\u003ediff 机制基本就是不断的遍历子节点和 vnode，来实现对比不同。将 vnode 里面的内容添加到 dom 里面，而将 dom 里面不需要的多余的子节点移除掉。所以这里还需要理解整体的移除机制，以及组件生成对比的机制，将在下篇文章里面介绍到。\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"July 7, 2018","title":"preact源码 - diff机制","content":"\u003ch3\u003e前言\u003c/h3\u003e\n\u003cp\u003e每次看到有人谈起 React 的 diff 机制的时候，总觉得很厉害的样子，所以自然这里也是立马就想介绍 diff 机制。\u003c/p\u003e\n\u003ch3\u003ediff 机制\u003c/h3\u003e\n\u003cp\u003e以下面为例子来介绍：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { h, render } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'preact'\u003c/span\u003e;\n\nrender((\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"foo\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u0026gt;\u003c/span\u003eHello, world!\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ee\u003c/span\u003e =\u0026gt;\u003c/span\u003e alert(\"hi!\") }\u0026gt;Click Me\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n), \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.body);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003erender 方法的实现如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { diff } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./vdom/diff'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003evnode, parent, merge\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e diff(merge, vnode, {}, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, parent, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里面 \u003ccode\u003emerge\u003c/code\u003e 是需要对比的 \u003ccode\u003eVNode\u003c/code\u003e 节点，\u003ccode\u003evnode\u003c/code\u003e 就是传入节点，\u003ccode\u003eparent\u003c/code\u003e 则是挂载的节点。可以发现传入到 \u003ccode\u003erender\u003c/code\u003e 方法里面，最终还是会调用 \u003ccode\u003ediff\u003c/code\u003e 方法。看看 \u003ccode\u003ediff\u003c/code\u003e 的实现：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ediff\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edom, vnode, context, mountAll, parent, componentRoot\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 初始化的时候才进入，每次进入diff函数都会自增，递归的level\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!diffLevel++) {\n  \u003cspan class=\"hljs-comment\"\u003e// SVG处理，判断是否是在SVG里面diff。\u003c/span\u003e\n    isSvgMode = parent!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026amp;\u0026amp; parent.ownerSVGElement!==\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n    \u003cspan class=\"hljs-comment\"\u003e// 只有dom存在，且DOM没有__preactattr_属性，才为true；一般也就是初次进来的时候\u003c/span\u003e\n    hydrating = dom!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026amp;\u0026amp; !(ATTR_KEY \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e dom);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e ret = idiff(dom, vnode, context, mountAll, componentRoot);\n  \u003cspan class=\"hljs-comment\"\u003e// 挂载生成ret到parent去，也就是document.body\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (parent \u0026amp;\u0026amp; ret.parentNode!==parent) parent.appendChild(ret);\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!--diffLevel) {\n    hydrating = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    \u003cspan class=\"hljs-comment\"\u003e// 执行options.afterMount方法，和所有初次挂载的组件的componentDidMount方法\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!componentRoot) flushMounts();\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e ret;\n}\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eflushMounts\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e c;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e ((c=mounts.pop())) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (options.afterMount) options.afterMount(c);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (c.componentDidMount) c.componentDidMount();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e**\u003ccode\u003erender\u003c/code\u003e 传参 \u003ccode\u003emerge\u003c/code\u003e，也就是 \u003ccode\u003ediff\u003c/code\u003e 方法传参 \u003ccode\u003edom\u003c/code\u003e，是用来和 \u003ccode\u003evnode\u003c/code\u003e 做 \u003ccode\u003ediff\u003c/code\u003e 的前节点。**可以看到上面 \u003ccode\u003ediff\u003c/code\u003e 方法主要作用是生成 \u003ccode\u003eret\u003c/code\u003e，并将其挂载到 \u003ccode\u003eparent\u003c/code\u003e 上面去，并在最顶部的递归层，一般 \u003ccode\u003ecomponentRoot\u003c/code\u003e 是 \u003ccode\u003eundefined/false\u003c/code\u003e，可以执行所有已经加载的组件的 \u003ccode\u003ecomponentDidMount\u003c/code\u003e 方法。 \u003ccode\u003eidiff\u003c/code\u003e 的实现如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eidiff\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edom, vnode, context, mountAll, componentRoot\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e out = dom,\n    prevSvgMode = isSvgMode;\n  \u003cspan class=\"hljs-comment\"\u003e// 如果vnode是空，直接处理为''\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (vnode==\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e || \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e vnode===\u003cspan class=\"hljs-string\"\u003e'boolean'\u003c/span\u003e) vnode = \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// 若果vnode是字符串或则数字，便捷方式\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e vnode===\u003cspan class=\"hljs-string\"\u003e'string'\u003c/span\u003e || \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e vnode===\u003cspan class=\"hljs-string\"\u003e'number'\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 通过splitText方法来判断是不是文本节点。若果dom是文本，就直接直接dom的nodeValue替换为 vnode\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (dom \u0026amp;\u0026amp; dom.splitText!==\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e \u0026amp;\u0026amp; dom.parentNode \u0026amp;\u0026amp; (!dom._component || componentRoot)) {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (dom.nodeValue!=vnode) {\n        dom.nodeValue = vnode;\n      }\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// 如果dom不是文本节点，就创建vnode的文本节点，并在dom的parent上替换掉dom。\u003c/span\u003e\n      out = \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.createTextNode(vnode);\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (dom) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n        recollectNodeTree(dom, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n      }\n    }\n  out[ATTR_KEY] = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// 这里的out是个dom节点，而不是VNode\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e out;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 如果传入的 vnode 是函数，也就是class实例，是个组件，就返回buildComponentFromVNode的执行结果\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e vnodeName = vnode.nodeName;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e vnodeName===\u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e buildComponentFromVNode(dom, vnode, context, mountAll);\n  }\n  isSvgMode = vnodeName===\u003cspan class=\"hljs-string\"\u003e'svg'\u003c/span\u003e ? \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e : vnodeName===\u003cspan class=\"hljs-string\"\u003e'foreignObject'\u003c/span\u003e ? \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e : isSvgMode;\n  vnodeName = \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e(vnodeName);\n  \u003cspan class=\"hljs-comment\"\u003e// 将vnode里面填充上dom的子元素,只有dom存在且为文本的时候才不进入。\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!dom || !isNamedNode(dom, vnodeName)) {\n    \u003cspan class=\"hljs-comment\"\u003e// 生成 vnodeName 的元素节点\u003c/span\u003e\n    out = createNode(vnodeName, isSvgMode);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (dom) {\n      \u003cspan class=\"hljs-comment\"\u003e// 将dom里面的节点都添加到out里面\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (dom.firstChild) out.appendChild(dom.firstChild);\n      \u003cspan class=\"hljs-comment\"\u003e// 最后直接用out替换掉dom\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n      recollectNodeTree(dom, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n    }\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e fc = out.firstChild,\n    props = out[ATTR_KEY],\n    vchildren = vnode.children;\n  \u003cspan class=\"hljs-comment\"\u003e// 给dome节点，将attributes属性添加到__preactattr_属性里面\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (props==\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    props = out[ATTR_KEY] = {};\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e a=out.attributes, i=a.length; i--; ) props[a[i].name] = a[i].value;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// hydrating为false的时候，若vnode只有一个节点string就直接替换掉out的第一个子节点。自然out后面的其他节点都会被除去\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!hydrating \u0026amp;\u0026amp; vchildren \u0026amp;\u0026amp; vchildren.length===\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u0026amp;\u0026amp; \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e vchildren[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]===\u003cspan class=\"hljs-string\"\u003e'string'\u003c/span\u003e \u0026amp;\u0026amp; fc!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026amp;\u0026amp; fc.splitText!==\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e \u0026amp;\u0026amp; fc.nextSibling==\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (fc.nodeValue!=vchildren[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]) {\n      fc.nodeValue = vchildren[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e];\n    }\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 只要有vchildren和out有子节点就来innerDiffNode，\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (vchildren \u0026amp;\u0026amp; vchildren.length || fc!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    innerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n  }\n  \u003cspan class=\"hljs-comment\"\u003e//把vnode的属性都传到out，还有props吧。\u003c/span\u003e\n  diffAttributes(out, vnode.attributes, props);\n  \u003cspan class=\"hljs-comment\"\u003e//还原之前的isSvgMode值\u003c/span\u003e\n  isSvgMode = prevSvgMode;\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e out;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里的 \u003ccode\u003eidiff\u003c/code\u003e 方法，看着比较复杂，实际上还是对传参 vnode 进行分类判断，分为下面几种情况：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e简单的类型 string/number 之类的，直接用 vnode 替换掉 dom 元素，返回 vnode 的文本节点。\u003c/li\u003e\n\u003cli\u003evnode 是 Component的形式，调用 buildComponentFromVNode 方法，最后会返回处理过的 dom 节点。\u003c/li\u003e\n\u003cli\u003evnode 只有一个节点，且为文本，并且 dom 情况也是一样的，就替换掉 nodeValue。如若不是则调用 innerDiffNode 方法，来 diff dom 和 vnode。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这里面第一种情况是最基础的，\u003ccode\u003evnode\u003c/code\u003e 是文本，就要替换掉对应的 \u003ccode\u003edom\u003c/code\u003e，第二种情况是组件的方式，这里先不谈。第三种比较麻烦，是多个子节点情况，如若 \u003ccode\u003edom\u003c/code\u003e 存在并且为文本节点，\u003ccode\u003eout\u003c/code\u003e 变量就是 \u003ccode\u003edom\u003c/code\u003e 这个文本节点，否则 \u003ccode\u003eout\u003c/code\u003e 会是 \u003ccode\u003evnodeName\u003c/code\u003e 的元素空节点，随后将\u003ccode\u003edom\u003c/code\u003e 子节点转移到 \u003ccode\u003eout\u003c/code\u003e下面。接着设置 \u003ccode\u003eout\u003c/code\u003e 的 \u003ccode\u003e__preactattr_\u003c/code\u003e 属性。\u003c/p\u003e\n\u003cp\u003e在第三种情况时，对于前一种简答情况，如果 \u003ccode\u003edom\u003c/code\u003e 是 \u003ccode\u003e\u0026lt;div\u0026gt;123\u0026lt;/div\u0026gt;\u003c/code\u003e，而 vnode 的 children 属性为文本的话，例如：\u003ccode\u003evnode = {nodeName: 'SPAN', Children: ['sb'].....}\u003c/code\u003e，则生成的 \u003ccode\u003eout\u003c/code\u003e 为 \u003ccode\u003e\u0026lt;span\u0026gt;sb\u0026lt;/span\u0026gt;\u003c/code\u003e，这种是简单的情况。复杂情况下需要调用到 \u003ccode\u003einnerDiffNode\u003c/code\u003e 方法。在介绍 \u003ccode\u003einnerDiffNode\u003c/code\u003e 之前，先看看 \u003ccode\u003eidiff\u003c/code\u003e 方法最下面的 \u003ccode\u003ediffAttributes\u003c/code\u003e 方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ediffAttributes\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edom, attrs, old\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e name;\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (name \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e old) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!(attrs \u0026amp;\u0026amp; attrs[name]!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) \u0026amp;\u0026amp; old[name]!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n      setAccessor(dom, name, old[name], old[name] = \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e, isSvgMode);\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (name \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e attrs) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (name!==\u003cspan class=\"hljs-string\"\u003e'children'\u003c/span\u003e \u0026amp;\u0026amp; name!==\u003cspan class=\"hljs-string\"\u003e'innerHTML'\u003c/span\u003e \u0026amp;\u0026amp; (!(name \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e old) || attrs[name]!==(name===\u003cspan class=\"hljs-string\"\u003e'value'\u003c/span\u003e || name===\u003cspan class=\"hljs-string\"\u003e'checked'\u003c/span\u003e ? dom[name] : old[name]))) {\n      setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ediffAttributes\u003c/code\u003e 方法就是将 \u003ccode\u003evnode\u003c/code\u003e 里面 \u003ccode\u003eattribute\u003c/code\u003e 和 \u003ccode\u003eprops\u003c/code\u003e 属性添加到 \u003ccode\u003eout\u003c/code\u003e 里面，最后返回的是 \u003ccode\u003eout\u003c/code\u003e 元素而不是 vnode！\u003ccode\u003esetAccessor\u003c/code\u003e 基本就是些条件语句，根据出入的属性名，来分类处理，看看就好了。就这样\u003cstrong\u003e将 vnode 里面的 \u003ccode\u003eattribute\u003c/code\u003e 属性添加到 \u003ccode\u003eout\u003c/code\u003e 里面\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3\u003einnerDiffNode\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eidiff\u003c/code\u003e 第三种情况的复杂情况下下会调用 \u003ccode\u003einnerDiffNode\u003c/code\u003e 方法，实际上就是对 \u003ccode\u003evnode\u003c/code\u003e 的子元素和 \u003ccode\u003eout\u003c/code\u003e 的子元素进行递归对比。先看看 \u003ccode\u003einnerDiffNode\u003c/code\u003e 的实现：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003einnerDiffNode\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edom, vchildren, context, mountAll, isHydrating\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e originalChildren = dom.childNodes,\n    children = [],\n    keyed = {},\n    keyedLen = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n    min = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n    len = originalChildren.length,\n    childrenLen = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n    vlen = vchildren ? vchildren.length : \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n    j, c, f, vchild, child;\n  \u003cspan class=\"hljs-comment\"\u003e// 对比的dom有children的时候\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (len!==\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i\u0026lt;len; i++) {\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e child = originalChildren[i],\n        props = child[ATTR_KEY],\n        \u003cspan class=\"hljs-comment\"\u003e// key就是指平时写map循环的时候，数组里面的子vnode用来区分的key。如果child由component生成，则用component的__key。否则用props传入的key，如\u0026lt;div key={1}\u0026gt;\u0026lt;/div\u0026gt;这里面的key。\u003c/span\u003e\n        key = vlen \u0026amp;\u0026amp; props ? child._component ? child._component.__key : props.key : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n      \u003cspan class=\"hljs-comment\"\u003e// child有__preactattr_属性，也就是之前有添加过__preactattr_属性，可以看idff方法里面的第三种。\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (key!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n        keyedLen++;\n        keyed[key] = child;\n      }\n      \u003cspan class=\"hljs-comment\"\u003e// 如果child存在__preactattr_，或则child为文本，就将Dom的child缓存到children里面\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (props || (child.splitText!==\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e ? (isHydrating ? child.nodeValue.trim() : \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e) : isHydrating)) {\n        children[childrenLen++] = child;\n      }\n    }\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// vnode子节点长度不0\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (vlen!==\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i\u0026lt;vlen; i++) {\n      vchild = vchildren[i];\n      child = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n      \u003cspan class=\"hljs-comment\"\u003e// 试着去寻找vchild和keyed里面保存的相同之处，也就是key，如果vnode的子节点的key值，在out里面能找到的话，说明他们是应该一一对应的，child就是out里面对应的节点。\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e key = vchild.key;\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (key!=\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (keyedLen \u0026amp;\u0026amp; keyed[key]!==\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e) {\n          child = keyed[key];\n          keyed[key] = \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n          keyedLen--;\n        }\n      }\n      \u003cspan class=\"hljs-comment\"\u003e// 按out里面存在的子节点，依次和vnode里面的子节点排排坐对比。依次来，如果是相同的node类型，就找到了对应的out节点。并且后面的undefined设置和自加自减操作都是为了优化循环；\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!child \u0026amp;\u0026amp; min\u0026lt;childrenLen) {\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (j=min; j\u0026lt;childrenLen; j++) {\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (children[j]!==\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e \u0026amp;\u0026amp; isSameNodeType(c = children[j], vchild, isHydrating)) {\n            child = c;\n            children[j] = \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (j===childrenLen\u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e) childrenLen--;\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (j===min) min++;\n            \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n          }\n        }\n      }\n      \u003cspan class=\"hljs-comment\"\u003e// 对比生成新的child\u003c/span\u003e\n      child = idiff(child, vchild, context, mountAll);\n\n      f = originalChildren[i];\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (child \u0026amp;\u0026amp; child!==dom \u0026amp;\u0026amp; child!==f) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (f==\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n          dom.appendChild(child);\n        }\n        \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (child===f.nextSibling) {\n          removeNode(f);\n        }\n        \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n          dom.insertBefore(child, f);\n        }\n      }\n    }\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 下面两个步骤都是移除节点\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (keyedLen) {\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e keyed) \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (keyed[i]!==\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e) recollectNodeTree(keyed[i], \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (min\u0026lt;=childrenLen) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ((child = children[childrenLen--])!==\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e) recollectNodeTree(child, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003einnerDiffNode\u003c/code\u003e 的目的就是要 \u003ccode\u003evnode\u003c/code\u003e 的每个 \u003ccode\u003evchild\u003c/code\u003e 和能与其对应上的 \u003ccode\u003eout\u003c/code\u003e 下面的 \u003ccode\u003echild\u003c/code\u003e 进行对比，也就是调用 \u003ccode\u003ediff\u003c/code\u003e 方法，从而实现子节点之间的对比。在 \u003ccode\u003einnerDiffNode\u003c/code\u003e 里面对比找出 \u003ccode\u003echild\u003c/code\u003e 的过程，看上面代码中的解释就好了。在通过 \u003ccode\u003eidiff\u003c/code\u003e 方法生成新的 \u003ccode\u003echild\u003c/code\u003e 后，\u003ccode\u003echild\u003c/code\u003e 会被加入到 \u003ccode\u003eout\u003c/code\u003e 里面。从而一步步将 \u003ccode\u003evnode\u003c/code\u003e 的 \u003ccode\u003echildren\u003c/code\u003e 移入作为 \u003ccode\u003eout\u003c/code\u003e 的节点。在遍历了所有的 \u003ccode\u003evnode\u003c/code\u003e 的 \u003ccode\u003echildren\u003c/code\u003e 之后，还需要对下面两种 \u003ccode\u003eout\u003c/code\u003e 的子节点移除：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eout 子节点里面带 \u003ccode\u003ekey\u003c/code\u003e 属性的节点，如果没有匹配上 vnode 的 children ，需要移除；\u003c/li\u003e\n\u003cli\u003e再次进入循环的 child 节点或则是首次进入非空字符串的文本节点，如果没有匹配上 vnode 的 children 也会被移除掉。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e总结\u003c/h3\u003e\n\u003cp\u003ediff 机制基本就是不断的遍历子节点和 vnode，来实现对比不同。将 vnode 里面的内容添加到 dom 里面，而将 dom 里面不需要的多余的子节点移除掉。所以这里还需要理解整体的移除机制，以及组件生成对比的机制，将在下篇文章里面介绍到。\u003c/p\u003e\n"}},"buildId":"_P3qZyp8~kfTSPLoPskhF","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/_P3qZyp8~kfTSPLoPskhF/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/_P3qZyp8~kfTSPLoPskhF/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/_P3qZyp8~kfTSPLoPskhF/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" async=""></script></body></html>