<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">工程化新秀</title><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.587c5e31.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___2dTZ9 "><a class="logo___346dE" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___13XXt" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___29Pln"><h1 class="postTitle___1_m4g">工程化新秀</h1><span class="postTime___1x0_i">March 24, 2021</span></header><article class="postWrapper___3jnNg post-article"><div><p>炎热的七月，透着一点雨水，就这么来临。半年就如此过去了，看了不少内容，但是想写成博客的却越来越少，可能是人懒了。
最近不少工程化的新秀如后浪般出现，虽然不至于动摇 webpack 这个巨浪，只是对行业也有很深刻的影响，觉得蛮有意思，这里介绍一下：</p>
<h2>esbuild</h2>
<p>esbuild 做的事情很简单，打包压缩，没有其他的复杂功能，目前也没有其他的插件系统，倒是 esbuild 本身更像一个插件，有点像 webpack 刚出来那会的情况。</p>
<p>esbuild 最大特点就是快，飞快，其本身采用 Go 语言实现，加上高并发的特色，在打包压缩的路上，一骑绝尘。官方数据，和正常的 webpack 相比，在打包方面提高了 100+ 倍以上，这对于需要代码更新后立刻发版到线上的项目而言，超级有意义，这不就是大家一直追求的快速构建嘛。</p>
<p>在构建项目的时候，基本都可以看到这一幕，打包到最后，本以为要结束了，结果进度条一直在 90% 左右的位置，一动不动，尤其是项目大了之后。其实这个最后的过程，是代码丑化、压缩以及 tree-shaking 的过程。代码压缩这部分，在以前的 webpack，是 UglifyjsWebpackPlugin 来处理的，后来内置到 webpack 里面，再后来，由于 uglify-js 不支持 es6，改用 terser 作为 webpack 内置的默认打包压缩工具。即便如此，业务小的时候还好，上来后，打包的时间会非常长。</p>
<h3>本地尝试</h3>
<p>按照文档思索着建一个最小的 demo，来看看速度如何。按照首页的提示，采用如下内容，分别用 webpack 和 esbuild 来打包：</p>
<pre class="hljs"><code><span class="hljs-comment">// 业务内容</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"root"</span>));

<span class="hljs-comment">// webpack 配置，只是对jsx采用babel打包，同时还要配置babel的基本配置</span>
<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(js|jsx)$/</span>,
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
        <span class="hljs-attr">use</span>: {
          <span class="hljs-attr">loader</span>: <span class="hljs-string">"babel-loader"</span>,
        },
      },
    ],
  },
};

<span class="hljs-comment">// esbuild 指令内容，由于采用首页的方式一直报错，最后根据错误，改为如下指令</span>
esbuild --bundle main.jsx --outdir=dist --minify --sourcemap
</code></pre>
<p>采用 esbuild 的时候，可以明显感觉到速度飞快，基本上 半秒不到就打包好了，而 webpack 嗯。。。三四秒的样子，速度还是很明显的，可能是因为项目小，没有 100 倍的感觉，但是 esbuild 基本上不用等。只是看看打包的体积，发现 esbuild 的体积比 webpack 的大三倍。这难道是时间换体积？经过排查是 <code>process.env.NODE_ENV</code> 的问题，esbuild 的版本里面包含了 development 和 production 两个模式的内容。官方文档有提示到：</p>
<blockquote>
<p>Note that the double quotes around &quot;production&quot; are important because the replacement should be a string, not an identifier. The outer single quotes are for escaping the double quotes in Bash but may not be necessary in other shells.</p>
</blockquote>
<p><code>process.env.NODE_ENV</code> 变量需要配置，并且不能省略 <code>&quot;production&quot;</code> 的引号，只是在 json 里面，添加引号一直无法正常使用，去掉引号会导致无法识别变量，最后采用 api 的方式构建，如下</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> { build } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"esbuild"</span>);

build({
  <span class="hljs-attr">entryPoints</span>: [<span class="hljs-string">"./main.jsx"</span>],
  <span class="hljs-attr">outdir</span>: <span class="hljs-string">"dist"</span>,
  <span class="hljs-attr">minify</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">bundle</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">sourcemap</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">define</span>: {
    <span class="hljs-string">"process.env.NODE_ENV"</span>: <span class="hljs-string">'"production"'</span>,
  },
}).catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> process.exit(<span class="hljs-number">1</span>));
</code></pre>
<p>需要注意的是，define 里面的 key-value 结构的 value 不能是对象，不支持嵌套的 key。最后会打包有如下效果：</p>
<pre class="hljs"><code><span class="hljs-comment">// 原本的 process.env.NODE_ENV 会被替换，development的内容会被设置为null</span>
<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  checkDCE();
  <span class="hljs-built_in">module</span>.exports = require_react_dom_production_min();
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">module</span>.exports = <span class="hljs-literal">null</span>;
}
</code></pre>
<p>最后回头一看发现和 webpack 打包的体积居然是一模一样的，esbuild 大了 0.5k 不到。另外有个有趣的现象，如果把 bundle 配置去掉，包的内容，真的只有上面的 react 的业务代码。</p>
<p>想看看 esbuild 的源码，专门学了一下 go 语言，发现还是蛮简单（可能是学比较基础）。只是三脚猫功夫直接看源码，还是云里雾里的，也就放弃了。</p>
<h3>esbuild-webpack-plugin</h3>
<p>看到 umi 里面支持 esbuild，具体可以看看 <code>esbuild-webpack-plugin</code> 的代码。结构是一个典型的 webpack 的插件，通过 esbuild 的 transform 这个 api 来实现打包，可以看看下面的配置：</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> transform = <span class="hljs-keyword">async</span> () =&gt;
  <span class="hljs-keyword">await</span> ESBuildPlugin.service.transform(source, {
    ...this.options,
    <span class="hljs-attr">minify</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">sourcemap</span>: !!devtool,
    <span class="hljs-attr">sourcefile</span>: file,
  });
</code></pre>
<p>官方介绍到，如果需要重复调用 esbuild 的 api，最好是实例化 esbuild，达到复用的方式，也就是采用 transform 这个 api。</p>
<p>可以看到上面的代码，采用的配置只是 minify 而已，没有对 bundle 处理，按照作者的介绍</p>
<blockquote>
<p>esbuild 有两个功能，bundler 和 minifier。bundler 的功能和 babel 以及 webpack 相比肯定差很多，直接上风险太大；而 minifier 倒是可以试试，在 webpack 和 babel 产物的基础上做一次压缩，坑应该相对较少。</p>
</blockquote>
<p>这样确实不错，让 esbuild 做最专业的事情，同时可以继续使用生态丰富的 webpack，而压缩则是 esbuild，作者说到： <strong>试验性功能，可能有坑，但效果拔群</strong>，具体的时间效果也不对比了，送上<a href="https://zhuanlan.zhihu.com/p/139219361" target="_blank">传送门</a>。效果只是减少 1/3，估计是 webpack 本身其他操作占用了时间。</p>
<p>这个插件有配合 umi 的部分，但也可以用到其他 webapck 项目里面。具体是要配置 <code>optimization.minimizer</code> 如下：</p>
<pre class="hljs"><code>optimization: {
  <span class="hljs-attr">minimizer</span>: [<span class="hljs-keyword">new</span> (<span class="hljs-built_in">require</span>(<span class="hljs-string">"esbuild-webpack-plugin"</span>).default)()];
}
</code></pre>
<p>正常的 webpack 会采用 terser 作为内置的默认压缩工具，这里面改为 Esbuild 就可以了。</p>
<h2>ES Module</h2>
<p>上面的 esbuild，可以说很好的解决了生产模式的压缩疼点，提高打包速度，但是开发环境呢？能用上 esbuild 吗？当然也是可以的，只是最优解并非如此。</p>
<p>有一次，看到一个线上地址 <a href="https://iconsvg.xyz/" target="_blank">https://iconsvg.xyz/</a> 的页面，打开控制台一看发现居然是采用 ES Module 的形式，如下图。</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/iconsvg.PNG" alt=""></p>
<p>现在的浏览器基本已经支持 ES 模块化了，直接模块化有什么不可以？直接用在生产环境会有很多问题，比如请求加载数量，比如兼容性，那对于开发环境呢？如 <strong>vite 和 snowpack</strong> 这样的工具已经就是 bundleless 的工具，在开发环境上采用 ES Module 的方式实现快速热更新。</p>
<p>对于 ES Module，目前文件扩展名为 .js 结构，<a href="https://v8.dev/features/modules#mjs" target="_blank">有推荐采用 .mjs 后缀</a>，可以更清晰的表明是个模块，由于兼容问题，现在采用 .js 后缀就可以了。</p>
<p>应用的时候要采用下面的格式，来声明这个脚本是一个模块：</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"main.mjs"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>如果没有声明 <code>type=&quot;module&quot;</code> 浏览器会提示 <code>Uncaught SyntaxError: Cannot use import statement outside a module</code> 错误。</p>
<h2>vite</h2>
<p>vite 在开发环境通过解析文件返回到浏览器，不会有打包过程。这样当修改项目某个文件的时候，只会向浏览器发送更新该文件的请求，而不会去处理别的文件，最终打包的速度项目大小没有关系，可以很大提高开发环境热更新效率。需要注意的是 vite 在生产环境采用 rollup 打包。</p>
<h3>开发服务器劫持</h3>
<p>vite 在开发环境的定位和 webpack-dev-server 是有点像的，都是作为一个开发服务器，响应客户端的请求。先看看 demo 上具体的效果，官方直接提供一个 <a href="https://github.com/vitejs/create-vite-app" target="_blank">create-vite-app</a> 项目作为起步脚手架模板，上面提供 vue 到 react 的模板，采用 template-vue 模板，启动的时间非常快，基本上按下回车差不多就跑起来了。可以看看下图：</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/viteStart.gif" alt=""></p>
<p>几秒钟的时间，项目就启动完毕了，对比一下 vue-cli 3，差不多要 10s 的样子，当然也是由于业务体积的问题，少量的业务，webpack 自然是非常快的（复杂的例子，就没有了，因为 vite 支持的是 vue-next，老项目用的是 vue 2 可能支持力度不好，无法迁移）。</p>
<p>通过控制台可以看一下，发起的请求：</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/vite-network.PNG" alt=""></p>
<p><img src="https://github.com/funfish/blog/raw/master/images/vite-network-vue-cli4.PNG" alt=""></p>
<p>前面是 vite 加载过程，后面是 vue-cli 3 的项目，可以明显看到 vite 是直接请求了 <code>.vue</code> 文件以及 vue.js 文件，而 vue-cli 3 则是请求打包好后的开发文件，只是前图的 vite 里面明明是一个 <code>App.vue</code> 文件为什么会请求三次呢？这里就要说一下 vite 作为开发服务器对网络的劫持作用。</p>
<p>vite 里面会启动一个 koa 服务器，采用中间件的方式对请求的文件劫持，结构如下</p>
<pre class="hljs"><code><span class="hljs-comment">// 省略部分代码</span>
<span class="hljs-keyword">const</span> resolvedPlugins = [
  moduleRewritePlugin,
  htmlRewritePlugin,
  moduleResolvePlugin,
  proxyPlugin,
  serviceWorkerPlugin,
  hmrPlugin,
  vuePlugin,
  cssPlugin,
  esbuildPlugin,
  jsonPlugin,
  assetPathPlugin,
  serveStaticPlugin,
];
</code></pre>
<p>插件的配置从查找模块、模块路径重写到 vue、css 等资源的处理，客户端请求什么内容，就由专门的中间件处理。比如入口，请求 <code>http://localhost:3000/</code> 返回的是 <code>index.html</code>，但是结果如下：</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/vite-index-html.PNG" alt=""></p>
<p>中间的 script 部分是和原 <code>index.html</code> 不一样的。额外加载 hmr 文件，正是上面 vite 请求网络图里面的 hmr 请求，同时还注入了全局的环境变量 <code>process.env.NODE_ENV</code>，可以看一下是如何实现的：</p>
<pre class="hljs"><code><span class="hljs-comment">// htmlRewritePlugin 的内容，下面是注入的代码</span>
<span class="hljs-keyword">const</span> devInjectionCode =
  <span class="hljs-string">`\n&lt;script type="module"&gt;\n`</span> +
  <span class="hljs-string">`import "<span class="hljs-subst">${hmrClientPublicPath}</span>"\n`</span> +
  <span class="hljs-string">`window.__DEV__ = true\n`</span> +
  <span class="hljs-string">`window.process = { env: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify({
    ...env,
    NODE_ENV: mode,
    BASE_URL: <span class="hljs-string">"/"</span>,
  }</span>)}}\n`</span> +
  <span class="hljs-string">`&lt;/script&gt;\n`</span>;
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rewriteHtml</span>(<span class="hljs-params">importer: string, html: string</span>) </span>{
  <span class="hljs-comment">// 省略缓存以及script标签替换内容</span>
  <span class="hljs-keyword">return</span> injectScriptToHtml(html, devInjectionCode);
}
app.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; {
  <span class="hljs-keyword">await</span> next();
  <span class="hljs-keyword">if</span> (ctx.status === <span class="hljs-number">304</span>) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">if</span> (ctx.response.is(<span class="hljs-string">"html"</span>) &amp;&amp; ctx.body) {
    <span class="hljs-comment">// 省略部分代码</span>
    ctx.body = <span class="hljs-keyword">await</span> rewriteHtml(importer, html);
    <span class="hljs-keyword">return</span>;
  }
});
</code></pre>
<p>除了 html 的特殊处理外，vite 还会对 <code>import { createApp } from &quot;vue&quot;</code> 这样的 import 语句重写路径为 <code>import { createApp } from &quot;/@modules/vue.js&quot;</code>，前者的路径客户端是无法正常找到的，通过重写 <code>@modules</code> vite 可以明白这是一个第三方模块包的请求，对于这些 node_modules 的包可以做一系列的优化，后面会介绍到。</p>
<h3>vue 文件处理</h3>
<p>对于 vue 单文件的处理，首个文件的访问路径还是源于 main.js 的正常 import，但是到了 vite，.vue 文件则会被 vuePlugin 处理，毕竟浏览器无法识别 .vue 文件，需要解析再返回给浏览器。先看看原始代码 App.vue：</p>
<pre class="hljs"><code><span class="hljs-comment">// 原始文件</span>
&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"hehe"</span>&gt;</span>522215{{ a }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;<span class="hljs-regexp">/template&gt;

&lt;script&gt;
export default {
  name: "App",
  data() {
    return {
      a: 123
    };
  }
};
&lt;/</span>script&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.hehe</span> {
  <span class="hljs-attribute">background</span>: red;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span>
</code></pre>
<p>拦截后输出的文件
<img src="https://github.com/funfish/blog/raw/master/images/vite-vue-loading.PNG" alt=""></p>
<p>截图是返回的 App.vue 文件，可以看到原始的 .vue 文件变成一个 js 文件，也就是上图的代码。上图仅保留了原 App.vue 里面的 script 部分，渲染模板 template 以及样式 style 在 script 部分里通过 import 的方式引入，一个 .vue 文件拆分成三个。于是就有了左边 network 里面请求的 <code>App.vue?type=style&amp;index=0</code> 和 <code>App.vue?type=template</code>。拆分成三个请求，每个请求各司其责，比如更新 template 的时候，就发送新的 template 文件到客户端，避免一次修改三个文件：script、template 和 style 混在一起发送，可以说很巧妙。</p>
<p>vuePlugin 里面的实现，更多的是对请求路径的参数判断，如果参数 type 为 undefined(就是 script)、template 以及 style，都分别处理，同时在 script 的时候，如果文件是 typescript，还会采用 esbuild 的 transform API 来编译代码。</p>
<p>三个请求的由来，其实可以追朔到 vue 对 sfc 文件的解析，在 sfc 单文件处理的模块里面，会通过 ast 的方式将文件拆分成，script、template 和 style 三个模式，自然 vite 里面应该按照这三个模式更新 vue 是最合理的。</p>
<h3>热更新机制</h3>
<p>上面截图以及代码部分可以看到 hmr 的字样，hmr 则是代表热更新的部分。热更新分为两部分，一部分在客户端，一部分在开发服务器。客户端的主要热更新的代码，在 html 访问的时候，已经通过 <code>import &quot;${hmrClientPublicPath}&quot;</code> 这样的方式加载，而 vite 也会通过 chokidar 来监听访问过的文件，当文件变化的时候，会通过 websocket 来通知客户端，再由客户端请求具体的更新代码。</p>
<pre class="hljs"><code><span class="hljs-comment">// 客户端主要代码</span>
socket.addEventListener(<span class="hljs-string">"message"</span>, <span class="hljs-keyword">async</span> ({ data }) =&gt; {
  <span class="hljs-keyword">switch</span> (type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"connected"</span>:
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[vite] connected.`</span>);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">"vue-reload"</span>:
    <span class="hljs-comment">// 重新加载vue</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"vue-rerender"</span>:
    <span class="hljs-comment">// vue 组件重新渲染</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"style-update"</span>:
    <span class="hljs-comment">// 样式更新</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"style-remove"</span>:
    <span class="hljs-comment">// 移除样式</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"js-update"</span>:
    <span class="hljs-comment">// js更新，react项目更新依赖这个</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"custom"</span>:
    <span class="hljs-comment">// 自定义的，目前没有用到好像</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"full-reload"</span>:
    <span class="hljs-comment">// 整个页面重新加载，</span>
  }
});
</code></pre>
<p>客户端对 vue-rerender 的指令，在加载文件后，会直接调用 vue-next 里面的热更新的函数：</p>
<pre class="hljs"><code><span class="hljs-comment">// @vue/runtime-core &gt; hmr &gt; rerender 代码</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rerender</span>(<span class="hljs-params">id: string, newRender?: Function</span>) </span>{
  <span class="hljs-keyword">const</span> record = map.get(id)
  <span class="hljs-keyword">if</span> (!record) <span class="hljs-keyword">return</span>
  <span class="hljs-comment">// Array.from creates a snapshot which avoids the set being mutated during</span>
  <span class="hljs-comment">// updates</span>
  <span class="hljs-built_in">Array</span>.from(record).forEach(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (newRender) {
      instance.render = newRender <span class="hljs-keyword">as</span> InternalRenderFunction
    }
    instance.renderCache = []
    <span class="hljs-comment">// this flag forces child components with slot content to update</span>
    isHmrUpdating = <span class="hljs-literal">true</span>
    instance.update()
    isHmrUpdating = <span class="hljs-literal">false</span>
  })
}
</code></pre>
<p>可以看到这里将新的 render 注入，也就是 template 解析后生成的渲染函数，再调用实例的 update 方法，而这个 update 方法是，vue-next 里面渲染组件的主要入口，采用 effect 的方式。</p>
<p>服务端监听本地文件的变化。在 vue 的中间件里面，会对更新后的文件发送对应的指令，这里提一下重新加载 vue 文件和重新渲染 vue 组件的处理的方式不同。</p>
<pre class="hljs"><code><span class="hljs-comment">// descriptor 是 vue-sfc 里面通过 ast 分析出来的描述器</span>
<span class="hljs-keyword">if</span> (!isEqualBlock(descriptor.script, prevDescriptor.script)) {
  <span class="hljs-keyword">return</span> sendReload();
}

<span class="hljs-keyword">if</span> (!isEqualBlock(descriptor.template, prevDescriptor.template)) {
  needRerender = <span class="hljs-literal">true</span>;
}
</code></pre>
<p>可以看到如果前后脚本不一致会重新加载，而如果只是模板不一样，则只会重新渲染组件。这里可以看到是对 vue 的处理，那如果是 react 项目呢？</p>
<h3>react 项目处理</h3>
<p>在上面的代码里面，我们经常可以看到 vue 的影子，比如 vue 的中间件，vue 的客户端的热更新代码，而对于 react 是需要特殊的配置的，这里我们看看 react 项目的配置时候需要的插件：</p>
<pre class="hljs"><code><span class="hljs-comment">// @ts-check</span>
<span class="hljs-keyword">const</span> reactPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"vite-plugin-react"</span>);

<span class="hljs-comment">/**
 * @type { import('vite').UserConfig }
 */</span>
<span class="hljs-keyword">const</span> config = {
  <span class="hljs-attr">jsx</span>: <span class="hljs-string">"react"</span>,
  <span class="hljs-attr">plugins</span>: [reactPlugin],
};

<span class="hljs-built_in">module</span>.exports = config;
</code></pre>
<p>在 vite.config.js 里面需要按照如上配置，而之前的 vue-next 则是什么都不用写。可以明显感觉到 vite 里面 vue-next 是一等生，毕竟连客户端的热更新代码，都用到 vue 的热更新部分。。。。</p>
<p>通过 vite-plugin-react 可以向 vite 项目提供更多的中间件，这个也是类似于 vue 的中间件，只是一个是内置，一个第三方包来配置。通过劫持 html 返回自己的运行时更新代码 react-refresh 部分以及 vite 的 hmr 客户端代码。</p>
<pre class="hljs"><code><span class="hljs-comment">//  vite-plugin-react 里面代码</span>
<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">resolvers</span>: [resolver],
  <span class="hljs-attr">configureServer</span>: reactRefreshServerPlugin,
  <span class="hljs-attr">transforms</span>: [reactRefreshTransform],
};

<span class="hljs-comment">// vite 里面处理插件的 transforms 的方法</span>
app.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; {
  <span class="hljs-keyword">await</span> next();

  <span class="hljs-keyword">const</span> { path, query } = ctx;
  <span class="hljs-keyword">let</span> code: string | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> t <span class="hljs-keyword">of</span> transforms) {
    <span class="hljs-keyword">if</span> (t.test(path, query)) {
      ctx.type = <span class="hljs-string">"js"</span>;
      <span class="hljs-keyword">if</span> (ctx.body) {
        code = code || (<span class="hljs-keyword">await</span> readBody(ctx.body));
        <span class="hljs-keyword">if</span> (code) {
          ctx.body = <span class="hljs-keyword">await</span> t.transform(
            code,
            isImportRequest(ctx),
            <span class="hljs-literal">false</span>,
            path,
            query
          );
          code = ctx.body;
        }
      }
    }
  }
});
</code></pre>
<p>reactRefreshServerPlugin 会先服务器添加中间件，当访问 html 代码的时候，则会注入基本的全局代码；transforms 则会在 vite 开发服务器搭建的时候，通过 transforms 方式添加中间件，对 jsx/tsx 文件处理，注入以下关键代码。</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> header = <span class="hljs-string">`
  import RefreshRuntime from "<span class="hljs-subst">${runtimePublicPath}</span>";
  let prevRefreshReg;
  let prevRefreshSig;
  if (!window.__vite_plugin_react_preamble_installed__) {
    throw new Error(
      "vite-plugin-react can't detect preamble. Something is wrong. See https://github.com/vitejs/vite-plugin-react/pull/11#discussion_r430879201"
    );
  }
  if (import.meta.hot) {
    prevRefreshReg = window.$RefreshReg$;
    prevRefreshSig = window.$RefreshSig$;
    window.$RefreshReg$ = (type, id) =&gt; {
      RefreshRuntime.register(type, <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(path)}</span> + " " + id)
    };
    window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;
  }`</span>.replace(<span class="hljs-regexp">/[\n]+/gm</span>, <span class="hljs-string">""</span>);

<span class="hljs-keyword">const</span> footer = <span class="hljs-string">`
  if (import.meta.hot) {
    window.$RefreshReg$ = prevRefreshReg;
    window.$RefreshSig$ = prevRefreshSig;
    import.meta.hot.accept();
    RefreshRuntime.performReactRefresh();
  }`</span>;
</code></pre>
<p>上面是注入的代码，header 和 footer。可以看出来来，主要注入的部分是热更新相关的。其中有个很特别的地方 <code>import.meta.hot</code>，这个是 vite 特有的标记；</p>
<blockquote>
<p>For manual HMR, an API is provided via import.meta.hot.
For a module to self-accept, use import.meta.hot.accept:</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> count = <span class="hljs-number">1</span>;
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">import</span>.meta.hot) {
  <span class="hljs-keyword">import</span>.meta.hot.accept(<span class="hljs-function">(<span class="hljs-params">newModule</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"updated: count is now "</span>, newModule.count);
  });
}
</code></pre>
<p>这是 <code>import.meta.hot</code> 的用法，对于正常的需要热更新的代码文件，可以通过 <code>import.meta.hot</code> 这个条件语句判断。当内容更新的时候，加载内容，并执行下面 <code>accept</code> 的回调，至于回调里面如何处理，则需要自己控制了。react 采用的则是 <code>import.meta.hot</code> 的方式，更新的方式，当然是通过 react-refresh 来。</p>
<p>上面客户端热更新方式里面，有一种是 js-update，当 jsx 文件更新的时候，会通知到客户端执行 js-upload，并最终加载新的 jsx 文件，当然同时也包含上面的添加的代码。</p>
<p>在 js-update 里面，会分析服务端下发文件的 id 路径，而加载哪些文件，则是根据这个 id 路径来判断的，通过分析 id 的所有依赖，依次加载。这些依赖的来源，并不是 webpack 打包时候分析的 import 的包，而是需要用户调用 accept 或者 acceptDeps 显示添加的，以及依赖更新后的回调函数。比如下面的方式：</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { foo } <span class="hljs-keyword">from</span> <span class="hljs-string">"./foo.js"</span>;

foo();

<span class="hljs-keyword">if</span> (<span class="hljs-keyword">import</span>.meta.hot) {
  <span class="hljs-keyword">import</span>.meta.hot.acceptDeps(<span class="hljs-string">"./foo.js"</span>, (newFoo) =&gt; {
    <span class="hljs-comment">// the callback receives the updated './foo.js' module</span>
    newFoo.foo();
  });

  <span class="hljs-comment">// Can also accept an array of dep modules:</span>
  <span class="hljs-keyword">import</span>.meta.hot.acceptDeps(
    [<span class="hljs-string">"./foo.js"</span>, <span class="hljs-string">"./bar.js"</span>],
    ([newFooModule, newBarModule]) =&gt; {
      <span class="hljs-comment">// the callback receives the updated modules in an Array</span>
    }
  );
}
</code></pre>
<p>官网介绍的这种方式，通过 acceptDeps 指明依赖的路径，当文件变化的时候（指的是自身或者 import 进来的文件），会加载 acceptDeps 中的文件，执行对应的回调。如果不需要指出具体的依赖，比如像 react 的方式，采用 <code>import.meta.hot.accept()</code>，表明是自身的更新，或者是自身 import 的文件的更新，重新加载本身，也就是 jsx 文件就好了。</p>
<p>回到 react 身上，采用 <code>import.meta.hot.accept()</code> 的方式加 react-fresh 的热更新，好像不是最稳妥的，毕竟每次修改，都要重新加载一次文件，再去更新，没有 vue 来得优雅。当然还有就是不像 sfc 那样需要拆分成三个文件。</p>
<h3>vite 启动</h3>
<p>前面介绍了 vite 的拦截，vue 和 react 的处理，但是在一开始的时候会解析 package.json 中的文件，对 dependencies 中的包缓存到 <code>node_modules/.vite_opt_cache</code> 里面，不管项目中有没有遇到。多次访问的时候，缓存可以提高访问速度，比如对 vue-next 访问速度的提高。</p>
<h2>snowpack</h2>
<p>snowpack 和 vite 都是优秀 ES Module 加载方案，发力的领域也是开发环境。vite 文档介绍到，项目依赖关系的处理是受到 snowpack 的启发，在开发环境上都是会启动一个开发服务器，并且解析返回速度也是类似的。可以看出来 vite 有不少方面是借鉴了 snowpack 。</p>
<p>当然 vite 有自己特色的部分，比如 热更新，可以做到深入到 vue 的热更新机制，以及调用 react 的热更新，当然 vite 里面 vue 是第一公民。snowpack 不同于 vite 的地方在于，其构建的时候，支持 webpack 和 Parcel 等，这样无疑对开发者更加友好。</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/vite-snowpack-build.PNG" alt=""></p>
<p>这里很好的介绍了 snowpack 构建的 O(1) 的过程，基本上每次文件更新都小于 50ms。well，现在 webpack 5 也做了很多优化，本地开发没有这么不堪了。上图也适用于 vite，两者都是 ES Module 级别的构建。</p>
<h3>snowpack 的劫持</h3>
<p>snowpack 和 vite 很不一样，vite 使用 koa 中间件的方式，对不同的文件处理，snowpack 没有中间件的概念，没有 koa 甚至是 express，采用 http-proxy、http 和 http2 来搭建开服服务器。</p>
<p>先看看网络加载情况</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/vite-snowpack-network.PNG" alt=""></p>
<p>可以看出在 vite 里面 App.vue 被拆分成三个文件加载，而这里，只是分成两个文件，app.js 包含 script 和 template， app.css.proxy.js 则是 style 部分。</p>
<p>snowpack 采用外部插件来解析 vue 的方式，比如 vue 项目里面的配置：</p>
<pre class="hljs"><code><span class="hljs-comment">// snowpack.config.json 里面的配置</span>
<span class="hljs-string">"extends"</span>: <span class="hljs-string">"@snowpack/app-scripts-vue"</span>

<span class="hljs-comment">// @snowpack/app-scripts-vue 里面的配置</span>
<span class="hljs-keyword">const</span> scripts = {
  <span class="hljs-string">"mount:public"</span>: <span class="hljs-string">"mount public --to /"</span>,
  <span class="hljs-string">"mount:src"</span>: <span class="hljs-string">"mount src --to /_dist_"</span>,
};

<span class="hljs-built_in">module</span>.exports = {
  scripts,
  <span class="hljs-attr">plugins</span>: [<span class="hljs-string">"@snowpack/plugin-vue"</span>, <span class="hljs-string">"@snowpack/plugin-dotenv"</span>],
  <span class="hljs-attr">installOptions</span>: {},
  <span class="hljs-attr">devOptions</span>: {},
};

<span class="hljs-comment">// @snowpack/plugin-vue 里面的配置</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">plugin</span>(<span class="hljs-params">config, pluginOptions</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">defaultBuildScript</span>: <span class="hljs-string">"build:vue"</span>,
    <span class="hljs-keyword">async</span> build({ contents, filePath }) {
      <span class="hljs-comment">// 采用 @vue/compiler-sfc 里面的parse来编译 sfc 文件，和 vite 的编译是一样的。</span>
    }
  }
}
</code></pre>
<p>如上面的结构，通过加载插件里面的 build 方法，实现对 sfc 文件的解析，中间过程比 vite 要复杂一些，vite 的中间件体系很直观，而 snowpack 则是通过不断的分析 <code>config.scripts</code> 里面的配置（通过不断的调用 <code>fs.stat</code> 判断），来得到正确的文件路径以及对应的解析方式，比如 <code>_dist_/App.js</code> 最后会转换为 <code>src/App.vue</code>，并采用上述的 <code>@snowpack/plugin-vue</code> 的 build 方法加载 <code>src/App.vue</code>，得到打包后的 script/template 组成的部分，以及 css 内容。发送到客户端并作缓存处理后。</p>
<p>build 方法里面会通过 parse 编译 sfc 文件，得到的 descriptor 和 vite 的差不多，包含 script、template 和 style 三个部分，其中 script 部分的代码会和 tempalte 的代码合并也就是后面 App.js 的主体。 style 作为单独的部分不会立刻发送到客户端，而是先做本地缓存里面。</p>
<p>css 部分会有如下处理方式</p>
<pre class="hljs"><code><span class="hljs-comment">// snowpack dev.js wrapResponse</span>
<span class="hljs-keyword">if</span> (responseFileExt === <span class="hljs-string">".js"</span>) {
  code = wrapImportMeta({ code, <span class="hljs-attr">env</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">hmr</span>: isHmr, config });
}
<span class="hljs-keyword">if</span> (responseFileExt === <span class="hljs-string">".js"</span> &amp;&amp; cssResource) {
  code =
    <span class="hljs-string">`import './<span class="hljs-subst">${path.basename(reqPath).replace(<span class="hljs-regexp">/.js$/</span>, <span class="hljs-string">".css.proxy.js"</span>)}</span>';\n`</span> +
    code;
}
</code></pre>
<p>可以看到在 App.js 里面添加 css 的 import 部分，这个和 vite 类似，只是 css 文件后缀采用 css.proxy.js 标识，而 vite 采用 <code>type=style</code> 的方式来区分。</p>
<p>另外 snowpack 对 html 的处理，会有一个 <code>isRoute</code> 变量来判断，并注入热更新等代码；</p>
<h3>热更新机制</h3>
<p>分为两套代码，客户端代码和开发服务器的代码，其中客户端的代码没有 vite 种类复杂</p>
<pre class="hljs"><code>socket.addEventListener(<span class="hljs-string">"message"</span>, ({ <span class="hljs-attr">data</span>: _data }) =&gt; {
  <span class="hljs-keyword">if</span> (!_data) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">const</span> data = <span class="hljs-built_in">JSON</span>.parse(_data);
  debug(<span class="hljs-string">"message"</span>, data);
  <span class="hljs-keyword">if</span> (data.type === <span class="hljs-string">"reload"</span>) {
    reload();
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">if</span> (data.type !== <span class="hljs-string">"update"</span>) {
    <span class="hljs-keyword">return</span>;
  }
  runModuleAccept(data.url)
    .then(<span class="hljs-function">(<span class="hljs-params">ok</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (!ok) {
        reload();
      }
    })
    .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
      <span class="hljs-built_in">console</span>.error(err);
      reload();
    });
});
</code></pre>
<p>可以看出 snowpack 只有 reload 和 update 模式，没有 vite 那样复杂，但是其 js 部分更新逻辑是基本一致的，并且有很相同的 <code>import.meta.hot</code> 方式以及 <code>import.meta.hot.accept</code> 功能。基本和 vite 差不多，这里就不介绍了，当然 snowpack 不用判断 <code>import.meta.hot</code> 是不是在 if 条件语句里面。</p>
<p>snowpack 没有像 vite 那样在客户端采用 vue 的热更新。</p>
<p>snowpack 启动的时候，也会对依赖进行分析，不同的是它会将依赖放在 <code>node_modules/.cache/snowpack/dev</code> 下面。node_modules 包的请求路径也会被改写为 <code>web_modules/vue.js</code> 这样的特殊标记。</p>
<h3>webpack</h3>
<p>在 snowpack 还可以使用 webpack，官方专门维护了 <code>@snowpack/plugin-webpack</code> 插件，和上面的 <code>@snowpack/plugin-vue</code> 一样都归属于插件范畴，在解析文件的时候会用到，提供一个 build 方法，并且最后通过 webpack 打包文件。snowpack 提供了一些默认配置，比如 babel、MiniCssExtractPlugin 这些。如果要扩展的话采用以下的方式配置，和 vue.config.js 的方式蛮像的。</p>
<pre class="hljs"><code><span class="hljs-comment">// snowpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">plugins</span>: [
    [
      <span class="hljs-string">"@snowpack/plugin-webpack"</span>,
      {
        <span class="hljs-attr">extendConfig</span>: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {
          config.plugins.push(<span class="hljs-comment">/* ... */</span>);
          <span class="hljs-keyword">return</span> config;
        },
      },
    ],
  ],
};
</code></pre>
<p>这里 webpack 的处理方式蛮奇怪的，会将打包好之后的文件，手动注入到 html 里面，而不是采用默认的方式，可能是没有 index.html？可能也是受限于 snowpack 和 webpack 的结合？具体的也就没有深入研究了，感兴趣的可以看看。</p>
<h2>总结</h2>
<p>上面介绍了三款最近流行的打包工具，esbuild 用于生产环境，vite 和 snowpack 主要用于开发环境。esbuild 打包压缩速度远超同行，也被用于 vite 和 snowpack 里面，作为 JavaScript 文件和 Typescript 文件降级和编译的工具，esbuild 如果要用于生产的话，可以考虑使用 <code>esbuild-webpack-plugin</code>，仅仅作为压缩工具，效率也能提高不少。</p>
<p>vite 里面有不少借鉴 snowpack 的部分，当然也有自己特别的方式，比如中间件的结构，比如客户端更精准的热更新，当然和 snowpack 一样支持 webpack 更好了，只是目前看来难度不大？两者都可以用在生产，目前看来 vite 采用 rollup 打包，离主流 webpack 有点远，而 snowpack 支持 webpack 所以友好度更高。当然 vite 有尤大佬参与，自然不太一样。</p>
<p>本文还有不少源码没有深入介绍到，只是做一个稍微浅的解读，感兴趣的可以继续深入研究，如果能理解 esbuild 的 go 语言的源码就更好了。</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"March 24, 2021","title":"工程化新秀","content":"\u003cp\u003e炎热的七月，透着一点雨水，就这么来临。半年就如此过去了，看了不少内容，但是想写成博客的却越来越少，可能是人懒了。\n最近不少工程化的新秀如后浪般出现，虽然不至于动摇 webpack 这个巨浪，只是对行业也有很深刻的影响，觉得蛮有意思，这里介绍一下：\u003c/p\u003e\n\u003ch2\u003eesbuild\u003c/h2\u003e\n\u003cp\u003eesbuild 做的事情很简单，打包压缩，没有其他的复杂功能，目前也没有其他的插件系统，倒是 esbuild 本身更像一个插件，有点像 webpack 刚出来那会的情况。\u003c/p\u003e\n\u003cp\u003eesbuild 最大特点就是快，飞快，其本身采用 Go 语言实现，加上高并发的特色，在打包压缩的路上，一骑绝尘。官方数据，和正常的 webpack 相比，在打包方面提高了 100+ 倍以上，这对于需要代码更新后立刻发版到线上的项目而言，超级有意义，这不就是大家一直追求的快速构建嘛。\u003c/p\u003e\n\u003cp\u003e在构建项目的时候，基本都可以看到这一幕，打包到最后，本以为要结束了，结果进度条一直在 90% 左右的位置，一动不动，尤其是项目大了之后。其实这个最后的过程，是代码丑化、压缩以及 tree-shaking 的过程。代码压缩这部分，在以前的 webpack，是 UglifyjsWebpackPlugin 来处理的，后来内置到 webpack 里面，再后来，由于 uglify-js 不支持 es6，改用 terser 作为 webpack 内置的默认打包压缩工具。即便如此，业务小的时候还好，上来后，打包的时间会非常长。\u003c/p\u003e\n\u003ch3\u003e本地尝试\u003c/h3\u003e\n\u003cp\u003e按照文档思索着建一个最小的 demo，来看看速度如何。按照首页的提示，采用如下内容，分别用 webpack 和 esbuild 来打包：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 业务内容\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e React \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e ReactDOM \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react-dom\"\u003c/span\u003e;\n\nReactDOM.render(\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003eHello, world!\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.getElementById(\u003cspan class=\"hljs-string\"\u003e\"root\"\u003c/span\u003e));\n\n\u003cspan class=\"hljs-comment\"\u003e// webpack 配置，只是对jsx采用babel打包，同时还要配置babel的基本配置\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = {\n  \u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003erules\u003c/span\u003e: [\n      {\n        \u003cspan class=\"hljs-attr\"\u003etest\u003c/span\u003e: \u003cspan class=\"hljs-regexp\"\u003e/\\.(js|jsx)$/\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003eexclude\u003c/span\u003e: \u003cspan class=\"hljs-regexp\"\u003e/node_modules/\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003euse\u003c/span\u003e: {\n          \u003cspan class=\"hljs-attr\"\u003eloader\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"babel-loader\"\u003c/span\u003e,\n        },\n      },\n    ],\n  },\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// esbuild 指令内容，由于采用首页的方式一直报错，最后根据错误，改为如下指令\u003c/span\u003e\nesbuild --bundle main.jsx --outdir=dist --minify --sourcemap\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e采用 esbuild 的时候，可以明显感觉到速度飞快，基本上 半秒不到就打包好了，而 webpack 嗯。。。三四秒的样子，速度还是很明显的，可能是因为项目小，没有 100 倍的感觉，但是 esbuild 基本上不用等。只是看看打包的体积，发现 esbuild 的体积比 webpack 的大三倍。这难道是时间换体积？经过排查是 \u003ccode\u003eprocess.env.NODE_ENV\u003c/code\u003e 的问题，esbuild 的版本里面包含了 development 和 production 两个模式的内容。官方文档有提示到：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNote that the double quotes around \u0026quot;production\u0026quot; are important because the replacement should be a string, not an identifier. The outer single quotes are for escaping the double quotes in Bash but may not be necessary in other shells.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ccode\u003eprocess.env.NODE_ENV\u003c/code\u003e 变量需要配置，并且不能省略 \u003ccode\u003e\u0026quot;production\u0026quot;\u003c/code\u003e 的引号，只是在 json 里面，添加引号一直无法正常使用，去掉引号会导致无法识别变量，最后采用 api 的方式构建，如下\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { build } = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"esbuild\"\u003c/span\u003e);\n\nbuild({\n  \u003cspan class=\"hljs-attr\"\u003eentryPoints\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"./main.jsx\"\u003c/span\u003e],\n  \u003cspan class=\"hljs-attr\"\u003eoutdir\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"dist\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eminify\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ebundle\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003esourcemap\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003edefine\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"process.env.NODE_ENV\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'\"production\"'\u003c/span\u003e,\n  },\n}).catch(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e process.exit(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e需要注意的是，define 里面的 key-value 结构的 value 不能是对象，不支持嵌套的 key。最后会打包有如下效果：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 原本的 process.env.NODE_ENV 会被替换，development的内容会被设置为null\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e) {\n  checkDCE();\n  \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = require_react_dom_production_min();\n} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n  \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e最后回头一看发现和 webpack 打包的体积居然是一模一样的，esbuild 大了 0.5k 不到。另外有个有趣的现象，如果把 bundle 配置去掉，包的内容，真的只有上面的 react 的业务代码。\u003c/p\u003e\n\u003cp\u003e想看看 esbuild 的源码，专门学了一下 go 语言，发现还是蛮简单（可能是学比较基础）。只是三脚猫功夫直接看源码，还是云里雾里的，也就放弃了。\u003c/p\u003e\n\u003ch3\u003eesbuild-webpack-plugin\u003c/h3\u003e\n\u003cp\u003e看到 umi 里面支持 esbuild，具体可以看看 \u003ccode\u003eesbuild-webpack-plugin\u003c/code\u003e 的代码。结构是一个典型的 webpack 的插件，通过 esbuild 的 transform 这个 api 来实现打包，可以看看下面的配置：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e transform = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u0026gt;\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e ESBuildPlugin.service.transform(source, {\n    ...this.options,\n    \u003cspan class=\"hljs-attr\"\u003eminify\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003esourcemap\u003c/span\u003e: !!devtool,\n    \u003cspan class=\"hljs-attr\"\u003esourcefile\u003c/span\u003e: file,\n  });\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e官方介绍到，如果需要重复调用 esbuild 的 api，最好是实例化 esbuild，达到复用的方式，也就是采用 transform 这个 api。\u003c/p\u003e\n\u003cp\u003e可以看到上面的代码，采用的配置只是 minify 而已，没有对 bundle 处理，按照作者的介绍\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eesbuild 有两个功能，bundler 和 minifier。bundler 的功能和 babel 以及 webpack 相比肯定差很多，直接上风险太大；而 minifier 倒是可以试试，在 webpack 和 babel 产物的基础上做一次压缩，坑应该相对较少。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这样确实不错，让 esbuild 做最专业的事情，同时可以继续使用生态丰富的 webpack，而压缩则是 esbuild，作者说到： \u003cstrong\u003e试验性功能，可能有坑，但效果拔群\u003c/strong\u003e，具体的时间效果也不对比了，送上\u003ca href=\"https://zhuanlan.zhihu.com/p/139219361\" target=\"_blank\"\u003e传送门\u003c/a\u003e。效果只是减少 1/3，估计是 webpack 本身其他操作占用了时间。\u003c/p\u003e\n\u003cp\u003e这个插件有配合 umi 的部分，但也可以用到其他 webapck 项目里面。具体是要配置 \u003ccode\u003eoptimization.minimizer\u003c/code\u003e 如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eoptimization: {\n  \u003cspan class=\"hljs-attr\"\u003eminimizer\u003c/span\u003e: [\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e (\u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"esbuild-webpack-plugin\"\u003c/span\u003e).default)()];\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e正常的 webpack 会采用 terser 作为内置的默认压缩工具，这里面改为 Esbuild 就可以了。\u003c/p\u003e\n\u003ch2\u003eES Module\u003c/h2\u003e\n\u003cp\u003e上面的 esbuild，可以说很好的解决了生产模式的压缩疼点，提高打包速度，但是开发环境呢？能用上 esbuild 吗？当然也是可以的，只是最优解并非如此。\u003c/p\u003e\n\u003cp\u003e有一次，看到一个线上地址 \u003ca href=\"https://iconsvg.xyz/\" target=\"_blank\"\u003ehttps://iconsvg.xyz/\u003c/a\u003e 的页面，打开控制台一看发现居然是采用 ES Module 的形式，如下图。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/iconsvg.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e现在的浏览器基本已经支持 ES 模块化了，直接模块化有什么不可以？直接用在生产环境会有很多问题，比如请求加载数量，比如兼容性，那对于开发环境呢？如 \u003cstrong\u003evite 和 snowpack\u003c/strong\u003e 这样的工具已经就是 bundleless 的工具，在开发环境上采用 ES Module 的方式实现快速热更新。\u003c/p\u003e\n\u003cp\u003e对于 ES Module，目前文件扩展名为 .js 结构，\u003ca href=\"https://v8.dev/features/modules#mjs\" target=\"_blank\"\u003e有推荐采用 .mjs 后缀\u003c/a\u003e，可以更清晰的表明是个模块，由于兼容问题，现在采用 .js 后缀就可以了。\u003c/p\u003e\n\u003cp\u003e应用的时候要采用下面的格式，来声明这个脚本是一个模块：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"module\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"main.mjs\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果没有声明 \u003ccode\u003etype=\u0026quot;module\u0026quot;\u003c/code\u003e 浏览器会提示 \u003ccode\u003eUncaught SyntaxError: Cannot use import statement outside a module\u003c/code\u003e 错误。\u003c/p\u003e\n\u003ch2\u003evite\u003c/h2\u003e\n\u003cp\u003evite 在开发环境通过解析文件返回到浏览器，不会有打包过程。这样当修改项目某个文件的时候，只会向浏览器发送更新该文件的请求，而不会去处理别的文件，最终打包的速度项目大小没有关系，可以很大提高开发环境热更新效率。需要注意的是 vite 在生产环境采用 rollup 打包。\u003c/p\u003e\n\u003ch3\u003e开发服务器劫持\u003c/h3\u003e\n\u003cp\u003evite 在开发环境的定位和 webpack-dev-server 是有点像的，都是作为一个开发服务器，响应客户端的请求。先看看 demo 上具体的效果，官方直接提供一个 \u003ca href=\"https://github.com/vitejs/create-vite-app\" target=\"_blank\"\u003ecreate-vite-app\u003c/a\u003e 项目作为起步脚手架模板，上面提供 vue 到 react 的模板，采用 template-vue 模板，启动的时间非常快，基本上按下回车差不多就跑起来了。可以看看下图：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/viteStart.gif\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e几秒钟的时间，项目就启动完毕了，对比一下 vue-cli 3，差不多要 10s 的样子，当然也是由于业务体积的问题，少量的业务，webpack 自然是非常快的（复杂的例子，就没有了，因为 vite 支持的是 vue-next，老项目用的是 vue 2 可能支持力度不好，无法迁移）。\u003c/p\u003e\n\u003cp\u003e通过控制台可以看一下，发起的请求：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/vite-network.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/vite-network-vue-cli4.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e前面是 vite 加载过程，后面是 vue-cli 3 的项目，可以明显看到 vite 是直接请求了 \u003ccode\u003e.vue\u003c/code\u003e 文件以及 vue.js 文件，而 vue-cli 3 则是请求打包好后的开发文件，只是前图的 vite 里面明明是一个 \u003ccode\u003eApp.vue\u003c/code\u003e 文件为什么会请求三次呢？这里就要说一下 vite 作为开发服务器对网络的劫持作用。\u003c/p\u003e\n\u003cp\u003evite 里面会启动一个 koa 服务器，采用中间件的方式对请求的文件劫持，结构如下\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e resolvedPlugins = [\n  moduleRewritePlugin,\n  htmlRewritePlugin,\n  moduleResolvePlugin,\n  proxyPlugin,\n  serviceWorkerPlugin,\n  hmrPlugin,\n  vuePlugin,\n  cssPlugin,\n  esbuildPlugin,\n  jsonPlugin,\n  assetPathPlugin,\n  serveStaticPlugin,\n];\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e插件的配置从查找模块、模块路径重写到 vue、css 等资源的处理，客户端请求什么内容，就由专门的中间件处理。比如入口，请求 \u003ccode\u003ehttp://localhost:3000/\u003c/code\u003e 返回的是 \u003ccode\u003eindex.html\u003c/code\u003e，但是结果如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/vite-index-html.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e中间的 script 部分是和原 \u003ccode\u003eindex.html\u003c/code\u003e 不一样的。额外加载 hmr 文件，正是上面 vite 请求网络图里面的 hmr 请求，同时还注入了全局的环境变量 \u003ccode\u003eprocess.env.NODE_ENV\u003c/code\u003e，可以看一下是如何实现的：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// htmlRewritePlugin 的内容，下面是注入的代码\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e devInjectionCode =\n  \u003cspan class=\"hljs-string\"\u003e`\\n\u0026lt;script type=\"module\"\u0026gt;\\n`\u003c/span\u003e +\n  \u003cspan class=\"hljs-string\"\u003e`import \"\u003cspan class=\"hljs-subst\"\u003e${hmrClientPublicPath}\u003c/span\u003e\"\\n`\u003c/span\u003e +\n  \u003cspan class=\"hljs-string\"\u003e`window.__DEV__ = true\\n`\u003c/span\u003e +\n  \u003cspan class=\"hljs-string\"\u003e`window.process = { env: \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.stringify({\n    ...env,\n    NODE_ENV: mode,\n    BASE_URL: \u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e,\n  }\u003c/span\u003e)}}\\n`\u003c/span\u003e +\n  \u003cspan class=\"hljs-string\"\u003e`\u0026lt;/script\u0026gt;\\n`\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erewriteHtml\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eimporter: string, html: string\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 省略缓存以及script标签替换内容\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e injectScriptToHtml(html, devInjectionCode);\n}\napp.use(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (ctx, next) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e next();\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ctx.status === \u003cspan class=\"hljs-number\"\u003e304\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ctx.response.is(\u003cspan class=\"hljs-string\"\u003e\"html\"\u003c/span\u003e) \u0026amp;\u0026amp; ctx.body) {\n    \u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n    ctx.body = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e rewriteHtml(importer, html);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e除了 html 的特殊处理外，vite 还会对 \u003ccode\u003eimport { createApp } from \u0026quot;vue\u0026quot;\u003c/code\u003e 这样的 import 语句重写路径为 \u003ccode\u003eimport { createApp } from \u0026quot;/@modules/vue.js\u0026quot;\u003c/code\u003e，前者的路径客户端是无法正常找到的，通过重写 \u003ccode\u003e@modules\u003c/code\u003e vite 可以明白这是一个第三方模块包的请求，对于这些 node_modules 的包可以做一系列的优化，后面会介绍到。\u003c/p\u003e\n\u003ch3\u003evue 文件处理\u003c/h3\u003e\n\u003cp\u003e对于 vue 单文件的处理，首个文件的访问路径还是源于 main.js 的正常 import，但是到了 vite，.vue 文件则会被 vuePlugin 处理，毕竟浏览器无法识别 .vue 文件，需要解析再返回给浏览器。先看看原始代码 App.vue：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 原始文件\u003c/span\u003e\n\u0026lt;template\u0026gt;\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"hehe\"\u003c/span\u003e\u0026gt;\u003c/span\u003e522215{{ a }}\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u0026lt;\u003cspan class=\"hljs-regexp\"\u003e/template\u0026gt;\n\n\u0026lt;script\u0026gt;\nexport default {\n  name: \"App\",\n  data() {\n    return {\n      a: 123\n    };\n  }\n};\n\u0026lt;/\u003c/span\u003escript\u0026gt;\n\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003estyle\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003escoped\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"css\"\u003e\n\u003cspan class=\"hljs-selector-class\"\u003e.hehe\u003c/span\u003e {\n  \u003cspan class=\"hljs-attribute\"\u003ebackground\u003c/span\u003e: red;\n}\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003estyle\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e拦截后输出的文件\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/vite-vue-loading.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e截图是返回的 App.vue 文件，可以看到原始的 .vue 文件变成一个 js 文件，也就是上图的代码。上图仅保留了原 App.vue 里面的 script 部分，渲染模板 template 以及样式 style 在 script 部分里通过 import 的方式引入，一个 .vue 文件拆分成三个。于是就有了左边 network 里面请求的 \u003ccode\u003eApp.vue?type=style\u0026amp;index=0\u003c/code\u003e 和 \u003ccode\u003eApp.vue?type=template\u003c/code\u003e。拆分成三个请求，每个请求各司其责，比如更新 template 的时候，就发送新的 template 文件到客户端，避免一次修改三个文件：script、template 和 style 混在一起发送，可以说很巧妙。\u003c/p\u003e\n\u003cp\u003evuePlugin 里面的实现，更多的是对请求路径的参数判断，如果参数 type 为 undefined(就是 script)、template 以及 style，都分别处理，同时在 script 的时候，如果文件是 typescript，还会采用 esbuild 的 transform API 来编译代码。\u003c/p\u003e\n\u003cp\u003e三个请求的由来，其实可以追朔到 vue 对 sfc 文件的解析，在 sfc 单文件处理的模块里面，会通过 ast 的方式将文件拆分成，script、template 和 style 三个模式，自然 vite 里面应该按照这三个模式更新 vue 是最合理的。\u003c/p\u003e\n\u003ch3\u003e热更新机制\u003c/h3\u003e\n\u003cp\u003e上面截图以及代码部分可以看到 hmr 的字样，hmr 则是代表热更新的部分。热更新分为两部分，一部分在客户端，一部分在开发服务器。客户端的主要热更新的代码，在 html 访问的时候，已经通过 \u003ccode\u003eimport \u0026quot;${hmrClientPublicPath}\u0026quot;\u003c/code\u003e 这样的方式加载，而 vite 也会通过 chokidar 来监听访问过的文件，当文件变化的时候，会通过 websocket 来通知客户端，再由客户端请求具体的更新代码。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 客户端主要代码\u003c/span\u003e\nsocket.addEventListener(\u003cspan class=\"hljs-string\"\u003e\"message\"\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e ({ data }) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (type) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"connected\"\u003c/span\u003e:\n      \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e`[vite] connected.`\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"vue-reload\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-comment\"\u003e// 重新加载vue\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"vue-rerender\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-comment\"\u003e// vue 组件重新渲染\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"style-update\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-comment\"\u003e// 样式更新\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"style-remove\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-comment\"\u003e// 移除样式\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"js-update\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-comment\"\u003e// js更新，react项目更新依赖这个\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"custom\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-comment\"\u003e// 自定义的，目前没有用到好像\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"full-reload\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-comment\"\u003e// 整个页面重新加载，\u003c/span\u003e\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e客户端对 vue-rerender 的指令，在加载文件后，会直接调用 vue-next 里面的热更新的函数：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// @vue/runtime-core \u0026gt; hmr \u0026gt; rerender 代码\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ererender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eid: string, newRender?: Function\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e record = map.get(id)\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!record) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// Array.from creates a snapshot which avoids the set being mutated during\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// updates\u003c/span\u003e\n  \u003cspan class=\"hljs-built_in\"\u003eArray\u003c/span\u003e.from(record).forEach(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003einstance\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (newRender) {\n      instance.render = newRender \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e InternalRenderFunction\n    }\n    instance.renderCache = []\n    \u003cspan class=\"hljs-comment\"\u003e// this flag forces child components with slot content to update\u003c/span\u003e\n    isHmrUpdating = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n    instance.update()\n    isHmrUpdating = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n  })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到这里将新的 render 注入，也就是 template 解析后生成的渲染函数，再调用实例的 update 方法，而这个 update 方法是，vue-next 里面渲染组件的主要入口，采用 effect 的方式。\u003c/p\u003e\n\u003cp\u003e服务端监听本地文件的变化。在 vue 的中间件里面，会对更新后的文件发送对应的指令，这里提一下重新加载 vue 文件和重新渲染 vue 组件的处理的方式不同。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// descriptor 是 vue-sfc 里面通过 ast 分析出来的描述器\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isEqualBlock(descriptor.script, prevDescriptor.script)) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e sendReload();\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isEqualBlock(descriptor.template, prevDescriptor.template)) {\n  needRerender = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到如果前后脚本不一致会重新加载，而如果只是模板不一样，则只会重新渲染组件。这里可以看到是对 vue 的处理，那如果是 react 项目呢？\u003c/p\u003e\n\u003ch3\u003ereact 项目处理\u003c/h3\u003e\n\u003cp\u003e在上面的代码里面，我们经常可以看到 vue 的影子，比如 vue 的中间件，vue 的客户端的热更新代码，而对于 react 是需要特殊的配置的，这里我们看看 react 项目的配置时候需要的插件：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// @ts-check\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e reactPlugin = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"vite-plugin-react\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e/**\n * @type { import('vite').UserConfig }\n */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e config = {\n  \u003cspan class=\"hljs-attr\"\u003ejsx\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [reactPlugin],\n};\n\n\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = config;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 vite.config.js 里面需要按照如上配置，而之前的 vue-next 则是什么都不用写。可以明显感觉到 vite 里面 vue-next 是一等生，毕竟连客户端的热更新代码，都用到 vue 的热更新部分。。。。\u003c/p\u003e\n\u003cp\u003e通过 vite-plugin-react 可以向 vite 项目提供更多的中间件，这个也是类似于 vue 的中间件，只是一个是内置，一个第三方包来配置。通过劫持 html 返回自己的运行时更新代码 react-refresh 部分以及 vite 的 hmr 客户端代码。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e//  vite-plugin-react 里面代码\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = {\n  \u003cspan class=\"hljs-attr\"\u003eresolvers\u003c/span\u003e: [resolver],\n  \u003cspan class=\"hljs-attr\"\u003econfigureServer\u003c/span\u003e: reactRefreshServerPlugin,\n  \u003cspan class=\"hljs-attr\"\u003etransforms\u003c/span\u003e: [reactRefreshTransform],\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// vite 里面处理插件的 transforms 的方法\u003c/span\u003e\napp.use(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (ctx, next) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e next();\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { path, query } = ctx;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e code: string | \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e t \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e transforms) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (t.test(path, query)) {\n      ctx.type = \u003cspan class=\"hljs-string\"\u003e\"js\"\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ctx.body) {\n        code = code || (\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e readBody(ctx.body));\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (code) {\n          ctx.body = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e t.transform(\n            code,\n            isImportRequest(ctx),\n            \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n            path,\n            query\n          );\n          code = ctx.body;\n        }\n      }\n    }\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ereactRefreshServerPlugin 会先服务器添加中间件，当访问 html 代码的时候，则会注入基本的全局代码；transforms 则会在 vite 开发服务器搭建的时候，通过 transforms 方式添加中间件，对 jsx/tsx 文件处理，注入以下关键代码。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e header = \u003cspan class=\"hljs-string\"\u003e`\n  import RefreshRuntime from \"\u003cspan class=\"hljs-subst\"\u003e${runtimePublicPath}\u003c/span\u003e\";\n  let prevRefreshReg;\n  let prevRefreshSig;\n  if (!window.__vite_plugin_react_preamble_installed__) {\n    throw new Error(\n      \"vite-plugin-react can't detect preamble. Something is wrong. See https://github.com/vitejs/vite-plugin-react/pull/11#discussion_r430879201\"\n    );\n  }\n  if (import.meta.hot) {\n    prevRefreshReg = window.$RefreshReg$;\n    prevRefreshSig = window.$RefreshSig$;\n    window.$RefreshReg$ = (type, id) =\u0026gt; {\n      RefreshRuntime.register(type, \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.stringify(path)}\u003c/span\u003e + \" \" + id)\n    };\n    window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;\n  }`\u003c/span\u003e.replace(\u003cspan class=\"hljs-regexp\"\u003e/[\\n]+/gm\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e footer = \u003cspan class=\"hljs-string\"\u003e`\n  if (import.meta.hot) {\n    window.$RefreshReg$ = prevRefreshReg;\n    window.$RefreshSig$ = prevRefreshSig;\n    import.meta.hot.accept();\n    RefreshRuntime.performReactRefresh();\n  }`\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面是注入的代码，header 和 footer。可以看出来来，主要注入的部分是热更新相关的。其中有个很特别的地方 \u003ccode\u003eimport.meta.hot\u003c/code\u003e，这个是 vite 特有的标记；\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eFor manual HMR, an API is provided via import.meta.hot.\nFor a module to self-accept, use import.meta.hot.accept:\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e count = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e.meta.hot) {\n  \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e.meta.hot.accept(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003enewModule\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e\"updated: count is now \"\u003c/span\u003e, newModule.count);\n  });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这是 \u003ccode\u003eimport.meta.hot\u003c/code\u003e 的用法，对于正常的需要热更新的代码文件，可以通过 \u003ccode\u003eimport.meta.hot\u003c/code\u003e 这个条件语句判断。当内容更新的时候，加载内容，并执行下面 \u003ccode\u003eaccept\u003c/code\u003e 的回调，至于回调里面如何处理，则需要自己控制了。react 采用的则是 \u003ccode\u003eimport.meta.hot\u003c/code\u003e 的方式，更新的方式，当然是通过 react-refresh 来。\u003c/p\u003e\n\u003cp\u003e上面客户端热更新方式里面，有一种是 js-update，当 jsx 文件更新的时候，会通知到客户端执行 js-upload，并最终加载新的 jsx 文件，当然同时也包含上面的添加的代码。\u003c/p\u003e\n\u003cp\u003e在 js-update 里面，会分析服务端下发文件的 id 路径，而加载哪些文件，则是根据这个 id 路径来判断的，通过分析 id 的所有依赖，依次加载。这些依赖的来源，并不是 webpack 打包时候分析的 import 的包，而是需要用户调用 accept 或者 acceptDeps 显示添加的，以及依赖更新后的回调函数。比如下面的方式：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { foo } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./foo.js\"\u003c/span\u003e;\n\nfoo();\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e.meta.hot) {\n  \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e.meta.hot.acceptDeps(\u003cspan class=\"hljs-string\"\u003e\"./foo.js\"\u003c/span\u003e, (newFoo) =\u0026gt; {\n    \u003cspan class=\"hljs-comment\"\u003e// the callback receives the updated './foo.js' module\u003c/span\u003e\n    newFoo.foo();\n  });\n\n  \u003cspan class=\"hljs-comment\"\u003e// Can also accept an array of dep modules:\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e.meta.hot.acceptDeps(\n    [\u003cspan class=\"hljs-string\"\u003e\"./foo.js\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"./bar.js\"\u003c/span\u003e],\n    ([newFooModule, newBarModule]) =\u0026gt; {\n      \u003cspan class=\"hljs-comment\"\u003e// the callback receives the updated modules in an Array\u003c/span\u003e\n    }\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e官网介绍的这种方式，通过 acceptDeps 指明依赖的路径，当文件变化的时候（指的是自身或者 import 进来的文件），会加载 acceptDeps 中的文件，执行对应的回调。如果不需要指出具体的依赖，比如像 react 的方式，采用 \u003ccode\u003eimport.meta.hot.accept()\u003c/code\u003e，表明是自身的更新，或者是自身 import 的文件的更新，重新加载本身，也就是 jsx 文件就好了。\u003c/p\u003e\n\u003cp\u003e回到 react 身上，采用 \u003ccode\u003eimport.meta.hot.accept()\u003c/code\u003e 的方式加 react-fresh 的热更新，好像不是最稳妥的，毕竟每次修改，都要重新加载一次文件，再去更新，没有 vue 来得优雅。当然还有就是不像 sfc 那样需要拆分成三个文件。\u003c/p\u003e\n\u003ch3\u003evite 启动\u003c/h3\u003e\n\u003cp\u003e前面介绍了 vite 的拦截，vue 和 react 的处理，但是在一开始的时候会解析 package.json 中的文件，对 dependencies 中的包缓存到 \u003ccode\u003enode_modules/.vite_opt_cache\u003c/code\u003e 里面，不管项目中有没有遇到。多次访问的时候，缓存可以提高访问速度，比如对 vue-next 访问速度的提高。\u003c/p\u003e\n\u003ch2\u003esnowpack\u003c/h2\u003e\n\u003cp\u003esnowpack 和 vite 都是优秀 ES Module 加载方案，发力的领域也是开发环境。vite 文档介绍到，项目依赖关系的处理是受到 snowpack 的启发，在开发环境上都是会启动一个开发服务器，并且解析返回速度也是类似的。可以看出来 vite 有不少方面是借鉴了 snowpack 。\u003c/p\u003e\n\u003cp\u003e当然 vite 有自己特色的部分，比如 热更新，可以做到深入到 vue 的热更新机制，以及调用 react 的热更新，当然 vite 里面 vue 是第一公民。snowpack 不同于 vite 的地方在于，其构建的时候，支持 webpack 和 Parcel 等，这样无疑对开发者更加友好。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/vite-snowpack-build.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e这里很好的介绍了 snowpack 构建的 O(1) 的过程，基本上每次文件更新都小于 50ms。well，现在 webpack 5 也做了很多优化，本地开发没有这么不堪了。上图也适用于 vite，两者都是 ES Module 级别的构建。\u003c/p\u003e\n\u003ch3\u003esnowpack 的劫持\u003c/h3\u003e\n\u003cp\u003esnowpack 和 vite 很不一样，vite 使用 koa 中间件的方式，对不同的文件处理，snowpack 没有中间件的概念，没有 koa 甚至是 express，采用 http-proxy、http 和 http2 来搭建开服服务器。\u003c/p\u003e\n\u003cp\u003e先看看网络加载情况\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/vite-snowpack-network.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e可以看出在 vite 里面 App.vue 被拆分成三个文件加载，而这里，只是分成两个文件，app.js 包含 script 和 template， app.css.proxy.js 则是 style 部分。\u003c/p\u003e\n\u003cp\u003esnowpack 采用外部插件来解析 vue 的方式，比如 vue 项目里面的配置：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// snowpack.config.json 里面的配置\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e\"extends\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"@snowpack/app-scripts-vue\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// @snowpack/app-scripts-vue 里面的配置\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e scripts = {\n  \u003cspan class=\"hljs-string\"\u003e\"mount:public\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"mount public --to /\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"mount:src\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"mount src --to /_dist_\"\u003c/span\u003e,\n};\n\n\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = {\n  scripts,\n  \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"@snowpack/plugin-vue\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"@snowpack/plugin-dotenv\"\u003c/span\u003e],\n  \u003cspan class=\"hljs-attr\"\u003einstallOptions\u003c/span\u003e: {},\n  \u003cspan class=\"hljs-attr\"\u003edevOptions\u003c/span\u003e: {},\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// @snowpack/plugin-vue 里面的配置\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eplugin\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003econfig, pluginOptions\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003edefaultBuildScript\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"build:vue\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e build({ contents, filePath }) {\n      \u003cspan class=\"hljs-comment\"\u003e// 采用 @vue/compiler-sfc 里面的parse来编译 sfc 文件，和 vite 的编译是一样的。\u003c/span\u003e\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如上面的结构，通过加载插件里面的 build 方法，实现对 sfc 文件的解析，中间过程比 vite 要复杂一些，vite 的中间件体系很直观，而 snowpack 则是通过不断的分析 \u003ccode\u003econfig.scripts\u003c/code\u003e 里面的配置（通过不断的调用 \u003ccode\u003efs.stat\u003c/code\u003e 判断），来得到正确的文件路径以及对应的解析方式，比如 \u003ccode\u003e_dist_/App.js\u003c/code\u003e 最后会转换为 \u003ccode\u003esrc/App.vue\u003c/code\u003e，并采用上述的 \u003ccode\u003e@snowpack/plugin-vue\u003c/code\u003e 的 build 方法加载 \u003ccode\u003esrc/App.vue\u003c/code\u003e，得到打包后的 script/template 组成的部分，以及 css 内容。发送到客户端并作缓存处理后。\u003c/p\u003e\n\u003cp\u003ebuild 方法里面会通过 parse 编译 sfc 文件，得到的 descriptor 和 vite 的差不多，包含 script、template 和 style 三个部分，其中 script 部分的代码会和 tempalte 的代码合并也就是后面 App.js 的主体。 style 作为单独的部分不会立刻发送到客户端，而是先做本地缓存里面。\u003c/p\u003e\n\u003cp\u003ecss 部分会有如下处理方式\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// snowpack dev.js wrapResponse\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (responseFileExt === \u003cspan class=\"hljs-string\"\u003e\".js\"\u003c/span\u003e) {\n  code = wrapImportMeta({ code, \u003cspan class=\"hljs-attr\"\u003eenv\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ehmr\u003c/span\u003e: isHmr, config });\n}\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (responseFileExt === \u003cspan class=\"hljs-string\"\u003e\".js\"\u003c/span\u003e \u0026amp;\u0026amp; cssResource) {\n  code =\n    \u003cspan class=\"hljs-string\"\u003e`import './\u003cspan class=\"hljs-subst\"\u003e${path.basename(reqPath).replace(\u003cspan class=\"hljs-regexp\"\u003e/.js$/\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\".css.proxy.js\"\u003c/span\u003e)}\u003c/span\u003e';\\n`\u003c/span\u003e +\n    code;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到在 App.js 里面添加 css 的 import 部分，这个和 vite 类似，只是 css 文件后缀采用 css.proxy.js 标识，而 vite 采用 \u003ccode\u003etype=style\u003c/code\u003e 的方式来区分。\u003c/p\u003e\n\u003cp\u003e另外 snowpack 对 html 的处理，会有一个 \u003ccode\u003eisRoute\u003c/code\u003e 变量来判断，并注入热更新等代码；\u003c/p\u003e\n\u003ch3\u003e热更新机制\u003c/h3\u003e\n\u003cp\u003e分为两套代码，客户端代码和开发服务器的代码，其中客户端的代码没有 vite 种类复杂\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003esocket.addEventListener(\u003cspan class=\"hljs-string\"\u003e\"message\"\u003c/span\u003e, ({ \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: _data }) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!_data) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.parse(_data);\n  debug(\u003cspan class=\"hljs-string\"\u003e\"message\"\u003c/span\u003e, data);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (data.type === \u003cspan class=\"hljs-string\"\u003e\"reload\"\u003c/span\u003e) {\n    reload();\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (data.type !== \u003cspan class=\"hljs-string\"\u003e\"update\"\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n  }\n  runModuleAccept(data.url)\n    .then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eok\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!ok) {\n        reload();\n      }\n    })\n    .catch(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n      \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.error(err);\n      reload();\n    });\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看出 snowpack 只有 reload 和 update 模式，没有 vite 那样复杂，但是其 js 部分更新逻辑是基本一致的，并且有很相同的 \u003ccode\u003eimport.meta.hot\u003c/code\u003e 方式以及 \u003ccode\u003eimport.meta.hot.accept\u003c/code\u003e 功能。基本和 vite 差不多，这里就不介绍了，当然 snowpack 不用判断 \u003ccode\u003eimport.meta.hot\u003c/code\u003e 是不是在 if 条件语句里面。\u003c/p\u003e\n\u003cp\u003esnowpack 没有像 vite 那样在客户端采用 vue 的热更新。\u003c/p\u003e\n\u003cp\u003esnowpack 启动的时候，也会对依赖进行分析，不同的是它会将依赖放在 \u003ccode\u003enode_modules/.cache/snowpack/dev\u003c/code\u003e 下面。node_modules 包的请求路径也会被改写为 \u003ccode\u003eweb_modules/vue.js\u003c/code\u003e 这样的特殊标记。\u003c/p\u003e\n\u003ch3\u003ewebpack\u003c/h3\u003e\n\u003cp\u003e在 snowpack 还可以使用 webpack，官方专门维护了 \u003ccode\u003e@snowpack/plugin-webpack\u003c/code\u003e 插件，和上面的 \u003ccode\u003e@snowpack/plugin-vue\u003c/code\u003e 一样都归属于插件范畴，在解析文件的时候会用到，提供一个 build 方法，并且最后通过 webpack 打包文件。snowpack 提供了一些默认配置，比如 babel、MiniCssExtractPlugin 这些。如果要扩展的话采用以下的方式配置，和 vue.config.js 的方式蛮像的。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// snowpack.config.js\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = {\n  \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [\n    [\n      \u003cspan class=\"hljs-string\"\u003e\"@snowpack/plugin-webpack\"\u003c/span\u003e,\n      {\n        \u003cspan class=\"hljs-attr\"\u003eextendConfig\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003econfig\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n          config.plugins.push(\u003cspan class=\"hljs-comment\"\u003e/* ... */\u003c/span\u003e);\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e config;\n        },\n      },\n    ],\n  ],\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里 webpack 的处理方式蛮奇怪的，会将打包好之后的文件，手动注入到 html 里面，而不是采用默认的方式，可能是没有 index.html？可能也是受限于 snowpack 和 webpack 的结合？具体的也就没有深入研究了，感兴趣的可以看看。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e上面介绍了三款最近流行的打包工具，esbuild 用于生产环境，vite 和 snowpack 主要用于开发环境。esbuild 打包压缩速度远超同行，也被用于 vite 和 snowpack 里面，作为 JavaScript 文件和 Typescript 文件降级和编译的工具，esbuild 如果要用于生产的话，可以考虑使用 \u003ccode\u003eesbuild-webpack-plugin\u003c/code\u003e，仅仅作为压缩工具，效率也能提高不少。\u003c/p\u003e\n\u003cp\u003evite 里面有不少借鉴 snowpack 的部分，当然也有自己特别的方式，比如中间件的结构，比如客户端更精准的热更新，当然和 snowpack 一样支持 webpack 更好了，只是目前看来难度不大？两者都可以用在生产，目前看来 vite 采用 rollup 打包，离主流 webpack 有点远，而 snowpack 支持 webpack 所以友好度更高。当然 vite 有尤大佬参与，自然不太一样。\u003c/p\u003e\n\u003cp\u003e本文还有不少源码没有深入介绍到，只是做一个稍微浅的解读，感兴趣的可以继续深入研究，如果能理解 esbuild 的 go 语言的源码就更好了。\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"March 24, 2021","title":"工程化新秀","content":"\u003cp\u003e炎热的七月，透着一点雨水，就这么来临。半年就如此过去了，看了不少内容，但是想写成博客的却越来越少，可能是人懒了。\n最近不少工程化的新秀如后浪般出现，虽然不至于动摇 webpack 这个巨浪，只是对行业也有很深刻的影响，觉得蛮有意思，这里介绍一下：\u003c/p\u003e\n\u003ch2\u003eesbuild\u003c/h2\u003e\n\u003cp\u003eesbuild 做的事情很简单，打包压缩，没有其他的复杂功能，目前也没有其他的插件系统，倒是 esbuild 本身更像一个插件，有点像 webpack 刚出来那会的情况。\u003c/p\u003e\n\u003cp\u003eesbuild 最大特点就是快，飞快，其本身采用 Go 语言实现，加上高并发的特色，在打包压缩的路上，一骑绝尘。官方数据，和正常的 webpack 相比，在打包方面提高了 100+ 倍以上，这对于需要代码更新后立刻发版到线上的项目而言，超级有意义，这不就是大家一直追求的快速构建嘛。\u003c/p\u003e\n\u003cp\u003e在构建项目的时候，基本都可以看到这一幕，打包到最后，本以为要结束了，结果进度条一直在 90% 左右的位置，一动不动，尤其是项目大了之后。其实这个最后的过程，是代码丑化、压缩以及 tree-shaking 的过程。代码压缩这部分，在以前的 webpack，是 UglifyjsWebpackPlugin 来处理的，后来内置到 webpack 里面，再后来，由于 uglify-js 不支持 es6，改用 terser 作为 webpack 内置的默认打包压缩工具。即便如此，业务小的时候还好，上来后，打包的时间会非常长。\u003c/p\u003e\n\u003ch3\u003e本地尝试\u003c/h3\u003e\n\u003cp\u003e按照文档思索着建一个最小的 demo，来看看速度如何。按照首页的提示，采用如下内容，分别用 webpack 和 esbuild 来打包：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 业务内容\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e React \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e ReactDOM \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react-dom\"\u003c/span\u003e;\n\nReactDOM.render(\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003eHello, world!\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.getElementById(\u003cspan class=\"hljs-string\"\u003e\"root\"\u003c/span\u003e));\n\n\u003cspan class=\"hljs-comment\"\u003e// webpack 配置，只是对jsx采用babel打包，同时还要配置babel的基本配置\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = {\n  \u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003erules\u003c/span\u003e: [\n      {\n        \u003cspan class=\"hljs-attr\"\u003etest\u003c/span\u003e: \u003cspan class=\"hljs-regexp\"\u003e/\\.(js|jsx)$/\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003eexclude\u003c/span\u003e: \u003cspan class=\"hljs-regexp\"\u003e/node_modules/\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003euse\u003c/span\u003e: {\n          \u003cspan class=\"hljs-attr\"\u003eloader\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"babel-loader\"\u003c/span\u003e,\n        },\n      },\n    ],\n  },\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// esbuild 指令内容，由于采用首页的方式一直报错，最后根据错误，改为如下指令\u003c/span\u003e\nesbuild --bundle main.jsx --outdir=dist --minify --sourcemap\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e采用 esbuild 的时候，可以明显感觉到速度飞快，基本上 半秒不到就打包好了，而 webpack 嗯。。。三四秒的样子，速度还是很明显的，可能是因为项目小，没有 100 倍的感觉，但是 esbuild 基本上不用等。只是看看打包的体积，发现 esbuild 的体积比 webpack 的大三倍。这难道是时间换体积？经过排查是 \u003ccode\u003eprocess.env.NODE_ENV\u003c/code\u003e 的问题，esbuild 的版本里面包含了 development 和 production 两个模式的内容。官方文档有提示到：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNote that the double quotes around \u0026quot;production\u0026quot; are important because the replacement should be a string, not an identifier. The outer single quotes are for escaping the double quotes in Bash but may not be necessary in other shells.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ccode\u003eprocess.env.NODE_ENV\u003c/code\u003e 变量需要配置，并且不能省略 \u003ccode\u003e\u0026quot;production\u0026quot;\u003c/code\u003e 的引号，只是在 json 里面，添加引号一直无法正常使用，去掉引号会导致无法识别变量，最后采用 api 的方式构建，如下\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { build } = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"esbuild\"\u003c/span\u003e);\n\nbuild({\n  \u003cspan class=\"hljs-attr\"\u003eentryPoints\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"./main.jsx\"\u003c/span\u003e],\n  \u003cspan class=\"hljs-attr\"\u003eoutdir\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"dist\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eminify\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ebundle\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003esourcemap\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003edefine\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"process.env.NODE_ENV\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'\"production\"'\u003c/span\u003e,\n  },\n}).catch(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e process.exit(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e需要注意的是，define 里面的 key-value 结构的 value 不能是对象，不支持嵌套的 key。最后会打包有如下效果：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 原本的 process.env.NODE_ENV 会被替换，development的内容会被设置为null\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e) {\n  checkDCE();\n  \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = require_react_dom_production_min();\n} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n  \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e最后回头一看发现和 webpack 打包的体积居然是一模一样的，esbuild 大了 0.5k 不到。另外有个有趣的现象，如果把 bundle 配置去掉，包的内容，真的只有上面的 react 的业务代码。\u003c/p\u003e\n\u003cp\u003e想看看 esbuild 的源码，专门学了一下 go 语言，发现还是蛮简单（可能是学比较基础）。只是三脚猫功夫直接看源码，还是云里雾里的，也就放弃了。\u003c/p\u003e\n\u003ch3\u003eesbuild-webpack-plugin\u003c/h3\u003e\n\u003cp\u003e看到 umi 里面支持 esbuild，具体可以看看 \u003ccode\u003eesbuild-webpack-plugin\u003c/code\u003e 的代码。结构是一个典型的 webpack 的插件，通过 esbuild 的 transform 这个 api 来实现打包，可以看看下面的配置：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e transform = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u0026gt;\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e ESBuildPlugin.service.transform(source, {\n    ...this.options,\n    \u003cspan class=\"hljs-attr\"\u003eminify\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003esourcemap\u003c/span\u003e: !!devtool,\n    \u003cspan class=\"hljs-attr\"\u003esourcefile\u003c/span\u003e: file,\n  });\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e官方介绍到，如果需要重复调用 esbuild 的 api，最好是实例化 esbuild，达到复用的方式，也就是采用 transform 这个 api。\u003c/p\u003e\n\u003cp\u003e可以看到上面的代码，采用的配置只是 minify 而已，没有对 bundle 处理，按照作者的介绍\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eesbuild 有两个功能，bundler 和 minifier。bundler 的功能和 babel 以及 webpack 相比肯定差很多，直接上风险太大；而 minifier 倒是可以试试，在 webpack 和 babel 产物的基础上做一次压缩，坑应该相对较少。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这样确实不错，让 esbuild 做最专业的事情，同时可以继续使用生态丰富的 webpack，而压缩则是 esbuild，作者说到： \u003cstrong\u003e试验性功能，可能有坑，但效果拔群\u003c/strong\u003e，具体的时间效果也不对比了，送上\u003ca href=\"https://zhuanlan.zhihu.com/p/139219361\" target=\"_blank\"\u003e传送门\u003c/a\u003e。效果只是减少 1/3，估计是 webpack 本身其他操作占用了时间。\u003c/p\u003e\n\u003cp\u003e这个插件有配合 umi 的部分，但也可以用到其他 webapck 项目里面。具体是要配置 \u003ccode\u003eoptimization.minimizer\u003c/code\u003e 如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eoptimization: {\n  \u003cspan class=\"hljs-attr\"\u003eminimizer\u003c/span\u003e: [\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e (\u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"esbuild-webpack-plugin\"\u003c/span\u003e).default)()];\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e正常的 webpack 会采用 terser 作为内置的默认压缩工具，这里面改为 Esbuild 就可以了。\u003c/p\u003e\n\u003ch2\u003eES Module\u003c/h2\u003e\n\u003cp\u003e上面的 esbuild，可以说很好的解决了生产模式的压缩疼点，提高打包速度，但是开发环境呢？能用上 esbuild 吗？当然也是可以的，只是最优解并非如此。\u003c/p\u003e\n\u003cp\u003e有一次，看到一个线上地址 \u003ca href=\"https://iconsvg.xyz/\" target=\"_blank\"\u003ehttps://iconsvg.xyz/\u003c/a\u003e 的页面，打开控制台一看发现居然是采用 ES Module 的形式，如下图。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/iconsvg.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e现在的浏览器基本已经支持 ES 模块化了，直接模块化有什么不可以？直接用在生产环境会有很多问题，比如请求加载数量，比如兼容性，那对于开发环境呢？如 \u003cstrong\u003evite 和 snowpack\u003c/strong\u003e 这样的工具已经就是 bundleless 的工具，在开发环境上采用 ES Module 的方式实现快速热更新。\u003c/p\u003e\n\u003cp\u003e对于 ES Module，目前文件扩展名为 .js 结构，\u003ca href=\"https://v8.dev/features/modules#mjs\" target=\"_blank\"\u003e有推荐采用 .mjs 后缀\u003c/a\u003e，可以更清晰的表明是个模块，由于兼容问题，现在采用 .js 后缀就可以了。\u003c/p\u003e\n\u003cp\u003e应用的时候要采用下面的格式，来声明这个脚本是一个模块：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"module\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"main.mjs\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果没有声明 \u003ccode\u003etype=\u0026quot;module\u0026quot;\u003c/code\u003e 浏览器会提示 \u003ccode\u003eUncaught SyntaxError: Cannot use import statement outside a module\u003c/code\u003e 错误。\u003c/p\u003e\n\u003ch2\u003evite\u003c/h2\u003e\n\u003cp\u003evite 在开发环境通过解析文件返回到浏览器，不会有打包过程。这样当修改项目某个文件的时候，只会向浏览器发送更新该文件的请求，而不会去处理别的文件，最终打包的速度项目大小没有关系，可以很大提高开发环境热更新效率。需要注意的是 vite 在生产环境采用 rollup 打包。\u003c/p\u003e\n\u003ch3\u003e开发服务器劫持\u003c/h3\u003e\n\u003cp\u003evite 在开发环境的定位和 webpack-dev-server 是有点像的，都是作为一个开发服务器，响应客户端的请求。先看看 demo 上具体的效果，官方直接提供一个 \u003ca href=\"https://github.com/vitejs/create-vite-app\" target=\"_blank\"\u003ecreate-vite-app\u003c/a\u003e 项目作为起步脚手架模板，上面提供 vue 到 react 的模板，采用 template-vue 模板，启动的时间非常快，基本上按下回车差不多就跑起来了。可以看看下图：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/viteStart.gif\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e几秒钟的时间，项目就启动完毕了，对比一下 vue-cli 3，差不多要 10s 的样子，当然也是由于业务体积的问题，少量的业务，webpack 自然是非常快的（复杂的例子，就没有了，因为 vite 支持的是 vue-next，老项目用的是 vue 2 可能支持力度不好，无法迁移）。\u003c/p\u003e\n\u003cp\u003e通过控制台可以看一下，发起的请求：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/vite-network.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/vite-network-vue-cli4.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e前面是 vite 加载过程，后面是 vue-cli 3 的项目，可以明显看到 vite 是直接请求了 \u003ccode\u003e.vue\u003c/code\u003e 文件以及 vue.js 文件，而 vue-cli 3 则是请求打包好后的开发文件，只是前图的 vite 里面明明是一个 \u003ccode\u003eApp.vue\u003c/code\u003e 文件为什么会请求三次呢？这里就要说一下 vite 作为开发服务器对网络的劫持作用。\u003c/p\u003e\n\u003cp\u003evite 里面会启动一个 koa 服务器，采用中间件的方式对请求的文件劫持，结构如下\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e resolvedPlugins = [\n  moduleRewritePlugin,\n  htmlRewritePlugin,\n  moduleResolvePlugin,\n  proxyPlugin,\n  serviceWorkerPlugin,\n  hmrPlugin,\n  vuePlugin,\n  cssPlugin,\n  esbuildPlugin,\n  jsonPlugin,\n  assetPathPlugin,\n  serveStaticPlugin,\n];\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e插件的配置从查找模块、模块路径重写到 vue、css 等资源的处理，客户端请求什么内容，就由专门的中间件处理。比如入口，请求 \u003ccode\u003ehttp://localhost:3000/\u003c/code\u003e 返回的是 \u003ccode\u003eindex.html\u003c/code\u003e，但是结果如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/vite-index-html.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e中间的 script 部分是和原 \u003ccode\u003eindex.html\u003c/code\u003e 不一样的。额外加载 hmr 文件，正是上面 vite 请求网络图里面的 hmr 请求，同时还注入了全局的环境变量 \u003ccode\u003eprocess.env.NODE_ENV\u003c/code\u003e，可以看一下是如何实现的：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// htmlRewritePlugin 的内容，下面是注入的代码\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e devInjectionCode =\n  \u003cspan class=\"hljs-string\"\u003e`\\n\u0026lt;script type=\"module\"\u0026gt;\\n`\u003c/span\u003e +\n  \u003cspan class=\"hljs-string\"\u003e`import \"\u003cspan class=\"hljs-subst\"\u003e${hmrClientPublicPath}\u003c/span\u003e\"\\n`\u003c/span\u003e +\n  \u003cspan class=\"hljs-string\"\u003e`window.__DEV__ = true\\n`\u003c/span\u003e +\n  \u003cspan class=\"hljs-string\"\u003e`window.process = { env: \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.stringify({\n    ...env,\n    NODE_ENV: mode,\n    BASE_URL: \u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e,\n  }\u003c/span\u003e)}}\\n`\u003c/span\u003e +\n  \u003cspan class=\"hljs-string\"\u003e`\u0026lt;/script\u0026gt;\\n`\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erewriteHtml\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eimporter: string, html: string\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 省略缓存以及script标签替换内容\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e injectScriptToHtml(html, devInjectionCode);\n}\napp.use(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (ctx, next) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e next();\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ctx.status === \u003cspan class=\"hljs-number\"\u003e304\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ctx.response.is(\u003cspan class=\"hljs-string\"\u003e\"html\"\u003c/span\u003e) \u0026amp;\u0026amp; ctx.body) {\n    \u003cspan class=\"hljs-comment\"\u003e// 省略部分代码\u003c/span\u003e\n    ctx.body = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e rewriteHtml(importer, html);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e除了 html 的特殊处理外，vite 还会对 \u003ccode\u003eimport { createApp } from \u0026quot;vue\u0026quot;\u003c/code\u003e 这样的 import 语句重写路径为 \u003ccode\u003eimport { createApp } from \u0026quot;/@modules/vue.js\u0026quot;\u003c/code\u003e，前者的路径客户端是无法正常找到的，通过重写 \u003ccode\u003e@modules\u003c/code\u003e vite 可以明白这是一个第三方模块包的请求，对于这些 node_modules 的包可以做一系列的优化，后面会介绍到。\u003c/p\u003e\n\u003ch3\u003evue 文件处理\u003c/h3\u003e\n\u003cp\u003e对于 vue 单文件的处理，首个文件的访问路径还是源于 main.js 的正常 import，但是到了 vite，.vue 文件则会被 vuePlugin 处理，毕竟浏览器无法识别 .vue 文件，需要解析再返回给浏览器。先看看原始代码 App.vue：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 原始文件\u003c/span\u003e\n\u0026lt;template\u0026gt;\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"hehe\"\u003c/span\u003e\u0026gt;\u003c/span\u003e522215{{ a }}\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u0026lt;\u003cspan class=\"hljs-regexp\"\u003e/template\u0026gt;\n\n\u0026lt;script\u0026gt;\nexport default {\n  name: \"App\",\n  data() {\n    return {\n      a: 123\n    };\n  }\n};\n\u0026lt;/\u003c/span\u003escript\u0026gt;\n\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003estyle\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003escoped\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"css\"\u003e\n\u003cspan class=\"hljs-selector-class\"\u003e.hehe\u003c/span\u003e {\n  \u003cspan class=\"hljs-attribute\"\u003ebackground\u003c/span\u003e: red;\n}\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003estyle\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e拦截后输出的文件\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/vite-vue-loading.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e截图是返回的 App.vue 文件，可以看到原始的 .vue 文件变成一个 js 文件，也就是上图的代码。上图仅保留了原 App.vue 里面的 script 部分，渲染模板 template 以及样式 style 在 script 部分里通过 import 的方式引入，一个 .vue 文件拆分成三个。于是就有了左边 network 里面请求的 \u003ccode\u003eApp.vue?type=style\u0026amp;index=0\u003c/code\u003e 和 \u003ccode\u003eApp.vue?type=template\u003c/code\u003e。拆分成三个请求，每个请求各司其责，比如更新 template 的时候，就发送新的 template 文件到客户端，避免一次修改三个文件：script、template 和 style 混在一起发送，可以说很巧妙。\u003c/p\u003e\n\u003cp\u003evuePlugin 里面的实现，更多的是对请求路径的参数判断，如果参数 type 为 undefined(就是 script)、template 以及 style，都分别处理，同时在 script 的时候，如果文件是 typescript，还会采用 esbuild 的 transform API 来编译代码。\u003c/p\u003e\n\u003cp\u003e三个请求的由来，其实可以追朔到 vue 对 sfc 文件的解析，在 sfc 单文件处理的模块里面，会通过 ast 的方式将文件拆分成，script、template 和 style 三个模式，自然 vite 里面应该按照这三个模式更新 vue 是最合理的。\u003c/p\u003e\n\u003ch3\u003e热更新机制\u003c/h3\u003e\n\u003cp\u003e上面截图以及代码部分可以看到 hmr 的字样，hmr 则是代表热更新的部分。热更新分为两部分，一部分在客户端，一部分在开发服务器。客户端的主要热更新的代码，在 html 访问的时候，已经通过 \u003ccode\u003eimport \u0026quot;${hmrClientPublicPath}\u0026quot;\u003c/code\u003e 这样的方式加载，而 vite 也会通过 chokidar 来监听访问过的文件，当文件变化的时候，会通过 websocket 来通知客户端，再由客户端请求具体的更新代码。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 客户端主要代码\u003c/span\u003e\nsocket.addEventListener(\u003cspan class=\"hljs-string\"\u003e\"message\"\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e ({ data }) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (type) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"connected\"\u003c/span\u003e:\n      \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e`[vite] connected.`\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"vue-reload\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-comment\"\u003e// 重新加载vue\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"vue-rerender\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-comment\"\u003e// vue 组件重新渲染\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"style-update\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-comment\"\u003e// 样式更新\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"style-remove\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-comment\"\u003e// 移除样式\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"js-update\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-comment\"\u003e// js更新，react项目更新依赖这个\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"custom\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-comment\"\u003e// 自定义的，目前没有用到好像\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"full-reload\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-comment\"\u003e// 整个页面重新加载，\u003c/span\u003e\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e客户端对 vue-rerender 的指令，在加载文件后，会直接调用 vue-next 里面的热更新的函数：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// @vue/runtime-core \u0026gt; hmr \u0026gt; rerender 代码\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ererender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eid: string, newRender?: Function\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e record = map.get(id)\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!record) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// Array.from creates a snapshot which avoids the set being mutated during\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// updates\u003c/span\u003e\n  \u003cspan class=\"hljs-built_in\"\u003eArray\u003c/span\u003e.from(record).forEach(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003einstance\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (newRender) {\n      instance.render = newRender \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e InternalRenderFunction\n    }\n    instance.renderCache = []\n    \u003cspan class=\"hljs-comment\"\u003e// this flag forces child components with slot content to update\u003c/span\u003e\n    isHmrUpdating = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n    instance.update()\n    isHmrUpdating = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n  })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到这里将新的 render 注入，也就是 template 解析后生成的渲染函数，再调用实例的 update 方法，而这个 update 方法是，vue-next 里面渲染组件的主要入口，采用 effect 的方式。\u003c/p\u003e\n\u003cp\u003e服务端监听本地文件的变化。在 vue 的中间件里面，会对更新后的文件发送对应的指令，这里提一下重新加载 vue 文件和重新渲染 vue 组件的处理的方式不同。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// descriptor 是 vue-sfc 里面通过 ast 分析出来的描述器\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isEqualBlock(descriptor.script, prevDescriptor.script)) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e sendReload();\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isEqualBlock(descriptor.template, prevDescriptor.template)) {\n  needRerender = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到如果前后脚本不一致会重新加载，而如果只是模板不一样，则只会重新渲染组件。这里可以看到是对 vue 的处理，那如果是 react 项目呢？\u003c/p\u003e\n\u003ch3\u003ereact 项目处理\u003c/h3\u003e\n\u003cp\u003e在上面的代码里面，我们经常可以看到 vue 的影子，比如 vue 的中间件，vue 的客户端的热更新代码，而对于 react 是需要特殊的配置的，这里我们看看 react 项目的配置时候需要的插件：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// @ts-check\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e reactPlugin = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"vite-plugin-react\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e/**\n * @type { import('vite').UserConfig }\n */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e config = {\n  \u003cspan class=\"hljs-attr\"\u003ejsx\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [reactPlugin],\n};\n\n\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = config;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 vite.config.js 里面需要按照如上配置，而之前的 vue-next 则是什么都不用写。可以明显感觉到 vite 里面 vue-next 是一等生，毕竟连客户端的热更新代码，都用到 vue 的热更新部分。。。。\u003c/p\u003e\n\u003cp\u003e通过 vite-plugin-react 可以向 vite 项目提供更多的中间件，这个也是类似于 vue 的中间件，只是一个是内置，一个第三方包来配置。通过劫持 html 返回自己的运行时更新代码 react-refresh 部分以及 vite 的 hmr 客户端代码。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e//  vite-plugin-react 里面代码\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = {\n  \u003cspan class=\"hljs-attr\"\u003eresolvers\u003c/span\u003e: [resolver],\n  \u003cspan class=\"hljs-attr\"\u003econfigureServer\u003c/span\u003e: reactRefreshServerPlugin,\n  \u003cspan class=\"hljs-attr\"\u003etransforms\u003c/span\u003e: [reactRefreshTransform],\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// vite 里面处理插件的 transforms 的方法\u003c/span\u003e\napp.use(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (ctx, next) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e next();\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { path, query } = ctx;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e code: string | \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e t \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e transforms) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (t.test(path, query)) {\n      ctx.type = \u003cspan class=\"hljs-string\"\u003e\"js\"\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ctx.body) {\n        code = code || (\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e readBody(ctx.body));\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (code) {\n          ctx.body = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e t.transform(\n            code,\n            isImportRequest(ctx),\n            \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n            path,\n            query\n          );\n          code = ctx.body;\n        }\n      }\n    }\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ereactRefreshServerPlugin 会先服务器添加中间件，当访问 html 代码的时候，则会注入基本的全局代码；transforms 则会在 vite 开发服务器搭建的时候，通过 transforms 方式添加中间件，对 jsx/tsx 文件处理，注入以下关键代码。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e header = \u003cspan class=\"hljs-string\"\u003e`\n  import RefreshRuntime from \"\u003cspan class=\"hljs-subst\"\u003e${runtimePublicPath}\u003c/span\u003e\";\n  let prevRefreshReg;\n  let prevRefreshSig;\n  if (!window.__vite_plugin_react_preamble_installed__) {\n    throw new Error(\n      \"vite-plugin-react can't detect preamble. Something is wrong. See https://github.com/vitejs/vite-plugin-react/pull/11#discussion_r430879201\"\n    );\n  }\n  if (import.meta.hot) {\n    prevRefreshReg = window.$RefreshReg$;\n    prevRefreshSig = window.$RefreshSig$;\n    window.$RefreshReg$ = (type, id) =\u0026gt; {\n      RefreshRuntime.register(type, \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.stringify(path)}\u003c/span\u003e + \" \" + id)\n    };\n    window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;\n  }`\u003c/span\u003e.replace(\u003cspan class=\"hljs-regexp\"\u003e/[\\n]+/gm\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e footer = \u003cspan class=\"hljs-string\"\u003e`\n  if (import.meta.hot) {\n    window.$RefreshReg$ = prevRefreshReg;\n    window.$RefreshSig$ = prevRefreshSig;\n    import.meta.hot.accept();\n    RefreshRuntime.performReactRefresh();\n  }`\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面是注入的代码，header 和 footer。可以看出来来，主要注入的部分是热更新相关的。其中有个很特别的地方 \u003ccode\u003eimport.meta.hot\u003c/code\u003e，这个是 vite 特有的标记；\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eFor manual HMR, an API is provided via import.meta.hot.\nFor a module to self-accept, use import.meta.hot.accept:\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e count = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e.meta.hot) {\n  \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e.meta.hot.accept(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003enewModule\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e\"updated: count is now \"\u003c/span\u003e, newModule.count);\n  });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这是 \u003ccode\u003eimport.meta.hot\u003c/code\u003e 的用法，对于正常的需要热更新的代码文件，可以通过 \u003ccode\u003eimport.meta.hot\u003c/code\u003e 这个条件语句判断。当内容更新的时候，加载内容，并执行下面 \u003ccode\u003eaccept\u003c/code\u003e 的回调，至于回调里面如何处理，则需要自己控制了。react 采用的则是 \u003ccode\u003eimport.meta.hot\u003c/code\u003e 的方式，更新的方式，当然是通过 react-refresh 来。\u003c/p\u003e\n\u003cp\u003e上面客户端热更新方式里面，有一种是 js-update，当 jsx 文件更新的时候，会通知到客户端执行 js-upload，并最终加载新的 jsx 文件，当然同时也包含上面的添加的代码。\u003c/p\u003e\n\u003cp\u003e在 js-update 里面，会分析服务端下发文件的 id 路径，而加载哪些文件，则是根据这个 id 路径来判断的，通过分析 id 的所有依赖，依次加载。这些依赖的来源，并不是 webpack 打包时候分析的 import 的包，而是需要用户调用 accept 或者 acceptDeps 显示添加的，以及依赖更新后的回调函数。比如下面的方式：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { foo } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./foo.js\"\u003c/span\u003e;\n\nfoo();\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e.meta.hot) {\n  \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e.meta.hot.acceptDeps(\u003cspan class=\"hljs-string\"\u003e\"./foo.js\"\u003c/span\u003e, (newFoo) =\u0026gt; {\n    \u003cspan class=\"hljs-comment\"\u003e// the callback receives the updated './foo.js' module\u003c/span\u003e\n    newFoo.foo();\n  });\n\n  \u003cspan class=\"hljs-comment\"\u003e// Can also accept an array of dep modules:\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e.meta.hot.acceptDeps(\n    [\u003cspan class=\"hljs-string\"\u003e\"./foo.js\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"./bar.js\"\u003c/span\u003e],\n    ([newFooModule, newBarModule]) =\u0026gt; {\n      \u003cspan class=\"hljs-comment\"\u003e// the callback receives the updated modules in an Array\u003c/span\u003e\n    }\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e官网介绍的这种方式，通过 acceptDeps 指明依赖的路径，当文件变化的时候（指的是自身或者 import 进来的文件），会加载 acceptDeps 中的文件，执行对应的回调。如果不需要指出具体的依赖，比如像 react 的方式，采用 \u003ccode\u003eimport.meta.hot.accept()\u003c/code\u003e，表明是自身的更新，或者是自身 import 的文件的更新，重新加载本身，也就是 jsx 文件就好了。\u003c/p\u003e\n\u003cp\u003e回到 react 身上，采用 \u003ccode\u003eimport.meta.hot.accept()\u003c/code\u003e 的方式加 react-fresh 的热更新，好像不是最稳妥的，毕竟每次修改，都要重新加载一次文件，再去更新，没有 vue 来得优雅。当然还有就是不像 sfc 那样需要拆分成三个文件。\u003c/p\u003e\n\u003ch3\u003evite 启动\u003c/h3\u003e\n\u003cp\u003e前面介绍了 vite 的拦截，vue 和 react 的处理，但是在一开始的时候会解析 package.json 中的文件，对 dependencies 中的包缓存到 \u003ccode\u003enode_modules/.vite_opt_cache\u003c/code\u003e 里面，不管项目中有没有遇到。多次访问的时候，缓存可以提高访问速度，比如对 vue-next 访问速度的提高。\u003c/p\u003e\n\u003ch2\u003esnowpack\u003c/h2\u003e\n\u003cp\u003esnowpack 和 vite 都是优秀 ES Module 加载方案，发力的领域也是开发环境。vite 文档介绍到，项目依赖关系的处理是受到 snowpack 的启发，在开发环境上都是会启动一个开发服务器，并且解析返回速度也是类似的。可以看出来 vite 有不少方面是借鉴了 snowpack 。\u003c/p\u003e\n\u003cp\u003e当然 vite 有自己特色的部分，比如 热更新，可以做到深入到 vue 的热更新机制，以及调用 react 的热更新，当然 vite 里面 vue 是第一公民。snowpack 不同于 vite 的地方在于，其构建的时候，支持 webpack 和 Parcel 等，这样无疑对开发者更加友好。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/vite-snowpack-build.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e这里很好的介绍了 snowpack 构建的 O(1) 的过程，基本上每次文件更新都小于 50ms。well，现在 webpack 5 也做了很多优化，本地开发没有这么不堪了。上图也适用于 vite，两者都是 ES Module 级别的构建。\u003c/p\u003e\n\u003ch3\u003esnowpack 的劫持\u003c/h3\u003e\n\u003cp\u003esnowpack 和 vite 很不一样，vite 使用 koa 中间件的方式，对不同的文件处理，snowpack 没有中间件的概念，没有 koa 甚至是 express，采用 http-proxy、http 和 http2 来搭建开服服务器。\u003c/p\u003e\n\u003cp\u003e先看看网络加载情况\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/vite-snowpack-network.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e可以看出在 vite 里面 App.vue 被拆分成三个文件加载，而这里，只是分成两个文件，app.js 包含 script 和 template， app.css.proxy.js 则是 style 部分。\u003c/p\u003e\n\u003cp\u003esnowpack 采用外部插件来解析 vue 的方式，比如 vue 项目里面的配置：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// snowpack.config.json 里面的配置\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e\"extends\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"@snowpack/app-scripts-vue\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// @snowpack/app-scripts-vue 里面的配置\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e scripts = {\n  \u003cspan class=\"hljs-string\"\u003e\"mount:public\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"mount public --to /\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"mount:src\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"mount src --to /_dist_\"\u003c/span\u003e,\n};\n\n\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = {\n  scripts,\n  \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"@snowpack/plugin-vue\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"@snowpack/plugin-dotenv\"\u003c/span\u003e],\n  \u003cspan class=\"hljs-attr\"\u003einstallOptions\u003c/span\u003e: {},\n  \u003cspan class=\"hljs-attr\"\u003edevOptions\u003c/span\u003e: {},\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// @snowpack/plugin-vue 里面的配置\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eplugin\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003econfig, pluginOptions\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003edefaultBuildScript\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"build:vue\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e build({ contents, filePath }) {\n      \u003cspan class=\"hljs-comment\"\u003e// 采用 @vue/compiler-sfc 里面的parse来编译 sfc 文件，和 vite 的编译是一样的。\u003c/span\u003e\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如上面的结构，通过加载插件里面的 build 方法，实现对 sfc 文件的解析，中间过程比 vite 要复杂一些，vite 的中间件体系很直观，而 snowpack 则是通过不断的分析 \u003ccode\u003econfig.scripts\u003c/code\u003e 里面的配置（通过不断的调用 \u003ccode\u003efs.stat\u003c/code\u003e 判断），来得到正确的文件路径以及对应的解析方式，比如 \u003ccode\u003e_dist_/App.js\u003c/code\u003e 最后会转换为 \u003ccode\u003esrc/App.vue\u003c/code\u003e，并采用上述的 \u003ccode\u003e@snowpack/plugin-vue\u003c/code\u003e 的 build 方法加载 \u003ccode\u003esrc/App.vue\u003c/code\u003e，得到打包后的 script/template 组成的部分，以及 css 内容。发送到客户端并作缓存处理后。\u003c/p\u003e\n\u003cp\u003ebuild 方法里面会通过 parse 编译 sfc 文件，得到的 descriptor 和 vite 的差不多，包含 script、template 和 style 三个部分，其中 script 部分的代码会和 tempalte 的代码合并也就是后面 App.js 的主体。 style 作为单独的部分不会立刻发送到客户端，而是先做本地缓存里面。\u003c/p\u003e\n\u003cp\u003ecss 部分会有如下处理方式\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// snowpack dev.js wrapResponse\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (responseFileExt === \u003cspan class=\"hljs-string\"\u003e\".js\"\u003c/span\u003e) {\n  code = wrapImportMeta({ code, \u003cspan class=\"hljs-attr\"\u003eenv\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ehmr\u003c/span\u003e: isHmr, config });\n}\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (responseFileExt === \u003cspan class=\"hljs-string\"\u003e\".js\"\u003c/span\u003e \u0026amp;\u0026amp; cssResource) {\n  code =\n    \u003cspan class=\"hljs-string\"\u003e`import './\u003cspan class=\"hljs-subst\"\u003e${path.basename(reqPath).replace(\u003cspan class=\"hljs-regexp\"\u003e/.js$/\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\".css.proxy.js\"\u003c/span\u003e)}\u003c/span\u003e';\\n`\u003c/span\u003e +\n    code;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到在 App.js 里面添加 css 的 import 部分，这个和 vite 类似，只是 css 文件后缀采用 css.proxy.js 标识，而 vite 采用 \u003ccode\u003etype=style\u003c/code\u003e 的方式来区分。\u003c/p\u003e\n\u003cp\u003e另外 snowpack 对 html 的处理，会有一个 \u003ccode\u003eisRoute\u003c/code\u003e 变量来判断，并注入热更新等代码；\u003c/p\u003e\n\u003ch3\u003e热更新机制\u003c/h3\u003e\n\u003cp\u003e分为两套代码，客户端代码和开发服务器的代码，其中客户端的代码没有 vite 种类复杂\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003esocket.addEventListener(\u003cspan class=\"hljs-string\"\u003e\"message\"\u003c/span\u003e, ({ \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: _data }) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!_data) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.parse(_data);\n  debug(\u003cspan class=\"hljs-string\"\u003e\"message\"\u003c/span\u003e, data);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (data.type === \u003cspan class=\"hljs-string\"\u003e\"reload\"\u003c/span\u003e) {\n    reload();\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (data.type !== \u003cspan class=\"hljs-string\"\u003e\"update\"\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n  }\n  runModuleAccept(data.url)\n    .then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eok\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!ok) {\n        reload();\n      }\n    })\n    .catch(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n      \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.error(err);\n      reload();\n    });\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看出 snowpack 只有 reload 和 update 模式，没有 vite 那样复杂，但是其 js 部分更新逻辑是基本一致的，并且有很相同的 \u003ccode\u003eimport.meta.hot\u003c/code\u003e 方式以及 \u003ccode\u003eimport.meta.hot.accept\u003c/code\u003e 功能。基本和 vite 差不多，这里就不介绍了，当然 snowpack 不用判断 \u003ccode\u003eimport.meta.hot\u003c/code\u003e 是不是在 if 条件语句里面。\u003c/p\u003e\n\u003cp\u003esnowpack 没有像 vite 那样在客户端采用 vue 的热更新。\u003c/p\u003e\n\u003cp\u003esnowpack 启动的时候，也会对依赖进行分析，不同的是它会将依赖放在 \u003ccode\u003enode_modules/.cache/snowpack/dev\u003c/code\u003e 下面。node_modules 包的请求路径也会被改写为 \u003ccode\u003eweb_modules/vue.js\u003c/code\u003e 这样的特殊标记。\u003c/p\u003e\n\u003ch3\u003ewebpack\u003c/h3\u003e\n\u003cp\u003e在 snowpack 还可以使用 webpack，官方专门维护了 \u003ccode\u003e@snowpack/plugin-webpack\u003c/code\u003e 插件，和上面的 \u003ccode\u003e@snowpack/plugin-vue\u003c/code\u003e 一样都归属于插件范畴，在解析文件的时候会用到，提供一个 build 方法，并且最后通过 webpack 打包文件。snowpack 提供了一些默认配置，比如 babel、MiniCssExtractPlugin 这些。如果要扩展的话采用以下的方式配置，和 vue.config.js 的方式蛮像的。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// snowpack.config.js\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = {\n  \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [\n    [\n      \u003cspan class=\"hljs-string\"\u003e\"@snowpack/plugin-webpack\"\u003c/span\u003e,\n      {\n        \u003cspan class=\"hljs-attr\"\u003eextendConfig\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003econfig\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n          config.plugins.push(\u003cspan class=\"hljs-comment\"\u003e/* ... */\u003c/span\u003e);\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e config;\n        },\n      },\n    ],\n  ],\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里 webpack 的处理方式蛮奇怪的，会将打包好之后的文件，手动注入到 html 里面，而不是采用默认的方式，可能是没有 index.html？可能也是受限于 snowpack 和 webpack 的结合？具体的也就没有深入研究了，感兴趣的可以看看。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e上面介绍了三款最近流行的打包工具，esbuild 用于生产环境，vite 和 snowpack 主要用于开发环境。esbuild 打包压缩速度远超同行，也被用于 vite 和 snowpack 里面，作为 JavaScript 文件和 Typescript 文件降级和编译的工具，esbuild 如果要用于生产的话，可以考虑使用 \u003ccode\u003eesbuild-webpack-plugin\u003c/code\u003e，仅仅作为压缩工具，效率也能提高不少。\u003c/p\u003e\n\u003cp\u003evite 里面有不少借鉴 snowpack 的部分，当然也有自己特别的方式，比如中间件的结构，比如客户端更精准的热更新，当然和 snowpack 一样支持 webpack 更好了，只是目前看来难度不大？两者都可以用在生产，目前看来 vite 采用 rollup 打包，离主流 webpack 有点远，而 snowpack 支持 webpack 所以友好度更高。当然 vite 有尤大佬参与，自然不太一样。\u003c/p\u003e\n\u003cp\u003e本文还有不少源码没有深入介绍到，只是做一个稍微浅的解读，感兴趣的可以继续深入研究，如果能理解 esbuild 的 go 语言的源码就更好了。\u003c/p\u003e\n"}},"buildId":"r4Ww0YLm8YL5~6SwciWHH","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" async=""></script></body></html>