<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">vue-router源码分析</title><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.587c5e31.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___2dTZ9 "><a class="logo___346dE" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___13XXt" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___29Pln"><h1 class="postTitle___1_m4g">vue-router源码分析</h1><span class="postTime___1x0_i">March 24, 2021</span></header><article class="postWrapper___3jnNg post-article"><div><h1>前言</h1>
<p>用了Vue快一年多了(虽然中间间断好长时间)，就越发的对其周边的生态感兴趣，尤其是对Vue-router和Vuex，Vue-router是单页面应用的核心部件，基本上的路由跳转都依赖它，项目上用的比较多的Vonic也是基于于Vue-router的；而Vuex只是在状态变化较多，需要store的时候才用上。本文先介绍Vue-router(2.7.0)，有时间再介绍Vuex；</p>
<h1>从示例开始</h1>
<p>下面是官方给出的示例basic，清晰的介绍了VueRouter最基本使用方法：</p>
<pre class="hljs"><code><span class="hljs-comment">// 1. 安装插件，同时注册&lt;router-view&gt;和&lt;router-link&gt;，并且劫持$router和$route</span>
Vue.use(VueRouter)

<span class="hljs-comment">// 2. 定义路由组件</span>
<span class="hljs-keyword">const</span> Home = { <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;home&lt;/div&gt;'</span> }
<span class="hljs-keyword">const</span> Foo = { <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;foo&lt;/div&gt;'</span> }
<span class="hljs-keyword">const</span> Bar = { <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;bar&lt;/div&gt;'</span> }

<span class="hljs-comment">// 3. 创建路由</span>
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter({
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'history'</span>,
  <span class="hljs-attr">base</span>: __dirname,
  <span class="hljs-attr">routes</span>: [
    { <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>, <span class="hljs-attr">component</span>: Home },
    { <span class="hljs-attr">path</span>: <span class="hljs-string">'/foo'</span>, <span class="hljs-attr">component</span>: Foo },
    { <span class="hljs-attr">path</span>: <span class="hljs-string">'/bar'</span>, <span class="hljs-attr">component</span>: Bar }
  ]
})
</code></pre>
<p>上面代码就可以构成最简单的Vue-router示例，当然创建好的router还需要加入Vue的option中。
可以发现一切的开始在于<code>Vue.use(VueRouter)</code>，use之后，直接使用Vue-router里面的api就好了。看看Vue里面use的用法：</p>
<pre class="hljs"><code>@Vue.js

Vue.use = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">plugin: Function | Object</span>) </span>{
  <span class="hljs-keyword">const</span> installedPlugins = (<span class="hljs-keyword">this</span>._installedPlugins || (<span class="hljs-keyword">this</span>._installedPlugins = []))
  <span class="hljs-keyword">if</span> (installedPlugins.indexOf(plugin) &gt; <span class="hljs-number">-1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
  }

  <span class="hljs-comment">// additional parameters</span>
  <span class="hljs-keyword">const</span> args = toArray(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>)
  args.unshift(<span class="hljs-keyword">this</span>)
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin.install === <span class="hljs-string">'function'</span>) {
    plugin.install.apply(plugin, args)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin === <span class="hljs-string">'function'</span>) {
    plugin.apply(<span class="hljs-literal">null</span>, args)
  }
  installedPlugins.push(plugin)
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
}
</code></pre>
<p>在Vue.js里面不难发现，use方法主要功能就是执行插件，若有install方法就执行install，并在将该插件push到内部变量_installedPlugins数组里面；而Vue-router的index.js文件里面<code>VueRouter.install = install</code>，install变量从install.js文件导入，所以Vue.use(VueRouter)，相当于执行了install.js导出的install方法。
再看看install方法都做了些什么：</p>
<pre class="hljs"><code>Vue.mixin({
  beforeCreate () {
    <span class="hljs-keyword">if</span> (isDef(<span class="hljs-keyword">this</span>.$options.router)) {
      <span class="hljs-keyword">this</span>._routerRoot = <span class="hljs-keyword">this</span>
      <span class="hljs-keyword">this</span>._router = <span class="hljs-keyword">this</span>.$options.router
      <span class="hljs-keyword">this</span>._router.init(<span class="hljs-keyword">this</span>)
      Vue.util.defineReactive(<span class="hljs-keyword">this</span>, <span class="hljs-string">'_route'</span>, <span class="hljs-keyword">this</span>._router.history.current)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>._routerRoot = (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent._routerRoot) || <span class="hljs-keyword">this</span>
    }
    registerInstance(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>)
  },
  destroyed () {
    registerInstance(<span class="hljs-keyword">this</span>)
  }
})
<span class="hljs-comment">// 劫持$router，getter方法返回的是VueRouter</span>
<span class="hljs-built_in">Object</span>.defineProperty(Vue.prototype, <span class="hljs-string">'$router'</span>, {
  <span class="hljs-keyword">get</span> () { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._routerRoot._router }
})
<span class="hljs-comment">// 劫持$router，getter方法返回的是VueRouter的路由对象</span>
<span class="hljs-built_in">Object</span>.defineProperty(Vue.prototype, <span class="hljs-string">'$route'</span>, {
  <span class="hljs-keyword">get</span> () { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._routerRoot._route }
})
<span class="hljs-comment">// 注册router-view和router-link全局组件</span>
Vue.component(<span class="hljs-string">'router-view'</span>, View)
Vue.component(<span class="hljs-string">'router-link'</span>, Link)
</code></pre>
<p>Vue.minxin作用是将混合对象的方法和组件合并，install.js里面则是为每个组件都添加beforeCreate钩子和destroyed钩子；在beforeCreate里面只有Vue实例化的时候才会进入true语句里面(router选项是配置在Vue对象里面)，其他的组件创建时候this.$options没有router对象，只有this.$options.parent才有router对象。如此，Vue实例化的时候，会对router进行初始化<code>this._router.init(this)</code>和'_route'的劫持。registerInstance方法是专门针对router-view组件，分析router-view组件的时候会介绍到。</p>
<h1>init 初始化VueRouter实例</h1>
<p>VueRouter这个class的实例化过程中会根据配置的选项mode，判断是要进行HTML5History，HashHistory还是AbstractHistory，默认下就是HashHistory，其兼容性是最好的；
而install方法里面重要的就是调用VueRouter实例的init方法：</p>
<pre class="hljs"><code>init (app: any <span class="hljs-comment">/* Vue component instance */</span>) {
  <span class="hljs-comment">// 判断是否已经处理过app</span>
  <span class="hljs-comment">// ...</span>
  <span class="hljs-comment">// 切换路由</span>
  <span class="hljs-keyword">if</span> (history <span class="hljs-keyword">instanceof</span> HTML5History) {
    history.transitionTo(history.getCurrentLocation())
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (history <span class="hljs-keyword">instanceof</span> HashHistory) {
    <span class="hljs-keyword">const</span> setupHashListener = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      history.setupListeners()
    }
    history.transitionTo(
      history.getCurrentLocation(),
      setupHashListener,
      setupHashListener
    )
  }
  <span class="hljs-comment">// history实例的cb</span>
  history.listen(<span class="hljs-function"><span class="hljs-params">route</span> =&gt;</span> {
    <span class="hljs-keyword">this</span>.apps.forEach(<span class="hljs-function">(<span class="hljs-params">app</span>) =&gt;</span> {
      app._route = route
    })
  })
}
</code></pre>
<p>在init里面对于HTML5History和HashHistory，进行<code>history.transitionTo</code>而history是在前文提到的VueRouter里面实例化的，<code>history.getCurrentLocation()</code>对于hash模式，就是<code>window.location.hash</code>#符号后面的地址；而<code>history.setupListeners()</code>则是监听hashchange事件，并执行<code>history.transitionTo</code></p>
<h2>路由匹配</h2>
<p>看看transitionTo如何实现：</p>
<pre class="hljs"><code>transitionTo (location: RawLocation, onComplete?: <span class="hljs-built_in">Function</span>, onAbort?: <span class="hljs-built_in">Function</span>) {
  <span class="hljs-keyword">const</span> route = <span class="hljs-keyword">this</span>.router.match(location, <span class="hljs-keyword">this</span>.current)
  <span class="hljs-keyword">this</span>.confirmTransition(route, () =&gt; {
    <span class="hljs-keyword">this</span>.updateRoute(route)
    onComplete &amp;&amp; onComplete(route)
    <span class="hljs-keyword">this</span>.ensureURL()
  <span class="hljs-comment">// ...</span>
  }, err =&gt; {
  <span class="hljs-comment">// ...</span>
  })
}
</code></pre>
<p>在transitionTo中，对于hash模式，传参是路径字符串(location)，和监听的回调函数(onComplete/onAbort)；第一步调用VueRouter实例的match方法，返回一个匹配的route对象。在介绍route对象之前，需要先了解<code>create-route-map.js</code>，里面的路由字典生成函数createRouteMap，其返回:</p>
<pre class="hljs"><code><span class="hljs-keyword">return</span> {
  pathList,
  pathMap,
  nameMap
}
</code></pre>
<p>pathList:是自然是示例中routes的path集合，pathMap则是每个path对应的路由记录对象字典，nameMap则是每个name对应的路由记录对象字典；路由记录对象里面其他选项都较好理解，里面的regex用了'path-to-regexp'模块，可以对路由记录对象里面的path处理为正则表达式，方便和当前路由进行配对；另外路由记录里面还有parent选项，当routes下面某个路由有children的时候parent指的就是上一级的路由记录对象。
回过头来，继续看match方法，该方法传入的参数是当前路由hash部分和current对象，current对象可以追溯到route.js里面的<code>Object.freeze(route)</code>，返回的是冻结了的路由对象，值得注意的是这个路由对象的matched，matched数组是所有传入createRoute的record路由记录对象及其所有父路由记录对象。在所有初始化的过程中，this.current的path就是'/'。
match里面现实如下：</p>
<pre class="hljs"><code>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">match</span> (<span class="hljs-params">
    raw: RawLocation,
    currentRoute?: Route,
    redirectedFrom?: Location
  </span>): <span class="hljs-title">Route</span> </span>{
    <span class="hljs-keyword">const</span> location = normalizeLocation(raw, currentRoute, <span class="hljs-literal">false</span>, router)
    <span class="hljs-keyword">const</span> { name } = location
    <span class="hljs-keyword">if</span> (name) {
    <span class="hljs-comment">// ...</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (location.path) {
      location.params = {}
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pathList.length; i++) {
        <span class="hljs-keyword">const</span> path = pathList[i]
        <span class="hljs-keyword">const</span> record = pathMap[path]
        <span class="hljs-keyword">if</span> (matchRoute(record.regex, location.path, location.params)) {
          <span class="hljs-keyword">return</span> _createRoute(record, location, redirectedFrom)
        }
      }
    }
    <span class="hljs-comment">// no match</span>
    <span class="hljs-keyword">return</span> _createRoute(<span class="hljs-literal">null</span>, location)
  }
</code></pre>
<p>normalizeLocation方法则是对当前hash和当前路由对象做比较，生成path，query，hash三个键以及<code>_normalized: true</code>，_normalized可以用于判断是否已经对当前hash和路由对象对比过了，在match的else if语句里面，可以看到对pathlist进行遍历，存储的路由记录对象的regex和生成的path对比，若能匹配上，则对location对象的params为path里面解析出来的参数；最后match会返回_createRoute函数，该函数在匹配的路由记录对象没重定向和别名时，会返回一个路由对象。而这个路由对象和match传参里面的current同出自createRoute方法，返回的结构自然也是一样的，于是就有猜想this.current会不会赋值为normalizeLocation生成的location呢？结果发现还真是这样。</p>
<h2>确认切换以及_route劫持</h2>
<p>上面提到transitionTo中执行的路由确认，生成新的路由对象route，接着confirmTransition结构如下所示：</p>
<ol>
<li>创建abort中止方法，判断当前current对象是否和路由对象route是相同路由，如果是则返回中止函数</li>
<li>创建执行队列queue针对current和route，按需执行</li>
<li>创建迭代器iterator，在iterator里面执行hook，而hook是queue队列中的函数</li>
<li>执行runQueue，迭代上文3中的iterator，并在最后执行回调
confirmTransition中的queue队列如下:</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">const</span> queue: <span class="hljs-built_in">Array</span>&lt;?NavigationGuard&gt; = [].concat(
  <span class="hljs-comment">// beforeRouteLeave方法</span>
  extractLeaveGuards(deactivated),
  <span class="hljs-comment">// 全局路由切换前动作</span>
  <span class="hljs-keyword">this</span>.router.beforeHooks,
  <span class="hljs-comment">// beforeRouteUpdate方法</span>
  extractUpdateHooks(updated),
  <span class="hljs-comment">// beforeEnter方法</span>
  activated.map(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.beforeEnter),
  <span class="hljs-comment">// 异步组件</span>
  resolveAsyncComponents(activated)
)
</code></pre>
<p>其中在Vue-router的<a href="https://router.vuejs.org/zh-cn/advanced/navigation-guards.html" target="_blank">官方文档</a>里面介绍了组件内部的方法beforeRouteEnter，beforeRouteUpdate ，beforeRouteLeave，可以对应queue里面的两个方法，而queue里面的beforeEnter，是写在routes里面的方法名beforeEnter；至于文档里面提到的beforeRouteEnter，则对应runQueue方法内部，执行的extractEnterGuards方法，也是最后执行的钩子；
迭代器iterater的是否进入下一步迭代，是由传入hook里面的to来确定的(这个to为何物？要具体到每个方法的next函数传参)。
在transistorTo中，传给confirmTransition的除了route，还有onComplete，确认切换的回调函数，代码如下：</p>
<pre class="hljs"><code><span class="hljs-comment">// confirmTransition的onComplete方法</span>
<span class="hljs-keyword">this</span>.updateRoute(route)
onComplete &amp;&amp; onComplete(route)
<span class="hljs-keyword">this</span>.ensureURL()

<span class="hljs-comment">// fire ready cbs once</span>
<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.ready) {
  <span class="hljs-keyword">this</span>.ready = <span class="hljs-literal">true</span>
  <span class="hljs-keyword">this</span>.readyCbs.forEach(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> { cb(route) })
}
</code></pre>
<p>好奇的你估计会问怎么onComplete里面还有个onComplete，后面这个回调是transistorTo自己的，也就是我们前文提到的<code>history.setupListeners</code>，至于updateRounte方法，则如下所示：</p>
<pre class="hljs"><code>updateRoute (route: Route) {
  <span class="hljs-keyword">const</span> prev = <span class="hljs-keyword">this</span>.current
  <span class="hljs-keyword">this</span>.current = route
  <span class="hljs-keyword">this</span>.cb &amp;&amp; <span class="hljs-keyword">this</span>.cb(route)
  <span class="hljs-keyword">this</span>.router.afterHooks.forEach(<span class="hljs-function"><span class="hljs-params">hook</span> =&gt;</span> {
    hook &amp;&amp; hook(route, prev)
  })
}
</code></pre>
<p>将获得的路由匹配中创建的路由对象route指向this.current，这也涉及到我们前面所说的两者都是由createRoute生成的；this.cb，该方法在init初始里面的末端有涉及如下：</p>
<pre class="hljs"><code>history.listen(<span class="hljs-function"><span class="hljs-params">route</span> =&gt;</span> {
  <span class="hljs-keyword">this</span>.apps.forEach(<span class="hljs-function">(<span class="hljs-params">app</span>) =&gt;</span> {
    app._route = route
  })
})
</code></pre>
<p>Vue实例化的时候，也初始化history.cb，实现对_route的赋值修改，但是其并没有在初始化的时候执行，Vue实例化中history.cb的赋值是在transitionTo之后的，也就是在updateRoute之后，但是在后面的路由跳转中，因为history.cb已经初始化，则会执行history.cb()。这也就实现了install过程里面对$route的数据劫持，其返回this._routerRoot._route就是route路由对象。
至于ensureURL，这个就神奇了，Vue-router中是以最新的路由对象为标准来修改hash的，为了确保window.location.hash的正确性，会在确认切换路由回调里面再次确认当前hash是否与当前路由对象的记录一直，不一致的话，以最新的路由对象为标准再次修改window.location.hash。
在Vue实例化中beforeCreate有一下一句：</p>
<pre class="hljs"><code>Vue.util.defineReactive(<span class="hljs-keyword">this</span>, <span class="hljs-string">'_route'</span>, <span class="hljs-keyword">this</span>._router.history.current)
</code></pre>
<p>defineReactive这是Vue里面观察者劫持数据的方法， 而这里是劫持_route，当_route触发setter方法的时候，则会通知到依赖的组件；</p>
<h1>组件</h1>
<p>在install的过程里面已经将router-link和router-view两个组件注册好了，稍微看一下源码就不难发现，这两个组件用的都是render方法渲染组件
对于router-link，默认标签tag为a标签，也是h函数的第一个参数，而数据对象data，有on和attrs，on是router-link里prop过来的事件，默认为click事件；而attrs处理时候，调用了<code>router.resolve(this.to, current, this.append)</code>在index.js里面的resolve方法也是调用了match方法，返回匹配的路由route，虽然和transistorTo方法里match传参格式不同，但是结果都是返回路由对象route。
在h函数创建Vnode的时候，data.class还会根据传参，当前路由来设置对应的class样式。
router-link里面还会自动创建a标签，并且当click事件触发的时候会调用内部的handler函数，当props的replace为false的时候，会触发transitionTo方法，并切换路由，点击a标签当然要触发跳转，而该transitionTo的回调则是修改window.location.hash的方法，从而修改地址栏的hash。当然由于前文提到的在Vue实例化过程中，我们在transitionTo的回调里面用了setupListeners去监听hashchange事件，所以在hashchange监听函数里面也会调用transitionTo方法，但是因为此时路由对象已经是最新的得了，所以不会进一步切换。</p>
<p>对于router，值得注意的部分是registerRouteInstance，也是最开始的install里面提到的，beforeCreate和destroyed都可能触发这个方法。registerRouteInstance其功能和路由对象里面的match：记录路由对象的instances相关联，就是会将对当前的router-view组件添加到对应的路由记录的instance里面，并在router-view组件destoryed的时候将该instance置为undefined；而这个instance的主要作用是在confirmTransition中的queue中使用到的，以及<a href="https://github.com/vuejs/vue-router/issues/750" target="_blank">issue#750</a>里面提到的。</p>
<h1>History</h1>
<p>上文提到的都是HashHistory下的，当然其实还有HTML5History模式，HTML5History顾名思义，用的HTML5的特性，老版本的浏览器会有兼容问题，所以默认情况下是hash模式，可以自己手动开启；
HTML5提供了两个api:</p>
<ol>
<li>history.pushState()</li>
<li>history.replaceState()
分别添加和更新浏览器的历史纪录，pushState方法会在transitorTo的回调里面调用，类似于hash模式下的pushHash，而replaceState则类似与replaceHash方法。在init初始化的时候，还有HTML5History还有直接对事件popstate监听，popstate类似于hashchange事件，同样的也会有transitionTo调用，主要作用也是监听浏览器的前进后退功能，基本上是大同小异的；</li>
</ol>
<p>至于AbstractHistory就更简单了，不是用于浏览器的，自然没有window.location的负担，没有浏览器的后退前进按钮，所以历史浏览记录用个数组和index代替就好了。实现简单，这里就不再谈了</p>
<p>ps: 附上Vue-router 0.4.0 src/transition.js里面对router-view切换时候组件处理的思路，2.7.0版本已经没有这部分注释了</p>
<blockquote>
<p>A router view transition's pipeline can be described as
follows, assuming we are transitioning from an existing
<router-view> chain [Component A, Component B] to a new
chain [Component A, Component C]:
A    A
| =&gt; |
B    C<br>
1. Reusablity phase:
-&gt; canReuse(A, A)
-&gt; canReuse(B, C)
-&gt; determine new queues:
- deactivation: [B]
- activation: [C]<br>
2. Validation phase:
-&gt; canDeactivate(B)
-&gt; canActivate(C)
3. Activation phase:
-&gt; deactivate(B)
-&gt; activate(C)
Each of these steps can be asynchronous, and any
step can potentially abort the transition.</p>
</blockquote>
<p>参考资料</p>
<ol>
<li><a href="http://www.zhangxinxu.com/wordpress/2013/06/html5-history-api-pushstate-replacestate-ajax/" target="_blank">ajax与HTML5 history pushState/replaceState实例</a></li>
</ol>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"March 24, 2021","title":"vue-router源码分析","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e用了Vue快一年多了(虽然中间间断好长时间)，就越发的对其周边的生态感兴趣，尤其是对Vue-router和Vuex，Vue-router是单页面应用的核心部件，基本上的路由跳转都依赖它，项目上用的比较多的Vonic也是基于于Vue-router的；而Vuex只是在状态变化较多，需要store的时候才用上。本文先介绍Vue-router(2.7.0)，有时间再介绍Vuex；\u003c/p\u003e\n\u003ch1\u003e从示例开始\u003c/h1\u003e\n\u003cp\u003e下面是官方给出的示例basic，清晰的介绍了VueRouter最基本使用方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 1. 安装插件，同时注册\u0026lt;router-view\u0026gt;和\u0026lt;router-link\u0026gt;，并且劫持$router和$route\u003c/span\u003e\nVue.use(VueRouter)\n\n\u003cspan class=\"hljs-comment\"\u003e// 2. 定义路由组件\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Home = { \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'\u0026lt;div\u0026gt;home\u0026lt;/div\u0026gt;'\u003c/span\u003e }\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Foo = { \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'\u0026lt;div\u0026gt;foo\u0026lt;/div\u0026gt;'\u003c/span\u003e }\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Bar = { \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'\u0026lt;div\u0026gt;bar\u0026lt;/div\u0026gt;'\u003c/span\u003e }\n\n\u003cspan class=\"hljs-comment\"\u003e// 3. 创建路由\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e router = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e VueRouter({\n  \u003cspan class=\"hljs-attr\"\u003emode\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'history'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ebase\u003c/span\u003e: __dirname,\n  \u003cspan class=\"hljs-attr\"\u003eroutes\u003c/span\u003e: [\n    { \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e: Home },\n    { \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/foo'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e: Foo },\n    { \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/bar'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e: Bar }\n  ]\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码就可以构成最简单的Vue-router示例，当然创建好的router还需要加入Vue的option中。\n可以发现一切的开始在于\u003ccode\u003eVue.use(VueRouter)\u003c/code\u003e，use之后，直接使用Vue-router里面的api就好了。看看Vue里面use的用法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e@Vue.js\n\nVue.use = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eplugin: Function | Object\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e installedPlugins = (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._installedPlugins || (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._installedPlugins = []))\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (installedPlugins.indexOf(plugin) \u0026gt; \u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// additional parameters\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e args = toArray(\u003cspan class=\"hljs-built_in\"\u003earguments\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n  args.unshift(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e)\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e plugin.install === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n    plugin.install.apply(plugin, args)\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e plugin === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n    plugin.apply(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, args)\n  }\n  installedPlugins.push(plugin)\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在Vue.js里面不难发现，use方法主要功能就是执行插件，若有install方法就执行install，并在将该插件push到内部变量_installedPlugins数组里面；而Vue-router的index.js文件里面\u003ccode\u003eVueRouter.install = install\u003c/code\u003e，install变量从install.js文件导入，所以Vue.use(VueRouter)，相当于执行了install.js导出的install方法。\n再看看install方法都做了些什么：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eVue.mixin({\n  beforeCreate () {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isDef(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$options.router)) {\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._routerRoot = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._router = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$options.router\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._router.init(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e)\n      Vue.util.defineReactive(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'_route'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._router.history.current)\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._routerRoot = (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$parent \u0026amp;\u0026amp; \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$parent._routerRoot) || \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e\n    }\n    registerInstance(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e)\n  },\n  destroyed () {\n    registerInstance(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e)\n  }\n})\n\u003cspan class=\"hljs-comment\"\u003e// 劫持$router，getter方法返回的是VueRouter\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.defineProperty(Vue.prototype, \u003cspan class=\"hljs-string\"\u003e'$router'\u003c/span\u003e, {\n  \u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e () { \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._routerRoot._router }\n})\n\u003cspan class=\"hljs-comment\"\u003e// 劫持$router，getter方法返回的是VueRouter的路由对象\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.defineProperty(Vue.prototype, \u003cspan class=\"hljs-string\"\u003e'$route'\u003c/span\u003e, {\n  \u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e () { \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._routerRoot._route }\n})\n\u003cspan class=\"hljs-comment\"\u003e// 注册router-view和router-link全局组件\u003c/span\u003e\nVue.component(\u003cspan class=\"hljs-string\"\u003e'router-view'\u003c/span\u003e, View)\nVue.component(\u003cspan class=\"hljs-string\"\u003e'router-link'\u003c/span\u003e, Link)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eVue.minxin作用是将混合对象的方法和组件合并，install.js里面则是为每个组件都添加beforeCreate钩子和destroyed钩子；在beforeCreate里面只有Vue实例化的时候才会进入true语句里面(router选项是配置在Vue对象里面)，其他的组件创建时候this.$options没有router对象，只有this.$options.parent才有router对象。如此，Vue实例化的时候，会对router进行初始化\u003ccode\u003ethis._router.init(this)\u003c/code\u003e和'_route'的劫持。registerInstance方法是专门针对router-view组件，分析router-view组件的时候会介绍到。\u003c/p\u003e\n\u003ch1\u003einit 初始化VueRouter实例\u003c/h1\u003e\n\u003cp\u003eVueRouter这个class的实例化过程中会根据配置的选项mode，判断是要进行HTML5History，HashHistory还是AbstractHistory，默认下就是HashHistory，其兼容性是最好的；\n而install方法里面重要的就是调用VueRouter实例的init方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003einit (app: any \u003cspan class=\"hljs-comment\"\u003e/* Vue component instance */\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 判断是否已经处理过app\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 切换路由\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (history \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e HTML5History) {\n    history.transitionTo(history.getCurrentLocation())\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (history \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e HashHistory) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e setupHashListener = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n      history.setupListeners()\n    }\n    history.transitionTo(\n      history.getCurrentLocation(),\n      setupHashListener,\n      setupHashListener\n    )\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// history实例的cb\u003c/span\u003e\n  history.listen(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eroute\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.apps.forEach(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eapp\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n      app._route = route\n    })\n  })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在init里面对于HTML5History和HashHistory，进行\u003ccode\u003ehistory.transitionTo\u003c/code\u003e而history是在前文提到的VueRouter里面实例化的，\u003ccode\u003ehistory.getCurrentLocation()\u003c/code\u003e对于hash模式，就是\u003ccode\u003ewindow.location.hash\u003c/code\u003e#符号后面的地址；而\u003ccode\u003ehistory.setupListeners()\u003c/code\u003e则是监听hashchange事件，并执行\u003ccode\u003ehistory.transitionTo\u003c/code\u003e\u003c/p\u003e\n\u003ch2\u003e路由匹配\u003c/h2\u003e\n\u003cp\u003e看看transitionTo如何实现：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003etransitionTo (location: RawLocation, onComplete?: \u003cspan class=\"hljs-built_in\"\u003eFunction\u003c/span\u003e, onAbort?: \u003cspan class=\"hljs-built_in\"\u003eFunction\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e route = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.router.match(location, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.current)\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.confirmTransition(route, () =\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.updateRoute(route)\n    onComplete \u0026amp;\u0026amp; onComplete(route)\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.ensureURL()\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  }, err =\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在transitionTo中，对于hash模式，传参是路径字符串(location)，和监听的回调函数(onComplete/onAbort)；第一步调用VueRouter实例的match方法，返回一个匹配的route对象。在介绍route对象之前，需要先了解\u003ccode\u003ecreate-route-map.js\u003c/code\u003e，里面的路由字典生成函数createRouteMap，其返回:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n  pathList,\n  pathMap,\n  nameMap\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003epathList:是自然是示例中routes的path集合，pathMap则是每个path对应的路由记录对象字典，nameMap则是每个name对应的路由记录对象字典；路由记录对象里面其他选项都较好理解，里面的regex用了'path-to-regexp'模块，可以对路由记录对象里面的path处理为正则表达式，方便和当前路由进行配对；另外路由记录里面还有parent选项，当routes下面某个路由有children的时候parent指的就是上一级的路由记录对象。\n回过头来，继续看match方法，该方法传入的参数是当前路由hash部分和current对象，current对象可以追溯到route.js里面的\u003ccode\u003eObject.freeze(route)\u003c/code\u003e，返回的是冻结了的路由对象，值得注意的是这个路由对象的matched，matched数组是所有传入createRoute的record路由记录对象及其所有父路由记录对象。在所有初始化的过程中，this.current的path就是'/'。\nmatch里面现实如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ematch\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\n    raw: RawLocation,\n    currentRoute?: Route,\n    redirectedFrom?: Location\n  \u003c/span\u003e): \u003cspan class=\"hljs-title\"\u003eRoute\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e location = normalizeLocation(raw, currentRoute, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, router)\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { name } = location\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (name) {\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (location.path) {\n      location.params = {}\n      \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; pathList.length; i++) {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e path = pathList[i]\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e record = pathMap[path]\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (matchRoute(record.regex, location.path, location.params)) {\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _createRoute(record, location, redirectedFrom)\n        }\n      }\n    }\n    \u003cspan class=\"hljs-comment\"\u003e// no match\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _createRoute(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, location)\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003enormalizeLocation方法则是对当前hash和当前路由对象做比较，生成path，query，hash三个键以及\u003ccode\u003e_normalized: true\u003c/code\u003e，_normalized可以用于判断是否已经对当前hash和路由对象对比过了，在match的else if语句里面，可以看到对pathlist进行遍历，存储的路由记录对象的regex和生成的path对比，若能匹配上，则对location对象的params为path里面解析出来的参数；最后match会返回_createRoute函数，该函数在匹配的路由记录对象没重定向和别名时，会返回一个路由对象。而这个路由对象和match传参里面的current同出自createRoute方法，返回的结构自然也是一样的，于是就有猜想this.current会不会赋值为normalizeLocation生成的location呢？结果发现还真是这样。\u003c/p\u003e\n\u003ch2\u003e确认切换以及_route劫持\u003c/h2\u003e\n\u003cp\u003e上面提到transitionTo中执行的路由确认，生成新的路由对象route，接着confirmTransition结构如下所示：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e创建abort中止方法，判断当前current对象是否和路由对象route是相同路由，如果是则返回中止函数\u003c/li\u003e\n\u003cli\u003e创建执行队列queue针对current和route，按需执行\u003c/li\u003e\n\u003cli\u003e创建迭代器iterator，在iterator里面执行hook，而hook是queue队列中的函数\u003c/li\u003e\n\u003cli\u003e执行runQueue，迭代上文3中的iterator，并在最后执行回调\nconfirmTransition中的queue队列如下:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e queue: \u003cspan class=\"hljs-built_in\"\u003eArray\u003c/span\u003e\u0026lt;?NavigationGuard\u0026gt; = [].concat(\n  \u003cspan class=\"hljs-comment\"\u003e// beforeRouteLeave方法\u003c/span\u003e\n  extractLeaveGuards(deactivated),\n  \u003cspan class=\"hljs-comment\"\u003e// 全局路由切换前动作\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.router.beforeHooks,\n  \u003cspan class=\"hljs-comment\"\u003e// beforeRouteUpdate方法\u003c/span\u003e\n  extractUpdateHooks(updated),\n  \u003cspan class=\"hljs-comment\"\u003e// beforeEnter方法\u003c/span\u003e\n  activated.map(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003em\u003c/span\u003e =\u0026gt;\u003c/span\u003e m.beforeEnter),\n  \u003cspan class=\"hljs-comment\"\u003e// 异步组件\u003c/span\u003e\n  resolveAsyncComponents(activated)\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中在Vue-router的\u003ca href=\"https://router.vuejs.org/zh-cn/advanced/navigation-guards.html\" target=\"_blank\"\u003e官方文档\u003c/a\u003e里面介绍了组件内部的方法beforeRouteEnter，beforeRouteUpdate ，beforeRouteLeave，可以对应queue里面的两个方法，而queue里面的beforeEnter，是写在routes里面的方法名beforeEnter；至于文档里面提到的beforeRouteEnter，则对应runQueue方法内部，执行的extractEnterGuards方法，也是最后执行的钩子；\n迭代器iterater的是否进入下一步迭代，是由传入hook里面的to来确定的(这个to为何物？要具体到每个方法的next函数传参)。\n在transistorTo中，传给confirmTransition的除了route，还有onComplete，确认切换的回调函数，代码如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// confirmTransition的onComplete方法\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.updateRoute(route)\nonComplete \u0026amp;\u0026amp; onComplete(route)\n\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.ensureURL()\n\n\u003cspan class=\"hljs-comment\"\u003e// fire ready cbs once\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.ready) {\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.ready = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.readyCbs.forEach(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ecb\u003c/span\u003e =\u0026gt;\u003c/span\u003e { cb(route) })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e好奇的你估计会问怎么onComplete里面还有个onComplete，后面这个回调是transistorTo自己的，也就是我们前文提到的\u003ccode\u003ehistory.setupListeners\u003c/code\u003e，至于updateRounte方法，则如下所示：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eupdateRoute (route: Route) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e prev = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.current\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.current = route\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.cb \u0026amp;\u0026amp; \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.cb(route)\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.router.afterHooks.forEach(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ehook\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    hook \u0026amp;\u0026amp; hook(route, prev)\n  })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e将获得的路由匹配中创建的路由对象route指向this.current，这也涉及到我们前面所说的两者都是由createRoute生成的；this.cb，该方法在init初始里面的末端有涉及如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003ehistory.listen(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eroute\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.apps.forEach(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eapp\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    app._route = route\n  })\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eVue实例化的时候，也初始化history.cb，实现对_route的赋值修改，但是其并没有在初始化的时候执行，Vue实例化中history.cb的赋值是在transitionTo之后的，也就是在updateRoute之后，但是在后面的路由跳转中，因为history.cb已经初始化，则会执行history.cb()。这也就实现了install过程里面对$route的数据劫持，其返回this._routerRoot._route就是route路由对象。\n至于ensureURL，这个就神奇了，Vue-router中是以最新的路由对象为标准来修改hash的，为了确保window.location.hash的正确性，会在确认切换路由回调里面再次确认当前hash是否与当前路由对象的记录一直，不一致的话，以最新的路由对象为标准再次修改window.location.hash。\n在Vue实例化中beforeCreate有一下一句：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eVue.util.defineReactive(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'_route'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._router.history.current)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edefineReactive这是Vue里面观察者劫持数据的方法， 而这里是劫持_route，当_route触发setter方法的时候，则会通知到依赖的组件；\u003c/p\u003e\n\u003ch1\u003e组件\u003c/h1\u003e\n\u003cp\u003e在install的过程里面已经将router-link和router-view两个组件注册好了，稍微看一下源码就不难发现，这两个组件用的都是render方法渲染组件\n对于router-link，默认标签tag为a标签，也是h函数的第一个参数，而数据对象data，有on和attrs，on是router-link里prop过来的事件，默认为click事件；而attrs处理时候，调用了\u003ccode\u003erouter.resolve(this.to, current, this.append)\u003c/code\u003e在index.js里面的resolve方法也是调用了match方法，返回匹配的路由route，虽然和transistorTo方法里match传参格式不同，但是结果都是返回路由对象route。\n在h函数创建Vnode的时候，data.class还会根据传参，当前路由来设置对应的class样式。\nrouter-link里面还会自动创建a标签，并且当click事件触发的时候会调用内部的handler函数，当props的replace为false的时候，会触发transitionTo方法，并切换路由，点击a标签当然要触发跳转，而该transitionTo的回调则是修改window.location.hash的方法，从而修改地址栏的hash。当然由于前文提到的在Vue实例化过程中，我们在transitionTo的回调里面用了setupListeners去监听hashchange事件，所以在hashchange监听函数里面也会调用transitionTo方法，但是因为此时路由对象已经是最新的得了，所以不会进一步切换。\u003c/p\u003e\n\u003cp\u003e对于router，值得注意的部分是registerRouteInstance，也是最开始的install里面提到的，beforeCreate和destroyed都可能触发这个方法。registerRouteInstance其功能和路由对象里面的match：记录路由对象的instances相关联，就是会将对当前的router-view组件添加到对应的路由记录的instance里面，并在router-view组件destoryed的时候将该instance置为undefined；而这个instance的主要作用是在confirmTransition中的queue中使用到的，以及\u003ca href=\"https://github.com/vuejs/vue-router/issues/750\" target=\"_blank\"\u003eissue#750\u003c/a\u003e里面提到的。\u003c/p\u003e\n\u003ch1\u003eHistory\u003c/h1\u003e\n\u003cp\u003e上文提到的都是HashHistory下的，当然其实还有HTML5History模式，HTML5History顾名思义，用的HTML5的特性，老版本的浏览器会有兼容问题，所以默认情况下是hash模式，可以自己手动开启；\nHTML5提供了两个api:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ehistory.pushState()\u003c/li\u003e\n\u003cli\u003ehistory.replaceState()\n分别添加和更新浏览器的历史纪录，pushState方法会在transitorTo的回调里面调用，类似于hash模式下的pushHash，而replaceState则类似与replaceHash方法。在init初始化的时候，还有HTML5History还有直接对事件popstate监听，popstate类似于hashchange事件，同样的也会有transitionTo调用，主要作用也是监听浏览器的前进后退功能，基本上是大同小异的；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e至于AbstractHistory就更简单了，不是用于浏览器的，自然没有window.location的负担，没有浏览器的后退前进按钮，所以历史浏览记录用个数组和index代替就好了。实现简单，这里就不再谈了\u003c/p\u003e\n\u003cp\u003eps: 附上Vue-router 0.4.0 src/transition.js里面对router-view切换时候组件处理的思路，2.7.0版本已经没有这部分注释了\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eA router view transition's pipeline can be described as\nfollows, assuming we are transitioning from an existing\n\u003crouter-view\u003e chain [Component A, Component B] to a new\nchain [Component A, Component C]:\nA    A\n| =\u0026gt; |\nB    C\u003cbr\u003e\n1. Reusablity phase:\n-\u0026gt; canReuse(A, A)\n-\u0026gt; canReuse(B, C)\n-\u0026gt; determine new queues:\n- deactivation: [B]\n- activation: [C]\u003cbr\u003e\n2. Validation phase:\n-\u0026gt; canDeactivate(B)\n-\u0026gt; canActivate(C)\n3. Activation phase:\n-\u0026gt; deactivate(B)\n-\u0026gt; activate(C)\nEach of these steps can be asynchronous, and any\nstep can potentially abort the transition.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e参考资料\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"http://www.zhangxinxu.com/wordpress/2013/06/html5-history-api-pushstate-replacestate-ajax/\" target=\"_blank\"\u003eajax与HTML5 history pushState/replaceState实例\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"March 24, 2021","title":"vue-router源码分析","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e用了Vue快一年多了(虽然中间间断好长时间)，就越发的对其周边的生态感兴趣，尤其是对Vue-router和Vuex，Vue-router是单页面应用的核心部件，基本上的路由跳转都依赖它，项目上用的比较多的Vonic也是基于于Vue-router的；而Vuex只是在状态变化较多，需要store的时候才用上。本文先介绍Vue-router(2.7.0)，有时间再介绍Vuex；\u003c/p\u003e\n\u003ch1\u003e从示例开始\u003c/h1\u003e\n\u003cp\u003e下面是官方给出的示例basic，清晰的介绍了VueRouter最基本使用方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 1. 安装插件，同时注册\u0026lt;router-view\u0026gt;和\u0026lt;router-link\u0026gt;，并且劫持$router和$route\u003c/span\u003e\nVue.use(VueRouter)\n\n\u003cspan class=\"hljs-comment\"\u003e// 2. 定义路由组件\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Home = { \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'\u0026lt;div\u0026gt;home\u0026lt;/div\u0026gt;'\u003c/span\u003e }\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Foo = { \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'\u0026lt;div\u0026gt;foo\u0026lt;/div\u0026gt;'\u003c/span\u003e }\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Bar = { \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'\u0026lt;div\u0026gt;bar\u0026lt;/div\u0026gt;'\u003c/span\u003e }\n\n\u003cspan class=\"hljs-comment\"\u003e// 3. 创建路由\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e router = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e VueRouter({\n  \u003cspan class=\"hljs-attr\"\u003emode\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'history'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ebase\u003c/span\u003e: __dirname,\n  \u003cspan class=\"hljs-attr\"\u003eroutes\u003c/span\u003e: [\n    { \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e: Home },\n    { \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/foo'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e: Foo },\n    { \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/bar'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e: Bar }\n  ]\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码就可以构成最简单的Vue-router示例，当然创建好的router还需要加入Vue的option中。\n可以发现一切的开始在于\u003ccode\u003eVue.use(VueRouter)\u003c/code\u003e，use之后，直接使用Vue-router里面的api就好了。看看Vue里面use的用法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e@Vue.js\n\nVue.use = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eplugin: Function | Object\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e installedPlugins = (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._installedPlugins || (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._installedPlugins = []))\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (installedPlugins.indexOf(plugin) \u0026gt; \u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// additional parameters\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e args = toArray(\u003cspan class=\"hljs-built_in\"\u003earguments\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n  args.unshift(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e)\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e plugin.install === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n    plugin.install.apply(plugin, args)\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e plugin === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n    plugin.apply(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, args)\n  }\n  installedPlugins.push(plugin)\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在Vue.js里面不难发现，use方法主要功能就是执行插件，若有install方法就执行install，并在将该插件push到内部变量_installedPlugins数组里面；而Vue-router的index.js文件里面\u003ccode\u003eVueRouter.install = install\u003c/code\u003e，install变量从install.js文件导入，所以Vue.use(VueRouter)，相当于执行了install.js导出的install方法。\n再看看install方法都做了些什么：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eVue.mixin({\n  beforeCreate () {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isDef(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$options.router)) {\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._routerRoot = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._router = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$options.router\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._router.init(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e)\n      Vue.util.defineReactive(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'_route'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._router.history.current)\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._routerRoot = (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$parent \u0026amp;\u0026amp; \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$parent._routerRoot) || \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e\n    }\n    registerInstance(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e)\n  },\n  destroyed () {\n    registerInstance(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e)\n  }\n})\n\u003cspan class=\"hljs-comment\"\u003e// 劫持$router，getter方法返回的是VueRouter\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.defineProperty(Vue.prototype, \u003cspan class=\"hljs-string\"\u003e'$router'\u003c/span\u003e, {\n  \u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e () { \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._routerRoot._router }\n})\n\u003cspan class=\"hljs-comment\"\u003e// 劫持$router，getter方法返回的是VueRouter的路由对象\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.defineProperty(Vue.prototype, \u003cspan class=\"hljs-string\"\u003e'$route'\u003c/span\u003e, {\n  \u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e () { \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._routerRoot._route }\n})\n\u003cspan class=\"hljs-comment\"\u003e// 注册router-view和router-link全局组件\u003c/span\u003e\nVue.component(\u003cspan class=\"hljs-string\"\u003e'router-view'\u003c/span\u003e, View)\nVue.component(\u003cspan class=\"hljs-string\"\u003e'router-link'\u003c/span\u003e, Link)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eVue.minxin作用是将混合对象的方法和组件合并，install.js里面则是为每个组件都添加beforeCreate钩子和destroyed钩子；在beforeCreate里面只有Vue实例化的时候才会进入true语句里面(router选项是配置在Vue对象里面)，其他的组件创建时候this.$options没有router对象，只有this.$options.parent才有router对象。如此，Vue实例化的时候，会对router进行初始化\u003ccode\u003ethis._router.init(this)\u003c/code\u003e和'_route'的劫持。registerInstance方法是专门针对router-view组件，分析router-view组件的时候会介绍到。\u003c/p\u003e\n\u003ch1\u003einit 初始化VueRouter实例\u003c/h1\u003e\n\u003cp\u003eVueRouter这个class的实例化过程中会根据配置的选项mode，判断是要进行HTML5History，HashHistory还是AbstractHistory，默认下就是HashHistory，其兼容性是最好的；\n而install方法里面重要的就是调用VueRouter实例的init方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003einit (app: any \u003cspan class=\"hljs-comment\"\u003e/* Vue component instance */\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 判断是否已经处理过app\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 切换路由\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (history \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e HTML5History) {\n    history.transitionTo(history.getCurrentLocation())\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (history \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e HashHistory) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e setupHashListener = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n      history.setupListeners()\n    }\n    history.transitionTo(\n      history.getCurrentLocation(),\n      setupHashListener,\n      setupHashListener\n    )\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// history实例的cb\u003c/span\u003e\n  history.listen(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eroute\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.apps.forEach(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eapp\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n      app._route = route\n    })\n  })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在init里面对于HTML5History和HashHistory，进行\u003ccode\u003ehistory.transitionTo\u003c/code\u003e而history是在前文提到的VueRouter里面实例化的，\u003ccode\u003ehistory.getCurrentLocation()\u003c/code\u003e对于hash模式，就是\u003ccode\u003ewindow.location.hash\u003c/code\u003e#符号后面的地址；而\u003ccode\u003ehistory.setupListeners()\u003c/code\u003e则是监听hashchange事件，并执行\u003ccode\u003ehistory.transitionTo\u003c/code\u003e\u003c/p\u003e\n\u003ch2\u003e路由匹配\u003c/h2\u003e\n\u003cp\u003e看看transitionTo如何实现：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003etransitionTo (location: RawLocation, onComplete?: \u003cspan class=\"hljs-built_in\"\u003eFunction\u003c/span\u003e, onAbort?: \u003cspan class=\"hljs-built_in\"\u003eFunction\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e route = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.router.match(location, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.current)\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.confirmTransition(route, () =\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.updateRoute(route)\n    onComplete \u0026amp;\u0026amp; onComplete(route)\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.ensureURL()\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  }, err =\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在transitionTo中，对于hash模式，传参是路径字符串(location)，和监听的回调函数(onComplete/onAbort)；第一步调用VueRouter实例的match方法，返回一个匹配的route对象。在介绍route对象之前，需要先了解\u003ccode\u003ecreate-route-map.js\u003c/code\u003e，里面的路由字典生成函数createRouteMap，其返回:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n  pathList,\n  pathMap,\n  nameMap\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003epathList:是自然是示例中routes的path集合，pathMap则是每个path对应的路由记录对象字典，nameMap则是每个name对应的路由记录对象字典；路由记录对象里面其他选项都较好理解，里面的regex用了'path-to-regexp'模块，可以对路由记录对象里面的path处理为正则表达式，方便和当前路由进行配对；另外路由记录里面还有parent选项，当routes下面某个路由有children的时候parent指的就是上一级的路由记录对象。\n回过头来，继续看match方法，该方法传入的参数是当前路由hash部分和current对象，current对象可以追溯到route.js里面的\u003ccode\u003eObject.freeze(route)\u003c/code\u003e，返回的是冻结了的路由对象，值得注意的是这个路由对象的matched，matched数组是所有传入createRoute的record路由记录对象及其所有父路由记录对象。在所有初始化的过程中，this.current的path就是'/'。\nmatch里面现实如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ematch\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\n    raw: RawLocation,\n    currentRoute?: Route,\n    redirectedFrom?: Location\n  \u003c/span\u003e): \u003cspan class=\"hljs-title\"\u003eRoute\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e location = normalizeLocation(raw, currentRoute, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, router)\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { name } = location\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (name) {\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (location.path) {\n      location.params = {}\n      \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; pathList.length; i++) {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e path = pathList[i]\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e record = pathMap[path]\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (matchRoute(record.regex, location.path, location.params)) {\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _createRoute(record, location, redirectedFrom)\n        }\n      }\n    }\n    \u003cspan class=\"hljs-comment\"\u003e// no match\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _createRoute(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, location)\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003enormalizeLocation方法则是对当前hash和当前路由对象做比较，生成path，query，hash三个键以及\u003ccode\u003e_normalized: true\u003c/code\u003e，_normalized可以用于判断是否已经对当前hash和路由对象对比过了，在match的else if语句里面，可以看到对pathlist进行遍历，存储的路由记录对象的regex和生成的path对比，若能匹配上，则对location对象的params为path里面解析出来的参数；最后match会返回_createRoute函数，该函数在匹配的路由记录对象没重定向和别名时，会返回一个路由对象。而这个路由对象和match传参里面的current同出自createRoute方法，返回的结构自然也是一样的，于是就有猜想this.current会不会赋值为normalizeLocation生成的location呢？结果发现还真是这样。\u003c/p\u003e\n\u003ch2\u003e确认切换以及_route劫持\u003c/h2\u003e\n\u003cp\u003e上面提到transitionTo中执行的路由确认，生成新的路由对象route，接着confirmTransition结构如下所示：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e创建abort中止方法，判断当前current对象是否和路由对象route是相同路由，如果是则返回中止函数\u003c/li\u003e\n\u003cli\u003e创建执行队列queue针对current和route，按需执行\u003c/li\u003e\n\u003cli\u003e创建迭代器iterator，在iterator里面执行hook，而hook是queue队列中的函数\u003c/li\u003e\n\u003cli\u003e执行runQueue，迭代上文3中的iterator，并在最后执行回调\nconfirmTransition中的queue队列如下:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e queue: \u003cspan class=\"hljs-built_in\"\u003eArray\u003c/span\u003e\u0026lt;?NavigationGuard\u0026gt; = [].concat(\n  \u003cspan class=\"hljs-comment\"\u003e// beforeRouteLeave方法\u003c/span\u003e\n  extractLeaveGuards(deactivated),\n  \u003cspan class=\"hljs-comment\"\u003e// 全局路由切换前动作\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.router.beforeHooks,\n  \u003cspan class=\"hljs-comment\"\u003e// beforeRouteUpdate方法\u003c/span\u003e\n  extractUpdateHooks(updated),\n  \u003cspan class=\"hljs-comment\"\u003e// beforeEnter方法\u003c/span\u003e\n  activated.map(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003em\u003c/span\u003e =\u0026gt;\u003c/span\u003e m.beforeEnter),\n  \u003cspan class=\"hljs-comment\"\u003e// 异步组件\u003c/span\u003e\n  resolveAsyncComponents(activated)\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中在Vue-router的\u003ca href=\"https://router.vuejs.org/zh-cn/advanced/navigation-guards.html\" target=\"_blank\"\u003e官方文档\u003c/a\u003e里面介绍了组件内部的方法beforeRouteEnter，beforeRouteUpdate ，beforeRouteLeave，可以对应queue里面的两个方法，而queue里面的beforeEnter，是写在routes里面的方法名beforeEnter；至于文档里面提到的beforeRouteEnter，则对应runQueue方法内部，执行的extractEnterGuards方法，也是最后执行的钩子；\n迭代器iterater的是否进入下一步迭代，是由传入hook里面的to来确定的(这个to为何物？要具体到每个方法的next函数传参)。\n在transistorTo中，传给confirmTransition的除了route，还有onComplete，确认切换的回调函数，代码如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// confirmTransition的onComplete方法\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.updateRoute(route)\nonComplete \u0026amp;\u0026amp; onComplete(route)\n\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.ensureURL()\n\n\u003cspan class=\"hljs-comment\"\u003e// fire ready cbs once\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.ready) {\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.ready = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.readyCbs.forEach(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ecb\u003c/span\u003e =\u0026gt;\u003c/span\u003e { cb(route) })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e好奇的你估计会问怎么onComplete里面还有个onComplete，后面这个回调是transistorTo自己的，也就是我们前文提到的\u003ccode\u003ehistory.setupListeners\u003c/code\u003e，至于updateRounte方法，则如下所示：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eupdateRoute (route: Route) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e prev = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.current\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.current = route\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.cb \u0026amp;\u0026amp; \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.cb(route)\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.router.afterHooks.forEach(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ehook\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    hook \u0026amp;\u0026amp; hook(route, prev)\n  })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e将获得的路由匹配中创建的路由对象route指向this.current，这也涉及到我们前面所说的两者都是由createRoute生成的；this.cb，该方法在init初始里面的末端有涉及如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003ehistory.listen(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eroute\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.apps.forEach(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eapp\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    app._route = route\n  })\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eVue实例化的时候，也初始化history.cb，实现对_route的赋值修改，但是其并没有在初始化的时候执行，Vue实例化中history.cb的赋值是在transitionTo之后的，也就是在updateRoute之后，但是在后面的路由跳转中，因为history.cb已经初始化，则会执行history.cb()。这也就实现了install过程里面对$route的数据劫持，其返回this._routerRoot._route就是route路由对象。\n至于ensureURL，这个就神奇了，Vue-router中是以最新的路由对象为标准来修改hash的，为了确保window.location.hash的正确性，会在确认切换路由回调里面再次确认当前hash是否与当前路由对象的记录一直，不一致的话，以最新的路由对象为标准再次修改window.location.hash。\n在Vue实例化中beforeCreate有一下一句：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eVue.util.defineReactive(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'_route'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._router.history.current)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edefineReactive这是Vue里面观察者劫持数据的方法， 而这里是劫持_route，当_route触发setter方法的时候，则会通知到依赖的组件；\u003c/p\u003e\n\u003ch1\u003e组件\u003c/h1\u003e\n\u003cp\u003e在install的过程里面已经将router-link和router-view两个组件注册好了，稍微看一下源码就不难发现，这两个组件用的都是render方法渲染组件\n对于router-link，默认标签tag为a标签，也是h函数的第一个参数，而数据对象data，有on和attrs，on是router-link里prop过来的事件，默认为click事件；而attrs处理时候，调用了\u003ccode\u003erouter.resolve(this.to, current, this.append)\u003c/code\u003e在index.js里面的resolve方法也是调用了match方法，返回匹配的路由route，虽然和transistorTo方法里match传参格式不同，但是结果都是返回路由对象route。\n在h函数创建Vnode的时候，data.class还会根据传参，当前路由来设置对应的class样式。\nrouter-link里面还会自动创建a标签，并且当click事件触发的时候会调用内部的handler函数，当props的replace为false的时候，会触发transitionTo方法，并切换路由，点击a标签当然要触发跳转，而该transitionTo的回调则是修改window.location.hash的方法，从而修改地址栏的hash。当然由于前文提到的在Vue实例化过程中，我们在transitionTo的回调里面用了setupListeners去监听hashchange事件，所以在hashchange监听函数里面也会调用transitionTo方法，但是因为此时路由对象已经是最新的得了，所以不会进一步切换。\u003c/p\u003e\n\u003cp\u003e对于router，值得注意的部分是registerRouteInstance，也是最开始的install里面提到的，beforeCreate和destroyed都可能触发这个方法。registerRouteInstance其功能和路由对象里面的match：记录路由对象的instances相关联，就是会将对当前的router-view组件添加到对应的路由记录的instance里面，并在router-view组件destoryed的时候将该instance置为undefined；而这个instance的主要作用是在confirmTransition中的queue中使用到的，以及\u003ca href=\"https://github.com/vuejs/vue-router/issues/750\" target=\"_blank\"\u003eissue#750\u003c/a\u003e里面提到的。\u003c/p\u003e\n\u003ch1\u003eHistory\u003c/h1\u003e\n\u003cp\u003e上文提到的都是HashHistory下的，当然其实还有HTML5History模式，HTML5History顾名思义，用的HTML5的特性，老版本的浏览器会有兼容问题，所以默认情况下是hash模式，可以自己手动开启；\nHTML5提供了两个api:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ehistory.pushState()\u003c/li\u003e\n\u003cli\u003ehistory.replaceState()\n分别添加和更新浏览器的历史纪录，pushState方法会在transitorTo的回调里面调用，类似于hash模式下的pushHash，而replaceState则类似与replaceHash方法。在init初始化的时候，还有HTML5History还有直接对事件popstate监听，popstate类似于hashchange事件，同样的也会有transitionTo调用，主要作用也是监听浏览器的前进后退功能，基本上是大同小异的；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e至于AbstractHistory就更简单了，不是用于浏览器的，自然没有window.location的负担，没有浏览器的后退前进按钮，所以历史浏览记录用个数组和index代替就好了。实现简单，这里就不再谈了\u003c/p\u003e\n\u003cp\u003eps: 附上Vue-router 0.4.0 src/transition.js里面对router-view切换时候组件处理的思路，2.7.0版本已经没有这部分注释了\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eA router view transition's pipeline can be described as\nfollows, assuming we are transitioning from an existing\n\u003crouter-view\u003e chain [Component A, Component B] to a new\nchain [Component A, Component C]:\nA    A\n| =\u0026gt; |\nB    C\u003cbr\u003e\n1. Reusablity phase:\n-\u0026gt; canReuse(A, A)\n-\u0026gt; canReuse(B, C)\n-\u0026gt; determine new queues:\n- deactivation: [B]\n- activation: [C]\u003cbr\u003e\n2. Validation phase:\n-\u0026gt; canDeactivate(B)\n-\u0026gt; canActivate(C)\n3. Activation phase:\n-\u0026gt; deactivate(B)\n-\u0026gt; activate(C)\nEach of these steps can be asynchronous, and any\nstep can potentially abort the transition.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e参考资料\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"http://www.zhangxinxu.com/wordpress/2013/06/html5-history-api-pushstate-replacestate-ajax/\" target=\"_blank\"\u003eajax与HTML5 history pushState/replaceState实例\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n"}},"buildId":"r4Ww0YLm8YL5~6SwciWHH","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" async=""></script></body></html>