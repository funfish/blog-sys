<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">Vue 0.6.0 早期源码研究</title><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.587c5e31.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___2dTZ9 "><a class="logo___346dE" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___13XXt" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___29Pln"><h1 class="postTitle___1_m4g">Vue 0.6.0 早期源码研究</h1><span class="postTime___1x0_i">March 24, 2021</span></header><article class="postWrapper___3jnNg post-article"><div><h1>前言</h1>
<p>相信大家都或多或少接触过Vue，先前就有人介绍学习Vue的源码，提到旧版本的源码行数只不过一千多行，可以一个一个commit学习下去。前段时间为了找下家，一直在用Vue做作品，效率也较以前原生JavaScript要快上许多，后来工作上手了，不禁想看看Vue源码长什么样子的，只是从第一个commit开始读起来较为费时，而Github上面Vue项目能够找到的最早branch是<a href="https://github.com/vuejs/vue/tree/0.10" target="_blank">Vue 0.10</a>，然而在发布版本里面，可以发现最好早一版本是<a href="https://github.com/vuejs/vue/tags?after=v0.7.2" target="_blank">0.6.0版本</a>。本文介绍也是从该本版开始，该版本较0.10的要上少40%左右。</p>
<h1>目标</h1>
<p>本文目的在于最短时间内，介绍Vue0.6.0的核心模块源码，数据双向绑定，computed计算属性等。
看完本文之后，能明白Vue框架到底做了些什么，并自行构建一个早期Vue框架的简化版本。</p>
<h1>准备</h1>
<p>在介绍Vue 源码之前，需要了解Object.defineProperty,通过这个方式，在获取对象字段值时，调用getter方法，而设置对象字段值时候，调用setter方法，来实现数据劫。Object.defineProperty是Vue的基础内容，至今不熟悉的请一定要看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank">Object.defineProperty MDN</a></p>
<h1>思路</h1>
<p>对于</p>
<pre class="hljs"><code>data: {
    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">c</span>: <span class="hljs-number">2</span>
}
</code></pre>
<p>如果你要设置data.a的值，并更新渲染DOM，会怎么做呢？
了解Object.defineProperty神奇的setter和getter数据劫持功能后，自然而然是有以下步骤：</p>
<ol>
<li>data.a的访问器属性setter里，通知所有和data.a有关的instances；</li>
<li>instances在源码中指的是Directive构造函数生成的实例集合，其中每个实例的this.el是一个指向data.a有关联的node节点，如<div>{{a}}</div>里面的textNode节点。如果有多个这样的节点，data.a就对应多个directive实例。在进行data.a重新赋值的时候，setter被调用，执行data.a下每个directive实例的update函数，实现局部DOM更新;</li>
<li>directive实例和data.a数据的对应关系可以用Binding构造函数说明，每个Binding都含有instances数组，该数组存放的就是directive实例集合，而data.a只有一个Binding</li>
</ol>
<h1>实现</h1>
<p>看了源码不难发现，创建的实例new Vue({}),指的是ViewModel构造函数，而ViewModel函数如下：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ViewModel</span> (<span class="hljs-params">options</span>) </span>{
    <span class="hljs-comment">// just compile. options are passed directly to compiler</span>
    <span class="hljs-keyword">new</span> Compiler(<span class="hljs-keyword">this</span>, options)
}
</code></pre>
<p>所以comilper.js才是生成Vue的核心所在，下面是简化了compiler构造函数</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Compiler</span>(<span class="hljs-params">vm, options</span>) </span>{
    <span class="hljs-keyword">let</span> compiler = <span class="hljs-keyword">this</span>;

    options = compiler.options = options || makeHash()

    <span class="hljs-keyword">var</span> el = compiler.setupElement(options)

    <span class="hljs-keyword">var</span> scope = options.scope;
    <span class="hljs-keyword">if</span> (scope) utils.extend(vm, scope, <span class="hljs-literal">true</span>)

    compiler.vm = vm

    <span class="hljs-keyword">var</span> observables = compiler.observables = [],
        computed    = compiler.computed    = [];

    compiler.bindings = makeHash()

    compiler.setupObserver()

    <span class="hljs-keyword">let</span> keyPrefix;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> vm) {
        keyPrefix = key.charAt(<span class="hljs-number">0</span>)
        <span class="hljs-keyword">if</span> (keyPrefix !== <span class="hljs-string">'$'</span> &amp;&amp; keyPrefix !== <span class="hljs-string">'_'</span>) {
            compiler.createBinding(key)
        }
    }

    compiler.compile(el, <span class="hljs-literal">true</span>)

    <span class="hljs-keyword">while</span> (i--) {
        binding = observables[i]
        Observer.observe(binding.value, binding.key, compiler.observer)
    }

    <span class="hljs-keyword">if</span> (computed.length) DepsParser.parse(computed)
}
</code></pre>
<p>上面过程分为三个阶段：</p>
<h2>准备设置</h2>
<ol>
<li>compiler.setupElement(options)通过querySelector返回Vue的el节点</li>
<li>我们熟悉的data，computed和metheds，在该版本中都是options.scope里面，也就是说米有data，computed和methods之分，统一在scope里面，utils.extend(vm, scope, true)则是将scope的所有字段扩展到vm下面，方便后面处理；</li>
<li>compiler.bindings = makeHash()则是给compiler的bindings设置为{}；</li>
</ol>
<h2>observer实现</h2>
<p>这里实现每个key的数据劫持和事件监听
4. compiler.setupObserver() 创建compiler.observer监听'get', 'set', 'mutate'动作
5. compiler.createBinding(key)，将所有的scope里面的字段key都创建Binding实例，而compiler.bindings[key]则指向创建的binding，同时若字段不含有'.'则会进行define方法，该方法先是将刚刚创建的Binding{key].value设置为vm[key]，实现每个key的Binding实例都保存下value值。如果该value是对象或则数组，如scope.a为对象，则push到compiler.observables里面；最后现实数据劫持Object.defineProperty
在define里面的Object.defineProperty，setter方法: 若新值不等于旧值，则重新对bindings[key].value设置为新值，同时进行Observer.unobserve旧值和Observer.observe新值，只有value是对象或则数组的时候，才会进入Oberver.oberver/unobserve方法，那对于普普通通的data.a等于字符串这种呢？前文说好的设置data.a的时候通知所有和data.a有关的instances，又发生在那里呢？
答案在在setter里面还通过compiler.observer触发了set事件,set事件里面就有bindings[key].update，而正如上文所说的bindings[key].instances就是directive实例，而directive实例又是什么时候添加进去的呢，且看下面</p>
<h2>compiler.compile的实现</h2>
<ol start="6">
<li>compiler.compile(el, true)解析DOM节点，通过遍历所有的节点，对不同的属性名字如v-text采用不同指令，如果是有效的字段就返回Directive实例，这个实例会通过CompilerProto.bindDirective方法处理Directive和Binding的关系。如<div>{{a}}</div>, 会先生成一个Directive实例，该实例包含textNode节点，v-text的更新指令，在bindDirective方法中，则会判断vm是否有bindings['a'],如果有的话，直接使用compiler.bindings['a']，并将directive实例push到bindings['a'].instances，接着执行directive.update(value),而这个value就是前文提到的binding['a'].value,至此完成DOM节点和scope的关系</li>
</ol>
<p>那对于scope.a为对象，如scope.a = {b: 1},这里的scope.a.b是无法在步骤5中实现的，只有scope.a会出现在步骤5，那scope.a.b要如何创建binding呢？
在步骤5中，进入define方法后，若检测到scope.a是对象，则将binding['a'] push到compiler.observables里面，到了步骤6，遍历到{{a.b}}的时候，会创建bindings['a.b'],但是不会进入define方法里面，无法对bindings['a.b']赋值，和Object.defineProperty数据劫持，没有赋值没有数据劫持，那又要如何实现{{a.b}}以及后面的重新设置a.b的值呢？</p>
<ol start="7">
<li>对observables遍历，通过Observer.observe方法对scope.a下的所有字段遍历，并在observer.js里面的bind方法，对所有的字段建立Object.defineProperty数据劫持，同时触发'set'事件，最后会传递到步骤4里面的事件监听'set'事件，执行bingdings['a.b'].update,现实DOM里面的数据首次展现</li>
</ol>
<p>通过对于普通的socpe.a = 12,而言打印创建的Vue实例有如下图
<img src="https://github.com/funfish/blog/blob/master/images/Vue.PNG" alt=""></p>
<p>compiler下创建了a:Binding构造函数，而这个实例的instances包含了一个Directive，里面存放的value 12，</p>
<h2>computed原理</h2>
<p>类似于observables，在compiler里面也会创建compiler.computed数组，在define方法里除了在compiler.observables.push(binding)外，若是对象，并且有$get方法，则是computed，这个版本里面，computed是有$get方法的，well...当然还有$set;</p>
<pre class="hljs"><code>scope: {
    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">c</span>: {
        <span class="hljs-attr">$get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a
        }
    }
}
</code></pre>
<ol start="8">
<li>DepsParser.parse(computed)，若computed存在元素，则调用DepsParser.parse，这个时候DOM里面的计算属性还没有赋值！只是创建了对应的binding，和observables的遭遇是一样的。。。。在 DepsParser.parse里面，当执行computed的$get函数的时候，如遇到依赖scope.a,则会调用步骤5里面为scope.a创建的数据劫持getter，这个方法里面触发'get'事件，在步骤4里面监听到'get'事件后，触发DepsParser.observer的'get'事件，而这个'get'事件作用则是将bindings['a']，bindings['c'].deps里面，同时bindings['a'].subs里面放入bindings['c'],为何要这样做呢？在初始化的时候是不必的毕竟$get已经可以获得正确的数值了，但是当重新设置scope.a的时候，就需要通知scope.c同步更新了，这个在bindings['a'].update里面实现</li>
</ol>
<p>自此Compiler构造函数也就大体如此，具体细节还是要多看源码</p>
<h2>监听数组</h2>
<p>在compiler.observables里面，在Observer.observe里面，可以看到当处理对象的typeOf值是对象或则数组都会进行特别处理，若是对象上文已经提过处理方法，若是数组的话又会如何呢？
这里简要概述一下：通过ExpParser.parse方法，将bindings['a[0]'].value设{$get: newFunction('this.a; return this.a[0]')}的形式，后面就和computed类似了，这里有一点需要注意，在observer.js里面，重写了['push','pop','shift','unshift','splice','sort','reverse']等数组方法，当a.push(1)的时候，会触发mutate动作，执行bindings['a'].pub()，从而通知bindings['a[0]']的instances更新，具体内容可以自己去看源码</p>
<p>参考资料</p>
<ol>
<li><a href="https://segmentfault.com/a/1190000006599500" target="_blank">剖析Vue原理&amp;实现双向绑定MVVM</a></li>
</ol>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"March 24, 2021","title":"Vue 0.6.0 早期源码研究","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e相信大家都或多或少接触过Vue，先前就有人介绍学习Vue的源码，提到旧版本的源码行数只不过一千多行，可以一个一个commit学习下去。前段时间为了找下家，一直在用Vue做作品，效率也较以前原生JavaScript要快上许多，后来工作上手了，不禁想看看Vue源码长什么样子的，只是从第一个commit开始读起来较为费时，而Github上面Vue项目能够找到的最早branch是\u003ca href=\"https://github.com/vuejs/vue/tree/0.10\" target=\"_blank\"\u003eVue 0.10\u003c/a\u003e，然而在发布版本里面，可以发现最好早一版本是\u003ca href=\"https://github.com/vuejs/vue/tags?after=v0.7.2\" target=\"_blank\"\u003e0.6.0版本\u003c/a\u003e。本文介绍也是从该本版开始，该版本较0.10的要上少40%左右。\u003c/p\u003e\n\u003ch1\u003e目标\u003c/h1\u003e\n\u003cp\u003e本文目的在于最短时间内，介绍Vue0.6.0的核心模块源码，数据双向绑定，computed计算属性等。\n看完本文之后，能明白Vue框架到底做了些什么，并自行构建一个早期Vue框架的简化版本。\u003c/p\u003e\n\u003ch1\u003e准备\u003c/h1\u003e\n\u003cp\u003e在介绍Vue 源码之前，需要了解Object.defineProperty,通过这个方式，在获取对象字段值时，调用getter方法，而设置对象字段值时候，调用setter方法，来实现数据劫。Object.defineProperty是Vue的基础内容，至今不熟悉的请一定要看\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\" target=\"_blank\"\u003eObject.defineProperty MDN\u003c/a\u003e\u003c/p\u003e\n\u003ch1\u003e思路\u003c/h1\u003e\n\u003cp\u003e对于\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003edata: {\n    \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ec\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果你要设置data.a的值，并更新渲染DOM，会怎么做呢？\n了解Object.defineProperty神奇的setter和getter数据劫持功能后，自然而然是有以下步骤：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003edata.a的访问器属性setter里，通知所有和data.a有关的instances；\u003c/li\u003e\n\u003cli\u003einstances在源码中指的是Directive构造函数生成的实例集合，其中每个实例的this.el是一个指向data.a有关联的node节点，如\u003cdiv\u003e{{a}}\u003c/div\u003e里面的textNode节点。如果有多个这样的节点，data.a就对应多个directive实例。在进行data.a重新赋值的时候，setter被调用，执行data.a下每个directive实例的update函数，实现局部DOM更新;\u003c/li\u003e\n\u003cli\u003edirective实例和data.a数据的对应关系可以用Binding构造函数说明，每个Binding都含有instances数组，该数组存放的就是directive实例集合，而data.a只有一个Binding\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1\u003e实现\u003c/h1\u003e\n\u003cp\u003e看了源码不难发现，创建的实例new Vue({}),指的是ViewModel构造函数，而ViewModel函数如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eViewModel\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eoptions\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e// just compile. options are passed directly to compiler\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Compiler(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, options)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e所以comilper.js才是生成Vue的核心所在，下面是简化了compiler构造函数\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eCompiler\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003evm, options\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e compiler = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n\n    options = compiler.options = options || makeHash()\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e el = compiler.setupElement(options)\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e scope = options.scope;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (scope) utils.extend(vm, scope, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e)\n\n    compiler.vm = vm\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e observables = compiler.observables = [],\n        computed    = compiler.computed    = [];\n\n    compiler.bindings = makeHash()\n\n    compiler.setupObserver()\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e keyPrefix;\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e key \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e vm) {\n        keyPrefix = key.charAt(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (keyPrefix !== \u003cspan class=\"hljs-string\"\u003e'$'\u003c/span\u003e \u0026amp;\u0026amp; keyPrefix !== \u003cspan class=\"hljs-string\"\u003e'_'\u003c/span\u003e) {\n            compiler.createBinding(key)\n        }\n    }\n\n    compiler.compile(el, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (i--) {\n        binding = observables[i]\n        Observer.observe(binding.value, binding.key, compiler.observer)\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (computed.length) DepsParser.parse(computed)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面过程分为三个阶段：\u003c/p\u003e\n\u003ch2\u003e准备设置\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003ecompiler.setupElement(options)通过querySelector返回Vue的el节点\u003c/li\u003e\n\u003cli\u003e我们熟悉的data，computed和metheds，在该版本中都是options.scope里面，也就是说米有data，computed和methods之分，统一在scope里面，utils.extend(vm, scope, true)则是将scope的所有字段扩展到vm下面，方便后面处理；\u003c/li\u003e\n\u003cli\u003ecompiler.bindings = makeHash()则是给compiler的bindings设置为{}；\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eobserver实现\u003c/h2\u003e\n\u003cp\u003e这里实现每个key的数据劫持和事件监听\n4. compiler.setupObserver() 创建compiler.observer监听'get', 'set', 'mutate'动作\n5. compiler.createBinding(key)，将所有的scope里面的字段key都创建Binding实例，而compiler.bindings[key]则指向创建的binding，同时若字段不含有'.'则会进行define方法，该方法先是将刚刚创建的Binding{key].value设置为vm[key]，实现每个key的Binding实例都保存下value值。如果该value是对象或则数组，如scope.a为对象，则push到compiler.observables里面；最后现实数据劫持Object.defineProperty\n在define里面的Object.defineProperty，setter方法: 若新值不等于旧值，则重新对bindings[key].value设置为新值，同时进行Observer.unobserve旧值和Observer.observe新值，只有value是对象或则数组的时候，才会进入Oberver.oberver/unobserve方法，那对于普普通通的data.a等于字符串这种呢？前文说好的设置data.a的时候通知所有和data.a有关的instances，又发生在那里呢？\n答案在在setter里面还通过compiler.observer触发了set事件,set事件里面就有bindings[key].update，而正如上文所说的bindings[key].instances就是directive实例，而directive实例又是什么时候添加进去的呢，且看下面\u003c/p\u003e\n\u003ch2\u003ecompiler.compile的实现\u003c/h2\u003e\n\u003col start=\"6\"\u003e\n\u003cli\u003ecompiler.compile(el, true)解析DOM节点，通过遍历所有的节点，对不同的属性名字如v-text采用不同指令，如果是有效的字段就返回Directive实例，这个实例会通过CompilerProto.bindDirective方法处理Directive和Binding的关系。如\u003cdiv\u003e{{a}}\u003c/div\u003e, 会先生成一个Directive实例，该实例包含textNode节点，v-text的更新指令，在bindDirective方法中，则会判断vm是否有bindings['a'],如果有的话，直接使用compiler.bindings['a']，并将directive实例push到bindings['a'].instances，接着执行directive.update(value),而这个value就是前文提到的binding['a'].value,至此完成DOM节点和scope的关系\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e那对于scope.a为对象，如scope.a = {b: 1},这里的scope.a.b是无法在步骤5中实现的，只有scope.a会出现在步骤5，那scope.a.b要如何创建binding呢？\n在步骤5中，进入define方法后，若检测到scope.a是对象，则将binding['a'] push到compiler.observables里面，到了步骤6，遍历到{{a.b}}的时候，会创建bindings['a.b'],但是不会进入define方法里面，无法对bindings['a.b']赋值，和Object.defineProperty数据劫持，没有赋值没有数据劫持，那又要如何实现{{a.b}}以及后面的重新设置a.b的值呢？\u003c/p\u003e\n\u003col start=\"7\"\u003e\n\u003cli\u003e对observables遍历，通过Observer.observe方法对scope.a下的所有字段遍历，并在observer.js里面的bind方法，对所有的字段建立Object.defineProperty数据劫持，同时触发'set'事件，最后会传递到步骤4里面的事件监听'set'事件，执行bingdings['a.b'].update,现实DOM里面的数据首次展现\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e通过对于普通的socpe.a = 12,而言打印创建的Vue实例有如下图\n\u003cimg src=\"https://github.com/funfish/blog/blob/master/images/Vue.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003ecompiler下创建了a:Binding构造函数，而这个实例的instances包含了一个Directive，里面存放的value 12，\u003c/p\u003e\n\u003ch2\u003ecomputed原理\u003c/h2\u003e\n\u003cp\u003e类似于observables，在compiler里面也会创建compiler.computed数组，在define方法里除了在compiler.observables.push(binding)外，若是对象，并且有$get方法，则是computed，这个版本里面，computed是有$get方法的，well...当然还有$set;\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003escope: {\n    \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ec\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003e$get\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e)\u003c/span\u003e{\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.a\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"8\"\u003e\n\u003cli\u003eDepsParser.parse(computed)，若computed存在元素，则调用DepsParser.parse，这个时候DOM里面的计算属性还没有赋值！只是创建了对应的binding，和observables的遭遇是一样的。。。。在 DepsParser.parse里面，当执行computed的$get函数的时候，如遇到依赖scope.a,则会调用步骤5里面为scope.a创建的数据劫持getter，这个方法里面触发'get'事件，在步骤4里面监听到'get'事件后，触发DepsParser.observer的'get'事件，而这个'get'事件作用则是将bindings['a']，bindings['c'].deps里面，同时bindings['a'].subs里面放入bindings['c'],为何要这样做呢？在初始化的时候是不必的毕竟$get已经可以获得正确的数值了，但是当重新设置scope.a的时候，就需要通知scope.c同步更新了，这个在bindings['a'].update里面实现\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e自此Compiler构造函数也就大体如此，具体细节还是要多看源码\u003c/p\u003e\n\u003ch2\u003e监听数组\u003c/h2\u003e\n\u003cp\u003e在compiler.observables里面，在Observer.observe里面，可以看到当处理对象的typeOf值是对象或则数组都会进行特别处理，若是对象上文已经提过处理方法，若是数组的话又会如何呢？\n这里简要概述一下：通过ExpParser.parse方法，将bindings['a[0]'].value设{$get: newFunction('this.a; return this.a[0]')}的形式，后面就和computed类似了，这里有一点需要注意，在observer.js里面，重写了['push','pop','shift','unshift','splice','sort','reverse']等数组方法，当a.push(1)的时候，会触发mutate动作，执行bindings['a'].pub()，从而通知bindings['a[0]']的instances更新，具体内容可以自己去看源码\u003c/p\u003e\n\u003cp\u003e参考资料\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://segmentfault.com/a/1190000006599500\" target=\"_blank\"\u003e剖析Vue原理\u0026amp;实现双向绑定MVVM\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"March 24, 2021","title":"Vue 0.6.0 早期源码研究","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e相信大家都或多或少接触过Vue，先前就有人介绍学习Vue的源码，提到旧版本的源码行数只不过一千多行，可以一个一个commit学习下去。前段时间为了找下家，一直在用Vue做作品，效率也较以前原生JavaScript要快上许多，后来工作上手了，不禁想看看Vue源码长什么样子的，只是从第一个commit开始读起来较为费时，而Github上面Vue项目能够找到的最早branch是\u003ca href=\"https://github.com/vuejs/vue/tree/0.10\" target=\"_blank\"\u003eVue 0.10\u003c/a\u003e，然而在发布版本里面，可以发现最好早一版本是\u003ca href=\"https://github.com/vuejs/vue/tags?after=v0.7.2\" target=\"_blank\"\u003e0.6.0版本\u003c/a\u003e。本文介绍也是从该本版开始，该版本较0.10的要上少40%左右。\u003c/p\u003e\n\u003ch1\u003e目标\u003c/h1\u003e\n\u003cp\u003e本文目的在于最短时间内，介绍Vue0.6.0的核心模块源码，数据双向绑定，computed计算属性等。\n看完本文之后，能明白Vue框架到底做了些什么，并自行构建一个早期Vue框架的简化版本。\u003c/p\u003e\n\u003ch1\u003e准备\u003c/h1\u003e\n\u003cp\u003e在介绍Vue 源码之前，需要了解Object.defineProperty,通过这个方式，在获取对象字段值时，调用getter方法，而设置对象字段值时候，调用setter方法，来实现数据劫。Object.defineProperty是Vue的基础内容，至今不熟悉的请一定要看\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\" target=\"_blank\"\u003eObject.defineProperty MDN\u003c/a\u003e\u003c/p\u003e\n\u003ch1\u003e思路\u003c/h1\u003e\n\u003cp\u003e对于\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003edata: {\n    \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ec\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果你要设置data.a的值，并更新渲染DOM，会怎么做呢？\n了解Object.defineProperty神奇的setter和getter数据劫持功能后，自然而然是有以下步骤：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003edata.a的访问器属性setter里，通知所有和data.a有关的instances；\u003c/li\u003e\n\u003cli\u003einstances在源码中指的是Directive构造函数生成的实例集合，其中每个实例的this.el是一个指向data.a有关联的node节点，如\u003cdiv\u003e{{a}}\u003c/div\u003e里面的textNode节点。如果有多个这样的节点，data.a就对应多个directive实例。在进行data.a重新赋值的时候，setter被调用，执行data.a下每个directive实例的update函数，实现局部DOM更新;\u003c/li\u003e\n\u003cli\u003edirective实例和data.a数据的对应关系可以用Binding构造函数说明，每个Binding都含有instances数组，该数组存放的就是directive实例集合，而data.a只有一个Binding\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1\u003e实现\u003c/h1\u003e\n\u003cp\u003e看了源码不难发现，创建的实例new Vue({}),指的是ViewModel构造函数，而ViewModel函数如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eViewModel\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eoptions\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e// just compile. options are passed directly to compiler\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Compiler(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, options)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e所以comilper.js才是生成Vue的核心所在，下面是简化了compiler构造函数\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eCompiler\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003evm, options\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e compiler = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n\n    options = compiler.options = options || makeHash()\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e el = compiler.setupElement(options)\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e scope = options.scope;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (scope) utils.extend(vm, scope, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e)\n\n    compiler.vm = vm\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e observables = compiler.observables = [],\n        computed    = compiler.computed    = [];\n\n    compiler.bindings = makeHash()\n\n    compiler.setupObserver()\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e keyPrefix;\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e key \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e vm) {\n        keyPrefix = key.charAt(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (keyPrefix !== \u003cspan class=\"hljs-string\"\u003e'$'\u003c/span\u003e \u0026amp;\u0026amp; keyPrefix !== \u003cspan class=\"hljs-string\"\u003e'_'\u003c/span\u003e) {\n            compiler.createBinding(key)\n        }\n    }\n\n    compiler.compile(el, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (i--) {\n        binding = observables[i]\n        Observer.observe(binding.value, binding.key, compiler.observer)\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (computed.length) DepsParser.parse(computed)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面过程分为三个阶段：\u003c/p\u003e\n\u003ch2\u003e准备设置\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003ecompiler.setupElement(options)通过querySelector返回Vue的el节点\u003c/li\u003e\n\u003cli\u003e我们熟悉的data，computed和metheds，在该版本中都是options.scope里面，也就是说米有data，computed和methods之分，统一在scope里面，utils.extend(vm, scope, true)则是将scope的所有字段扩展到vm下面，方便后面处理；\u003c/li\u003e\n\u003cli\u003ecompiler.bindings = makeHash()则是给compiler的bindings设置为{}；\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eobserver实现\u003c/h2\u003e\n\u003cp\u003e这里实现每个key的数据劫持和事件监听\n4. compiler.setupObserver() 创建compiler.observer监听'get', 'set', 'mutate'动作\n5. compiler.createBinding(key)，将所有的scope里面的字段key都创建Binding实例，而compiler.bindings[key]则指向创建的binding，同时若字段不含有'.'则会进行define方法，该方法先是将刚刚创建的Binding{key].value设置为vm[key]，实现每个key的Binding实例都保存下value值。如果该value是对象或则数组，如scope.a为对象，则push到compiler.observables里面；最后现实数据劫持Object.defineProperty\n在define里面的Object.defineProperty，setter方法: 若新值不等于旧值，则重新对bindings[key].value设置为新值，同时进行Observer.unobserve旧值和Observer.observe新值，只有value是对象或则数组的时候，才会进入Oberver.oberver/unobserve方法，那对于普普通通的data.a等于字符串这种呢？前文说好的设置data.a的时候通知所有和data.a有关的instances，又发生在那里呢？\n答案在在setter里面还通过compiler.observer触发了set事件,set事件里面就有bindings[key].update，而正如上文所说的bindings[key].instances就是directive实例，而directive实例又是什么时候添加进去的呢，且看下面\u003c/p\u003e\n\u003ch2\u003ecompiler.compile的实现\u003c/h2\u003e\n\u003col start=\"6\"\u003e\n\u003cli\u003ecompiler.compile(el, true)解析DOM节点，通过遍历所有的节点，对不同的属性名字如v-text采用不同指令，如果是有效的字段就返回Directive实例，这个实例会通过CompilerProto.bindDirective方法处理Directive和Binding的关系。如\u003cdiv\u003e{{a}}\u003c/div\u003e, 会先生成一个Directive实例，该实例包含textNode节点，v-text的更新指令，在bindDirective方法中，则会判断vm是否有bindings['a'],如果有的话，直接使用compiler.bindings['a']，并将directive实例push到bindings['a'].instances，接着执行directive.update(value),而这个value就是前文提到的binding['a'].value,至此完成DOM节点和scope的关系\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e那对于scope.a为对象，如scope.a = {b: 1},这里的scope.a.b是无法在步骤5中实现的，只有scope.a会出现在步骤5，那scope.a.b要如何创建binding呢？\n在步骤5中，进入define方法后，若检测到scope.a是对象，则将binding['a'] push到compiler.observables里面，到了步骤6，遍历到{{a.b}}的时候，会创建bindings['a.b'],但是不会进入define方法里面，无法对bindings['a.b']赋值，和Object.defineProperty数据劫持，没有赋值没有数据劫持，那又要如何实现{{a.b}}以及后面的重新设置a.b的值呢？\u003c/p\u003e\n\u003col start=\"7\"\u003e\n\u003cli\u003e对observables遍历，通过Observer.observe方法对scope.a下的所有字段遍历，并在observer.js里面的bind方法，对所有的字段建立Object.defineProperty数据劫持，同时触发'set'事件，最后会传递到步骤4里面的事件监听'set'事件，执行bingdings['a.b'].update,现实DOM里面的数据首次展现\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e通过对于普通的socpe.a = 12,而言打印创建的Vue实例有如下图\n\u003cimg src=\"https://github.com/funfish/blog/blob/master/images/Vue.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003ecompiler下创建了a:Binding构造函数，而这个实例的instances包含了一个Directive，里面存放的value 12，\u003c/p\u003e\n\u003ch2\u003ecomputed原理\u003c/h2\u003e\n\u003cp\u003e类似于observables，在compiler里面也会创建compiler.computed数组，在define方法里除了在compiler.observables.push(binding)外，若是对象，并且有$get方法，则是computed，这个版本里面，computed是有$get方法的，well...当然还有$set;\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003escope: {\n    \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ec\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003e$get\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e)\u003c/span\u003e{\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.a\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"8\"\u003e\n\u003cli\u003eDepsParser.parse(computed)，若computed存在元素，则调用DepsParser.parse，这个时候DOM里面的计算属性还没有赋值！只是创建了对应的binding，和observables的遭遇是一样的。。。。在 DepsParser.parse里面，当执行computed的$get函数的时候，如遇到依赖scope.a,则会调用步骤5里面为scope.a创建的数据劫持getter，这个方法里面触发'get'事件，在步骤4里面监听到'get'事件后，触发DepsParser.observer的'get'事件，而这个'get'事件作用则是将bindings['a']，bindings['c'].deps里面，同时bindings['a'].subs里面放入bindings['c'],为何要这样做呢？在初始化的时候是不必的毕竟$get已经可以获得正确的数值了，但是当重新设置scope.a的时候，就需要通知scope.c同步更新了，这个在bindings['a'].update里面实现\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e自此Compiler构造函数也就大体如此，具体细节还是要多看源码\u003c/p\u003e\n\u003ch2\u003e监听数组\u003c/h2\u003e\n\u003cp\u003e在compiler.observables里面，在Observer.observe里面，可以看到当处理对象的typeOf值是对象或则数组都会进行特别处理，若是对象上文已经提过处理方法，若是数组的话又会如何呢？\n这里简要概述一下：通过ExpParser.parse方法，将bindings['a[0]'].value设{$get: newFunction('this.a; return this.a[0]')}的形式，后面就和computed类似了，这里有一点需要注意，在observer.js里面，重写了['push','pop','shift','unshift','splice','sort','reverse']等数组方法，当a.push(1)的时候，会触发mutate动作，执行bindings['a'].pub()，从而通知bindings['a[0]']的instances更新，具体内容可以自己去看源码\u003c/p\u003e\n\u003cp\u003e参考资料\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://segmentfault.com/a/1190000006599500\" target=\"_blank\"\u003e剖析Vue原理\u0026amp;实现双向绑定MVVM\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n"}},"buildId":"r4Ww0YLm8YL5~6SwciWHH","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" async=""></script></body></html>