<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">三种常见算法</title><link rel="preload" href="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.491f56ba.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___3Hk0c "><a class="logo___1KD30" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___1qXLb" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___3VKNp"><h1 class="postTitle___26vXM">三种常见算法</h1><span class="postTime___16Ish">July 7, 2018</span></header><article class="postWrapper___3NXol post-article"><div><h2>前言</h2>
<p>先吐槽。
金三银四，最近来我司计划招聘两名前端工程师，一名初级，一名中级，结果前来面试的人络绎不绝，让我也当面试官，结果呢。前来的有一两年工作经验的初级工程师，都是渣渣，不是基础差，就是广度不够，连笔试题目都做不出来，尤其是算法题目，简单的排序都做不出来。给我的感觉，连刚参加工作的我都不如。而后面试的两个中级工程师，面试后感觉也就比我差点，工作经验比我长点，可是这个期望薪水，是不是有点高呀。只是排序算法题大多用的是冒泡法，作为工程师不应该开口闭口都是快排吗。嗯，只是忽然想想自己也只是知道快排的思想，具体怎么实现，就懵逼了，于是才有了这篇博客。</p>
<h2>常见的冒泡法</h2>
<p>冒泡法的概念，很是基础，基本上C语言入门书籍，都会介绍一遍。算法实现和其名字一样<strong>冒泡</strong>，(从小到大排)高个子从数组的低序号冒泡到高序号，并结束本轮循环。下轮循环的时候，剔除掉已经排好序的高个子，开始排下个高个子，这样需要写到两个循环。具体实现如下：</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> bubbleSort = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> arrLength = arr.length;
  <span class="hljs-keyword">let</span> temp;
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arrLength; i++ ) {
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arrLength - i; j++) {
      <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) {
        temp = arr[j + <span class="hljs-number">1</span>];
        arr[j + <span class="hljs-number">1</span>] = arr[j];
        arr[j] = temp;
      }
    }
  }

  <span class="hljs-keyword">return</span> arr;
}
</code></pre>
<p>如此计算，自然可以简单的想到啦，当然还有另外一种更傻的方法，就是每次都出一个数字正确排序，再求出下个数的正确排序，如此下来，也是能实现，只是算发并不不好看，先看看具体实现：</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> rubbishSort = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> arrLength = arr.length;
  <span class="hljs-keyword">let</span> sameControl = {};
  <span class="hljs-keyword">let</span> result = [];
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arrLength; i++) {
    <span class="hljs-keyword">let</span> target = arr[i],
        left = <span class="hljs-number">0</span>,
        same = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arrLength; j++) {
      <span class="hljs-keyword">if</span>(arr[j] &lt; target) {
        left++;
      } 
      <span class="hljs-keyword">if</span>(arr[j] === target) {
        same++;
      }
    }
    <span class="hljs-keyword">if</span>(result[left] === <span class="hljs-literal">undefined</span>) {
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> resultIndex = left; resultIndex &lt; left + same; resultIndex++) {
        result[resultIndex] = target;
      }
    }
  }
  <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>上面算法一看还是很麻烦的，为了相同的元素还特地设置了 <code>same</code> 变量，虽然最后也是能实现排序的，只是其计算的步骤却是要比冒泡法高很多的，不仅仅有两个长度为 <code>arrLength</code> 的 <code>for</code> 循环，在最后一个循环里面还要做两次判断。而冒泡法，第二个 <code>for</code> 循环 就要精简很多了。</p>
<h3>大O表示法</h3>
<p>要如何判断哪种算法更好呢？常用的比较方法是<strong>运行时间</strong>，通过运行时间来比较，运行时间越少的，自然越优，毕竟计算机是按照一条条指令并行处理的。<strong>大O表示法</strong>是种特殊的表示法，指出运行速度的快慢。</p>
<p>对于长度为 n 的数组，若用冒泡法需要循环 n 次，每次循环长度从 n 一直下降到 0，可以求得其运行时间为 <code>n²/2</code>，用大O表示法就是 <code>O(n²)</code>，大O法是自然省略前面的常数的。若用第二种算法，逻辑基本差不多，但是其运行时间为 <code>n²</code>，用大O表示法就是 <code>O(n²)</code>。可以看出来后一种的运行时间足足是前者的两倍之长。</p>
<p>虽然如此，但是 <code>O(n²)</code> 这样的时间，你可以忍？如果有1000个数字，那岂不要花 1,000,000 次计算。想想要是计算机这么搞，岂不是累死了。</p>
<h3>快速排序算法</h3>
<p>面对传统的这些方法，比如上面，每次排好一个位置都需要循环一遍，效率低下，实在麻烦，有没有更好的办法？<strong>分而治之</strong>就提供了一个很好的思路，就是要将问题从大化小，一个个简单击破，最后合并在一起就好了。在排序的体现上就是将待排序的数组不断的拆分成小数组，最后划分到根本不用排序的数组，再排序合并。</p>
<p>具体怎么做呢？先看看<a href="http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html" target="_blank">快速排序（Quicksort）的Javascript实现</a> 这里阮老师给出的思想是：</p>
<blockquote>
<p>在数据集之中，选择一个元素作为&quot;基准&quot;（pivot）</p>
</blockquote>
<p>**通过基准值pivot来实现分而治之的思想，**拆分出小的单元，再仿佛拆分。具体如下：</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> quickSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>{
　<span class="hljs-keyword">if</span> (arr.length &lt;= <span class="hljs-number">1</span>) { <span class="hljs-keyword">return</span> arr; }
　<span class="hljs-keyword">var</span> pivotIndex = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>);
　<span class="hljs-keyword">var</span> pivot = arr.splice(pivotIndex, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];
　<span class="hljs-keyword">var</span> left = [];
　<span class="hljs-keyword">var</span> right = [];
　<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++){
　　<span class="hljs-keyword">if</span> (arr[i] &lt; pivot) {
　　　left.push(arr[i]);
　　} <span class="hljs-keyword">else</span> {
　　　right.push(arr[i]);
  　}
  }
  <span class="hljs-keyword">return</span> quickSort(left).concat([pivot], quickSort(right));
};
</code></pre>
<p>这么一看很有分而治之的味道，每次将数组分为两半，分别排序，从而降低迭代次数，实现了优化。在最优的时候，每次都可以将数组分成两半，**于是调用栈为 O(logN)，底数为2，每次调用排序数量为 <code>n</code>，所以时间复杂度为 <code>O(NlogN)</code>，**相比于冒泡的 <code>O(n²)</code>，快了特别多，如当 <code>n = 10000</code> 的时候，相差1000倍。这个过程其实和二分法有点类似了。</p>
<p>上面算法看着好简单，难道传说中的快速排序就是这样的？在上面的例子中可以发现，主要通过 left 和 right 来进行数据存储，也就是说其每次迭代的<strong>空间复杂度</strong>为 <code>O(n)</code>，而迭代次数为 <code>O(logN)</code>，所以总的空间复杂度为 <code>O(NlogN)</code>。此时，意味着随着待排序对象的加长，其所占用的空间会不断叠加，与之对比冒泡排序的空间复杂度。。。嗯，不就是 <code>O(1)</code>嘛，</p>
<p>空间复杂度的提高也会影响性能。那有没有运行时间又少，空间复杂度又低的呢？下面给出我自己下的方法：</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> quickSort = <span class="hljs-function">(<span class="hljs-params">arr, left, right</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (arr.length &lt;= <span class="hljs-number">1</span>) { 
    <span class="hljs-keyword">return</span> arr; 
  }
  left = left || <span class="hljs-number">0</span>;
  right = right || arr.length - <span class="hljs-number">1</span>;

  <span class="hljs-keyword">const</span> target = arr[left];
  <span class="hljs-keyword">const</span> leftInit = left;
  <span class="hljs-keyword">const</span> rightInit = right;
  <span class="hljs-keyword">let</span> leftEnd;
  <span class="hljs-keyword">let</span> rightStart;
  <span class="hljs-keyword">let</span> temp;
  left++;

  <span class="hljs-keyword">if</span>(left === right) {
    <span class="hljs-keyword">if</span>(target &gt; arr[right]) {
      temp = arr[left - <span class="hljs-number">1</span>];
      arr[left - <span class="hljs-number">1</span>] = arr[right];
      arr[right] = temp;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">while</span>(left &lt; right) {
    <span class="hljs-keyword">while</span>(arr[left] &lt;= target &amp;&amp; left &lt; right) {
      left++;
    }
    <span class="hljs-keyword">while</span>(arr[right] &gt; target &amp;&amp; left &lt; right) {
      right--;
    }
    <span class="hljs-keyword">if</span>(left &lt; right ) {
      temp = arr[left];
      arr[left] = arr[right];
      arr[right] = temp;
    }
    <span class="hljs-keyword">if</span>(left === right) {
      <span class="hljs-keyword">if</span>(target &gt; arr[left]) {
        arr[leftInit] =  arr[left];
        arr[left] = target;
        leftEnd = left - <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(leftInit !== left <span class="hljs-number">-1</span>) {
        arr[leftInit] = arr[left - <span class="hljs-number">1</span>];
        arr[left - <span class="hljs-number">1</span>] = target;
        leftEnd = left - <span class="hljs-number">2</span>;
        rightStart = left;
      } <span class="hljs-keyword">else</span> {
        rightStart = left + <span class="hljs-number">1</span>;
      }
    }
  }
  <span class="hljs-keyword">if</span>(leftEnd !== <span class="hljs-literal">undefined</span>) {
    qs(arr, leftInit, leftEnd);
  }
  <span class="hljs-keyword">if</span>(rightStart !== <span class="hljs-literal">undefined</span>) {
    qs(arr, rightStart || right, rightInit)
  }
}
</code></pre>
<p>（吐个槽，quickSort 方法，写了一个小时半才写好，一开始以为很简单，结果跑一下，才发现各种bug，实在惭愧，现在有点体谅那些写不出快速排序的面试者了）</p>
<p>具体的思想可以参考这篇 <a href="http://blog.csdn.net/morewindows/article/details/6684558" target="_blank">博客</a>。上面的 quickSort 的思想还是很简单的，通过两边不断的推移，将小于 target 的数放在左边，大于 target 的数放在右边。只是可能出现左边的数都小于 target，又或者是左边的数都大于 target，所以需要特别处理，导致复杂度提高了。</p>
<p>这时候看到了 <a href="http://efe.baidu.com/blog/talk-about-sort-in-front-end/" target="_blank">聊聊前端排序的那些事</a> 上面介绍到排序 sort 在 Chrome 中的实现，核心部分还是快速排序，原来 Chrome 里面也是用 JavaScript 来实现 sort 方法的！<a href="https://github.com/v8/v8/blob/master/src/js/array.js#L755" target="_blank">具体源码</a>，只是没有想到 Chrome 里面居然用了 partition 来跳转 js 代码，太可怕了。</p>
<p>chrome 里面先是对输入数组范围小于10的，采用<strong>插入排序</strong>，包括迭代过程中也是，否则采用<strong>快排</strong>。快排中采用三点取值，分别是首尾数值，和中间数值。中间数值的下标会根据数组是否大于 1000 来分情况生成，具体情况请看源码。随后对这三个数值排序，<strong>取中间值作为基准</strong>。采用的快速方法和上文中的第二种思路相似的，只是用了 for 循环和一个 <code>do while</code> 循环，实现起来也是麻烦不少，但是估计速度会更快，更优秀吧。</p>
<h4>快排复杂度</h4>
<p>前面有提到快速排序算法的运算时间为 <code>O(NlogN)</code>，这是根据调用栈和每次调用量，来计算的，但是其调用栈却不总是 <code>O(logN)</code>，<code>O(logN)</code> 是建立在每次循环取基准值刚好是该数组的中间值，如果不是中位数值呢？如对数组[1, 2, 3, 4, 5]，这种混乱度低的数组，如果还是用从 0 下标开始的快速排序算法，那其计算下来和普通的冒泡法的运行时间是相似的。</p>
<p>由于这种原因，Chrome 里面的快排用三值分而治之，保证随机性，提高快排的运算效能。快排的最糟糕运行时间为 <code>O(n²)</code>，最佳为 <code>O(NlogN)</code>，当然平均时间为 <code>O(NlogN)</code>，基准值取值随机的情况下， <code>O(n²)</code> 是低概率事件。</p>
<h3>归并排序</h3>
<p>在 <a href="http://efe.baidu.com/blog/talk-about-sort-in-front-end/" target="_blank">聊聊前端排序的那些事</a> 中看到<strong>Firefox采用归并排序</strong>，具体缘由文中后面后面也是介绍了一下历史，但是归并排序是什么呢？思路如下图所示<img src="https://github.com/funfish/blog/blob/master/images/%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95.PNG" alt=""></p>
<p>算法也挺简单的，如下：</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> mergeSort = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> { 
  <span class="hljs-keyword">const</span> len = arr.length;
  <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">return</span> arr;
  }
  <span class="hljs-keyword">const</span> middle = <span class="hljs-built_in">Math</span>.floor(len / <span class="hljs-number">2</span>),
      left = arr.slice(<span class="hljs-number">0</span>, middle),
      right = arr.slice(middle);
  <span class="hljs-keyword">return</span> merge(mergeSort(left), mergeSort(right));
}

<span class="hljs-keyword">const</span> merge = <span class="hljs-function">(<span class="hljs-params">left, right</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> result = [];
  <span class="hljs-keyword">while</span> (left.length &amp;&amp; right.length) {
    <span class="hljs-keyword">if</span> (left[<span class="hljs-number">0</span>] &lt;= right[<span class="hljs-number">0</span>]) {
      result.push(left.shift());
    } <span class="hljs-keyword">else</span> {
      result.push(right.shift());
    }
  }
  <span class="hljs-keyword">while</span> (left.length) {
    result.push(left.shift());
  }
  <span class="hljs-keyword">while</span> (right.length) {
    result.push(right.shift());
  }
  <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>上面代码计算参考 <a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank">这篇博客</a>。</p>
<p>归并也是采用分而治之的思路，和二分法的思路有些接近，就像上图一样，把数组整体分割成最小单元，两个元素或则一个元素。先从小数组中排序，再和相邻的数组间排序，一级一级往上走。可以知道这种方式下，调用栈肯定是 <code>O(logN)</code>，而每次调用运算为 <code>N</code>，所以其运算时间为 <code>O(NlogN)</code>。其运行时间比快排还要稳定，是稳定排序，只是问题在于 <code>result</code> 数组，归并运算的问题在于其空间复杂度为 <code>O(NlogN)</code>，和阮老师里面提到的快速算法空间复杂度是一致的，其实由于反复递归，每次递归的代码执行栈是很高的，相对于上文自己写的快速排序还是有很大差别的。</p>
<h3>其他排序</h3>
<p>其他排序还有一些很经典的：</p>
<ol>
<li>插入排序。插排序如同打扑克牌，插入牌一样。从第二个元素开始，每个数都回溯其应该排序位置，和冒泡法的套路有点像。</li>
<li>选择排序；</li>
<li>堆排序；
当然还有很多，只是怕全都看完容易忘记，还是记住三个常见有用的算法吧。</li>
</ol>
<p>关于排序，还有个有趣的地方，<a href="https://www.h5jun.com/post/array-shuffle.html" target="_blank">数组的完全随机排列</a>，洗牌算法和排序算法之间的矛盾问题，算是一个扩展吧。</p>
<p>ps: 为何网上查找的快速排序算法大多不是快速排序，或者是错误的，这如何是好。。。。。。
另外块排是不稳定排序，这也是个隐患。以后可以出个面试题，哈哈哈哈</p>
<h2>参考</h2>
<ol>
<li><a href="http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html" target="_blank">快速排序（Quicksort）的Javascript实现</a></li>
<li><a href="http://efe.baidu.com/blog/talk-about-sort-in-front-end/" target="_blank">聊聊前端排序的那些事</a></li>
<li><a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank">十大经典排序算法</a></li>
</ol>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"July 7, 2018","title":"三种常见算法","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e先吐槽。\n金三银四，最近来我司计划招聘两名前端工程师，一名初级，一名中级，结果前来面试的人络绎不绝，让我也当面试官，结果呢。前来的有一两年工作经验的初级工程师，都是渣渣，不是基础差，就是广度不够，连笔试题目都做不出来，尤其是算法题目，简单的排序都做不出来。给我的感觉，连刚参加工作的我都不如。而后面试的两个中级工程师，面试后感觉也就比我差点，工作经验比我长点，可是这个期望薪水，是不是有点高呀。只是排序算法题大多用的是冒泡法，作为工程师不应该开口闭口都是快排吗。嗯，只是忽然想想自己也只是知道快排的思想，具体怎么实现，就懵逼了，于是才有了这篇博客。\u003c/p\u003e\n\u003ch2\u003e常见的冒泡法\u003c/h2\u003e\n\u003cp\u003e冒泡法的概念，很是基础，基本上C语言入门书籍，都会介绍一遍。算法实现和其名字一样\u003cstrong\u003e冒泡\u003c/strong\u003e，(从小到大排)高个子从数组的低序号冒泡到高序号，并结束本轮循环。下轮循环的时候，剔除掉已经排好序的高个子，开始排下个高个子，这样需要写到两个循环。具体实现如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e bubbleSort = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003earr\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arrLength = arr.length;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e temp;\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; i \u0026lt; arrLength; i++ ) {\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e j = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; j \u0026lt; arrLength - i; j++) {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(arr[j] \u0026gt; arr[j + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]) {\n        temp = arr[j + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n        arr[j + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e arr;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如此计算，自然可以简单的想到啦，当然还有另外一种更傻的方法，就是每次都出一个数字正确排序，再求出下个数的正确排序，如此下来，也是能实现，只是算发并不不好看，先看看具体实现：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e rubbishSort = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003earr\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arrLength = arr.length;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e sameControl = {};\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e result = [];\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; arrLength; i++) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e target = arr[i],\n        left = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n        same = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e j = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; j \u0026lt; arrLength; j++) {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(arr[j] \u0026lt; target) {\n        left++;\n      } \n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(arr[j] === target) {\n        same++;\n      }\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(result[left] === \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e resultIndex = left; resultIndex \u0026lt; left + same; resultIndex++) {\n        result[resultIndex] = target;\n      }\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面算法一看还是很麻烦的，为了相同的元素还特地设置了 \u003ccode\u003esame\u003c/code\u003e 变量，虽然最后也是能实现排序的，只是其计算的步骤却是要比冒泡法高很多的，不仅仅有两个长度为 \u003ccode\u003earrLength\u003c/code\u003e 的 \u003ccode\u003efor\u003c/code\u003e 循环，在最后一个循环里面还要做两次判断。而冒泡法，第二个 \u003ccode\u003efor\u003c/code\u003e 循环 就要精简很多了。\u003c/p\u003e\n\u003ch3\u003e大O表示法\u003c/h3\u003e\n\u003cp\u003e要如何判断哪种算法更好呢？常用的比较方法是\u003cstrong\u003e运行时间\u003c/strong\u003e，通过运行时间来比较，运行时间越少的，自然越优，毕竟计算机是按照一条条指令并行处理的。\u003cstrong\u003e大O表示法\u003c/strong\u003e是种特殊的表示法，指出运行速度的快慢。\u003c/p\u003e\n\u003cp\u003e对于长度为 n 的数组，若用冒泡法需要循环 n 次，每次循环长度从 n 一直下降到 0，可以求得其运行时间为 \u003ccode\u003en²/2\u003c/code\u003e，用大O表示法就是 \u003ccode\u003eO(n²)\u003c/code\u003e，大O法是自然省略前面的常数的。若用第二种算法，逻辑基本差不多，但是其运行时间为 \u003ccode\u003en²\u003c/code\u003e，用大O表示法就是 \u003ccode\u003eO(n²)\u003c/code\u003e。可以看出来后一种的运行时间足足是前者的两倍之长。\u003c/p\u003e\n\u003cp\u003e虽然如此，但是 \u003ccode\u003eO(n²)\u003c/code\u003e 这样的时间，你可以忍？如果有1000个数字，那岂不要花 1,000,000 次计算。想想要是计算机这么搞，岂不是累死了。\u003c/p\u003e\n\u003ch3\u003e快速排序算法\u003c/h3\u003e\n\u003cp\u003e面对传统的这些方法，比如上面，每次排好一个位置都需要循环一遍，效率低下，实在麻烦，有没有更好的办法？\u003cstrong\u003e分而治之\u003c/strong\u003e就提供了一个很好的思路，就是要将问题从大化小，一个个简单击破，最后合并在一起就好了。在排序的体现上就是将待排序的数组不断的拆分成小数组，最后划分到根本不用排序的数组，再排序合并。\u003c/p\u003e\n\u003cp\u003e具体怎么做呢？先看看\u003ca href=\"http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html\" target=\"_blank\"\u003e快速排序（Quicksort）的Javascript实现\u003c/a\u003e 这里阮老师给出的思想是：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在数据集之中，选择一个元素作为\u0026quot;基准\u0026quot;（pivot）\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e**通过基准值pivot来实现分而治之的思想，**拆分出小的单元，再仿佛拆分。具体如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e quickSort = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003earr\u003c/span\u003e) \u003c/span\u003e{\n　\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (arr.length \u0026lt;= \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) { \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e arr; }\n　\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e pivotIndex = \u003cspan class=\"hljs-built_in\"\u003eMath\u003c/span\u003e.floor(arr.length / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n　\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e pivot = arr.splice(pivotIndex, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e];\n　\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e left = [];\n　\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e right = [];\n　\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; arr.length; i++){\n　　\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (arr[i] \u0026lt; pivot) {\n　　　left.push(arr[i]);\n　　} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n　　　right.push(arr[i]);\n  　}\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e quickSort(left).concat([pivot], quickSort(right));\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这么一看很有分而治之的味道，每次将数组分为两半，分别排序，从而降低迭代次数，实现了优化。在最优的时候，每次都可以将数组分成两半，**于是调用栈为 O(logN)，底数为2，每次调用排序数量为 \u003ccode\u003en\u003c/code\u003e，所以时间复杂度为 \u003ccode\u003eO(NlogN)\u003c/code\u003e，**相比于冒泡的 \u003ccode\u003eO(n²)\u003c/code\u003e，快了特别多，如当 \u003ccode\u003en = 10000\u003c/code\u003e 的时候，相差1000倍。这个过程其实和二分法有点类似了。\u003c/p\u003e\n\u003cp\u003e上面算法看着好简单，难道传说中的快速排序就是这样的？在上面的例子中可以发现，主要通过 left 和 right 来进行数据存储，也就是说其每次迭代的\u003cstrong\u003e空间复杂度\u003c/strong\u003e为 \u003ccode\u003eO(n)\u003c/code\u003e，而迭代次数为 \u003ccode\u003eO(logN)\u003c/code\u003e，所以总的空间复杂度为 \u003ccode\u003eO(NlogN)\u003c/code\u003e。此时，意味着随着待排序对象的加长，其所占用的空间会不断叠加，与之对比冒泡排序的空间复杂度。。。嗯，不就是 \u003ccode\u003eO(1)\u003c/code\u003e嘛，\u003c/p\u003e\n\u003cp\u003e空间复杂度的提高也会影响性能。那有没有运行时间又少，空间复杂度又低的呢？下面给出我自己下的方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e quickSort = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003earr, left, right\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (arr.length \u0026lt;= \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) { \n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e arr; \n  }\n  left = left || \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  right = right || arr.length - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e target = arr[left];\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e leftInit = left;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e rightInit = right;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e leftEnd;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e rightStart;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e temp;\n  left++;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(left === right) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(target \u0026gt; arr[right]) {\n      temp = arr[left - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n      arr[left - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] = arr[right];\n      arr[right] = temp;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(left \u0026lt; right) {\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(arr[left] \u0026lt;= target \u0026amp;\u0026amp; left \u0026lt; right) {\n      left++;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(arr[right] \u0026gt; target \u0026amp;\u0026amp; left \u0026lt; right) {\n      right--;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(left \u0026lt; right ) {\n      temp = arr[left];\n      arr[left] = arr[right];\n      arr[right] = temp;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(left === right) {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(target \u0026gt; arr[left]) {\n        arr[leftInit] =  arr[left];\n        arr[left] = target;\n        leftEnd = left - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(leftInit !== left \u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e) {\n        arr[leftInit] = arr[left - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n        arr[left - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] = target;\n        leftEnd = left - \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n        rightStart = left;\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        rightStart = left + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n      }\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(leftEnd !== \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e) {\n    qs(arr, leftInit, leftEnd);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(rightStart !== \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e) {\n    qs(arr, rightStart || right, rightInit)\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e（吐个槽，quickSort 方法，写了一个小时半才写好，一开始以为很简单，结果跑一下，才发现各种bug，实在惭愧，现在有点体谅那些写不出快速排序的面试者了）\u003c/p\u003e\n\u003cp\u003e具体的思想可以参考这篇 \u003ca href=\"http://blog.csdn.net/morewindows/article/details/6684558\" target=\"_blank\"\u003e博客\u003c/a\u003e。上面的 quickSort 的思想还是很简单的，通过两边不断的推移，将小于 target 的数放在左边，大于 target 的数放在右边。只是可能出现左边的数都小于 target，又或者是左边的数都大于 target，所以需要特别处理，导致复杂度提高了。\u003c/p\u003e\n\u003cp\u003e这时候看到了 \u003ca href=\"http://efe.baidu.com/blog/talk-about-sort-in-front-end/\" target=\"_blank\"\u003e聊聊前端排序的那些事\u003c/a\u003e 上面介绍到排序 sort 在 Chrome 中的实现，核心部分还是快速排序，原来 Chrome 里面也是用 JavaScript 来实现 sort 方法的！\u003ca href=\"https://github.com/v8/v8/blob/master/src/js/array.js#L755\" target=\"_blank\"\u003e具体源码\u003c/a\u003e，只是没有想到 Chrome 里面居然用了 partition 来跳转 js 代码，太可怕了。\u003c/p\u003e\n\u003cp\u003echrome 里面先是对输入数组范围小于10的，采用\u003cstrong\u003e插入排序\u003c/strong\u003e，包括迭代过程中也是，否则采用\u003cstrong\u003e快排\u003c/strong\u003e。快排中采用三点取值，分别是首尾数值，和中间数值。中间数值的下标会根据数组是否大于 1000 来分情况生成，具体情况请看源码。随后对这三个数值排序，\u003cstrong\u003e取中间值作为基准\u003c/strong\u003e。采用的快速方法和上文中的第二种思路相似的，只是用了 for 循环和一个 \u003ccode\u003edo while\u003c/code\u003e 循环，实现起来也是麻烦不少，但是估计速度会更快，更优秀吧。\u003c/p\u003e\n\u003ch4\u003e快排复杂度\u003c/h4\u003e\n\u003cp\u003e前面有提到快速排序算法的运算时间为 \u003ccode\u003eO(NlogN)\u003c/code\u003e，这是根据调用栈和每次调用量，来计算的，但是其调用栈却不总是 \u003ccode\u003eO(logN)\u003c/code\u003e，\u003ccode\u003eO(logN)\u003c/code\u003e 是建立在每次循环取基准值刚好是该数组的中间值，如果不是中位数值呢？如对数组[1, 2, 3, 4, 5]，这种混乱度低的数组，如果还是用从 0 下标开始的快速排序算法，那其计算下来和普通的冒泡法的运行时间是相似的。\u003c/p\u003e\n\u003cp\u003e由于这种原因，Chrome 里面的快排用三值分而治之，保证随机性，提高快排的运算效能。快排的最糟糕运行时间为 \u003ccode\u003eO(n²)\u003c/code\u003e，最佳为 \u003ccode\u003eO(NlogN)\u003c/code\u003e，当然平均时间为 \u003ccode\u003eO(NlogN)\u003c/code\u003e，基准值取值随机的情况下， \u003ccode\u003eO(n²)\u003c/code\u003e 是低概率事件。\u003c/p\u003e\n\u003ch3\u003e归并排序\u003c/h3\u003e\n\u003cp\u003e在 \u003ca href=\"http://efe.baidu.com/blog/talk-about-sort-in-front-end/\" target=\"_blank\"\u003e聊聊前端排序的那些事\u003c/a\u003e 中看到\u003cstrong\u003eFirefox采用归并排序\u003c/strong\u003e，具体缘由文中后面后面也是介绍了一下历史，但是归并排序是什么呢？思路如下图所示\u003cimg src=\"https://github.com/funfish/blog/blob/master/images/%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e算法也挺简单的，如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e mergeSort = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003earr\u003c/span\u003e) =\u0026gt;\u003c/span\u003e { \n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e len = arr.length;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(len \u0026lt; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e arr;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e middle = \u003cspan class=\"hljs-built_in\"\u003eMath\u003c/span\u003e.floor(len / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e),\n      left = arr.slice(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, middle),\n      right = arr.slice(middle);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e merge(mergeSort(left), mergeSort(right));\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e merge = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eleft, right\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e result = [];\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (left.length \u0026amp;\u0026amp; right.length) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (left[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] \u0026lt;= right[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]) {\n      result.push(left.shift());\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      result.push(right.shift());\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (left.length) {\n    result.push(left.shift());\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (right.length) {\n    result.push(right.shift());\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码计算参考 \u003ca href=\"https://www.cnblogs.com/onepixel/articles/7674659.html\" target=\"_blank\"\u003e这篇博客\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e归并也是采用分而治之的思路，和二分法的思路有些接近，就像上图一样，把数组整体分割成最小单元，两个元素或则一个元素。先从小数组中排序，再和相邻的数组间排序，一级一级往上走。可以知道这种方式下，调用栈肯定是 \u003ccode\u003eO(logN)\u003c/code\u003e，而每次调用运算为 \u003ccode\u003eN\u003c/code\u003e，所以其运算时间为 \u003ccode\u003eO(NlogN)\u003c/code\u003e。其运行时间比快排还要稳定，是稳定排序，只是问题在于 \u003ccode\u003eresult\u003c/code\u003e 数组，归并运算的问题在于其空间复杂度为 \u003ccode\u003eO(NlogN)\u003c/code\u003e，和阮老师里面提到的快速算法空间复杂度是一致的，其实由于反复递归，每次递归的代码执行栈是很高的，相对于上文自己写的快速排序还是有很大差别的。\u003c/p\u003e\n\u003ch3\u003e其他排序\u003c/h3\u003e\n\u003cp\u003e其他排序还有一些很经典的：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e插入排序。插排序如同打扑克牌，插入牌一样。从第二个元素开始，每个数都回溯其应该排序位置，和冒泡法的套路有点像。\u003c/li\u003e\n\u003cli\u003e选择排序；\u003c/li\u003e\n\u003cli\u003e堆排序；\n当然还有很多，只是怕全都看完容易忘记，还是记住三个常见有用的算法吧。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e关于排序，还有个有趣的地方，\u003ca href=\"https://www.h5jun.com/post/array-shuffle.html\" target=\"_blank\"\u003e数组的完全随机排列\u003c/a\u003e，洗牌算法和排序算法之间的矛盾问题，算是一个扩展吧。\u003c/p\u003e\n\u003cp\u003eps: 为何网上查找的快速排序算法大多不是快速排序，或者是错误的，这如何是好。。。。。。\n另外块排是不稳定排序，这也是个隐患。以后可以出个面试题，哈哈哈哈\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html\" target=\"_blank\"\u003e快速排序（Quicksort）的Javascript实现\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://efe.baidu.com/blog/talk-about-sort-in-front-end/\" target=\"_blank\"\u003e聊聊前端排序的那些事\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.cnblogs.com/onepixel/articles/7674659.html\" target=\"_blank\"\u003e十大经典排序算法\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"July 7, 2018","title":"三种常见算法","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e先吐槽。\n金三银四，最近来我司计划招聘两名前端工程师，一名初级，一名中级，结果前来面试的人络绎不绝，让我也当面试官，结果呢。前来的有一两年工作经验的初级工程师，都是渣渣，不是基础差，就是广度不够，连笔试题目都做不出来，尤其是算法题目，简单的排序都做不出来。给我的感觉，连刚参加工作的我都不如。而后面试的两个中级工程师，面试后感觉也就比我差点，工作经验比我长点，可是这个期望薪水，是不是有点高呀。只是排序算法题大多用的是冒泡法，作为工程师不应该开口闭口都是快排吗。嗯，只是忽然想想自己也只是知道快排的思想，具体怎么实现，就懵逼了，于是才有了这篇博客。\u003c/p\u003e\n\u003ch2\u003e常见的冒泡法\u003c/h2\u003e\n\u003cp\u003e冒泡法的概念，很是基础，基本上C语言入门书籍，都会介绍一遍。算法实现和其名字一样\u003cstrong\u003e冒泡\u003c/strong\u003e，(从小到大排)高个子从数组的低序号冒泡到高序号，并结束本轮循环。下轮循环的时候，剔除掉已经排好序的高个子，开始排下个高个子，这样需要写到两个循环。具体实现如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e bubbleSort = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003earr\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arrLength = arr.length;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e temp;\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; i \u0026lt; arrLength; i++ ) {\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e j = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; j \u0026lt; arrLength - i; j++) {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(arr[j] \u0026gt; arr[j + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]) {\n        temp = arr[j + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n        arr[j + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e arr;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如此计算，自然可以简单的想到啦，当然还有另外一种更傻的方法，就是每次都出一个数字正确排序，再求出下个数的正确排序，如此下来，也是能实现，只是算发并不不好看，先看看具体实现：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e rubbishSort = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003earr\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arrLength = arr.length;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e sameControl = {};\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e result = [];\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; arrLength; i++) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e target = arr[i],\n        left = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n        same = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e j = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; j \u0026lt; arrLength; j++) {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(arr[j] \u0026lt; target) {\n        left++;\n      } \n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(arr[j] === target) {\n        same++;\n      }\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(result[left] === \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e resultIndex = left; resultIndex \u0026lt; left + same; resultIndex++) {\n        result[resultIndex] = target;\n      }\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面算法一看还是很麻烦的，为了相同的元素还特地设置了 \u003ccode\u003esame\u003c/code\u003e 变量，虽然最后也是能实现排序的，只是其计算的步骤却是要比冒泡法高很多的，不仅仅有两个长度为 \u003ccode\u003earrLength\u003c/code\u003e 的 \u003ccode\u003efor\u003c/code\u003e 循环，在最后一个循环里面还要做两次判断。而冒泡法，第二个 \u003ccode\u003efor\u003c/code\u003e 循环 就要精简很多了。\u003c/p\u003e\n\u003ch3\u003e大O表示法\u003c/h3\u003e\n\u003cp\u003e要如何判断哪种算法更好呢？常用的比较方法是\u003cstrong\u003e运行时间\u003c/strong\u003e，通过运行时间来比较，运行时间越少的，自然越优，毕竟计算机是按照一条条指令并行处理的。\u003cstrong\u003e大O表示法\u003c/strong\u003e是种特殊的表示法，指出运行速度的快慢。\u003c/p\u003e\n\u003cp\u003e对于长度为 n 的数组，若用冒泡法需要循环 n 次，每次循环长度从 n 一直下降到 0，可以求得其运行时间为 \u003ccode\u003en²/2\u003c/code\u003e，用大O表示法就是 \u003ccode\u003eO(n²)\u003c/code\u003e，大O法是自然省略前面的常数的。若用第二种算法，逻辑基本差不多，但是其运行时间为 \u003ccode\u003en²\u003c/code\u003e，用大O表示法就是 \u003ccode\u003eO(n²)\u003c/code\u003e。可以看出来后一种的运行时间足足是前者的两倍之长。\u003c/p\u003e\n\u003cp\u003e虽然如此，但是 \u003ccode\u003eO(n²)\u003c/code\u003e 这样的时间，你可以忍？如果有1000个数字，那岂不要花 1,000,000 次计算。想想要是计算机这么搞，岂不是累死了。\u003c/p\u003e\n\u003ch3\u003e快速排序算法\u003c/h3\u003e\n\u003cp\u003e面对传统的这些方法，比如上面，每次排好一个位置都需要循环一遍，效率低下，实在麻烦，有没有更好的办法？\u003cstrong\u003e分而治之\u003c/strong\u003e就提供了一个很好的思路，就是要将问题从大化小，一个个简单击破，最后合并在一起就好了。在排序的体现上就是将待排序的数组不断的拆分成小数组，最后划分到根本不用排序的数组，再排序合并。\u003c/p\u003e\n\u003cp\u003e具体怎么做呢？先看看\u003ca href=\"http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html\" target=\"_blank\"\u003e快速排序（Quicksort）的Javascript实现\u003c/a\u003e 这里阮老师给出的思想是：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在数据集之中，选择一个元素作为\u0026quot;基准\u0026quot;（pivot）\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e**通过基准值pivot来实现分而治之的思想，**拆分出小的单元，再仿佛拆分。具体如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e quickSort = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003earr\u003c/span\u003e) \u003c/span\u003e{\n　\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (arr.length \u0026lt;= \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) { \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e arr; }\n　\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e pivotIndex = \u003cspan class=\"hljs-built_in\"\u003eMath\u003c/span\u003e.floor(arr.length / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n　\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e pivot = arr.splice(pivotIndex, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e];\n　\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e left = [];\n　\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e right = [];\n　\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; arr.length; i++){\n　　\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (arr[i] \u0026lt; pivot) {\n　　　left.push(arr[i]);\n　　} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n　　　right.push(arr[i]);\n  　}\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e quickSort(left).concat([pivot], quickSort(right));\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这么一看很有分而治之的味道，每次将数组分为两半，分别排序，从而降低迭代次数，实现了优化。在最优的时候，每次都可以将数组分成两半，**于是调用栈为 O(logN)，底数为2，每次调用排序数量为 \u003ccode\u003en\u003c/code\u003e，所以时间复杂度为 \u003ccode\u003eO(NlogN)\u003c/code\u003e，**相比于冒泡的 \u003ccode\u003eO(n²)\u003c/code\u003e，快了特别多，如当 \u003ccode\u003en = 10000\u003c/code\u003e 的时候，相差1000倍。这个过程其实和二分法有点类似了。\u003c/p\u003e\n\u003cp\u003e上面算法看着好简单，难道传说中的快速排序就是这样的？在上面的例子中可以发现，主要通过 left 和 right 来进行数据存储，也就是说其每次迭代的\u003cstrong\u003e空间复杂度\u003c/strong\u003e为 \u003ccode\u003eO(n)\u003c/code\u003e，而迭代次数为 \u003ccode\u003eO(logN)\u003c/code\u003e，所以总的空间复杂度为 \u003ccode\u003eO(NlogN)\u003c/code\u003e。此时，意味着随着待排序对象的加长，其所占用的空间会不断叠加，与之对比冒泡排序的空间复杂度。。。嗯，不就是 \u003ccode\u003eO(1)\u003c/code\u003e嘛，\u003c/p\u003e\n\u003cp\u003e空间复杂度的提高也会影响性能。那有没有运行时间又少，空间复杂度又低的呢？下面给出我自己下的方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e quickSort = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003earr, left, right\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (arr.length \u0026lt;= \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) { \n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e arr; \n  }\n  left = left || \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  right = right || arr.length - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e target = arr[left];\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e leftInit = left;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e rightInit = right;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e leftEnd;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e rightStart;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e temp;\n  left++;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(left === right) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(target \u0026gt; arr[right]) {\n      temp = arr[left - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n      arr[left - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] = arr[right];\n      arr[right] = temp;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(left \u0026lt; right) {\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(arr[left] \u0026lt;= target \u0026amp;\u0026amp; left \u0026lt; right) {\n      left++;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(arr[right] \u0026gt; target \u0026amp;\u0026amp; left \u0026lt; right) {\n      right--;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(left \u0026lt; right ) {\n      temp = arr[left];\n      arr[left] = arr[right];\n      arr[right] = temp;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(left === right) {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(target \u0026gt; arr[left]) {\n        arr[leftInit] =  arr[left];\n        arr[left] = target;\n        leftEnd = left - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(leftInit !== left \u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e) {\n        arr[leftInit] = arr[left - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n        arr[left - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] = target;\n        leftEnd = left - \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n        rightStart = left;\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        rightStart = left + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n      }\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(leftEnd !== \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e) {\n    qs(arr, leftInit, leftEnd);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(rightStart !== \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e) {\n    qs(arr, rightStart || right, rightInit)\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e（吐个槽，quickSort 方法，写了一个小时半才写好，一开始以为很简单，结果跑一下，才发现各种bug，实在惭愧，现在有点体谅那些写不出快速排序的面试者了）\u003c/p\u003e\n\u003cp\u003e具体的思想可以参考这篇 \u003ca href=\"http://blog.csdn.net/morewindows/article/details/6684558\" target=\"_blank\"\u003e博客\u003c/a\u003e。上面的 quickSort 的思想还是很简单的，通过两边不断的推移，将小于 target 的数放在左边，大于 target 的数放在右边。只是可能出现左边的数都小于 target，又或者是左边的数都大于 target，所以需要特别处理，导致复杂度提高了。\u003c/p\u003e\n\u003cp\u003e这时候看到了 \u003ca href=\"http://efe.baidu.com/blog/talk-about-sort-in-front-end/\" target=\"_blank\"\u003e聊聊前端排序的那些事\u003c/a\u003e 上面介绍到排序 sort 在 Chrome 中的实现，核心部分还是快速排序，原来 Chrome 里面也是用 JavaScript 来实现 sort 方法的！\u003ca href=\"https://github.com/v8/v8/blob/master/src/js/array.js#L755\" target=\"_blank\"\u003e具体源码\u003c/a\u003e，只是没有想到 Chrome 里面居然用了 partition 来跳转 js 代码，太可怕了。\u003c/p\u003e\n\u003cp\u003echrome 里面先是对输入数组范围小于10的，采用\u003cstrong\u003e插入排序\u003c/strong\u003e，包括迭代过程中也是，否则采用\u003cstrong\u003e快排\u003c/strong\u003e。快排中采用三点取值，分别是首尾数值，和中间数值。中间数值的下标会根据数组是否大于 1000 来分情况生成，具体情况请看源码。随后对这三个数值排序，\u003cstrong\u003e取中间值作为基准\u003c/strong\u003e。采用的快速方法和上文中的第二种思路相似的，只是用了 for 循环和一个 \u003ccode\u003edo while\u003c/code\u003e 循环，实现起来也是麻烦不少，但是估计速度会更快，更优秀吧。\u003c/p\u003e\n\u003ch4\u003e快排复杂度\u003c/h4\u003e\n\u003cp\u003e前面有提到快速排序算法的运算时间为 \u003ccode\u003eO(NlogN)\u003c/code\u003e，这是根据调用栈和每次调用量，来计算的，但是其调用栈却不总是 \u003ccode\u003eO(logN)\u003c/code\u003e，\u003ccode\u003eO(logN)\u003c/code\u003e 是建立在每次循环取基准值刚好是该数组的中间值，如果不是中位数值呢？如对数组[1, 2, 3, 4, 5]，这种混乱度低的数组，如果还是用从 0 下标开始的快速排序算法，那其计算下来和普通的冒泡法的运行时间是相似的。\u003c/p\u003e\n\u003cp\u003e由于这种原因，Chrome 里面的快排用三值分而治之，保证随机性，提高快排的运算效能。快排的最糟糕运行时间为 \u003ccode\u003eO(n²)\u003c/code\u003e，最佳为 \u003ccode\u003eO(NlogN)\u003c/code\u003e，当然平均时间为 \u003ccode\u003eO(NlogN)\u003c/code\u003e，基准值取值随机的情况下， \u003ccode\u003eO(n²)\u003c/code\u003e 是低概率事件。\u003c/p\u003e\n\u003ch3\u003e归并排序\u003c/h3\u003e\n\u003cp\u003e在 \u003ca href=\"http://efe.baidu.com/blog/talk-about-sort-in-front-end/\" target=\"_blank\"\u003e聊聊前端排序的那些事\u003c/a\u003e 中看到\u003cstrong\u003eFirefox采用归并排序\u003c/strong\u003e，具体缘由文中后面后面也是介绍了一下历史，但是归并排序是什么呢？思路如下图所示\u003cimg src=\"https://github.com/funfish/blog/blob/master/images/%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e算法也挺简单的，如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e mergeSort = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003earr\u003c/span\u003e) =\u0026gt;\u003c/span\u003e { \n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e len = arr.length;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(len \u0026lt; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e arr;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e middle = \u003cspan class=\"hljs-built_in\"\u003eMath\u003c/span\u003e.floor(len / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e),\n      left = arr.slice(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, middle),\n      right = arr.slice(middle);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e merge(mergeSort(left), mergeSort(right));\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e merge = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eleft, right\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e result = [];\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (left.length \u0026amp;\u0026amp; right.length) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (left[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] \u0026lt;= right[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]) {\n      result.push(left.shift());\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      result.push(right.shift());\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (left.length) {\n    result.push(left.shift());\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (right.length) {\n    result.push(right.shift());\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码计算参考 \u003ca href=\"https://www.cnblogs.com/onepixel/articles/7674659.html\" target=\"_blank\"\u003e这篇博客\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e归并也是采用分而治之的思路，和二分法的思路有些接近，就像上图一样，把数组整体分割成最小单元，两个元素或则一个元素。先从小数组中排序，再和相邻的数组间排序，一级一级往上走。可以知道这种方式下，调用栈肯定是 \u003ccode\u003eO(logN)\u003c/code\u003e，而每次调用运算为 \u003ccode\u003eN\u003c/code\u003e，所以其运算时间为 \u003ccode\u003eO(NlogN)\u003c/code\u003e。其运行时间比快排还要稳定，是稳定排序，只是问题在于 \u003ccode\u003eresult\u003c/code\u003e 数组，归并运算的问题在于其空间复杂度为 \u003ccode\u003eO(NlogN)\u003c/code\u003e，和阮老师里面提到的快速算法空间复杂度是一致的，其实由于反复递归，每次递归的代码执行栈是很高的，相对于上文自己写的快速排序还是有很大差别的。\u003c/p\u003e\n\u003ch3\u003e其他排序\u003c/h3\u003e\n\u003cp\u003e其他排序还有一些很经典的：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e插入排序。插排序如同打扑克牌，插入牌一样。从第二个元素开始，每个数都回溯其应该排序位置，和冒泡法的套路有点像。\u003c/li\u003e\n\u003cli\u003e选择排序；\u003c/li\u003e\n\u003cli\u003e堆排序；\n当然还有很多，只是怕全都看完容易忘记，还是记住三个常见有用的算法吧。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e关于排序，还有个有趣的地方，\u003ca href=\"https://www.h5jun.com/post/array-shuffle.html\" target=\"_blank\"\u003e数组的完全随机排列\u003c/a\u003e，洗牌算法和排序算法之间的矛盾问题，算是一个扩展吧。\u003c/p\u003e\n\u003cp\u003eps: 为何网上查找的快速排序算法大多不是快速排序，或者是错误的，这如何是好。。。。。。\n另外块排是不稳定排序，这也是个隐患。以后可以出个面试题，哈哈哈哈\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html\" target=\"_blank\"\u003e快速排序（Quicksort）的Javascript实现\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://efe.baidu.com/blog/talk-about-sort-in-front-end/\" target=\"_blank\"\u003e聊聊前端排序的那些事\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.cnblogs.com/onepixel/articles/7674659.html\" target=\"_blank\"\u003e十大经典排序算法\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n"}},"buildId":"IdQI6resUd3YjXidM2HVB","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" async=""></script></body></html>