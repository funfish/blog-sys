<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">react 时间调度</title><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.587c5e31.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___2dTZ9 "><a class="logo___346dE" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___13XXt" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___29Pln"><h1 class="postTitle___1_m4g">react 时间调度</h1><span class="postTime___1x0_i">March 24, 2021</span></header><article class="postWrapper___3jnNg post-article"><div><h2>前言</h2>
<p>继续前面两篇 react 的分析。提到 react 16，除了 fiber 机制之外，还有其调度机制。这里就不得不提 requestIdleCallback 了，react 采用了 requestIdleCallback 的思想来实现调度，为什么说思想呢，因为 requestIdleCallback 是新出的 api，兼容性差，很多现代浏览器都不支持。于是 react 团队就写了一个 ployfill。</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/requestIdleCallback-caniuse.PNG" alt=""></p>
<h2>requestIdleCallback</h2>
<p>关于 requestIdleCallback，请先看看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank">MDN 上面的介绍</a>。requestIdleCallback 的出现意使得浏览器可以在空闲的时候执行 callback，这对单线程的 V8 而言就相当又用了。假设你需要大量涉及到 DOM 的操作的计算，在运算时，浏览器可能就会出现明显的卡顿行为，甚至不能进行任何操作，因为是单线程，就算用</p>
<p>在输入处理，给定帧渲染和合成之后，用户的主线程就会变得空闲，直到下一帧的开始，或者有优先的待处理任务，或者是存在输入。用户所看到的页面都是一帧一帧渲染出来的，下图中可以看到一帧的过程：</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/life-of-a-frame.PNG" alt=""></p>
<p>虽然上面是介绍 requestAnimationFrame 时用到的图片，但是也很详细的介绍到一帧里面浏览器都做了些什么，一帧里面除了上面干的活外就是空余时间 idle 了。可以看看 <a href="https://w3c.github.io/requestidlecallback/" target="_blank">W3C requestidlecallback 的介绍</a>:</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/frame-idle.PNG" alt=""></p>
<p>Layout 和 paint 就是我们常见的重排和重绘，也就是 render 的部分，而 Task 就包含了各种任务，包括输入处理，js 处理等等。完成这些事情还有多少时间剩余呢？一般是按照 60fps 来处理的。至于为什么是 60fps 呢，大多数浏览器遵循 W3C 所建议的刷新频率也就是 60fps 了，requestAnimationFrame 里面就是按照频率来的。60 fps 就已经能够保证看到的动画不会一卡一卡了。所以在一帧 16.66ms 的时间里面空闲的时间就是 requestIdleCallback 调用处理的阶段了。</p>
<h3>requestIdleCallback 参数</h3>
<p>MDN 里面介绍到语法，这里再提一下：</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> handle = <span class="hljs-built_in">window</span>.requestIdleCallback(callback[, options]);
</code></pre>
<p>callback 是要执行的回调函数，会传入 deadline 对象作为参数，deadline 包含：</p>
<ol>
<li>timeRemaining：剩余时间，单位 ms，指的是该帧剩余时间。</li>
<li>didTimeout：布尔型，true 表示该帧里面没有执行回调，超时了。</li>
</ol>
<p>options 里面有个重要参数 timeout，如果给定 timeout，那到了时间，不管有没有剩余时间，都会立刻执行回调 callback。</p>
<h2>React 中的实现</h2>
<p>先看两张 amazing 的图：
首先是 React 16 之前版本的
<img src="https://github.com/funfish/blog/raw/master/images/react15Stack.PNG" alt=""></p>
<p>在之前的版本里面，若 React 要开始更新的时候，就会处于深度调用的状态，程序会一直处理更新，而不会接受处理外部的输入。如果更新的层级多而深则会导致更新时间长的问题。到了 React 16 fiber 的阶段呢，如下所示；</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/react16AsyncFiber.PNG" alt=""></p>
<p>可以明显的看到每次处理完一部分之后，react 都会从非常深的调用栈上看看有没有其他优先要做的事情，有则开始做其他事情，如输入事件等等，结束后再回过头来继续之前的事情。是不是很神奇！这种时间丝滑般的设计，对于大量数据的渲染很有帮助。看看 react 中设计的 requestIdleCallback ployfill。</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> localRequestAnimationFrame = requestAnimationFrame;
<span class="hljs-comment">// 链表头部与尾部</span>
<span class="hljs-keyword">let</span>  headOfPendingCallbacksLinkedList = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">let</span>  tailOfPendingCallbacksLinkedList = <span class="hljs-literal">null</span>;
<span class="hljs-comment">// frameDeadlineObject 为传入callback的参数 deadline</span>
<span class="hljs-keyword">const</span> frameDeadlineObject = {
  <span class="hljs-attr">didTimeout</span>: <span class="hljs-literal">false</span>,
  timeRemaining() {
    <span class="hljs-comment">// 通过 frameDeadline 来判断，该帧剩余时间</span>
    <span class="hljs-keyword">const</span> remaining = frameDeadline - now();
    <span class="hljs-keyword">return</span> remaining &gt; <span class="hljs-number">0</span> ? remaining : <span class="hljs-number">0</span>;
  },
};
<span class="hljs-comment">// export 对外函数，也就是 requestIdleCallback ployfill</span>
scheduleWork = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, options</span>) </span>{
  <span class="hljs-keyword">const</span> timeoutTime = now() + options.timeout;
  <span class="hljs-keyword">const</span> scheduledCallbackConfig: CallbackConfigType = {
    <span class="hljs-attr">scheduledCallback</span>: callback,
    timeoutTime,
    <span class="hljs-attr">prev</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,
  };
  <span class="hljs-comment">// 省略将scheduledCallbackConfig插入到链表里面过程</span>
  <span class="hljs-keyword">if</span> (!isAnimationFrameScheduled) {
    isAnimationFrameScheduled = <span class="hljs-literal">true</span>;
    localRequestAnimationFrame(animationTick);
  }
}
<span class="hljs-comment">// requestAnimationFrame 调用函数</span>
<span class="hljs-keyword">const</span> animationTick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rafTime</span>) </span>{
  isAnimationFrameScheduled = <span class="hljs-literal">false</span>;
  <span class="hljs-comment">// 更新 frameDeadline</span>
  frameDeadline = rafTime + activeFrameTime;
  <span class="hljs-keyword">if</span> (!isIdleScheduled) {
    isIdleScheduled = <span class="hljs-literal">true</span>;
    <span class="hljs-built_in">window</span>.postMessage(messageKey, <span class="hljs-string">'*'</span>);
  }
}
<span class="hljs-comment">// 省略消息监听处理部分</span>

<span class="hljs-comment">// 执行 callback，与传参 deadline</span>
<span class="hljs-keyword">const</span> callUnsafely = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callbackConfig, arg</span>) </span>{
  <span class="hljs-keyword">const</span> callback = callbackConfig.scheduledCallback;
  callback(arg);
  <span class="hljs-comment">// 总是会删除调用过的 callbackConfig</span>
  cancelScheduledWork(callbackConfig);
}

cancelScheduledWork = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callbackConfig</span>) </span>{
  <span class="hljs-comment">// 在链表中删除对应节点，并维护好pre以及next关系</span>
}
</code></pre>
<p>可以看出这里是采用 requestAnimationFrame 来代替 requestIdleCallback，这也很好理解。关键地方在于 deadline 参数的传递。这里用了 frameDeadlineObject 来表示，每次 requestAnimationFrame 的时候都会更新 frameDeadlineObject 对象里面的 frameDeadline 基线。<strong>frameDeadline 正如其名，就是每次 requestAnimationFrame 开始的时间以及该帧时长之和。只要 <code>now()</code> 的时间大于它，自然是表示没有空闲时间。</strong></p>
<p>比如在一个帧里面，可能第一个 callback 运行时间过长，<code>frameDeadline - now()</code> 不为正数，则不会无法继续执行。程序会在下一帧开始的时候执行 input 事件什么的，若有空闲时间才执行 idle callback。</p>
<p>上文中通过链表的结构，每次都将传入的 callback 和 timeoutTime 保存起来，以 pre/next 的形式来维系。并在 callUnsafely 里面调用完之后就删除掉。回顾一下上面处理流程，通过 scheduleWork 传入 callback，用 requestAnimationFrame 方式第一次启用 animationTick，并用事件的方式 <code>window.postMessage</code> 消息的方式来调用。其中省略的消息监听的处理如下：</p>
<pre class="hljs"><code><span class="hljs-comment">// messageKey 为特点字符串</span>
<span class="hljs-keyword">const</span> idleTick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
  <span class="hljs-keyword">if</span> (event.source !== <span class="hljs-built_in">window</span> || event.data !== messageKey) {
    <span class="hljs-keyword">return</span>;
  }
  isIdleScheduled = <span class="hljs-literal">false</span>;
  callTimedOutCallbacks();
  <span class="hljs-keyword">let</span> currentTime = now();
  <span class="hljs-comment">// 空闲时间判断</span>
  <span class="hljs-keyword">while</span> (
    frameDeadline - currentTime &gt; <span class="hljs-number">0</span> &amp;&amp;
    headOfPendingCallbacksLinkedList !== <span class="hljs-literal">null</span>
  ) {
    <span class="hljs-keyword">const</span> latestCallbackConfig = headOfPendingCallbacksLinkedList;
    frameDeadlineObject.didTimeout = <span class="hljs-literal">false</span>;
    callUnsafely(latestCallbackConfig, frameDeadlineObject);
    currentTime = now();
  }
  <span class="hljs-comment">// 继续下一个节点，调用requestAnimationFrame</span>
  <span class="hljs-keyword">if</span> (
    !isAnimationFrameScheduled &amp;&amp;
    headOfPendingCallbacksLinkedList !== <span class="hljs-literal">null</span>
  ) {
    isAnimationFrameScheduled = <span class="hljs-literal">true</span>;
    localRequestAnimationFrame(animationTick);
  }
}
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, idleTick, <span class="hljs-literal">false</span>);
<span class="hljs-comment">// 如果设置了 timeoutTime 的话，自然是无脑执行到底的，而不会把时间让渡予下一帧</span>
<span class="hljs-keyword">const</span> callTimedOutCallbacks = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> currentTime = now();
  <span class="hljs-keyword">const</span> timedOutCallbacks = [];
  <span class="hljs-keyword">let</span> currentCallbackConfig = headOfPendingCallbacksLinkedList;
  <span class="hljs-keyword">while</span> (currentCallbackConfig !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">if</span> (timeoutTime !== <span class="hljs-number">-1</span> &amp;&amp; timeoutTime &lt;= currentTime) {
      timedOutCallbacks.push(currentCallbackConfig);
    }
  }
  <span class="hljs-comment">// 存在 timeoutTime 的事件，并且发生超时了，那就执行，不考虑帧的问题了</span>
  <span class="hljs-keyword">if</span> (timedOutCallbacks.length &gt; <span class="hljs-number">0</span>) {
    frameDeadlineObject.didTimeout = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = timedOutCallbacks.length; i &lt; len; i++) {
      callUnsafely(timedOutCallbacks[i], frameDeadlineObject);
    }
  }
}
</code></pre>
<p>animationTick 结合 idleTick 形成消息传递事件的发送方和接收方，同时也分别是 requestAnimationFrame 回调函数和触发函数。通过 messageKey 来识别是否是通知的自己。idleTick 里面的循环判断和 timeRemaining 相同，判断是否有空闲时间，有才进行 callUnsafely，执行 callback。</p>
<h2>fiber 与 requestIdleCallback</h2>
<p>在上面的代码好像都没有看到 timeRemaining 使用的地方哦，其实在 workLoop 里面才会有判断</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">workLoop</span>(<span class="hljs-params">isYieldy</span>) </span>{
  <span class="hljs-keyword">if</span>(isYield) {
    <span class="hljs-keyword">while</span> (nextUnitOfWork !== <span class="hljs-literal">null</span> &amp;&amp; !shouldYield()) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    }
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldYield</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (deadline === <span class="hljs-literal">null</span> || deadlineDidExpire) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">if</span> (deadline.timeRemaining() &gt; <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  deadlineDidExpire = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</code></pre>
<p>对于异步更新的每次执行 performUnitOfWork 前都会判断一次是否有空余时间，有才会继续。通过这个地方判断是否有空闲时间。</p>
<p>前者 idleTick 里面是在初始化的时候判断，能否立马执行 performWork 函数，以及在该帧里面能够执行链表的下一个 performWork。
后则 workLoop 是在 render/reconcilation 阶段的 workLoop 循环里面判断空闲时间，有就继续。当然在第二个阶段 commit 是没有检查空闲时间过程的。从而实现了之前版本没有现实的方式。当一次组件更新时间较长的时候，仍然运行 input 等操作，同时，<strong>更重要的是不会发生局部更新</strong>。事件能打断的只是 render/reconcilation 阶段，这个阶段不会发生任何的真实 DOM 的变化。这也是调度里面最神奇的地方，空闲时间的检查仅仅发生在 render/reconcilation 阶段。</p>
<p>只是该阶段还是会执行 ComponentWillUpdate 这些生命钩子，well，react 团队表示着没有关系。</p>
<p><strong>于是到了timeRemaining之后，render/reconcilation 阶段就会被打断，继续处理浏览器的其他输入事件。并在输入后执行</strong></p>
<h3>expirationTime 与优先级别</h3>
<p>之前我们计算 expirationTime，都是按照同步来算的，也就是值为 1（SYNC）。既然是同步自然就不需要调度来控制任务系统了。当 <code>expirationTime !== SYNC</code> 的时候，才进入 requestIdleCallback 的任务调度</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestWork</span>(<span class="hljs-params">root, expirationTime</span>) </span>{
  <span class="hljs-keyword">if</span> (expirationTime === Sync) {
    performSyncWork();
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 进入调度</span>
    scheduleCallbackWithExpirationTime(expirationTime);
  }
}
</code></pre>
<p>这里的 expirationTime 是 <code>root.expirationTime</code>。也就是说 React 当前是处于同步还是调度模式，是由 root 的 expirationTime 决定的。这也就是说明了其模式分两种，一种是同步，一种是调度。而调度的优先级将取决于 expirationTime。</p>
<p>##总结
本文更多的只是结合 requestIdleCallback 来介绍异步相关过程，但是更多的内容还是没有介绍到，将放在下篇文章 <a href="https://github.com/funfish/blog/blob/master/31.%20react%20%E5%BC%80%E5%90%AF%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7.md" target="_blank">react 开启异步渲染与优先级</a> 介绍到。</p>
<h2>参考</h2>
<ol>
<li><a href="https://w3c.github.io/requestidlecallback/" target="_blank">W3C requestidlecallback</a></li>
<li><a href="https://medium.com/@paul_irish/requestanimationframe-scheduling-for-nerds-9c57f7438ef4" target="_blank">requestAnimationFrame Scheduling For Nerds</a></li>
</ol>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"March 24, 2021","title":"react 时间调度","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e继续前面两篇 react 的分析。提到 react 16，除了 fiber 机制之外，还有其调度机制。这里就不得不提 requestIdleCallback 了，react 采用了 requestIdleCallback 的思想来实现调度，为什么说思想呢，因为 requestIdleCallback 是新出的 api，兼容性差，很多现代浏览器都不支持。于是 react 团队就写了一个 ployfill。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/requestIdleCallback-caniuse.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch2\u003erequestIdleCallback\u003c/h2\u003e\n\u003cp\u003e关于 requestIdleCallback，请先看看 \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback\" target=\"_blank\"\u003eMDN 上面的介绍\u003c/a\u003e。requestIdleCallback 的出现意使得浏览器可以在空闲的时候执行 callback，这对单线程的 V8 而言就相当又用了。假设你需要大量涉及到 DOM 的操作的计算，在运算时，浏览器可能就会出现明显的卡顿行为，甚至不能进行任何操作，因为是单线程，就算用\u003c/p\u003e\n\u003cp\u003e在输入处理，给定帧渲染和合成之后，用户的主线程就会变得空闲，直到下一帧的开始，或者有优先的待处理任务，或者是存在输入。用户所看到的页面都是一帧一帧渲染出来的，下图中可以看到一帧的过程：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/life-of-a-frame.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e虽然上面是介绍 requestAnimationFrame 时用到的图片，但是也很详细的介绍到一帧里面浏览器都做了些什么，一帧里面除了上面干的活外就是空余时间 idle 了。可以看看 \u003ca href=\"https://w3c.github.io/requestidlecallback/\" target=\"_blank\"\u003eW3C requestidlecallback 的介绍\u003c/a\u003e:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/frame-idle.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eLayout 和 paint 就是我们常见的重排和重绘，也就是 render 的部分，而 Task 就包含了各种任务，包括输入处理，js 处理等等。完成这些事情还有多少时间剩余呢？一般是按照 60fps 来处理的。至于为什么是 60fps 呢，大多数浏览器遵循 W3C 所建议的刷新频率也就是 60fps 了，requestAnimationFrame 里面就是按照频率来的。60 fps 就已经能够保证看到的动画不会一卡一卡了。所以在一帧 16.66ms 的时间里面空闲的时间就是 requestIdleCallback 调用处理的阶段了。\u003c/p\u003e\n\u003ch3\u003erequestIdleCallback 参数\u003c/h3\u003e\n\u003cp\u003eMDN 里面介绍到语法，这里再提一下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e handle = \u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e.requestIdleCallback(callback[, options]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecallback 是要执行的回调函数，会传入 deadline 对象作为参数，deadline 包含：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003etimeRemaining：剩余时间，单位 ms，指的是该帧剩余时间。\u003c/li\u003e\n\u003cli\u003edidTimeout：布尔型，true 表示该帧里面没有执行回调，超时了。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eoptions 里面有个重要参数 timeout，如果给定 timeout，那到了时间，不管有没有剩余时间，都会立刻执行回调 callback。\u003c/p\u003e\n\u003ch2\u003eReact 中的实现\u003c/h2\u003e\n\u003cp\u003e先看两张 amazing 的图：\n首先是 React 16 之前版本的\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/react15Stack.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e在之前的版本里面，若 React 要开始更新的时候，就会处于深度调用的状态，程序会一直处理更新，而不会接受处理外部的输入。如果更新的层级多而深则会导致更新时间长的问题。到了 React 16 fiber 的阶段呢，如下所示；\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/react16AsyncFiber.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e可以明显的看到每次处理完一部分之后，react 都会从非常深的调用栈上看看有没有其他优先要做的事情，有则开始做其他事情，如输入事件等等，结束后再回过头来继续之前的事情。是不是很神奇！这种时间丝滑般的设计，对于大量数据的渲染很有帮助。看看 react 中设计的 requestIdleCallback ployfill。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e localRequestAnimationFrame = requestAnimationFrame;\n\u003cspan class=\"hljs-comment\"\u003e// 链表头部与尾部\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e  headOfPendingCallbacksLinkedList = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e  tailOfPendingCallbacksLinkedList = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// frameDeadlineObject 为传入callback的参数 deadline\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e frameDeadlineObject = {\n  \u003cspan class=\"hljs-attr\"\u003edidTimeout\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n  timeRemaining() {\n    \u003cspan class=\"hljs-comment\"\u003e// 通过 frameDeadline 来判断，该帧剩余时间\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e remaining = frameDeadline - now();\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e remaining \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e ? remaining : \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  },\n};\n\u003cspan class=\"hljs-comment\"\u003e// export 对外函数，也就是 requestIdleCallback ployfill\u003c/span\u003e\nscheduleWork = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecallback, options\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e timeoutTime = now() + options.timeout;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e scheduledCallbackConfig: CallbackConfigType = {\n    \u003cspan class=\"hljs-attr\"\u003escheduledCallback\u003c/span\u003e: callback,\n    timeoutTime,\n    \u003cspan class=\"hljs-attr\"\u003eprev\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n  };\n  \u003cspan class=\"hljs-comment\"\u003e// 省略将scheduledCallbackConfig插入到链表里面过程\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isAnimationFrameScheduled) {\n    isAnimationFrameScheduled = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    localRequestAnimationFrame(animationTick);\n  }\n}\n\u003cspan class=\"hljs-comment\"\u003e// requestAnimationFrame 调用函数\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e animationTick = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erafTime\u003c/span\u003e) \u003c/span\u003e{\n  isAnimationFrameScheduled = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// 更新 frameDeadline\u003c/span\u003e\n  frameDeadline = rafTime + activeFrameTime;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isIdleScheduled) {\n    isIdleScheduled = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    \u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e.postMessage(messageKey, \u003cspan class=\"hljs-string\"\u003e'*'\u003c/span\u003e);\n  }\n}\n\u003cspan class=\"hljs-comment\"\u003e// 省略消息监听处理部分\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 执行 callback，与传参 deadline\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e callUnsafely = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecallbackConfig, arg\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e callback = callbackConfig.scheduledCallback;\n  callback(arg);\n  \u003cspan class=\"hljs-comment\"\u003e// 总是会删除调用过的 callbackConfig\u003c/span\u003e\n  cancelScheduledWork(callbackConfig);\n}\n\ncancelScheduledWork = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecallbackConfig\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 在链表中删除对应节点，并维护好pre以及next关系\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看出这里是采用 requestAnimationFrame 来代替 requestIdleCallback，这也很好理解。关键地方在于 deadline 参数的传递。这里用了 frameDeadlineObject 来表示，每次 requestAnimationFrame 的时候都会更新 frameDeadlineObject 对象里面的 frameDeadline 基线。\u003cstrong\u003eframeDeadline 正如其名，就是每次 requestAnimationFrame 开始的时间以及该帧时长之和。只要 \u003ccode\u003enow()\u003c/code\u003e 的时间大于它，自然是表示没有空闲时间。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e比如在一个帧里面，可能第一个 callback 运行时间过长，\u003ccode\u003eframeDeadline - now()\u003c/code\u003e 不为正数，则不会无法继续执行。程序会在下一帧开始的时候执行 input 事件什么的，若有空闲时间才执行 idle callback。\u003c/p\u003e\n\u003cp\u003e上文中通过链表的结构，每次都将传入的 callback 和 timeoutTime 保存起来，以 pre/next 的形式来维系。并在 callUnsafely 里面调用完之后就删除掉。回顾一下上面处理流程，通过 scheduleWork 传入 callback，用 requestAnimationFrame 方式第一次启用 animationTick，并用事件的方式 \u003ccode\u003ewindow.postMessage\u003c/code\u003e 消息的方式来调用。其中省略的消息监听的处理如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// messageKey 为特点字符串\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e idleTick = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (event.source !== \u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e || event.data !== messageKey) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n  }\n  isIdleScheduled = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  callTimedOutCallbacks();\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e currentTime = now();\n  \u003cspan class=\"hljs-comment\"\u003e// 空闲时间判断\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (\n    frameDeadline - currentTime \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u0026amp;\u0026amp;\n    headOfPendingCallbacksLinkedList !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n  ) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e latestCallbackConfig = headOfPendingCallbacksLinkedList;\n    frameDeadlineObject.didTimeout = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    callUnsafely(latestCallbackConfig, frameDeadlineObject);\n    currentTime = now();\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 继续下一个节点，调用requestAnimationFrame\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n    !isAnimationFrameScheduled \u0026amp;\u0026amp;\n    headOfPendingCallbacksLinkedList !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n  ) {\n    isAnimationFrameScheduled = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    localRequestAnimationFrame(animationTick);\n  }\n}\n\u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e.addEventListener(\u003cspan class=\"hljs-string\"\u003e'message'\u003c/span\u003e, idleTick, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 如果设置了 timeoutTime 的话，自然是无脑执行到底的，而不会把时间让渡予下一帧\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e callTimedOutCallbacks = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e currentTime = now();\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e timedOutCallbacks = [];\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e currentCallbackConfig = headOfPendingCallbacksLinkedList;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (currentCallbackConfig !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (timeoutTime !== \u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e \u0026amp;\u0026amp; timeoutTime \u0026lt;= currentTime) {\n      timedOutCallbacks.push(currentCallbackConfig);\n    }\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 存在 timeoutTime 的事件，并且发生超时了，那就执行，不考虑帧的问题了\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (timedOutCallbacks.length \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    frameDeadlineObject.didTimeout = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, len = timedOutCallbacks.length; i \u0026lt; len; i++) {\n      callUnsafely(timedOutCallbacks[i], frameDeadlineObject);\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eanimationTick 结合 idleTick 形成消息传递事件的发送方和接收方，同时也分别是 requestAnimationFrame 回调函数和触发函数。通过 messageKey 来识别是否是通知的自己。idleTick 里面的循环判断和 timeRemaining 相同，判断是否有空闲时间，有才进行 callUnsafely，执行 callback。\u003c/p\u003e\n\u003ch2\u003efiber 与 requestIdleCallback\u003c/h2\u003e\n\u003cp\u003e在上面的代码好像都没有看到 timeRemaining 使用的地方哦，其实在 workLoop 里面才会有判断\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eworkLoop\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eisYieldy\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(isYield) {\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (nextUnitOfWork !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026amp;\u0026amp; !shouldYield()) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n  }\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eshouldYield\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (deadline === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e || deadlineDidExpire) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (deadline.timeRemaining() \u0026gt; \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  }\n  deadlineDidExpire = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于异步更新的每次执行 performUnitOfWork 前都会判断一次是否有空余时间，有才会继续。通过这个地方判断是否有空闲时间。\u003c/p\u003e\n\u003cp\u003e前者 idleTick 里面是在初始化的时候判断，能否立马执行 performWork 函数，以及在该帧里面能够执行链表的下一个 performWork。\n后则 workLoop 是在 render/reconcilation 阶段的 workLoop 循环里面判断空闲时间，有就继续。当然在第二个阶段 commit 是没有检查空闲时间过程的。从而实现了之前版本没有现实的方式。当一次组件更新时间较长的时候，仍然运行 input 等操作，同时，\u003cstrong\u003e更重要的是不会发生局部更新\u003c/strong\u003e。事件能打断的只是 render/reconcilation 阶段，这个阶段不会发生任何的真实 DOM 的变化。这也是调度里面最神奇的地方，空闲时间的检查仅仅发生在 render/reconcilation 阶段。\u003c/p\u003e\n\u003cp\u003e只是该阶段还是会执行 ComponentWillUpdate 这些生命钩子，well，react 团队表示着没有关系。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e于是到了timeRemaining之后，render/reconcilation 阶段就会被打断，继续处理浏览器的其他输入事件。并在输入后执行\u003c/strong\u003e\u003c/p\u003e\n\u003ch3\u003eexpirationTime 与优先级别\u003c/h3\u003e\n\u003cp\u003e之前我们计算 expirationTime，都是按照同步来算的，也就是值为 1（SYNC）。既然是同步自然就不需要调度来控制任务系统了。当 \u003ccode\u003eexpirationTime !== SYNC\u003c/code\u003e 的时候，才进入 requestIdleCallback 的任务调度\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erequestWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eroot, expirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (expirationTime === Sync) {\n    performSyncWork();\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 进入调度\u003c/span\u003e\n    scheduleCallbackWithExpirationTime(expirationTime);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里的 expirationTime 是 \u003ccode\u003eroot.expirationTime\u003c/code\u003e。也就是说 React 当前是处于同步还是调度模式，是由 root 的 expirationTime 决定的。这也就是说明了其模式分两种，一种是同步，一种是调度。而调度的优先级将取决于 expirationTime。\u003c/p\u003e\n\u003cp\u003e##总结\n本文更多的只是结合 requestIdleCallback 来介绍异步相关过程，但是更多的内容还是没有介绍到，将放在下篇文章 \u003ca href=\"https://github.com/funfish/blog/blob/master/31.%20react%20%E5%BC%80%E5%90%AF%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7.md\" target=\"_blank\"\u003ereact 开启异步渲染与优先级\u003c/a\u003e 介绍到。\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://w3c.github.io/requestidlecallback/\" target=\"_blank\"\u003eW3C requestidlecallback\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://medium.com/@paul_irish/requestanimationframe-scheduling-for-nerds-9c57f7438ef4\" target=\"_blank\"\u003erequestAnimationFrame Scheduling For Nerds\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"March 24, 2021","title":"react 时间调度","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e继续前面两篇 react 的分析。提到 react 16，除了 fiber 机制之外，还有其调度机制。这里就不得不提 requestIdleCallback 了，react 采用了 requestIdleCallback 的思想来实现调度，为什么说思想呢，因为 requestIdleCallback 是新出的 api，兼容性差，很多现代浏览器都不支持。于是 react 团队就写了一个 ployfill。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/requestIdleCallback-caniuse.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch2\u003erequestIdleCallback\u003c/h2\u003e\n\u003cp\u003e关于 requestIdleCallback，请先看看 \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback\" target=\"_blank\"\u003eMDN 上面的介绍\u003c/a\u003e。requestIdleCallback 的出现意使得浏览器可以在空闲的时候执行 callback，这对单线程的 V8 而言就相当又用了。假设你需要大量涉及到 DOM 的操作的计算，在运算时，浏览器可能就会出现明显的卡顿行为，甚至不能进行任何操作，因为是单线程，就算用\u003c/p\u003e\n\u003cp\u003e在输入处理，给定帧渲染和合成之后，用户的主线程就会变得空闲，直到下一帧的开始，或者有优先的待处理任务，或者是存在输入。用户所看到的页面都是一帧一帧渲染出来的，下图中可以看到一帧的过程：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/life-of-a-frame.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e虽然上面是介绍 requestAnimationFrame 时用到的图片，但是也很详细的介绍到一帧里面浏览器都做了些什么，一帧里面除了上面干的活外就是空余时间 idle 了。可以看看 \u003ca href=\"https://w3c.github.io/requestidlecallback/\" target=\"_blank\"\u003eW3C requestidlecallback 的介绍\u003c/a\u003e:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/frame-idle.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eLayout 和 paint 就是我们常见的重排和重绘，也就是 render 的部分，而 Task 就包含了各种任务，包括输入处理，js 处理等等。完成这些事情还有多少时间剩余呢？一般是按照 60fps 来处理的。至于为什么是 60fps 呢，大多数浏览器遵循 W3C 所建议的刷新频率也就是 60fps 了，requestAnimationFrame 里面就是按照频率来的。60 fps 就已经能够保证看到的动画不会一卡一卡了。所以在一帧 16.66ms 的时间里面空闲的时间就是 requestIdleCallback 调用处理的阶段了。\u003c/p\u003e\n\u003ch3\u003erequestIdleCallback 参数\u003c/h3\u003e\n\u003cp\u003eMDN 里面介绍到语法，这里再提一下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e handle = \u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e.requestIdleCallback(callback[, options]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecallback 是要执行的回调函数，会传入 deadline 对象作为参数，deadline 包含：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003etimeRemaining：剩余时间，单位 ms，指的是该帧剩余时间。\u003c/li\u003e\n\u003cli\u003edidTimeout：布尔型，true 表示该帧里面没有执行回调，超时了。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eoptions 里面有个重要参数 timeout，如果给定 timeout，那到了时间，不管有没有剩余时间，都会立刻执行回调 callback。\u003c/p\u003e\n\u003ch2\u003eReact 中的实现\u003c/h2\u003e\n\u003cp\u003e先看两张 amazing 的图：\n首先是 React 16 之前版本的\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/react15Stack.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e在之前的版本里面，若 React 要开始更新的时候，就会处于深度调用的状态，程序会一直处理更新，而不会接受处理外部的输入。如果更新的层级多而深则会导致更新时间长的问题。到了 React 16 fiber 的阶段呢，如下所示；\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/react16AsyncFiber.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e可以明显的看到每次处理完一部分之后，react 都会从非常深的调用栈上看看有没有其他优先要做的事情，有则开始做其他事情，如输入事件等等，结束后再回过头来继续之前的事情。是不是很神奇！这种时间丝滑般的设计，对于大量数据的渲染很有帮助。看看 react 中设计的 requestIdleCallback ployfill。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e localRequestAnimationFrame = requestAnimationFrame;\n\u003cspan class=\"hljs-comment\"\u003e// 链表头部与尾部\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e  headOfPendingCallbacksLinkedList = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e  tailOfPendingCallbacksLinkedList = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// frameDeadlineObject 为传入callback的参数 deadline\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e frameDeadlineObject = {\n  \u003cspan class=\"hljs-attr\"\u003edidTimeout\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n  timeRemaining() {\n    \u003cspan class=\"hljs-comment\"\u003e// 通过 frameDeadline 来判断，该帧剩余时间\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e remaining = frameDeadline - now();\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e remaining \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e ? remaining : \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  },\n};\n\u003cspan class=\"hljs-comment\"\u003e// export 对外函数，也就是 requestIdleCallback ployfill\u003c/span\u003e\nscheduleWork = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecallback, options\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e timeoutTime = now() + options.timeout;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e scheduledCallbackConfig: CallbackConfigType = {\n    \u003cspan class=\"hljs-attr\"\u003escheduledCallback\u003c/span\u003e: callback,\n    timeoutTime,\n    \u003cspan class=\"hljs-attr\"\u003eprev\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n  };\n  \u003cspan class=\"hljs-comment\"\u003e// 省略将scheduledCallbackConfig插入到链表里面过程\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isAnimationFrameScheduled) {\n    isAnimationFrameScheduled = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    localRequestAnimationFrame(animationTick);\n  }\n}\n\u003cspan class=\"hljs-comment\"\u003e// requestAnimationFrame 调用函数\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e animationTick = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erafTime\u003c/span\u003e) \u003c/span\u003e{\n  isAnimationFrameScheduled = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// 更新 frameDeadline\u003c/span\u003e\n  frameDeadline = rafTime + activeFrameTime;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isIdleScheduled) {\n    isIdleScheduled = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    \u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e.postMessage(messageKey, \u003cspan class=\"hljs-string\"\u003e'*'\u003c/span\u003e);\n  }\n}\n\u003cspan class=\"hljs-comment\"\u003e// 省略消息监听处理部分\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 执行 callback，与传参 deadline\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e callUnsafely = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecallbackConfig, arg\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e callback = callbackConfig.scheduledCallback;\n  callback(arg);\n  \u003cspan class=\"hljs-comment\"\u003e// 总是会删除调用过的 callbackConfig\u003c/span\u003e\n  cancelScheduledWork(callbackConfig);\n}\n\ncancelScheduledWork = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecallbackConfig\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 在链表中删除对应节点，并维护好pre以及next关系\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看出这里是采用 requestAnimationFrame 来代替 requestIdleCallback，这也很好理解。关键地方在于 deadline 参数的传递。这里用了 frameDeadlineObject 来表示，每次 requestAnimationFrame 的时候都会更新 frameDeadlineObject 对象里面的 frameDeadline 基线。\u003cstrong\u003eframeDeadline 正如其名，就是每次 requestAnimationFrame 开始的时间以及该帧时长之和。只要 \u003ccode\u003enow()\u003c/code\u003e 的时间大于它，自然是表示没有空闲时间。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e比如在一个帧里面，可能第一个 callback 运行时间过长，\u003ccode\u003eframeDeadline - now()\u003c/code\u003e 不为正数，则不会无法继续执行。程序会在下一帧开始的时候执行 input 事件什么的，若有空闲时间才执行 idle callback。\u003c/p\u003e\n\u003cp\u003e上文中通过链表的结构，每次都将传入的 callback 和 timeoutTime 保存起来，以 pre/next 的形式来维系。并在 callUnsafely 里面调用完之后就删除掉。回顾一下上面处理流程，通过 scheduleWork 传入 callback，用 requestAnimationFrame 方式第一次启用 animationTick，并用事件的方式 \u003ccode\u003ewindow.postMessage\u003c/code\u003e 消息的方式来调用。其中省略的消息监听的处理如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// messageKey 为特点字符串\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e idleTick = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (event.source !== \u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e || event.data !== messageKey) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n  }\n  isIdleScheduled = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  callTimedOutCallbacks();\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e currentTime = now();\n  \u003cspan class=\"hljs-comment\"\u003e// 空闲时间判断\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (\n    frameDeadline - currentTime \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u0026amp;\u0026amp;\n    headOfPendingCallbacksLinkedList !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n  ) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e latestCallbackConfig = headOfPendingCallbacksLinkedList;\n    frameDeadlineObject.didTimeout = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    callUnsafely(latestCallbackConfig, frameDeadlineObject);\n    currentTime = now();\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 继续下一个节点，调用requestAnimationFrame\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n    !isAnimationFrameScheduled \u0026amp;\u0026amp;\n    headOfPendingCallbacksLinkedList !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n  ) {\n    isAnimationFrameScheduled = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    localRequestAnimationFrame(animationTick);\n  }\n}\n\u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e.addEventListener(\u003cspan class=\"hljs-string\"\u003e'message'\u003c/span\u003e, idleTick, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 如果设置了 timeoutTime 的话，自然是无脑执行到底的，而不会把时间让渡予下一帧\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e callTimedOutCallbacks = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e currentTime = now();\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e timedOutCallbacks = [];\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e currentCallbackConfig = headOfPendingCallbacksLinkedList;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (currentCallbackConfig !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (timeoutTime !== \u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e \u0026amp;\u0026amp; timeoutTime \u0026lt;= currentTime) {\n      timedOutCallbacks.push(currentCallbackConfig);\n    }\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 存在 timeoutTime 的事件，并且发生超时了，那就执行，不考虑帧的问题了\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (timedOutCallbacks.length \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    frameDeadlineObject.didTimeout = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, len = timedOutCallbacks.length; i \u0026lt; len; i++) {\n      callUnsafely(timedOutCallbacks[i], frameDeadlineObject);\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eanimationTick 结合 idleTick 形成消息传递事件的发送方和接收方，同时也分别是 requestAnimationFrame 回调函数和触发函数。通过 messageKey 来识别是否是通知的自己。idleTick 里面的循环判断和 timeRemaining 相同，判断是否有空闲时间，有才进行 callUnsafely，执行 callback。\u003c/p\u003e\n\u003ch2\u003efiber 与 requestIdleCallback\u003c/h2\u003e\n\u003cp\u003e在上面的代码好像都没有看到 timeRemaining 使用的地方哦，其实在 workLoop 里面才会有判断\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eworkLoop\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eisYieldy\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(isYield) {\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (nextUnitOfWork !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026amp;\u0026amp; !shouldYield()) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n  }\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eshouldYield\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (deadline === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e || deadlineDidExpire) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (deadline.timeRemaining() \u0026gt; \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  }\n  deadlineDidExpire = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于异步更新的每次执行 performUnitOfWork 前都会判断一次是否有空余时间，有才会继续。通过这个地方判断是否有空闲时间。\u003c/p\u003e\n\u003cp\u003e前者 idleTick 里面是在初始化的时候判断，能否立马执行 performWork 函数，以及在该帧里面能够执行链表的下一个 performWork。\n后则 workLoop 是在 render/reconcilation 阶段的 workLoop 循环里面判断空闲时间，有就继续。当然在第二个阶段 commit 是没有检查空闲时间过程的。从而实现了之前版本没有现实的方式。当一次组件更新时间较长的时候，仍然运行 input 等操作，同时，\u003cstrong\u003e更重要的是不会发生局部更新\u003c/strong\u003e。事件能打断的只是 render/reconcilation 阶段，这个阶段不会发生任何的真实 DOM 的变化。这也是调度里面最神奇的地方，空闲时间的检查仅仅发生在 render/reconcilation 阶段。\u003c/p\u003e\n\u003cp\u003e只是该阶段还是会执行 ComponentWillUpdate 这些生命钩子，well，react 团队表示着没有关系。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e于是到了timeRemaining之后，render/reconcilation 阶段就会被打断，继续处理浏览器的其他输入事件。并在输入后执行\u003c/strong\u003e\u003c/p\u003e\n\u003ch3\u003eexpirationTime 与优先级别\u003c/h3\u003e\n\u003cp\u003e之前我们计算 expirationTime，都是按照同步来算的，也就是值为 1（SYNC）。既然是同步自然就不需要调度来控制任务系统了。当 \u003ccode\u003eexpirationTime !== SYNC\u003c/code\u003e 的时候，才进入 requestIdleCallback 的任务调度\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erequestWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eroot, expirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (expirationTime === Sync) {\n    performSyncWork();\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 进入调度\u003c/span\u003e\n    scheduleCallbackWithExpirationTime(expirationTime);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里的 expirationTime 是 \u003ccode\u003eroot.expirationTime\u003c/code\u003e。也就是说 React 当前是处于同步还是调度模式，是由 root 的 expirationTime 决定的。这也就是说明了其模式分两种，一种是同步，一种是调度。而调度的优先级将取决于 expirationTime。\u003c/p\u003e\n\u003cp\u003e##总结\n本文更多的只是结合 requestIdleCallback 来介绍异步相关过程，但是更多的内容还是没有介绍到，将放在下篇文章 \u003ca href=\"https://github.com/funfish/blog/blob/master/31.%20react%20%E5%BC%80%E5%90%AF%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7.md\" target=\"_blank\"\u003ereact 开启异步渲染与优先级\u003c/a\u003e 介绍到。\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://w3c.github.io/requestidlecallback/\" target=\"_blank\"\u003eW3C requestidlecallback\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://medium.com/@paul_irish/requestanimationframe-scheduling-for-nerds-9c57f7438ef4\" target=\"_blank\"\u003erequestAnimationFrame Scheduling For Nerds\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n"}},"buildId":"r4Ww0YLm8YL5~6SwciWHH","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" async=""></script></body></html>