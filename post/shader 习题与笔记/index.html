<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">shader 习题与笔记</title><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.587c5e31.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___2dTZ9 hasBannerImg___38HzA"><a class="logo___346dE" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___13XXt" href="/blog-sys/">Home</a></li></ul></nav><header style="background-image:url(https://github.com/funfish/blog/raw/master/images/shaderGfx00.jpg);background-size:contain" class="banner___2amdC"><div class="mask___1yJbK"></div><div class="postTitleWrap___1dXon"><h1 class="postTitle___1_m4g">shader 习题与笔记</h1><p>March 24, 2021</p></div></header><article class="postWrapper___3jnNg post-article"><div><p>从元旦就开始学习 WebGL，只是网上的资料很少，没有相关的课程，three.js 还好一点，更多的是关于 OpenGL 的书。最后看了看有：<a href="http://taobaofed.org/blog/2015/12/21/webgl-handbook/" target="_blank">WebGL 技术储备指南</a> 这篇介绍入门，网上首推资料 <a href="http://learnwebgl.brown37.net/" target="_blank">Learn WebGL</a>，还有同人翻译的书 WebGL编程指南。</p>
<p>一个月的时间看完了上述内容，Learn WebGL 后面几章觉得意义不大就没有继续学习了。只是学了，做了 demo 之后很是困惑，学的 WebGL 和工作关系有点难联系上，最低也要用 three.js，难道这就要上手 three.js 吗？直到后面发现了 <a href="https://github.com/patriciogonzalezvivo/thebookofshaders" target="_blank">thebookofshaders</a>。之前学的基本都是以顶点着色器为主，对片元着色器的进一步介绍很少，而片元着色器和我的日常工作更加有关系。thebookofshaders 刚好有中文版，只是原文残缺，没有对 纹理/模拟/3D图形 的继续介绍。</p>
<p>前面部分比较基础，也好理解，加上其他的 webgl 基础内容这里就不介绍了。下面介绍 生成设计 里面的部分内容及课后习题：</p>
<h3>技术</h3>
<p>沿着 thebookofshaders 里面的内容学习，会用到两个基本的库，同样的都是出自作者 Patricio Gonzalez Vivo：glslCanvas（加载 webgl 的通用库），glslEditor（实时渲染的辅助调试工具）。这些作者已经在电子资料里面用到了，平时只要在线修改代码调试就好了。</p>
<h2>随机 random</h2>
<p>这里介绍的随机，不是真正的随机，包括文中接下来的部分都是 <strong>伪随机</strong> ，意味着同样的输入，会有同样的输出，并且在 x 值附近具有 <strong>连续性</strong>。这是和以前用的 <code>Math.random</code> 的随机是不一样的。</p>
<pre class="hljs"><code><span class="hljs-comment">// 一维随机 </span>
<span class="hljs-type">float</span> random (<span class="hljs-type">float</span> x) {
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">fract</span>(<span class="hljs-built_in">sin</span>(x) * <span class="hljs-number">1e4</span>);
}

<span class="hljs-comment">// 2D 随机</span>
<span class="hljs-type">float</span> random (<span class="hljs-type">vec2</span> st) {
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">fract</span>(<span class="hljs-built_in">sin</span>(<span class="hljs-built_in">dot</span>(st.xy, <span class="hljs-type">vec2</span>(<span class="hljs-number">12.9898</span>,<span class="hljs-number">78.233</span>))) * <span class="hljs-number">43758.5453123</span>);
}
</code></pre>
<p>由上面代码就可以看出来，这是确定性随机。这样的随机要如何利用？关键是同样的输入会有同样的输出，于是，可以传入 x 的整数部分来随机分块。具体可以看以下联系：</p>
<ol>
<li>做按行随机移动的单元（以相反方向）。只显示亮一些的单元。让各行的速度随时间变化
<img src="https://github.com/funfish/blog/raw/master/images/shader10.1.PNG" alt=""></li>
</ol>
<pre class="hljs"><code><span class="hljs-meta">#define TIMEPERIOD .2</span>

<span class="hljs-type">void</span> main() {
  <span class="hljs-type">vec2</span> st = <span class="hljs-built_in">gl_FragCoord</span>.xy / u_resolution.xy;
    
  <span class="hljs-type">float</span> speed = <span class="hljs-number">0.</span>;
  <span class="hljs-type">float</span> xRate = <span class="hljs-number">0.</span>;
  <span class="hljs-type">float</span> floorTimeRate = random(<span class="hljs-built_in">floor</span>(u_time * TIMEPERIOD));
  <span class="hljs-type">float</span> fractTimeRate = <span class="hljs-built_in">fract</span>(u_time * TIMEPERIOD);

  <span class="hljs-keyword">if</span> (st.y &gt; <span class="hljs-number">0.5</span>) {
    xRate = floorTimeRate * <span class="hljs-number">50.</span> + <span class="hljs-number">10.</span>;
    speed = floorTimeRate * <span class="hljs-number">2.</span>+ <span class="hljs-number">2.</span>; 
  } <span class="hljs-keyword">else</span> {
    xRate = -floorTimeRate * <span class="hljs-number">50.</span> + <span class="hljs-number">60.</span>;
    speed = -floorTimeRate * <span class="hljs-number">2.</span> - <span class="hljs-number">2.</span>; 
  }
  st.x = st.x + fractTimeRate * speed;
  
  <span class="hljs-type">float</span> floorX = random(<span class="hljs-built_in">floor</span>(st.x * xRate)) * <span class="hljs-number">4.</span>;
  <span class="hljs-type">float</span> randomX = <span class="hljs-built_in">step</span>(<span class="hljs-number">0.20</span>, floorX);
  <span class="hljs-type">vec3</span> color = <span class="hljs-type">vec3</span>(randomX);

  <span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(color,<span class="hljs-number">1.0</span>);
}
</code></pre>
<p>这里 xRate 代表黑线放大的倍数，speed 则是黑线的移动速度，其中速度和放大倍数要随着时间变化而变化，图中上下两部分要分开处理。</p>
<ol start="2">
<li>同样地，让某几行以不同的速度和方向。用鼠标位置关联显示单元的阀值。
<img src="https://github.com/funfish/blog/raw/master/images/shader10.2.PNG" alt=""></li>
</ol>
<pre class="hljs"><code><span class="hljs-type">void</span> main() {
  <span class="hljs-type">vec2</span> st = <span class="hljs-built_in">gl_FragCoord</span>.xy / u_resolution.xy;
  st.x *= u_resolution.x / u_resolution.y;
  <span class="hljs-type">float</span> mouseX = u_mouse.x / u_resolution.x;
  <span class="hljs-type">float</span> thresholdX = <span class="hljs-number">0.5</span> + mouseX / <span class="hljs-number">2.</span>;
  
  <span class="hljs-type">vec2</span> grid = <span class="hljs-type">vec2</span>(<span class="hljs-number">100.0</span>, <span class="hljs-number">50.</span>);
  st *= grid;
  
  <span class="hljs-type">float</span> positionX = (st.x - u_time * <span class="hljs-number">60.</span> * random(<span class="hljs-built_in">floor</span>(st.y))) * random   (<span class="hljs-built_in">floor</span>(st.y)) / <span class="hljs-number">1.5</span>;
  <span class="hljs-type">float</span> randomX = <span class="hljs-built_in">step</span>(thresholdX, random(<span class="hljs-built_in">floor</span>(positionX))) ;
  <span class="hljs-type">vec2</span> fpos = <span class="hljs-built_in">fract</span>(st);
  
  <span class="hljs-type">vec3</span> color = <span class="hljs-type">vec3</span>(randomX);
  
  <span class="hljs-comment">// Y轴的每一行产生白边</span>
  color *= <span class="hljs-built_in">step</span>(<span class="hljs-number">0.2</span>, fpos.y);
  <span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span> - color, <span class="hljs-number">1.0</span>);
}
</code></pre>
<p>x 轴的黑色部分宽度思路和之前不一样，这里是通过 grid 放大整体的倍数，包括 y 轴的。最后以鼠标的 x 轴位置来改变 step 函数的阈值，实现交互。</p>
<ol start="3">
<li>创造其他有趣的效果：
<img src="https://github.com/funfish/blog/raw/master/images/shader10.3.PNG" alt=""></li>
</ol>
<pre class="hljs"><code><span class="hljs-type">vec2</span> ipos = <span class="hljs-built_in">floor</span>(st); 
color *= <span class="hljs-built_in">step</span>(st.x +  (<span class="hljs-number">50.</span> - ipos.y) * <span class="hljs-number">100.</span>, <span class="hljs-built_in">fract</span>(u_time/<span class="hljs-number">50.</span>) * <span class="hljs-number">5100.</span>);
</code></pre>
<p>这个图和上面 2 的图是很相似的，唯一不同的地方在于周期性从上到下显示，从左到右显示。需要从 x 、y  与时间一起考虑。</p>
<h2>噪音 noise</h2>
<p>上面的 random 更多的只是伪随机数，通过获取整数部分、小数部分来实现效果。图形的显示不是黑就是白，没有过渡，缺少平滑。
这里的 noise 方程式，则使得 2D 的噪音平滑：</p>
<pre class="hljs"><code><span class="hljs-type">float</span> noise (<span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> st) {
  <span class="hljs-type">vec2</span> i = <span class="hljs-built_in">floor</span>(st);
  <span class="hljs-type">vec2</span> f = <span class="hljs-built_in">fract</span>(st);

  <span class="hljs-comment">// Four corners in 2D of a tile</span>
  <span class="hljs-type">float</span> a = random(i);
  <span class="hljs-type">float</span> b = random(i + <span class="hljs-type">vec2</span>(<span class="hljs-number">1.</span>, <span class="hljs-number">0.0</span>));
  <span class="hljs-type">float</span> c = random(i + <span class="hljs-type">vec2</span>(<span class="hljs-number">0.</span>, <span class="hljs-number">1.0</span>));
  <span class="hljs-type">float</span> d = random(i + <span class="hljs-type">vec2</span>(<span class="hljs-number">1.</span>, <span class="hljs-number">1.0</span>));

  <span class="hljs-comment">// Smooth Interpolation</span>

  <span class="hljs-comment">// Cubic Hermine Curve.  Same as SmoothStep()</span>
  <span class="hljs-type">vec2</span> u = f * f * (<span class="hljs-number">3.</span> - <span class="hljs-number">2.</span> * f);
  <span class="hljs-comment">// u = smoothstep(0., 1., f);</span>

  <span class="hljs-comment">// Mix 4 coorners percentages</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">mix</span>(a, b, u.x) +
    (c - a)* u.y * (<span class="hljs-number">1.</span> - u.x) +
    (d - b) * u.x * u.y;
}
</code></pre>
<p>生成式设计中的 noise 应用：上面提到的 noise 生成的图片更多的是块状模糊的，也被叫做 <em><strong>Value Noise</strong></em>。下面提到了另外一种 <em><strong>Gradient Noise</strong></em>。通过这个 <a href="https://www.shadertoy.com/view/XdXGW8" target="_blank">例子</a> 而已看得出两者的区别。</p>
<p>下面看看习题：</p>
<ol>
<li>你还能做出什么其他图案呢？花岗岩？大理石？岩浆？水？找三种你感兴趣的材质，用 noise 加一些算法把它们做出来。
<img src="https://github.com/funfish/blog/raw/master/images/shader11.1.PNG" alt=""></li>
</ol>
<pre class="hljs"><code><span class="hljs-type">float</span> noise(<span class="hljs-type">vec2</span> st) {
    <span class="hljs-type">vec2</span> i = <span class="hljs-built_in">floor</span>(st);
    <span class="hljs-type">vec2</span> f = <span class="hljs-built_in">fract</span>(st);

    <span class="hljs-type">vec2</span> u = f*f*(<span class="hljs-number">3.0</span><span class="hljs-number">-2.0</span>*f);

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">mix</span>( <span class="hljs-built_in">mix</span>( <span class="hljs-built_in">dot</span>( random2(i + <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>) ), f - <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>) ),
                     <span class="hljs-built_in">dot</span>( random2(i + <span class="hljs-type">vec2</span>(<span class="hljs-number">1.0</span>,<span class="hljs-number">0.0</span>) ), f - <span class="hljs-type">vec2</span>(<span class="hljs-number">1.0</span>,<span class="hljs-number">0.0</span>) ), u.x),
                <span class="hljs-built_in">mix</span>( <span class="hljs-built_in">dot</span>( random2(i + <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>) ), f - <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>) ),
                     <span class="hljs-built_in">dot</span>( random2(i + <span class="hljs-type">vec2</span>(<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>) ), f - <span class="hljs-type">vec2</span>(<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>) ), u.x), u.y);
}

<span class="hljs-type">void</span> main() {
  <span class="hljs-type">vec2</span> st = <span class="hljs-built_in">gl_FragCoord</span>.xy / u_resolution.xy;
  st.x *= u_resolution.x / u_resolution.y;
  <span class="hljs-type">vec3</span> color = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>);
  color = <span class="hljs-type">vec3</span>(<span class="hljs-number">1.</span>) * <span class="hljs-built_in">smoothstep</span>(<span class="hljs-number">.0</span>, <span class="hljs-number">.2</span>, noise(st * <span class="hljs-number">4000000.</span>));

  <span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.</span> - color, <span class="hljs-number">1.0</span>);
}
</code></pre>
<p>这个图，是调试着调出来的，像格子衫的布料，一块一块的米格子，很好看。通过尽量放大倍数，来实现效果的。</p>
<ol start="2">
<li>用 noise 给一个形状变形。
<img src="https://github.com/funfish/blog/raw/master/images/shader11.2.PNG" alt=""></li>
</ol>
<pre class="hljs"><code><span class="hljs-type">float</span> shape(<span class="hljs-type">vec2</span> st, <span class="hljs-type">float</span> radius) {
	st = <span class="hljs-type">vec2</span>(<span class="hljs-number">0.5</span>) - st;
  <span class="hljs-type">float</span> dotDirection = <span class="hljs-built_in">length</span>(st) * <span class="hljs-number">2.0</span>;

  <span class="hljs-type">float</span> newRadius = radius * (noise(st * u_time) + <span class="hljs-number">1.</span>);
  
  <span class="hljs-keyword">return</span> <span class="hljs-number">1.</span> - <span class="hljs-built_in">smoothstep</span>(newRadius, newRadius + <span class="hljs-number">0.007</span>, dotDirection);
}

<span class="hljs-type">void</span> main() {
	<span class="hljs-type">vec2</span> st = <span class="hljs-built_in">gl_FragCoord</span>.xy/u_resolution.xy;
	<span class="hljs-type">vec3</span> color = <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>) * shape(st,<span class="hljs-number">0.5</span>);

	<span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(color, <span class="hljs-number">1.0</span> );
}
</code></pre>
<p>这个是圆形的边界散点图。如何画圆，在之前章节里面有介绍过，中心点 (0.5, 0.5)，半径长度则是通过 newRadius 表示，传入的常数 redius，随着时间变化，通过 noise 处理，从而达到边界散点的效果。</p>
<p>3， 把 noise 加到动作中会如何？回顾第八章。用移动 “+” 四处跑的那个例子，加一些 random 和 noise 进去。
这个涉及到之前第八章画的十字架，最后的图如下：
<img src="https://github.com/funfish/blog/raw/master/images/shader11.3.gif" alt=""></p>
<pre class="hljs"><code><span class="hljs-type">float</span> box(<span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> _st, <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> _size){
  _size = <span class="hljs-type">vec2</span>(<span class="hljs-number">0.5</span>) - _size * <span class="hljs-number">0.5</span>;
  <span class="hljs-type">vec2</span> uv = <span class="hljs-built_in">smoothstep</span>(_size, _size+<span class="hljs-type">vec2</span>(<span class="hljs-number">0.001</span>), _st);
  uv *= <span class="hljs-built_in">smoothstep</span>(_size, _size+<span class="hljs-type">vec2</span>(<span class="hljs-number">0.001</span>), <span class="hljs-type">vec2</span>(<span class="hljs-number">1.0</span>)-_st);
  <span class="hljs-keyword">return</span> uv.x*uv.y;
}

<span class="hljs-type">float</span> <span class="hljs-built_in">cross</span>(<span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> _st, <span class="hljs-type">float</span> _size){
  <span class="hljs-keyword">return</span>  box(_st, <span class="hljs-type">vec2</span>(_size,_size/<span class="hljs-number">4.</span>)) +
          box(_st, <span class="hljs-type">vec2</span>(_size/<span class="hljs-number">4.</span>,_size));
}
<span class="hljs-type">void</span> main(){
  <span class="hljs-type">vec2</span> st = <span class="hljs-built_in">gl_FragCoord</span>.xy/u_resolution.xy;
  <span class="hljs-type">vec3</span> color = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>);

  st.x += noise(<span class="hljs-type">vec2</span>(u_time, <span class="hljs-number">0.</span>)); 
  st.y += noise(<span class="hljs-type">vec2</span>(<span class="hljs-number">0.</span>, u_time));
  color += <span class="hljs-type">vec3</span>(<span class="hljs-built_in">cross</span>(st,<span class="hljs-number">0.25</span>));

  <span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(color,<span class="hljs-number">1.0</span>);
}
</code></pre>
<p>将 st 的 x/y 值加上 noise 时间的效果，达到 “+” 四处跑的效果，而不是规律运动。</p>
<h3>Simplex Noise</h3>
<p>前面的 Noise 实现方式过于复杂，对于 N 维你需要插入 2 的 n 次方个点，而 Simplex Noise 采用三角形来替换正方形，并把平滑函数改成四次 Hermite 函数，效果更平滑。</p>
<p>习题： 做一个 shader 来表现流体的质感。比如像熔岩灯，墨水滴，水，等等。
<img src="https://github.com/funfish/blog/raw/master/images/shader11.4.gif" alt=""></p>
<pre class="hljs"><code><span class="hljs-type">float</span> snoise(<span class="hljs-type">vec2</span> v) {
  <span class="hljs-keyword">const</span> <span class="hljs-type">vec4</span> C = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.211324865405187</span>,  <span class="hljs-comment">// (3.0-sqrt(3.0))/6.0</span>
                      <span class="hljs-number">0.366025403784439</span>,  <span class="hljs-comment">// 0.5*(sqrt(3.0)-1.0)</span>
                      <span class="hljs-number">-0.577350269189626</span>,  <span class="hljs-comment">// -1.0 + 2.0 * C.x</span>
                      <span class="hljs-number">0.024390243902439</span>); <span class="hljs-comment">// 1.0 / 41.0</span>
  <span class="hljs-type">vec2</span> i  = <span class="hljs-built_in">floor</span>(v + <span class="hljs-built_in">dot</span>(v, C.yy) );
  <span class="hljs-type">vec2</span> x0 = v -   i + <span class="hljs-built_in">dot</span>(i, C.xx);
  <span class="hljs-type">vec2</span> i1;
  i1 = (x0.x &gt; x0.y) ? <span class="hljs-type">vec2</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>) : <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);
  <span class="hljs-type">vec4</span> x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod289(i); <span class="hljs-comment">// Avoid truncation effects in permutation</span>
  <span class="hljs-type">vec3</span> p = permute( permute( i.y + <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, i1.y, <span class="hljs-number">1.0</span> ))
      + i.x + <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, i1.x, <span class="hljs-number">1.0</span> ));

  <span class="hljs-type">vec3</span> m = <span class="hljs-built_in">max</span>(<span class="hljs-number">0.5</span> - <span class="hljs-type">vec3</span>(<span class="hljs-built_in">dot</span>(x0,x0), <span class="hljs-built_in">dot</span>(x12.xy,x12.xy), <span class="hljs-built_in">dot</span>(x12.zw,x12.zw)), <span class="hljs-number">0.0</span>);
  m = m*m ;
  m = m*m ;
  <span class="hljs-type">vec3</span> x = <span class="hljs-number">2.0</span> * <span class="hljs-built_in">fract</span>(p * C.www) - <span class="hljs-number">1.0</span>;
  <span class="hljs-type">vec3</span> h = <span class="hljs-built_in">abs</span>(x) - <span class="hljs-number">0.5</span>;
  <span class="hljs-type">vec3</span> ox = <span class="hljs-built_in">floor</span>(x + <span class="hljs-number">0.5</span>);
  <span class="hljs-type">vec3</span> a0 = x - ox;
  m *= <span class="hljs-number">1.79284291400159</span> - <span class="hljs-number">0.85373472095314</span> * ( a0*a0 + h*h );
  <span class="hljs-type">vec3</span> g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  <span class="hljs-keyword">return</span> <span class="hljs-number">130.0</span> * <span class="hljs-built_in">dot</span>(m, g);
}

<span class="hljs-type">void</span> main() {
  <span class="hljs-type">vec2</span> st = <span class="hljs-built_in">gl_FragCoord</span>.xy / u_resolution.xy;
  st.x *= u_resolution.x / u_resolution.y;
  <span class="hljs-type">vec3</span> color = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>);

  st = st + st * snoise(st + u_time / <span class="hljs-number">50.</span>) / <span class="hljs-number">3.</span>;
  color += <span class="hljs-built_in">smoothstep</span>(<span class="hljs-number">.4</span> , <span class="hljs-number">0.5</span>, snoise(st * <span class="hljs-number">5.</span>));

  <span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.</span>-color,<span class="hljs-number">1.0</span>);
}
</code></pre>
<p>首先是先做出合适的泼墨图，这个在前文就有介绍到，采用的是 Gradient Noise 的方式，改造好后，则是加入时间变量，让 st 的坐标随着 snoise 下的时间变化。</p>
<h2>网格噪声 Cellular Noise 与 分形布朗运动 Fractal Brownian Motion</h2>
<p>GLSL 对 for 循环是不太友好，无法动态处理，当你有多个特征点的时候，若每个像素都计算一次到特征点的关系距离，其计算量也是很大的。为此，提出了 <strong>网格噪音</strong> 方式，即是：将空间分割成网状，每个像素点只计算其相邻块（一共八个）的特征点。</p>
<p>分形布朗运动：则是在循环的过程中叠加噪音，并提高频率降低振幅，来显示更好的细节。如下面的方式</p>
<pre class="hljs"><code><span class="hljs-meta">#define OCTAVES 6</span>
<span class="hljs-type">float</span> fbm (<span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> st) {
  <span class="hljs-comment">// Initial values</span>
  <span class="hljs-type">float</span> value = <span class="hljs-number">0.0</span>;
  <span class="hljs-type">float</span> amplitude = <span class="hljs-number">.5</span>;
  <span class="hljs-type">float</span> frequency = <span class="hljs-number">0.6</span>;

  <span class="hljs-comment">// Loop of octaves</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; OCTAVES; i++) {
    value += amplitude * noise(st);
    st *= <span class="hljs-number">2.</span>;
    amplitude *= <span class="hljs-number">.5</span>;
  }
  <span class="hljs-keyword">return</span> value;
}
</code></pre>
<p>fbm 函数在循环的过程中，叠加噪音，让图形有更多的细节。</p>
<p>域翘曲：通过 fbm 函数来扭曲 fbm，简单来讲就是多维的 fbm，通过下面来了解一下：</p>
<pre class="hljs"><code><span class="hljs-comment">// 基本方式 f(p) = fbm( p )</span>
<span class="hljs-type">float</span> pattern( <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> p ) {
  <span class="hljs-keyword">return</span> fbm( p );
}

<span class="hljs-comment">// 添加第二次翘曲 (p) = fbm( p + fbm( p ) )</span>
<span class="hljs-type">float</span> pattern( <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> p ) {
  <span class="hljs-type">vec2</span> q = <span class="hljs-type">vec2</span>( fbm( p + <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>) ),
                 fbm( p + <span class="hljs-type">vec2</span>(<span class="hljs-number">5.2</span>,<span class="hljs-number">1.3</span>) ) );
  <span class="hljs-keyword">return</span> fbm( p + <span class="hljs-number">4.0</span>*q );
}

<span class="hljs-comment">// 添加第三次翘曲 f(p) = fbm( p + fbm( p + fbm( p )) )</span>
<span class="hljs-type">float</span> pattern( <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> p ) {
  <span class="hljs-type">vec2</span> q = <span class="hljs-type">vec2</span>( fbm( p + <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>) ),
                 fbm( p + <span class="hljs-type">vec2</span>(<span class="hljs-number">5.2</span>,<span class="hljs-number">1.3</span>) ) );

  <span class="hljs-type">vec2</span> r = <span class="hljs-type">vec2</span>( fbm( p + <span class="hljs-number">4.0</span>*q + <span class="hljs-type">vec2</span>(<span class="hljs-number">1.7</span>,<span class="hljs-number">9.2</span>) ),
                 fbm( p + <span class="hljs-number">4.0</span>*q + <span class="hljs-type">vec2</span>(<span class="hljs-number">8.3</span>,<span class="hljs-number">2.8</span>) ) );

  <span class="hljs-keyword">return</span> fbm( p + <span class="hljs-number">4.0</span>*r );
}
</code></pre>
<p>多次 fbm 之后生成类似 fbm 的纹理。比如下图：
<img src="https://github.com/funfish/blog/raw/master/images/shader12.gif" alt=""></p>
<h2>总结</h2>
<p>片元着色器和顶点着色器的学习很不一样，前者需要对图形实现的熟悉，比如常见的方法函数，后者则是三维空间变化，涉及到更多矩阵数据。后面的学习，将继续牢固基础，看更多的教程，同时也要开始筹划 three.js 的学习了。</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"March 24, 2021","title":"shader 习题与笔记","bannerUrl":"https://github.com/funfish/blog/raw/master/images/shaderGfx00.jpg","content":"\u003cp\u003e从元旦就开始学习 WebGL，只是网上的资料很少，没有相关的课程，three.js 还好一点，更多的是关于 OpenGL 的书。最后看了看有：\u003ca href=\"http://taobaofed.org/blog/2015/12/21/webgl-handbook/\" target=\"_blank\"\u003eWebGL 技术储备指南\u003c/a\u003e 这篇介绍入门，网上首推资料 \u003ca href=\"http://learnwebgl.brown37.net/\" target=\"_blank\"\u003eLearn WebGL\u003c/a\u003e，还有同人翻译的书 WebGL编程指南。\u003c/p\u003e\n\u003cp\u003e一个月的时间看完了上述内容，Learn WebGL 后面几章觉得意义不大就没有继续学习了。只是学了，做了 demo 之后很是困惑，学的 WebGL 和工作关系有点难联系上，最低也要用 three.js，难道这就要上手 three.js 吗？直到后面发现了 \u003ca href=\"https://github.com/patriciogonzalezvivo/thebookofshaders\" target=\"_blank\"\u003ethebookofshaders\u003c/a\u003e。之前学的基本都是以顶点着色器为主，对片元着色器的进一步介绍很少，而片元着色器和我的日常工作更加有关系。thebookofshaders 刚好有中文版，只是原文残缺，没有对 纹理/模拟/3D图形 的继续介绍。\u003c/p\u003e\n\u003cp\u003e前面部分比较基础，也好理解，加上其他的 webgl 基础内容这里就不介绍了。下面介绍 生成设计 里面的部分内容及课后习题：\u003c/p\u003e\n\u003ch3\u003e技术\u003c/h3\u003e\n\u003cp\u003e沿着 thebookofshaders 里面的内容学习，会用到两个基本的库，同样的都是出自作者 Patricio Gonzalez Vivo：glslCanvas（加载 webgl 的通用库），glslEditor（实时渲染的辅助调试工具）。这些作者已经在电子资料里面用到了，平时只要在线修改代码调试就好了。\u003c/p\u003e\n\u003ch2\u003e随机 random\u003c/h2\u003e\n\u003cp\u003e这里介绍的随机，不是真正的随机，包括文中接下来的部分都是 \u003cstrong\u003e伪随机\u003c/strong\u003e ，意味着同样的输入，会有同样的输出，并且在 x 值附近具有 \u003cstrong\u003e连续性\u003c/strong\u003e。这是和以前用的 \u003ccode\u003eMath.random\u003c/code\u003e 的随机是不一样的。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 一维随机 \u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e random (\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e x) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003efract\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003esin\u003c/span\u003e(x) * \u003cspan class=\"hljs-number\"\u003e1e4\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 2D 随机\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e random (\u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003efract\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003esin\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e(st.xy, \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e12.9898\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e78.233\u003c/span\u003e))) * \u003cspan class=\"hljs-number\"\u003e43758.5453123\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e由上面代码就可以看出来，这是确定性随机。这样的随机要如何利用？关键是同样的输入会有同样的输出，于是，可以传入 x 的整数部分来随机分块。具体可以看以下联系：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e做按行随机移动的单元（以相反方向）。只显示亮一些的单元。让各行的速度随时间变化\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/shader10.1.PNG\" alt=\"\"\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-meta\"\u003e#define TIMEPERIOD .2\u003c/span\u003e\n\n\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e main() {\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st = \u003cspan class=\"hljs-built_in\"\u003egl_FragCoord\u003c/span\u003e.xy / u_resolution.xy;\n    \n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e speed = \u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e;\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e xRate = \u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e;\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e floorTimeRate = random(\u003cspan class=\"hljs-built_in\"\u003efloor\u003c/span\u003e(u_time * TIMEPERIOD));\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e fractTimeRate = \u003cspan class=\"hljs-built_in\"\u003efract\u003c/span\u003e(u_time * TIMEPERIOD);\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (st.y \u0026gt; \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e) {\n    xRate = floorTimeRate * \u003cspan class=\"hljs-number\"\u003e50.\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e10.\u003c/span\u003e;\n    speed = floorTimeRate * \u003cspan class=\"hljs-number\"\u003e2.\u003c/span\u003e+ \u003cspan class=\"hljs-number\"\u003e2.\u003c/span\u003e; \n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    xRate = -floorTimeRate * \u003cspan class=\"hljs-number\"\u003e50.\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e60.\u003c/span\u003e;\n    speed = -floorTimeRate * \u003cspan class=\"hljs-number\"\u003e2.\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e2.\u003c/span\u003e; \n  }\n  st.x = st.x + fractTimeRate * speed;\n  \n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e floorX = random(\u003cspan class=\"hljs-built_in\"\u003efloor\u003c/span\u003e(st.x * xRate)) * \u003cspan class=\"hljs-number\"\u003e4.\u003c/span\u003e;\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e randomX = \u003cspan class=\"hljs-built_in\"\u003estep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.20\u003c/span\u003e, floorX);\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e color = \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(randomX);\n\n  \u003cspan class=\"hljs-built_in\"\u003egl_FragColor\u003c/span\u003e = \u003cspan class=\"hljs-type\"\u003evec4\u003c/span\u003e(color,\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里 xRate 代表黑线放大的倍数，speed 则是黑线的移动速度，其中速度和放大倍数要随着时间变化而变化，图中上下两部分要分开处理。\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e同样地，让某几行以不同的速度和方向。用鼠标位置关联显示单元的阀值。\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/shader10.2.PNG\" alt=\"\"\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e main() {\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st = \u003cspan class=\"hljs-built_in\"\u003egl_FragCoord\u003c/span\u003e.xy / u_resolution.xy;\n  st.x *= u_resolution.x / u_resolution.y;\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e mouseX = u_mouse.x / u_resolution.x;\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e thresholdX = \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e + mouseX / \u003cspan class=\"hljs-number\"\u003e2.\u003c/span\u003e;\n  \n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e grid = \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100.0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e50.\u003c/span\u003e);\n  st *= grid;\n  \n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e positionX = (st.x - u_time * \u003cspan class=\"hljs-number\"\u003e60.\u003c/span\u003e * random(\u003cspan class=\"hljs-built_in\"\u003efloor\u003c/span\u003e(st.y))) * random   (\u003cspan class=\"hljs-built_in\"\u003efloor\u003c/span\u003e(st.y)) / \u003cspan class=\"hljs-number\"\u003e1.5\u003c/span\u003e;\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e randomX = \u003cspan class=\"hljs-built_in\"\u003estep\u003c/span\u003e(thresholdX, random(\u003cspan class=\"hljs-built_in\"\u003efloor\u003c/span\u003e(positionX))) ;\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e fpos = \u003cspan class=\"hljs-built_in\"\u003efract\u003c/span\u003e(st);\n  \n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e color = \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(randomX);\n  \n  \u003cspan class=\"hljs-comment\"\u003e// Y轴的每一行产生白边\u003c/span\u003e\n  color *= \u003cspan class=\"hljs-built_in\"\u003estep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.2\u003c/span\u003e, fpos.y);\n  \u003cspan class=\"hljs-built_in\"\u003egl_FragColor\u003c/span\u003e = \u003cspan class=\"hljs-type\"\u003evec4\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e - color, \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ex 轴的黑色部分宽度思路和之前不一样，这里是通过 grid 放大整体的倍数，包括 y 轴的。最后以鼠标的 x 轴位置来改变 step 函数的阈值，实现交互。\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e创造其他有趣的效果：\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/shader10.3.PNG\" alt=\"\"\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e ipos = \u003cspan class=\"hljs-built_in\"\u003efloor\u003c/span\u003e(st); \ncolor *= \u003cspan class=\"hljs-built_in\"\u003estep\u003c/span\u003e(st.x +  (\u003cspan class=\"hljs-number\"\u003e50.\u003c/span\u003e - ipos.y) * \u003cspan class=\"hljs-number\"\u003e100.\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003efract\u003c/span\u003e(u_time/\u003cspan class=\"hljs-number\"\u003e50.\u003c/span\u003e) * \u003cspan class=\"hljs-number\"\u003e5100.\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个图和上面 2 的图是很相似的，唯一不同的地方在于周期性从上到下显示，从左到右显示。需要从 x 、y  与时间一起考虑。\u003c/p\u003e\n\u003ch2\u003e噪音 noise\u003c/h2\u003e\n\u003cp\u003e上面的 random 更多的只是伪随机数，通过获取整数部分、小数部分来实现效果。图形的显示不是黑就是白，没有过渡，缺少平滑。\n这里的 noise 方程式，则使得 2D 的噪音平滑：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e noise (\u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st) {\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e i = \u003cspan class=\"hljs-built_in\"\u003efloor\u003c/span\u003e(st);\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e f = \u003cspan class=\"hljs-built_in\"\u003efract\u003c/span\u003e(st);\n\n  \u003cspan class=\"hljs-comment\"\u003e// Four corners in 2D of a tile\u003c/span\u003e\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e a = random(i);\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e b = random(i + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e));\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e c = random(i + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e));\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e d = random(i + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e));\n\n  \u003cspan class=\"hljs-comment\"\u003e// Smooth Interpolation\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// Cubic Hermine Curve.  Same as SmoothStep()\u003c/span\u003e\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e u = f * f * (\u003cspan class=\"hljs-number\"\u003e3.\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e2.\u003c/span\u003e * f);\n  \u003cspan class=\"hljs-comment\"\u003e// u = smoothstep(0., 1., f);\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// Mix 4 coorners percentages\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003emix\u003c/span\u003e(a, b, u.x) +\n    (c - a)* u.y * (\u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003e - u.x) +\n    (d - b) * u.x * u.y;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e生成式设计中的 noise 应用：上面提到的 noise 生成的图片更多的是块状模糊的，也被叫做 \u003cem\u003e\u003cstrong\u003eValue Noise\u003c/strong\u003e\u003c/em\u003e。下面提到了另外一种 \u003cem\u003e\u003cstrong\u003eGradient Noise\u003c/strong\u003e\u003c/em\u003e。通过这个 \u003ca href=\"https://www.shadertoy.com/view/XdXGW8\" target=\"_blank\"\u003e例子\u003c/a\u003e 而已看得出两者的区别。\u003c/p\u003e\n\u003cp\u003e下面看看习题：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e你还能做出什么其他图案呢？花岗岩？大理石？岩浆？水？找三种你感兴趣的材质，用 noise 加一些算法把它们做出来。\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/shader11.1.PNG\" alt=\"\"\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e noise(\u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st) {\n    \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e i = \u003cspan class=\"hljs-built_in\"\u003efloor\u003c/span\u003e(st);\n    \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e f = \u003cspan class=\"hljs-built_in\"\u003efract\u003c/span\u003e(st);\n\n    \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e u = f*f*(\u003cspan class=\"hljs-number\"\u003e3.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e-2.0\u003c/span\u003e*f);\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003emix\u003c/span\u003e( \u003cspan class=\"hljs-built_in\"\u003emix\u003c/span\u003e( \u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e( random2(i + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e) ), f - \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e) ),\n                     \u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e( random2(i + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e) ), f - \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e) ), u.x),\n                \u003cspan class=\"hljs-built_in\"\u003emix\u003c/span\u003e( \u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e( random2(i + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e) ), f - \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e) ),\n                     \u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e( random2(i + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e) ), f - \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e) ), u.x), u.y);\n}\n\n\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e main() {\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st = \u003cspan class=\"hljs-built_in\"\u003egl_FragCoord\u003c/span\u003e.xy / u_resolution.xy;\n  st.x *= u_resolution.x / u_resolution.y;\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e color = \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e);\n  color = \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003e) * \u003cspan class=\"hljs-built_in\"\u003esmoothstep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e.2\u003c/span\u003e, noise(st * \u003cspan class=\"hljs-number\"\u003e4000000.\u003c/span\u003e));\n\n  \u003cspan class=\"hljs-built_in\"\u003egl_FragColor\u003c/span\u003e = \u003cspan class=\"hljs-type\"\u003evec4\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003e - color, \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个图，是调试着调出来的，像格子衫的布料，一块一块的米格子，很好看。通过尽量放大倍数，来实现效果的。\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e用 noise 给一个形状变形。\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/shader11.2.PNG\" alt=\"\"\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e shape(\u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st, \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e radius) {\n\tst = \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e) - st;\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e dotDirection = \u003cspan class=\"hljs-built_in\"\u003elength\u003c/span\u003e(st) * \u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e newRadius = radius * (noise(st * u_time) + \u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003e);\n  \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003e - \u003cspan class=\"hljs-built_in\"\u003esmoothstep\u003c/span\u003e(newRadius, newRadius + \u003cspan class=\"hljs-number\"\u003e0.007\u003c/span\u003e, dotDirection);\n}\n\n\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e main() {\n\t\u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st = \u003cspan class=\"hljs-built_in\"\u003egl_FragCoord\u003c/span\u003e.xy/u_resolution.xy;\n\t\u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e color = \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e) * shape(st,\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e);\n\n\t\u003cspan class=\"hljs-built_in\"\u003egl_FragColor\u003c/span\u003e = \u003cspan class=\"hljs-type\"\u003evec4\u003c/span\u003e(color, \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个是圆形的边界散点图。如何画圆，在之前章节里面有介绍过，中心点 (0.5, 0.5)，半径长度则是通过 newRadius 表示，传入的常数 redius，随着时间变化，通过 noise 处理，从而达到边界散点的效果。\u003c/p\u003e\n\u003cp\u003e3， 把 noise 加到动作中会如何？回顾第八章。用移动 “+” 四处跑的那个例子，加一些 random 和 noise 进去。\n这个涉及到之前第八章画的十字架，最后的图如下：\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/shader11.3.gif\" alt=\"\"\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e box(\u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e _st, \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e _size){\n  _size = \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e) - _size * \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e;\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e uv = \u003cspan class=\"hljs-built_in\"\u003esmoothstep\u003c/span\u003e(_size, _size+\u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.001\u003c/span\u003e), _st);\n  uv *= \u003cspan class=\"hljs-built_in\"\u003esmoothstep\u003c/span\u003e(_size, _size+\u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.001\u003c/span\u003e), \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e)-_st);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e uv.x*uv.y;\n}\n\n\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ecross\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e _st, \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e _size){\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e  box(_st, \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(_size,_size/\u003cspan class=\"hljs-number\"\u003e4.\u003c/span\u003e)) +\n          box(_st, \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(_size/\u003cspan class=\"hljs-number\"\u003e4.\u003c/span\u003e,_size));\n}\n\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e main(){\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st = \u003cspan class=\"hljs-built_in\"\u003egl_FragCoord\u003c/span\u003e.xy/u_resolution.xy;\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e color = \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e);\n\n  st.x += noise(\u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(u_time, \u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e)); \n  st.y += noise(\u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e, u_time));\n  color += \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003ecross\u003c/span\u003e(st,\u003cspan class=\"hljs-number\"\u003e0.25\u003c/span\u003e));\n\n  \u003cspan class=\"hljs-built_in\"\u003egl_FragColor\u003c/span\u003e = \u003cspan class=\"hljs-type\"\u003evec4\u003c/span\u003e(color,\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e将 st 的 x/y 值加上 noise 时间的效果，达到 “+” 四处跑的效果，而不是规律运动。\u003c/p\u003e\n\u003ch3\u003eSimplex Noise\u003c/h3\u003e\n\u003cp\u003e前面的 Noise 实现方式过于复杂，对于 N 维你需要插入 2 的 n 次方个点，而 Simplex Noise 采用三角形来替换正方形，并把平滑函数改成四次 Hermite 函数，效果更平滑。\u003c/p\u003e\n\u003cp\u003e习题： 做一个 shader 来表现流体的质感。比如像熔岩灯，墨水滴，水，等等。\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/shader11.4.gif\" alt=\"\"\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e snoise(\u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e v) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003evec4\u003c/span\u003e C = \u003cspan class=\"hljs-type\"\u003evec4\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.211324865405187\u003c/span\u003e,  \u003cspan class=\"hljs-comment\"\u003e// (3.0-sqrt(3.0))/6.0\u003c/span\u003e\n                      \u003cspan class=\"hljs-number\"\u003e0.366025403784439\u003c/span\u003e,  \u003cspan class=\"hljs-comment\"\u003e// 0.5*(sqrt(3.0)-1.0)\u003c/span\u003e\n                      \u003cspan class=\"hljs-number\"\u003e-0.577350269189626\u003c/span\u003e,  \u003cspan class=\"hljs-comment\"\u003e// -1.0 + 2.0 * C.x\u003c/span\u003e\n                      \u003cspan class=\"hljs-number\"\u003e0.024390243902439\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 1.0 / 41.0\u003c/span\u003e\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e i  = \u003cspan class=\"hljs-built_in\"\u003efloor\u003c/span\u003e(v + \u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e(v, C.yy) );\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e x0 = v -   i + \u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e(i, C.xx);\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e i1;\n  i1 = (x0.x \u0026gt; x0.y) ? \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e) : \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e);\n  \u003cspan class=\"hljs-type\"\u003evec4\u003c/span\u003e x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod289(i); \u003cspan class=\"hljs-comment\"\u003e// Avoid truncation effects in permutation\u003c/span\u003e\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e p = permute( permute( i.y + \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e, i1.y, \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e ))\n      + i.x + \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e, i1.x, \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e ));\n\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e m = \u003cspan class=\"hljs-built_in\"\u003emax\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e - \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e(x0,x0), \u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e(x12.xy,x12.xy), \u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e(x12.zw,x12.zw)), \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e);\n  m = m*m ;\n  m = m*m ;\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e * \u003cspan class=\"hljs-built_in\"\u003efract\u003c/span\u003e(p * C.www) - \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e;\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e h = \u003cspan class=\"hljs-built_in\"\u003eabs\u003c/span\u003e(x) - \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e;\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e ox = \u003cspan class=\"hljs-built_in\"\u003efloor\u003c/span\u003e(x + \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e);\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e a0 = x - ox;\n  m *= \u003cspan class=\"hljs-number\"\u003e1.79284291400159\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e0.85373472095314\u003c/span\u003e * ( a0*a0 + h*h );\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e130.0\u003c/span\u003e * \u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e(m, g);\n}\n\n\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e main() {\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st = \u003cspan class=\"hljs-built_in\"\u003egl_FragCoord\u003c/span\u003e.xy / u_resolution.xy;\n  st.x *= u_resolution.x / u_resolution.y;\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e color = \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e);\n\n  st = st + st * snoise(st + u_time / \u003cspan class=\"hljs-number\"\u003e50.\u003c/span\u003e) / \u003cspan class=\"hljs-number\"\u003e3.\u003c/span\u003e;\n  color += \u003cspan class=\"hljs-built_in\"\u003esmoothstep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e.4\u003c/span\u003e , \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e, snoise(st * \u003cspan class=\"hljs-number\"\u003e5.\u003c/span\u003e));\n\n  \u003cspan class=\"hljs-built_in\"\u003egl_FragColor\u003c/span\u003e = \u003cspan class=\"hljs-type\"\u003evec4\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003e-color,\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e首先是先做出合适的泼墨图，这个在前文就有介绍到，采用的是 Gradient Noise 的方式，改造好后，则是加入时间变量，让 st 的坐标随着 snoise 下的时间变化。\u003c/p\u003e\n\u003ch2\u003e网格噪声 Cellular Noise 与 分形布朗运动 Fractal Brownian Motion\u003c/h2\u003e\n\u003cp\u003eGLSL 对 for 循环是不太友好，无法动态处理，当你有多个特征点的时候，若每个像素都计算一次到特征点的关系距离，其计算量也是很大的。为此，提出了 \u003cstrong\u003e网格噪音\u003c/strong\u003e 方式，即是：将空间分割成网状，每个像素点只计算其相邻块（一共八个）的特征点。\u003c/p\u003e\n\u003cp\u003e分形布朗运动：则是在循环的过程中叠加噪音，并提高频率降低振幅，来显示更好的细节。如下面的方式\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-meta\"\u003e#define OCTAVES 6\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e fbm (\u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st) {\n  \u003cspan class=\"hljs-comment\"\u003e// Initial values\u003c/span\u003e\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e value = \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e;\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e amplitude = \u003cspan class=\"hljs-number\"\u003e.5\u003c/span\u003e;\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e frequency = \u003cspan class=\"hljs-number\"\u003e0.6\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e// Loop of octaves\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; OCTAVES; i++) {\n    value += amplitude * noise(st);\n    st *= \u003cspan class=\"hljs-number\"\u003e2.\u003c/span\u003e;\n    amplitude *= \u003cspan class=\"hljs-number\"\u003e.5\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e value;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efbm 函数在循环的过程中，叠加噪音，让图形有更多的细节。\u003c/p\u003e\n\u003cp\u003e域翘曲：通过 fbm 函数来扭曲 fbm，简单来讲就是多维的 fbm，通过下面来了解一下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 基本方式 f(p) = fbm( p )\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e pattern( \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e p ) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e fbm( p );\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 添加第二次翘曲 (p) = fbm( p + fbm( p ) )\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e pattern( \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e p ) {\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e q = \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e( fbm( p + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e) ),\n                 fbm( p + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5.2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1.3\u003c/span\u003e) ) );\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e fbm( p + \u003cspan class=\"hljs-number\"\u003e4.0\u003c/span\u003e*q );\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 添加第三次翘曲 f(p) = fbm( p + fbm( p + fbm( p )) )\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e pattern( \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e p ) {\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e q = \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e( fbm( p + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e) ),\n                 fbm( p + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5.2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1.3\u003c/span\u003e) ) );\n\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e r = \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e( fbm( p + \u003cspan class=\"hljs-number\"\u003e4.0\u003c/span\u003e*q + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.7\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e9.2\u003c/span\u003e) ),\n                 fbm( p + \u003cspan class=\"hljs-number\"\u003e4.0\u003c/span\u003e*q + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e8.3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2.8\u003c/span\u003e) ) );\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e fbm( p + \u003cspan class=\"hljs-number\"\u003e4.0\u003c/span\u003e*r );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e多次 fbm 之后生成类似 fbm 的纹理。比如下图：\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/shader12.gif\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e片元着色器和顶点着色器的学习很不一样，前者需要对图形实现的熟悉，比如常见的方法函数，后者则是三维空间变化，涉及到更多矩阵数据。后面的学习，将继续牢固基础，看更多的教程，同时也要开始筹划 three.js 的学习了。\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"March 24, 2021","title":"shader 习题与笔记","bannerUrl":"https://github.com/funfish/blog/raw/master/images/shaderGfx00.jpg","content":"\u003cp\u003e从元旦就开始学习 WebGL，只是网上的资料很少，没有相关的课程，three.js 还好一点，更多的是关于 OpenGL 的书。最后看了看有：\u003ca href=\"http://taobaofed.org/blog/2015/12/21/webgl-handbook/\" target=\"_blank\"\u003eWebGL 技术储备指南\u003c/a\u003e 这篇介绍入门，网上首推资料 \u003ca href=\"http://learnwebgl.brown37.net/\" target=\"_blank\"\u003eLearn WebGL\u003c/a\u003e，还有同人翻译的书 WebGL编程指南。\u003c/p\u003e\n\u003cp\u003e一个月的时间看完了上述内容，Learn WebGL 后面几章觉得意义不大就没有继续学习了。只是学了，做了 demo 之后很是困惑，学的 WebGL 和工作关系有点难联系上，最低也要用 three.js，难道这就要上手 three.js 吗？直到后面发现了 \u003ca href=\"https://github.com/patriciogonzalezvivo/thebookofshaders\" target=\"_blank\"\u003ethebookofshaders\u003c/a\u003e。之前学的基本都是以顶点着色器为主，对片元着色器的进一步介绍很少，而片元着色器和我的日常工作更加有关系。thebookofshaders 刚好有中文版，只是原文残缺，没有对 纹理/模拟/3D图形 的继续介绍。\u003c/p\u003e\n\u003cp\u003e前面部分比较基础，也好理解，加上其他的 webgl 基础内容这里就不介绍了。下面介绍 生成设计 里面的部分内容及课后习题：\u003c/p\u003e\n\u003ch3\u003e技术\u003c/h3\u003e\n\u003cp\u003e沿着 thebookofshaders 里面的内容学习，会用到两个基本的库，同样的都是出自作者 Patricio Gonzalez Vivo：glslCanvas（加载 webgl 的通用库），glslEditor（实时渲染的辅助调试工具）。这些作者已经在电子资料里面用到了，平时只要在线修改代码调试就好了。\u003c/p\u003e\n\u003ch2\u003e随机 random\u003c/h2\u003e\n\u003cp\u003e这里介绍的随机，不是真正的随机，包括文中接下来的部分都是 \u003cstrong\u003e伪随机\u003c/strong\u003e ，意味着同样的输入，会有同样的输出，并且在 x 值附近具有 \u003cstrong\u003e连续性\u003c/strong\u003e。这是和以前用的 \u003ccode\u003eMath.random\u003c/code\u003e 的随机是不一样的。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 一维随机 \u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e random (\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e x) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003efract\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003esin\u003c/span\u003e(x) * \u003cspan class=\"hljs-number\"\u003e1e4\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 2D 随机\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e random (\u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003efract\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003esin\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e(st.xy, \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e12.9898\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e78.233\u003c/span\u003e))) * \u003cspan class=\"hljs-number\"\u003e43758.5453123\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e由上面代码就可以看出来，这是确定性随机。这样的随机要如何利用？关键是同样的输入会有同样的输出，于是，可以传入 x 的整数部分来随机分块。具体可以看以下联系：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e做按行随机移动的单元（以相反方向）。只显示亮一些的单元。让各行的速度随时间变化\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/shader10.1.PNG\" alt=\"\"\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-meta\"\u003e#define TIMEPERIOD .2\u003c/span\u003e\n\n\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e main() {\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st = \u003cspan class=\"hljs-built_in\"\u003egl_FragCoord\u003c/span\u003e.xy / u_resolution.xy;\n    \n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e speed = \u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e;\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e xRate = \u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e;\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e floorTimeRate = random(\u003cspan class=\"hljs-built_in\"\u003efloor\u003c/span\u003e(u_time * TIMEPERIOD));\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e fractTimeRate = \u003cspan class=\"hljs-built_in\"\u003efract\u003c/span\u003e(u_time * TIMEPERIOD);\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (st.y \u0026gt; \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e) {\n    xRate = floorTimeRate * \u003cspan class=\"hljs-number\"\u003e50.\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e10.\u003c/span\u003e;\n    speed = floorTimeRate * \u003cspan class=\"hljs-number\"\u003e2.\u003c/span\u003e+ \u003cspan class=\"hljs-number\"\u003e2.\u003c/span\u003e; \n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    xRate = -floorTimeRate * \u003cspan class=\"hljs-number\"\u003e50.\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e60.\u003c/span\u003e;\n    speed = -floorTimeRate * \u003cspan class=\"hljs-number\"\u003e2.\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e2.\u003c/span\u003e; \n  }\n  st.x = st.x + fractTimeRate * speed;\n  \n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e floorX = random(\u003cspan class=\"hljs-built_in\"\u003efloor\u003c/span\u003e(st.x * xRate)) * \u003cspan class=\"hljs-number\"\u003e4.\u003c/span\u003e;\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e randomX = \u003cspan class=\"hljs-built_in\"\u003estep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.20\u003c/span\u003e, floorX);\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e color = \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(randomX);\n\n  \u003cspan class=\"hljs-built_in\"\u003egl_FragColor\u003c/span\u003e = \u003cspan class=\"hljs-type\"\u003evec4\u003c/span\u003e(color,\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里 xRate 代表黑线放大的倍数，speed 则是黑线的移动速度，其中速度和放大倍数要随着时间变化而变化，图中上下两部分要分开处理。\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e同样地，让某几行以不同的速度和方向。用鼠标位置关联显示单元的阀值。\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/shader10.2.PNG\" alt=\"\"\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e main() {\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st = \u003cspan class=\"hljs-built_in\"\u003egl_FragCoord\u003c/span\u003e.xy / u_resolution.xy;\n  st.x *= u_resolution.x / u_resolution.y;\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e mouseX = u_mouse.x / u_resolution.x;\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e thresholdX = \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e + mouseX / \u003cspan class=\"hljs-number\"\u003e2.\u003c/span\u003e;\n  \n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e grid = \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100.0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e50.\u003c/span\u003e);\n  st *= grid;\n  \n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e positionX = (st.x - u_time * \u003cspan class=\"hljs-number\"\u003e60.\u003c/span\u003e * random(\u003cspan class=\"hljs-built_in\"\u003efloor\u003c/span\u003e(st.y))) * random   (\u003cspan class=\"hljs-built_in\"\u003efloor\u003c/span\u003e(st.y)) / \u003cspan class=\"hljs-number\"\u003e1.5\u003c/span\u003e;\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e randomX = \u003cspan class=\"hljs-built_in\"\u003estep\u003c/span\u003e(thresholdX, random(\u003cspan class=\"hljs-built_in\"\u003efloor\u003c/span\u003e(positionX))) ;\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e fpos = \u003cspan class=\"hljs-built_in\"\u003efract\u003c/span\u003e(st);\n  \n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e color = \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(randomX);\n  \n  \u003cspan class=\"hljs-comment\"\u003e// Y轴的每一行产生白边\u003c/span\u003e\n  color *= \u003cspan class=\"hljs-built_in\"\u003estep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.2\u003c/span\u003e, fpos.y);\n  \u003cspan class=\"hljs-built_in\"\u003egl_FragColor\u003c/span\u003e = \u003cspan class=\"hljs-type\"\u003evec4\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e - color, \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ex 轴的黑色部分宽度思路和之前不一样，这里是通过 grid 放大整体的倍数，包括 y 轴的。最后以鼠标的 x 轴位置来改变 step 函数的阈值，实现交互。\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e创造其他有趣的效果：\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/shader10.3.PNG\" alt=\"\"\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e ipos = \u003cspan class=\"hljs-built_in\"\u003efloor\u003c/span\u003e(st); \ncolor *= \u003cspan class=\"hljs-built_in\"\u003estep\u003c/span\u003e(st.x +  (\u003cspan class=\"hljs-number\"\u003e50.\u003c/span\u003e - ipos.y) * \u003cspan class=\"hljs-number\"\u003e100.\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003efract\u003c/span\u003e(u_time/\u003cspan class=\"hljs-number\"\u003e50.\u003c/span\u003e) * \u003cspan class=\"hljs-number\"\u003e5100.\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个图和上面 2 的图是很相似的，唯一不同的地方在于周期性从上到下显示，从左到右显示。需要从 x 、y  与时间一起考虑。\u003c/p\u003e\n\u003ch2\u003e噪音 noise\u003c/h2\u003e\n\u003cp\u003e上面的 random 更多的只是伪随机数，通过获取整数部分、小数部分来实现效果。图形的显示不是黑就是白，没有过渡，缺少平滑。\n这里的 noise 方程式，则使得 2D 的噪音平滑：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e noise (\u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st) {\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e i = \u003cspan class=\"hljs-built_in\"\u003efloor\u003c/span\u003e(st);\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e f = \u003cspan class=\"hljs-built_in\"\u003efract\u003c/span\u003e(st);\n\n  \u003cspan class=\"hljs-comment\"\u003e// Four corners in 2D of a tile\u003c/span\u003e\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e a = random(i);\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e b = random(i + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e));\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e c = random(i + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e));\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e d = random(i + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e));\n\n  \u003cspan class=\"hljs-comment\"\u003e// Smooth Interpolation\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// Cubic Hermine Curve.  Same as SmoothStep()\u003c/span\u003e\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e u = f * f * (\u003cspan class=\"hljs-number\"\u003e3.\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e2.\u003c/span\u003e * f);\n  \u003cspan class=\"hljs-comment\"\u003e// u = smoothstep(0., 1., f);\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// Mix 4 coorners percentages\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003emix\u003c/span\u003e(a, b, u.x) +\n    (c - a)* u.y * (\u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003e - u.x) +\n    (d - b) * u.x * u.y;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e生成式设计中的 noise 应用：上面提到的 noise 生成的图片更多的是块状模糊的，也被叫做 \u003cem\u003e\u003cstrong\u003eValue Noise\u003c/strong\u003e\u003c/em\u003e。下面提到了另外一种 \u003cem\u003e\u003cstrong\u003eGradient Noise\u003c/strong\u003e\u003c/em\u003e。通过这个 \u003ca href=\"https://www.shadertoy.com/view/XdXGW8\" target=\"_blank\"\u003e例子\u003c/a\u003e 而已看得出两者的区别。\u003c/p\u003e\n\u003cp\u003e下面看看习题：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e你还能做出什么其他图案呢？花岗岩？大理石？岩浆？水？找三种你感兴趣的材质，用 noise 加一些算法把它们做出来。\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/shader11.1.PNG\" alt=\"\"\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e noise(\u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st) {\n    \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e i = \u003cspan class=\"hljs-built_in\"\u003efloor\u003c/span\u003e(st);\n    \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e f = \u003cspan class=\"hljs-built_in\"\u003efract\u003c/span\u003e(st);\n\n    \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e u = f*f*(\u003cspan class=\"hljs-number\"\u003e3.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e-2.0\u003c/span\u003e*f);\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003emix\u003c/span\u003e( \u003cspan class=\"hljs-built_in\"\u003emix\u003c/span\u003e( \u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e( random2(i + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e) ), f - \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e) ),\n                     \u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e( random2(i + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e) ), f - \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e) ), u.x),\n                \u003cspan class=\"hljs-built_in\"\u003emix\u003c/span\u003e( \u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e( random2(i + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e) ), f - \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e) ),\n                     \u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e( random2(i + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e) ), f - \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e) ), u.x), u.y);\n}\n\n\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e main() {\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st = \u003cspan class=\"hljs-built_in\"\u003egl_FragCoord\u003c/span\u003e.xy / u_resolution.xy;\n  st.x *= u_resolution.x / u_resolution.y;\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e color = \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e);\n  color = \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003e) * \u003cspan class=\"hljs-built_in\"\u003esmoothstep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e.2\u003c/span\u003e, noise(st * \u003cspan class=\"hljs-number\"\u003e4000000.\u003c/span\u003e));\n\n  \u003cspan class=\"hljs-built_in\"\u003egl_FragColor\u003c/span\u003e = \u003cspan class=\"hljs-type\"\u003evec4\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003e - color, \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个图，是调试着调出来的，像格子衫的布料，一块一块的米格子，很好看。通过尽量放大倍数，来实现效果的。\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e用 noise 给一个形状变形。\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/shader11.2.PNG\" alt=\"\"\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e shape(\u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st, \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e radius) {\n\tst = \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e) - st;\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e dotDirection = \u003cspan class=\"hljs-built_in\"\u003elength\u003c/span\u003e(st) * \u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e newRadius = radius * (noise(st * u_time) + \u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003e);\n  \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003e - \u003cspan class=\"hljs-built_in\"\u003esmoothstep\u003c/span\u003e(newRadius, newRadius + \u003cspan class=\"hljs-number\"\u003e0.007\u003c/span\u003e, dotDirection);\n}\n\n\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e main() {\n\t\u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st = \u003cspan class=\"hljs-built_in\"\u003egl_FragCoord\u003c/span\u003e.xy/u_resolution.xy;\n\t\u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e color = \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e) * shape(st,\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e);\n\n\t\u003cspan class=\"hljs-built_in\"\u003egl_FragColor\u003c/span\u003e = \u003cspan class=\"hljs-type\"\u003evec4\u003c/span\u003e(color, \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个是圆形的边界散点图。如何画圆，在之前章节里面有介绍过，中心点 (0.5, 0.5)，半径长度则是通过 newRadius 表示，传入的常数 redius，随着时间变化，通过 noise 处理，从而达到边界散点的效果。\u003c/p\u003e\n\u003cp\u003e3， 把 noise 加到动作中会如何？回顾第八章。用移动 “+” 四处跑的那个例子，加一些 random 和 noise 进去。\n这个涉及到之前第八章画的十字架，最后的图如下：\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/shader11.3.gif\" alt=\"\"\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e box(\u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e _st, \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e _size){\n  _size = \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e) - _size * \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e;\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e uv = \u003cspan class=\"hljs-built_in\"\u003esmoothstep\u003c/span\u003e(_size, _size+\u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.001\u003c/span\u003e), _st);\n  uv *= \u003cspan class=\"hljs-built_in\"\u003esmoothstep\u003c/span\u003e(_size, _size+\u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.001\u003c/span\u003e), \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e)-_st);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e uv.x*uv.y;\n}\n\n\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ecross\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e _st, \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e _size){\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e  box(_st, \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(_size,_size/\u003cspan class=\"hljs-number\"\u003e4.\u003c/span\u003e)) +\n          box(_st, \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(_size/\u003cspan class=\"hljs-number\"\u003e4.\u003c/span\u003e,_size));\n}\n\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e main(){\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st = \u003cspan class=\"hljs-built_in\"\u003egl_FragCoord\u003c/span\u003e.xy/u_resolution.xy;\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e color = \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e);\n\n  st.x += noise(\u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(u_time, \u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e)); \n  st.y += noise(\u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e, u_time));\n  color += \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003ecross\u003c/span\u003e(st,\u003cspan class=\"hljs-number\"\u003e0.25\u003c/span\u003e));\n\n  \u003cspan class=\"hljs-built_in\"\u003egl_FragColor\u003c/span\u003e = \u003cspan class=\"hljs-type\"\u003evec4\u003c/span\u003e(color,\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e将 st 的 x/y 值加上 noise 时间的效果，达到 “+” 四处跑的效果，而不是规律运动。\u003c/p\u003e\n\u003ch3\u003eSimplex Noise\u003c/h3\u003e\n\u003cp\u003e前面的 Noise 实现方式过于复杂，对于 N 维你需要插入 2 的 n 次方个点，而 Simplex Noise 采用三角形来替换正方形，并把平滑函数改成四次 Hermite 函数，效果更平滑。\u003c/p\u003e\n\u003cp\u003e习题： 做一个 shader 来表现流体的质感。比如像熔岩灯，墨水滴，水，等等。\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/shader11.4.gif\" alt=\"\"\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e snoise(\u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e v) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003evec4\u003c/span\u003e C = \u003cspan class=\"hljs-type\"\u003evec4\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.211324865405187\u003c/span\u003e,  \u003cspan class=\"hljs-comment\"\u003e// (3.0-sqrt(3.0))/6.0\u003c/span\u003e\n                      \u003cspan class=\"hljs-number\"\u003e0.366025403784439\u003c/span\u003e,  \u003cspan class=\"hljs-comment\"\u003e// 0.5*(sqrt(3.0)-1.0)\u003c/span\u003e\n                      \u003cspan class=\"hljs-number\"\u003e-0.577350269189626\u003c/span\u003e,  \u003cspan class=\"hljs-comment\"\u003e// -1.0 + 2.0 * C.x\u003c/span\u003e\n                      \u003cspan class=\"hljs-number\"\u003e0.024390243902439\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 1.0 / 41.0\u003c/span\u003e\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e i  = \u003cspan class=\"hljs-built_in\"\u003efloor\u003c/span\u003e(v + \u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e(v, C.yy) );\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e x0 = v -   i + \u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e(i, C.xx);\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e i1;\n  i1 = (x0.x \u0026gt; x0.y) ? \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e) : \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e);\n  \u003cspan class=\"hljs-type\"\u003evec4\u003c/span\u003e x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod289(i); \u003cspan class=\"hljs-comment\"\u003e// Avoid truncation effects in permutation\u003c/span\u003e\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e p = permute( permute( i.y + \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e, i1.y, \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e ))\n      + i.x + \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e, i1.x, \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e ));\n\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e m = \u003cspan class=\"hljs-built_in\"\u003emax\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e - \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e(x0,x0), \u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e(x12.xy,x12.xy), \u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e(x12.zw,x12.zw)), \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e);\n  m = m*m ;\n  m = m*m ;\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e * \u003cspan class=\"hljs-built_in\"\u003efract\u003c/span\u003e(p * C.www) - \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e;\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e h = \u003cspan class=\"hljs-built_in\"\u003eabs\u003c/span\u003e(x) - \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e;\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e ox = \u003cspan class=\"hljs-built_in\"\u003efloor\u003c/span\u003e(x + \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e);\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e a0 = x - ox;\n  m *= \u003cspan class=\"hljs-number\"\u003e1.79284291400159\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e0.85373472095314\u003c/span\u003e * ( a0*a0 + h*h );\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e130.0\u003c/span\u003e * \u003cspan class=\"hljs-built_in\"\u003edot\u003c/span\u003e(m, g);\n}\n\n\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e main() {\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st = \u003cspan class=\"hljs-built_in\"\u003egl_FragCoord\u003c/span\u003e.xy / u_resolution.xy;\n  st.x *= u_resolution.x / u_resolution.y;\n  \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e color = \u003cspan class=\"hljs-type\"\u003evec3\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e);\n\n  st = st + st * snoise(st + u_time / \u003cspan class=\"hljs-number\"\u003e50.\u003c/span\u003e) / \u003cspan class=\"hljs-number\"\u003e3.\u003c/span\u003e;\n  color += \u003cspan class=\"hljs-built_in\"\u003esmoothstep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e.4\u003c/span\u003e , \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e, snoise(st * \u003cspan class=\"hljs-number\"\u003e5.\u003c/span\u003e));\n\n  \u003cspan class=\"hljs-built_in\"\u003egl_FragColor\u003c/span\u003e = \u003cspan class=\"hljs-type\"\u003evec4\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003e-color,\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e首先是先做出合适的泼墨图，这个在前文就有介绍到，采用的是 Gradient Noise 的方式，改造好后，则是加入时间变量，让 st 的坐标随着 snoise 下的时间变化。\u003c/p\u003e\n\u003ch2\u003e网格噪声 Cellular Noise 与 分形布朗运动 Fractal Brownian Motion\u003c/h2\u003e\n\u003cp\u003eGLSL 对 for 循环是不太友好，无法动态处理，当你有多个特征点的时候，若每个像素都计算一次到特征点的关系距离，其计算量也是很大的。为此，提出了 \u003cstrong\u003e网格噪音\u003c/strong\u003e 方式，即是：将空间分割成网状，每个像素点只计算其相邻块（一共八个）的特征点。\u003c/p\u003e\n\u003cp\u003e分形布朗运动：则是在循环的过程中叠加噪音，并提高频率降低振幅，来显示更好的细节。如下面的方式\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-meta\"\u003e#define OCTAVES 6\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e fbm (\u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e st) {\n  \u003cspan class=\"hljs-comment\"\u003e// Initial values\u003c/span\u003e\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e value = \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e;\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e amplitude = \u003cspan class=\"hljs-number\"\u003e.5\u003c/span\u003e;\n  \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e frequency = \u003cspan class=\"hljs-number\"\u003e0.6\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e// Loop of octaves\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; OCTAVES; i++) {\n    value += amplitude * noise(st);\n    st *= \u003cspan class=\"hljs-number\"\u003e2.\u003c/span\u003e;\n    amplitude *= \u003cspan class=\"hljs-number\"\u003e.5\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e value;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efbm 函数在循环的过程中，叠加噪音，让图形有更多的细节。\u003c/p\u003e\n\u003cp\u003e域翘曲：通过 fbm 函数来扭曲 fbm，简单来讲就是多维的 fbm，通过下面来了解一下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 基本方式 f(p) = fbm( p )\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e pattern( \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e p ) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e fbm( p );\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 添加第二次翘曲 (p) = fbm( p + fbm( p ) )\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e pattern( \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e p ) {\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e q = \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e( fbm( p + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e) ),\n                 fbm( p + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5.2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1.3\u003c/span\u003e) ) );\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e fbm( p + \u003cspan class=\"hljs-number\"\u003e4.0\u003c/span\u003e*q );\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 添加第三次翘曲 f(p) = fbm( p + fbm( p + fbm( p )) )\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e pattern( \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e p ) {\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e q = \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e( fbm( p + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e) ),\n                 fbm( p + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5.2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1.3\u003c/span\u003e) ) );\n\n  \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e r = \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e( fbm( p + \u003cspan class=\"hljs-number\"\u003e4.0\u003c/span\u003e*q + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.7\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e9.2\u003c/span\u003e) ),\n                 fbm( p + \u003cspan class=\"hljs-number\"\u003e4.0\u003c/span\u003e*q + \u003cspan class=\"hljs-type\"\u003evec2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e8.3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2.8\u003c/span\u003e) ) );\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e fbm( p + \u003cspan class=\"hljs-number\"\u003e4.0\u003c/span\u003e*r );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e多次 fbm 之后生成类似 fbm 的纹理。比如下图：\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/shader12.gif\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e片元着色器和顶点着色器的学习很不一样，前者需要对图形实现的熟悉，比如常见的方法函数，后者则是三维空间变化，涉及到更多矩阵数据。后面的学习，将继续牢固基础，看更多的教程，同时也要开始筹划 three.js 的学习了。\u003c/p\u003e\n"}},"buildId":"r4Ww0YLm8YL5~6SwciWHH","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/r4Ww0YLm8YL5~6SwciWHH/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.8cd9ed8a1e291a1c384b.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.353e3313ade96b9a9aaa.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-e6109d035063d4ea44d2.js" async=""></script></body></html>