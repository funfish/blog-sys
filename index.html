<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">funfish 的博客</title><link rel="preload" href="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/Index/Index.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.ce3e8fb7a689beb447ad.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.8d98f9151bcde6fb2a87.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-45be5a1f94c3fe5df8ee.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.bb30b296.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___3Hk0c hasBannerImg___86Yg8"><a class="logo___1KD30" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___1qXLb" href="/blog-sys/">Home</a></li></ul></nav><header style="background-image:url(/blog-sys/static/snowfield.jpg);background-size:cover" class="banner___2FJmA"><div class="mask___1Eks5"></div><div class="indexTitleWrap___25J7Q"><h1 class="postTitle___26vXM">Funfish Blog</h1><p>纸上得来终觉浅，绝知此事要躬行</p></div></header><div class="postListWrapper___2b-To"><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">对布局和视频加载的想法</h2><div class="postContent___2t3Ln"><p>最近上线了一个<a href="http://www.coloros.com/topic/coloros6.html" target="_blank">官网主题页</a>，也是我的第一个对外页面，嗯，很符合活动页特点，开发周期短，逻辑含量低。但是毕竟以前没有接触过，写下来还是有不少感受的。</p>
<h2>布局</h2>
<p>布局最常见的方案就是居中布局 + 响应式布局。居中布局可选方案多，为了兼容 ie 9，选取的是 <code>text-align: center</code> 的方式；响应式布局为了提高维护性，以 pc 端设计稿的 100px 为 1rem。立马开工，只是没有一会就发现问题了：</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->November 25, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">React Suspense data fetching 探究</h2><div class="postContent___2t3Ln"><p>最近 React 16.6 中提出了新组件 Suspense 允许 React 挂起组件渲染直到 IO 的数据返回。这个特性在 JSConf Iceland 中 <a href="https://www.youtube.com/watch?v=nLF0n9SACd4" target="_blank">Beyond React 16</a> 里面 Dan 就介绍到了，并在半年后的今天登陆 React 16.6。</p>
<h3>Suspense 简单用法</h3>
<p>在官网教程里面介绍到 Suspense 与 React.lazy 结合做 <a href="https://reactjs.org/docs/code-splitting.html#reactlazy" target="_blank">Code-Spliting</a> ，自然是可以这么用的，只是这更多的是代码分割，除了代码分割以外 IO 的处理，在 Beyond React 16 演讲中还提到了 <strong>data fetching</strong>，Dan 的第二个 demo 主要提到的也是 data fetching。下面先看看 Suspense 的一个简单的非代码分割的 demo：</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->December 12, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">Decorator</h2><div class="postContent___2t3Ln"><h3>前言</h3>
<p>ESnext 里面提到的修饰器，在 redux 的推广下，几乎每个工程师都有或多或少的用过，最常见的就是 <code>@connect</code> 的形式，而在 Java 领域同样也存在 <code>@</code> 这种符号的存在，被称之为注解，而巧的是修饰器同样能实现注解的功能。在看 Java 的注解的时候必然会看到反射这个概念。在阅读下面之前请先看阮老师的文档<a href="http://es6.ruanyifeng.com/#docs/decorator" target="_blank">修饰器</a>，再看下文。</p>
<h3>Babel 开发环境须知</h3>
<p>修饰器 Decorator 是 ES7 里面提出的，在 babel 6 里面需要引入 <code>preset-stage-2</code>，并在 .babelrc 中配置 <code>&quot;presets&quot;: [&quot;env&quot;, &quot;stage-2&quot;]</code>。到了 babel 7.0.0-beta.54 之前，则是需要 npm 包 <code>@babel/preset-stage-2</code>，配置 .babelrc 为  [&quot;@babel/preset-stage-2&quot;, { &quot;decoratorsLegacy&quot;: true }]，默认是关闭的。而 babel 7.0.0-beta.54 之后的版本里面，已经 <strong>弃用 Stage Preset</strong> ，所以后面需要安装的版本是 <code>@babel/plugin-proposal-decorators</code> 配置为 <code>[&quot;@babel/plugin-proposal-decorators&quot;, { &quot;legacy&quot;: true }]</code>，这样可以达到以前的效果，具体看<a href="https://github.com/babel/babel/tree/master/packages/babel-preset-stage-0#babelpreset-stage-0" target="_blank">官方介绍</a>，以及<a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators" target="_blank">@babel/plugin-proposal-decorators</a>。目前 babel 7.1.0 已经发布了<a href="https://babeljs.io/blog/2018/09/17/decorators" target="_blank">TC39 Standards Track Decorators in Babel</a>。</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->October 11, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">react之Reconciliation</h2><div class="postContent___2t3Ln"><p>React 的特点在于其异步渲染，fiber机制，是其他类 react 框架无法比拟的。前面介绍了些很基本的异步渲染。接下来介绍一下传说中的 diff 算法吧。其实这个在 <a href="https://reactjs.org/docs/reconciliation.html" target="_blank">React 官方文档 Reconciliation</a> 里面早有介绍（advanced guide 里面的内容很多初级 React 工程师应该都没有看过，然而 advanced guide 里面包含了 context、错误边界、HOC、render props 以及 Reconciliation，没有看过的还请多刷几遍）。其中两大基准假设如下</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->August 4, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">react 开启异步渲染与优先级</h2><div class="postContent___2t3Ln"><p><img src="https://github.com/funfish/blog/raw/master/images/react16AsyncFiber.PNG" alt=""></p>
<p>在研究时间调度时就有 React 的异步渲染的迹象了，只是在实际应用中却不知道如何开启，如何跟踪，后来看了 <a href="https://github.com/koba04/react-fiber-resources" target="_blank">react-fiber-resources</a> 上面介绍的 <strong>Try React Fiber asynchronous rendering!</strong>。其实在 React 的博客 <a href="https://reactjs.org/blog/2017/09/26/react-v16.0.html" target="_blank">React v16.0</a> 发布之际就已经说明了：</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 30, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">react 时间调度</h2><div class="postContent___2t3Ln"><h2>前言</h2>
<p>继续前面两篇 react 的分析。提到 react 16，除了 fiber 机制之外，还有其调度机制。这里就不得不提 requestIdleCallback 了，react 采用了 requestIdleCallback 的思想来实现调度，为什么说思想呢，因为 requestIdleCallback 是新出的 api，兼容性差，很多现代浏览器都不支持。于是 react 团队就写了一个 ployfill。</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/requestIdleCallback-caniuse.PNG" alt=""></p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 28, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">react 源码下一步</h2><div class="postContent___2t3Ln"><h2>前言</h2>
<p>前文提到了一个简单的 react 例子，结构如下所示</p>
<pre class="hljs"><code>ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>,
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'container'</span>)
);
</code></pre>
<p>只是实在简单呀，缺少 state，缺少状态的变化，于是用另外一个例子来继续研究：</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 15, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">react 源码开始的那一步</h2><div class="postContent___2t3Ln"><h2>前言</h2>
<p>本来想着学习路径是从 react 周围生态开始的，比如之前的 preact，react-router，再到后面 immutable.js，读懂这些源码，接着可以看 dva，rematch，亦或则是 redux，甚至是 ant-design 都可以看看的，到了最后再吃大餐，react 源码。只是不知道为什么想要挑战一下自己，不想这么循循渐进。想要试试自己的实力。于是便有了这次的 react 源码的阅读。</p>
<p>刚开始读的时候觉得看 react 源码是一种享受，就像在读一本小说一样，惊险刺激，停不下来。只是后面到了 fiber 的阶段，就有点懵逼了，这绝对是烧脑侦探片，而我是里面的路人甲，看几行代码都觉得费劲。这个时候遇到了<a href="https://zhuanlan.zhihu.com/p/36996225" target="_blank">如何阅读大型前端开源项目的源码</a>，文章写得极好，根据上面的内容开始去看 react 文档里面的 Contribution Guide 里面的指导，随后又读了读 Blog 部分，简直是 amazing，尤其是<a href="https://www.youtube.com/watch?v=v6iR3Zk4oDY" target="_blank">Beyond React 16 by Dan Abramov</a>，以及<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs&amp;list=PLb0IAmt7-GS3fZ46IGFirdqKTIxlws7e0&amp;index=5" target="_blank">A Cartoon Intro to Fiber </a>。看得内心澎湃，觉得为何自己不能早点入坑呢？随后有看了<a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank">正妹</a>，以及<a href="https://zhuanlan.zhihu.com/p/37098539" target="_blank">方大神</a>的介绍，顿时有了不少底气。</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->November 12, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">HTTP 2 笔记</h2><div class="postContent___2t3Ln"><h2>前言</h2>
<p>续网络请求后，学习 HTTP/2。HTTP/2 的主要协议 RFC 7540 出来已经三年多了，HTTP/2 的应用也越来越多。几年前还在为 HTTPS 响应速度慢，能不上 HTTPS 就不上，结果现在基本成为标配了。对于大型系统，HTTP/2 也会是这样，毕竟知乎都是 HTTP 2 了。</p>
<h2>HTTP/1.1</h2>
<p>从 HTTP/1.1 诞生至今，互联网已经走过了十几个年头，当初的 HTTP/1.1 协议出现了不少缺陷，其中管线化，就是其中一个突出问题。
<img src="https://github.com/funfish/blog/raw/master/images/httpInitLink.PNG" alt=""></p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">网络请求</h2><div class="postContent___2t3Ln"><h2>前言</h2>
<p>一直好奇网络请求具现出来是什么样子的。从面试官的一个问题，在浏览器输入网址之后，到页面生成，中间会发生什么。为了这个问题，看了《计算机网络:自顶向下》，《图解HTTP》，学习了 node.js 中关于网络部分的源码，结果却还是自认为相差甚远，直到接触了路由表，才开始所有感觉，觉得补上缺失的一脚。</p>
<h2>网络结构</h2>
<p>OSI 7 层模型定义了一个规范概念，而 TCP/IP 的4 层结构则给出了实现。两者的比较，网上多有资源，这里不做对比了，结合发快递的过程来说说吧：</p>
<ol>
<li>第七层，应用层，常见协议 Http、Https、DNS、FTP。作用是为应用程序接口提供网络，直白来讲，就是提供请求/响应数据服务。数据也叫做应用层数据 Application Data；在快递上，就是你自己把要发的快递准备好，包括目的地 url 等。</li>
</ol>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">翻译 RRB-Trees  Efficient Immutable Vectors</h2><div class="postContent___2t3Ln"><h3>概论</h3>
<p>不可变结构是一种很便利的函数式编程的数据结构，也是现代语言标准库如 Clojure 和 Scala 的一部分。其相同的部分是基于有固定数量的子节点的多阶树，允许快速查询和更新操作。在本文中我们采用了一种新的潜在的 vector 结构 Relaxed Radix Balanced Trees（RRB-Trees）。并展示了这种数据结构在 O(logN) 的时间里进行不可变数据 vector 的串联，插入和分割操作，同时维持着和原始 vector 数据结构的查询、更新和迭代接近的速度。</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">immutable.js 数据结构</h2><div class="postContent___2t3Ln"><h3>前言</h3>
<p>前文《初识immutable》介绍 immutable 的一些基本操作和特色，但是其重点部分<strong>结构共享</strong>，即数据结构留在了这里。这不是平时接触到的简单的数组、对象亦或则字典的形式，而是 tree ！日常开发基本就遇不到树结构，再复杂一个字典表就可以搞定了，于是乎 immutable.js 提供了一次很好的学习数据结构，学习算法的体验。</p>
<h3>共享结构</h3>
<p>共享结构还是比较简单的。对于已有的数据结构，若需要更新其中的某个节点（中间节点或则子叶），并不会把整个数据结构都拷贝一份，再修改该节点并返回新的数据结构。<strong>immutable.js 里面会采用路径修改的方式来实现更新。</strong></p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">初识immutable</h2><div class="postContent___2t3Ln"><h3>前言</h3>
<p>Immutable.js 出来已经有很长一段时间了，只是日常项目中一直用不上。一个是平时没有怎么接触，不了解，另外一个是团队的开发节奏和习惯已经稳定下来了，要改变也不容易。当然了解一下也不差。</p>
<p>不可变的数据一旦生成，就无法被改变，这就要求数据可持久化。可是日常中的引用类型的数据，一旦改变了，就改变了，谈什么持久化数据结构呢？</p>
<h3>接触immutable</h3>
<p>感受一下immutable的不同：</p>
<pre class="hljs"><code><span class="hljs-comment">// 原本写法：</span>
<span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
</code></pre>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">react-router 4 与 context</h2><div class="postContent___2t3Ln"><h2>前言</h2>
<p>最近我司要上线一个 Hybird 上的 SPA，17 年年底的时候已经写过 demo 给产品和 leader 看了，近期准备要上线。问题在于，当时准备仓促，又想要玩一玩 react，导致了用的版本是比较成熟的，嗯。。。。意思就是比较老的版本，react-router 是 3.x 版本，而 react 也只是 16.0 而已。对于有追求的我而言，升级势在必行。</p>
<h2>问题所在</h2>
<p>在 Vue 应用里面用 Vue-router 就是一个 routes 的事情，甚至连 routes 都可以不是嵌套解构，直接一维路由，毕竟业务少。到了之前写的 react 也是采用了这种方式，如下：</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">preact源码 - 组件与回收机制</h2><div class="postContent___2t3Ln"><h3>前言</h3>
<p>前面介绍到 diff 方法，但是我们只是从简单的例子开始的，并没有用到组件，而组件才是最重要的部分，毕竟一切的一切可以是组件。</p>
<h3>组件 Component</h3>
<p>先看看 Preact 输出的 Component 长什么样子：</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component</span>(<span class="hljs-params">props, context</span>) </span>{
  <span class="hljs-keyword">this</span>._dirty = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">this</span>.context = context;
  <span class="hljs-keyword">this</span>.props = props;
</code></pre>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->December 12, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">preact源码 - diff机制</h2><div class="postContent___2t3Ln"><h3>前言</h3>
<p>每次看到有人谈起 React 的 diff 机制的时候，总觉得很厉害的样子，所以自然这里也是立马就想介绍 diff 机制。</p>
<h3>diff 机制</h3>
<p>以下面为例子来介绍：</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { h, render } <span class="hljs-keyword">from</span> <span class="hljs-string">'preact'</span>;

render((
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"foo"</span>&gt;</span>
</span></code></pre>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">preact源码 - VDOM</h2><div class="postContent___2t3Ln"><h2>前言</h2>
<p>在工作上开始用 React 开发已经有四个多月了，不禁想看看 React 和 Vue 本质上有什么区别。当然一个是 jsx 文件，一个是 vue 文件，两个处理起来肯定是不一样的。想了想以后项目发展越来越大，肯定是要以 React 为主体的，深入了解 React 是必须的，尤其是 React 已经发展到 React 16 了，新特性都不晓得怎么用呢。为了减少初学习 React 源码的陡度，想着还是从 Preact 开始好了，毕竟后者声称兼容 React 而且，关键是体积小！</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">三种常见算法</h2><div class="postContent___2t3Ln"><h2>前言</h2>
<p>先吐槽。
金三银四，最近来我司计划招聘两名前端工程师，一名初级，一名中级，结果前来面试的人络绎不绝，让我也当面试官，结果呢。前来的有一两年工作经验的初级工程师，都是渣渣，不是基础差，就是广度不够，连笔试题目都做不出来，尤其是算法题目，简单的排序都做不出来。给我的感觉，连刚参加工作的我都不如。而后面试的两个中级工程师，面试后感觉也就比我差点，工作经验比我长点，可是这个期望薪水，是不是有点高呀。只是排序算法题大多用的是冒泡法，作为工程师不应该开口闭口都是快排吗。嗯，只是忽然想想自己也只是知道快排的思想，具体怎么实现，就懵逼了，于是才有了这篇博客。</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">webpack构建优化</h2><div class="postContent___2t3Ln"><h2>前言</h2>
<p>项目中经常用 Jenkins 构建项目，只要点击构建，服务端就会按照指令，重新拉取数据构建，这是很好的，只是久而久之发现一个问题：项目的构建时间从之前的飞快，到现在龟速。等待构建开发时间长是一个问题，更重要的是如果项目继续发展壮大呢？现在的 antd-pro 项目也就十来个页面，一点也不多，但是测试服构建起来，时间将近4分钟，特别吃内存。如果以后页面多很多呢？五六十个页面呢？那岂不是要二十来分钟的构建时间？内存呢，难道最后要溢出？这是难以置信的。</p>
<h2>初探问题</h2>
<p>春节期间前有空，上网查了一下方法，<code>webpack.optimize.UglifyJsPlugin</code> 几乎是千夫所指的，自带的代码丑化基本就是鸡肋，用上其他丑化插件，打包时间可以节省上30%，甚至更多，只是 antd-pro 用的是 roadhog.js，是一款接近于 create-react-app 的基础工具，能自己编写的配置参数少之又少，更不要提随意运用 webpack 的插件了。只是想要试探性的玩一下，于是在本地的 node_modules 里面修改了 roadhog 关于 webpack 的 UglifyJsPlugin 插件，结果一试，速度 duang 的一下就上来了。后来由于工作忙就没有怎么 care 构建问题。</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">白帽子讲web安全</h2><div class="postContent___2t3Ln"><h2>前言</h2>
<p>几个月前碰巧遇到人生第一个安全问题，在负责的输入部分没有做非法字符验证，于是随便写了个<code>alert('hahaha')</code>，导致保存后再次查看输入详情时，立马弹出对话框。究其缘由，是前端没有做字符验证，服务端也没有做验证，最后输入端采用jsp的后端渲染方式，于是一点开详情，就爆炸了。春节前有空就看了看《白帽子讲web安全》。</p>
<h2>XSS跨站脚本攻击</h2>
<p>XSS攻击，通常指黑客通过“HTML注入”篡改网页，插入恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。重点就是<strong>篡改网页</strong>。</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">文件的故事</h2><div class="postContent___2t3Ln"><h2>前言</h2>
<p>项目中遇到的文件下载，上传基本上最常见的事情了。大概半年前，需要实现某表单的查询下载功能，查询还好，只要后端返回数据，我负责展示就好了，但是下载要如何实现呢？用axios的GET请求返回的数据，不忍直视，根本就下载不了。一顿百度谷歌之后，哦，原来这么简单，只要一个<code>window.location.href=url</code>就搞定了，是不是很简单~</p>
<h2>文件下载</h2>
<p>后来的文件下载我都统统用这种方式，只是下载提示不够明显，后来改为<code>window.open</code>打开个新的tag页，然后自动关闭，明显点下载。好像到这里就已经很完美，一切交给浏览器解决。</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">初识系列：nodejs之stream可读流</h2><div class="postContent___2t3Ln"><h1>前言</h1>
<p>这是初识系列的第一篇：stream可读流。刚接触stream的时候有点难以理解，在客户端开发，基本接触不到stream，顶多也就是文档下载的时候，后端返回文件流，这个和stream沾边的东西。如此神秘，自然成为了首个研究的对象。nodejs对象里面有可读流，可写流，还有可读可写流，像HTTP响应Response对象就是可读流，而服务端的是可写流，下面介绍一下可读流Readable。</p>
<h1>基本</h1>
<p>常见用到可读流的情景是用<code>fs.createReadStream(path[, options])</code>，并通过监听可读流的<code>data</code>与<code>end</code>事件来操作，或则是用pipe方法将可读流的数据流到可写流里面。</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->November 12, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">Koa初识</h2><div class="postContent___2t3Ln"></div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">初识后端开发 express+MySQL</h2><div class="postContent___2t3Ln"><blockquote>
<p>本文大部分内容是基于<a href="http://www.alloyteam.com/2015/03/sexpressmysql/" target="_blank">初识NodeJS服务端开发（Express+MySQL）</a></p>
</blockquote>
<h1>前言</h1>
<p>本来只是想学习一下MySQL，毕竟隔几天就可以看到隔壁小伙伴在操作数据库有mySQL和Redis，好像还有mongodb？一直挺向往后端的，加上最近想自己打造一个个人博客,从数据库，服务器部署维护，后端nodejs实现集成，最后到前端展示，这些都想一一落实，于是开始数据库的学习。</p>
<p>正如本文开头所说的，大部分内容都是基于AlloyTeam的那边篇博客，本来没有必要写的，但是是第一次打通前后端的数据鸿沟，纪念一下，还是发表一下吧。</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">强制转换</h2><div class="postContent___2t3Ln"><h1>前言</h1>
<p>类型与文法，在两个月以前其实已经看完了，但看完‘this与对象原型’和‘类型与文法’章节后，却自以为早已经掌握，没有什么可以谈的，于是便束之高阁。直到前一阵子，部门分享python基础的时候，提到python没有变量声明，拿来就用。着不是和JS很像？JS为什么没有变量声明呢？记得C语言都用变量声明，为何JS没有呢？变量声明有什么作用？好不好？</p>
<p>知乎问题<a href="https://www.zhihu.com/question/19883873" target="_blank">为什么像 Java、C、C++ 这样的静态语言会比 Python、Ruby 这样的动态语言流行得多？</a></p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">vuex源码分析</h2><div class="postContent___2t3Ln"><h1>前言</h1>
<p>前文分析了Vue-router，感觉后劲十足，于是开始分析Vuex。在项目上，Vuex也是常客。它可以很好的管理状态，尤其是跨组件的时候，Vue的单向数据流使得子组件无法修改prop，经常用$emit和$on的话组件是要多难看就多难看。当组件切换，数据需要缓存总不能一直依赖于向上级组件emit传递数据吧？如果要更好的管理状态，Vuex是个很好的选择。Vuex代码量较Vue-router少了很多，而且也没有flow的校验机制，看起来更加习惯了。这里介绍的Vuex版本号为2.4.1。</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">vue-router源码分析</h2><div class="postContent___2t3Ln"><h1>前言</h1>
<p>用了Vue快一年多了(虽然中间间断好长时间)，就越发的对其周边的生态感兴趣，尤其是对Vue-router和Vuex，Vue-router是单页面应用的核心部件，基本上的路由跳转都依赖它，项目上用的比较多的Vonic也是基于于Vue-router的；而Vuex只是在状态变化较多，需要store的时候才用上。本文先介绍Vue-router(2.7.0)，有时间再介绍Vuex；</p>
<h1>从示例开始</h1>
<p>下面是官方给出的示例basic，清晰的介绍了VueRouter最基本使用方法：</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">了解Node.js中的网络通信</h2><div class="postContent___2t3Ln"><h1>前言</h1>
<p>一直想知道Node.js是如何作为一个用js语言写的后端平台。这个设定很是奇怪，前端开始涉足后端了？刚开始用api实现通信的时候，蛮简单的，框架都不用到，简单几句就能实现通信，于是借此机会研究一下Node.js的通信。</p>
<h1>从net模块出发</h1>
<p>看一个简单的例子</p>
<pre class="hljs"><code><span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>).createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    res.end(<span class="hljs-string">'hello world'</span>);
}).listen(<span class="hljs-number">8181</span>);
</code></pre>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">You-Dont-Know-JS之this 与对象原型</h2><div class="postContent___2t3Ln"><h1>前言</h1>
<p>遥记得以前刚开始写JavaScript的时候，起步就是jQuery，用的也简单，后来想学习原生的JavaScript，刚上来就遇到this的问题，每次都要去看阮老师那篇2010年写的博客，再不就去点开那篇一直珍藏着的<a href="http://bonsaiden.github.io/JavaScript-Garden/zh/" target="_blank">JavaScript 秘密花园</a>，每次看完都以为知道，但是后来遇到了总是要再回去一下，直到之前面试，以防万一又看了一遍。。。。。。书中提及的this，在这里更是要总结一下</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">You-Dont-Know-JS之作用域与闭包</h2><div class="postContent___2t3Ln"><h1>前言</h1>
<p>读的书多了，渐渐也能有自己的体会，书有平庸之作，也有佳作，但有些时候我觉得更多要看人。
在看了Vue和backbone的源码后，越发感觉自己的代码水平有待提高，但常见的各种动物书都看过了，一时间不知道看啥书好。于是在傻乎逛了一圈后，发现《你不知道的JavaScript》这本书，严格来说是上卷，很早以前就听大名，仿佛和高程三齐名，只是一直以没有时间为理由，没有接触。巧的是在傻乎上发现《你不知道的JavaScript》已经在github上出了<a href="https://github.com/JoeHetfield/You-Dont-Know-JS" target="_blank">中文版</a>，而且是全套完整的，幸福来的太突然。细读之，颇有收获，故在此分享。</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">backbone之Events实现</h2><div class="postContent___2t3Ln"><h1>前言</h1>
<p>记得某次在大神的博客里面讲技术选型，提到团队对Backbone的框架很熟悉，在一次开发的时候选用Backbone源码的一部分，再搭配其他的使用。虽然Backbone现在已经不流行了，但从几年前我就开始听说它的存在了，一直觉得这么神奇的框架肯定很有必要学习，看到大神提到选取Backbone源码的一部分，顿时觉得大神就是大神，对源码运用与此精通。最近有空看Backbone源码，细读时，如啃老牛肉，又硬又难吃，常常看了一部分忘记另外一部分，疼苦不堪，后来结合Backbone的<a href="http://www.css88.com/doc/backbone/" target="_blank">api文档</a>和里面的Todos例子顿时觉得，神清气爽，仿佛任督二脉都打通了，只是看过之后愈发觉得，Backbone框架已经不是前端的弄潮儿，只是接近2000+的源码，里面的MVC思想，值得去研究，而不是天天研究如何运用新框架的api</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">void 0 以及let const var 的理解</h2><div class="postContent___2t3Ln"><h1>void 0</h1>
<p>最近在backbone的源码(两年前就研究过underscore的源码，现在才看backbone是不是有点那个)，发现里面用到了void 0，这是什么鬼？void居然出现在JavaScript里面，敢情以前用的ES是假的....这么基础的东西，瞟一眼MDN文档，还果然有:</p>
<blockquote>
<p>void: 运算符 对给定的表达式进行求值，然后返回 undefined。</p>
</blockquote>
<p>So, void 0就是返回undefined了，这不是多此一举？直接用undefined来判断，不就完事了，何必用上void 0，这种云里雾里的操作？</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">webpack-dev-middleware主要源码理解</h2><div class="postContent___2t3Ln"><h1>前言</h1>
<p>每次用Vue-cli的时候，都会觉得配置的nodejs服务器很是让人省心，几个项目下来，都只用关心工程前端部分，用久了便想探其究竟。后来才发现原理用了express框架，代码也挺简单的，但是里面用的一个中间件webpack-dev-middleware，刚开始看的时候却不知有何用处？既然是express框架，又用的是SPA，路由不需要express来分发，那webpack-dev-middleware有何用处？抱着这样的疑问，看源码去吧</p>
<h1>思路</h1>
<p>一般express中间件的结构如下所示：</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section><section class="postPreview___1lWlV post-article"><h2 class="postTitle___LRAIr">Vue 0.6.0 早期源码研究</h2><div class="postContent___2t3Ln"><h1>前言</h1>
<p>相信大家都或多或少接触过Vue，先前就有人介绍学习Vue的源码，提到旧版本的源码行数只不过一千多行，可以一个一个commit学习下去。前段时间为了找下家，一直在用Vue做作品，效率也较以前原生JavaScript要快上许多，后来工作上手了，不禁想看看Vue源码长什么样子的，只是从第一个commit开始读起来较为费时，而Github上面Vue项目能够找到的最早branch是<a href="https://github.com/vuejs/vue/tree/0.10" target="_blank">Vue 0.10</a>，然而在发布版本里面，可以发现最好早一版本是<a href="https://github.com/vuejs/vue/tags?after=v0.7.2" target="_blank">0.6.0版本</a>。本文介绍也是从该本版开始，该版本较0.10的要上少40%左右。</p>
</div><p class="postTime___2RjIc">Posted by Funfish on <!-- -->July 7, 2018</p></section></div></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"postList":[{"createTimeEN":"November 25, 2018","id":33,"title":"对布局和视频加载的想法","content":"\u003cp\u003e最近上线了一个\u003ca href=\"http://www.coloros.com/topic/coloros6.html\" target=\"_blank\"\u003e官网主题页\u003c/a\u003e，也是我的第一个对外页面，嗯，很符合活动页特点，开发周期短，逻辑含量低。但是毕竟以前没有接触过，写下来还是有不少感受的。\u003c/p\u003e\n\u003ch2\u003e布局\u003c/h2\u003e\n\u003cp\u003e布局最常见的方案就是居中布局 + 响应式布局。居中布局可选方案多，为了兼容 ie 9，选取的是 \u003ccode\u003etext-align: center\u003c/code\u003e 的方式；响应式布局为了提高维护性，以 pc 端设计稿的 100px 为 1rem。立马开工，只是没有一会就发现问题了：\u003c/p\u003e\n"},{"createTimeEN":"December 12, 2018","id":32,"title":"React Suspense data fetching 探究","content":"\u003cp\u003e最近 React 16.6 中提出了新组件 Suspense 允许 React 挂起组件渲染直到 IO 的数据返回。这个特性在 JSConf Iceland 中 \u003ca href=\"https://www.youtube.com/watch?v=nLF0n9SACd4\" target=\"_blank\"\u003eBeyond React 16\u003c/a\u003e 里面 Dan 就介绍到了，并在半年后的今天登陆 React 16.6。\u003c/p\u003e\n\u003ch3\u003eSuspense 简单用法\u003c/h3\u003e\n\u003cp\u003e在官网教程里面介绍到 Suspense 与 React.lazy 结合做 \u003ca href=\"https://reactjs.org/docs/code-splitting.html#reactlazy\" target=\"_blank\"\u003eCode-Spliting\u003c/a\u003e ，自然是可以这么用的，只是这更多的是代码分割，除了代码分割以外 IO 的处理，在 Beyond React 16 演讲中还提到了 \u003cstrong\u003edata fetching\u003c/strong\u003e，Dan 的第二个 demo 主要提到的也是 data fetching。下面先看看 Suspense 的一个简单的非代码分割的 demo：\u003c/p\u003e\n"},{"createTimeEN":"October 11, 2018","id":31,"title":"Decorator","content":"\u003ch3\u003e前言\u003c/h3\u003e\n\u003cp\u003eESnext 里面提到的修饰器，在 redux 的推广下，几乎每个工程师都有或多或少的用过，最常见的就是 \u003ccode\u003e@connect\u003c/code\u003e 的形式，而在 Java 领域同样也存在 \u003ccode\u003e@\u003c/code\u003e 这种符号的存在，被称之为注解，而巧的是修饰器同样能实现注解的功能。在看 Java 的注解的时候必然会看到反射这个概念。在阅读下面之前请先看阮老师的文档\u003ca href=\"http://es6.ruanyifeng.com/#docs/decorator\" target=\"_blank\"\u003e修饰器\u003c/a\u003e，再看下文。\u003c/p\u003e\n\u003ch3\u003eBabel 开发环境须知\u003c/h3\u003e\n\u003cp\u003e修饰器 Decorator 是 ES7 里面提出的，在 babel 6 里面需要引入 \u003ccode\u003epreset-stage-2\u003c/code\u003e，并在 .babelrc 中配置 \u003ccode\u003e\u0026quot;presets\u0026quot;: [\u0026quot;env\u0026quot;, \u0026quot;stage-2\u0026quot;]\u003c/code\u003e。到了 babel 7.0.0-beta.54 之前，则是需要 npm 包 \u003ccode\u003e@babel/preset-stage-2\u003c/code\u003e，配置 .babelrc 为  [\u0026quot;@babel/preset-stage-2\u0026quot;, { \u0026quot;decoratorsLegacy\u0026quot;: true }]，默认是关闭的。而 babel 7.0.0-beta.54 之后的版本里面，已经 \u003cstrong\u003e弃用 Stage Preset\u003c/strong\u003e ，所以后面需要安装的版本是 \u003ccode\u003e@babel/plugin-proposal-decorators\u003c/code\u003e 配置为 \u003ccode\u003e[\u0026quot;@babel/plugin-proposal-decorators\u0026quot;, { \u0026quot;legacy\u0026quot;: true }]\u003c/code\u003e，这样可以达到以前的效果，具体看\u003ca href=\"https://github.com/babel/babel/tree/master/packages/babel-preset-stage-0#babelpreset-stage-0\" target=\"_blank\"\u003e官方介绍\u003c/a\u003e，以及\u003ca href=\"https://babeljs.io/docs/en/babel-plugin-proposal-decorators\" target=\"_blank\"\u003e@babel/plugin-proposal-decorators\u003c/a\u003e。目前 babel 7.1.0 已经发布了\u003ca href=\"https://babeljs.io/blog/2018/09/17/decorators\" target=\"_blank\"\u003eTC39 Standards Track Decorators in Babel\u003c/a\u003e。\u003c/p\u003e\n"},{"createTimeEN":"August 4, 2018","id":30,"title":"react之Reconciliation","content":"\u003cp\u003eReact 的特点在于其异步渲染，fiber机制，是其他类 react 框架无法比拟的。前面介绍了些很基本的异步渲染。接下来介绍一下传说中的 diff 算法吧。其实这个在 \u003ca href=\"https://reactjs.org/docs/reconciliation.html\" target=\"_blank\"\u003eReact 官方文档 Reconciliation\u003c/a\u003e 里面早有介绍（advanced guide 里面的内容很多初级 React 工程师应该都没有看过，然而 advanced guide 里面包含了 context、错误边界、HOC、render props 以及 Reconciliation，没有看过的还请多刷几遍）。其中两大基准假设如下\u003c/p\u003e\n"},{"createTimeEN":"July 30, 2018","id":29,"title":"react 开启异步渲染与优先级","content":"\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/react16AsyncFiber.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e在研究时间调度时就有 React 的异步渲染的迹象了，只是在实际应用中却不知道如何开启，如何跟踪，后来看了 \u003ca href=\"https://github.com/koba04/react-fiber-resources\" target=\"_blank\"\u003ereact-fiber-resources\u003c/a\u003e 上面介绍的 \u003cstrong\u003eTry React Fiber asynchronous rendering!\u003c/strong\u003e。其实在 React 的博客 \u003ca href=\"https://reactjs.org/blog/2017/09/26/react-v16.0.html\" target=\"_blank\"\u003eReact v16.0\u003c/a\u003e 发布之际就已经说明了：\u003c/p\u003e\n"},{"createTimeEN":"July 28, 2018","id":28,"title":"react 时间调度","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e继续前面两篇 react 的分析。提到 react 16，除了 fiber 机制之外，还有其调度机制。这里就不得不提 requestIdleCallback 了，react 采用了 requestIdleCallback 的思想来实现调度，为什么说思想呢，因为 requestIdleCallback 是新出的 api，兼容性差，很多现代浏览器都不支持。于是 react 团队就写了一个 ployfill。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/requestIdleCallback-caniuse.PNG\" alt=\"\"\u003e\u003c/p\u003e\n"},{"createTimeEN":"July 15, 2018","id":27,"title":"react 源码下一步","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e前文提到了一个简单的 react 例子，结构如下所示\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eReactDOM.render(\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003eHello World!\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e,\n  \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.getElementById(\u003cspan class=\"hljs-string\"\u003e'container'\u003c/span\u003e)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e只是实在简单呀，缺少 state，缺少状态的变化，于是用另外一个例子来继续研究：\u003c/p\u003e\n"},{"createTimeEN":"November 12, 2018","id":26,"title":"react 源码开始的那一步","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e本来想着学习路径是从 react 周围生态开始的，比如之前的 preact，react-router，再到后面 immutable.js，读懂这些源码，接着可以看 dva，rematch，亦或则是 redux，甚至是 ant-design 都可以看看的，到了最后再吃大餐，react 源码。只是不知道为什么想要挑战一下自己，不想这么循循渐进。想要试试自己的实力。于是便有了这次的 react 源码的阅读。\u003c/p\u003e\n\u003cp\u003e刚开始读的时候觉得看 react 源码是一种享受，就像在读一本小说一样，惊险刺激，停不下来。只是后面到了 fiber 的阶段，就有点懵逼了，这绝对是烧脑侦探片，而我是里面的路人甲，看几行代码都觉得费劲。这个时候遇到了\u003ca href=\"https://zhuanlan.zhihu.com/p/36996225\" target=\"_blank\"\u003e如何阅读大型前端开源项目的源码\u003c/a\u003e，文章写得极好，根据上面的内容开始去看 react 文档里面的 Contribution Guide 里面的指导，随后又读了读 Blog 部分，简直是 amazing，尤其是\u003ca href=\"https://www.youtube.com/watch?v=v6iR3Zk4oDY\" target=\"_blank\"\u003eBeyond React 16 by Dan Abramov\u003c/a\u003e，以及\u003ca href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs\u0026amp;list=PLb0IAmt7-GS3fZ46IGFirdqKTIxlws7e0\u0026amp;index=5\" target=\"_blank\"\u003eA Cartoon Intro to Fiber \u003c/a\u003e。看得内心澎湃，觉得为何自己不能早点入坑呢？随后有看了\u003ca href=\"https://zhuanlan.zhihu.com/p/37095662\" target=\"_blank\"\u003e正妹\u003c/a\u003e，以及\u003ca href=\"https://zhuanlan.zhihu.com/p/37098539\" target=\"_blank\"\u003e方大神\u003c/a\u003e的介绍，顿时有了不少底气。\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":25,"title":"HTTP 2 笔记","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e续网络请求后，学习 HTTP/2。HTTP/2 的主要协议 RFC 7540 出来已经三年多了，HTTP/2 的应用也越来越多。几年前还在为 HTTPS 响应速度慢，能不上 HTTPS 就不上，结果现在基本成为标配了。对于大型系统，HTTP/2 也会是这样，毕竟知乎都是 HTTP 2 了。\u003c/p\u003e\n\u003ch2\u003eHTTP/1.1\u003c/h2\u003e\n\u003cp\u003e从 HTTP/1.1 诞生至今，互联网已经走过了十几个年头，当初的 HTTP/1.1 协议出现了不少缺陷，其中管线化，就是其中一个突出问题。\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/httpInitLink.PNG\" alt=\"\"\u003e\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":24,"title":"网络请求","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e一直好奇网络请求具现出来是什么样子的。从面试官的一个问题，在浏览器输入网址之后，到页面生成，中间会发生什么。为了这个问题，看了《计算机网络:自顶向下》，《图解HTTP》，学习了 node.js 中关于网络部分的源码，结果却还是自认为相差甚远，直到接触了路由表，才开始所有感觉，觉得补上缺失的一脚。\u003c/p\u003e\n\u003ch2\u003e网络结构\u003c/h2\u003e\n\u003cp\u003eOSI 7 层模型定义了一个规范概念，而 TCP/IP 的4 层结构则给出了实现。两者的比较，网上多有资源，这里不做对比了，结合发快递的过程来说说吧：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e第七层，应用层，常见协议 Http、Https、DNS、FTP。作用是为应用程序接口提供网络，直白来讲，就是提供请求/响应数据服务。数据也叫做应用层数据 Application Data；在快递上，就是你自己把要发的快递准备好，包括目的地 url 等。\u003c/li\u003e\n\u003c/ol\u003e\n"},{"createTimeEN":"July 7, 2018","id":23,"title":"翻译 RRB-Trees  Efficient Immutable Vectors","content":"\u003ch3\u003e概论\u003c/h3\u003e\n\u003cp\u003e不可变结构是一种很便利的函数式编程的数据结构，也是现代语言标准库如 Clojure 和 Scala 的一部分。其相同的部分是基于有固定数量的子节点的多阶树，允许快速查询和更新操作。在本文中我们采用了一种新的潜在的 vector 结构 Relaxed Radix Balanced Trees（RRB-Trees）。并展示了这种数据结构在 O(logN) 的时间里进行不可变数据 vector 的串联，插入和分割操作，同时维持着和原始 vector 数据结构的查询、更新和迭代接近的速度。\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":22,"title":"immutable.js 数据结构","content":"\u003ch3\u003e前言\u003c/h3\u003e\n\u003cp\u003e前文《初识immutable》介绍 immutable 的一些基本操作和特色，但是其重点部分\u003cstrong\u003e结构共享\u003c/strong\u003e，即数据结构留在了这里。这不是平时接触到的简单的数组、对象亦或则字典的形式，而是 tree ！日常开发基本就遇不到树结构，再复杂一个字典表就可以搞定了，于是乎 immutable.js 提供了一次很好的学习数据结构，学习算法的体验。\u003c/p\u003e\n\u003ch3\u003e共享结构\u003c/h3\u003e\n\u003cp\u003e共享结构还是比较简单的。对于已有的数据结构，若需要更新其中的某个节点（中间节点或则子叶），并不会把整个数据结构都拷贝一份，再修改该节点并返回新的数据结构。\u003cstrong\u003eimmutable.js 里面会采用路径修改的方式来实现更新。\u003c/strong\u003e\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":21,"title":"初识immutable","content":"\u003ch3\u003e前言\u003c/h3\u003e\n\u003cp\u003eImmutable.js 出来已经有很长一段时间了，只是日常项目中一直用不上。一个是平时没有怎么接触，不了解，另外一个是团队的开发节奏和习惯已经稳定下来了，要改变也不容易。当然了解一下也不差。\u003c/p\u003e\n\u003cp\u003e不可变的数据一旦生成，就无法被改变，这就要求数据可持久化。可是日常中的引用类型的数据，一旦改变了，就改变了，谈什么持久化数据结构呢？\u003c/p\u003e\n\u003ch3\u003e接触immutable\u003c/h3\u003e\n\u003cp\u003e感受一下immutable的不同：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 原本写法：\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e a = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e];\n\u003c/code\u003e\u003c/pre\u003e\n"},{"createTimeEN":"July 7, 2018","id":20,"title":"react-router 4 与 context","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e最近我司要上线一个 Hybird 上的 SPA，17 年年底的时候已经写过 demo 给产品和 leader 看了，近期准备要上线。问题在于，当时准备仓促，又想要玩一玩 react，导致了用的版本是比较成熟的，嗯。。。。意思就是比较老的版本，react-router 是 3.x 版本，而 react 也只是 16.0 而已。对于有追求的我而言，升级势在必行。\u003c/p\u003e\n\u003ch2\u003e问题所在\u003c/h2\u003e\n\u003cp\u003e在 Vue 应用里面用 Vue-router 就是一个 routes 的事情，甚至连 routes 都可以不是嵌套解构，直接一维路由，毕竟业务少。到了之前写的 react 也是采用了这种方式，如下：\u003c/p\u003e\n"},{"createTimeEN":"December 12, 2018","id":19,"title":"preact源码 - 组件与回收机制","content":"\u003ch3\u003e前言\u003c/h3\u003e\n\u003cp\u003e前面介绍到 diff 方法，但是我们只是从简单的例子开始的，并没有用到组件，而组件才是最重要的部分，毕竟一切的一切可以是组件。\u003c/p\u003e\n\u003ch3\u003e组件 Component\u003c/h3\u003e\n\u003cp\u003e先看看 Preact 输出的 Component 长什么样子：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprops, context\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._dirty = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.context = context;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props = props;\n\u003c/code\u003e\u003c/pre\u003e\n"},{"createTimeEN":"July 7, 2018","id":18,"title":"preact源码 - diff机制","content":"\u003ch3\u003e前言\u003c/h3\u003e\n\u003cp\u003e每次看到有人谈起 React 的 diff 机制的时候，总觉得很厉害的样子，所以自然这里也是立马就想介绍 diff 机制。\u003c/p\u003e\n\u003ch3\u003ediff 机制\u003c/h3\u003e\n\u003cp\u003e以下面为例子来介绍：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { h, render } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'preact'\u003c/span\u003e;\n\nrender((\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"foo\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n"},{"createTimeEN":"July 7, 2018","id":17,"title":"preact源码 - VDOM","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e在工作上开始用 React 开发已经有四个多月了，不禁想看看 React 和 Vue 本质上有什么区别。当然一个是 jsx 文件，一个是 vue 文件，两个处理起来肯定是不一样的。想了想以后项目发展越来越大，肯定是要以 React 为主体的，深入了解 React 是必须的，尤其是 React 已经发展到 React 16 了，新特性都不晓得怎么用呢。为了减少初学习 React 源码的陡度，想着还是从 Preact 开始好了，毕竟后者声称兼容 React 而且，关键是体积小！\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":16,"title":"三种常见算法","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e先吐槽。\n金三银四，最近来我司计划招聘两名前端工程师，一名初级，一名中级，结果前来面试的人络绎不绝，让我也当面试官，结果呢。前来的有一两年工作经验的初级工程师，都是渣渣，不是基础差，就是广度不够，连笔试题目都做不出来，尤其是算法题目，简单的排序都做不出来。给我的感觉，连刚参加工作的我都不如。而后面试的两个中级工程师，面试后感觉也就比我差点，工作经验比我长点，可是这个期望薪水，是不是有点高呀。只是排序算法题大多用的是冒泡法，作为工程师不应该开口闭口都是快排吗。嗯，只是忽然想想自己也只是知道快排的思想，具体怎么实现，就懵逼了，于是才有了这篇博客。\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":15,"title":"webpack构建优化","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e项目中经常用 Jenkins 构建项目，只要点击构建，服务端就会按照指令，重新拉取数据构建，这是很好的，只是久而久之发现一个问题：项目的构建时间从之前的飞快，到现在龟速。等待构建开发时间长是一个问题，更重要的是如果项目继续发展壮大呢？现在的 antd-pro 项目也就十来个页面，一点也不多，但是测试服构建起来，时间将近4分钟，特别吃内存。如果以后页面多很多呢？五六十个页面呢？那岂不是要二十来分钟的构建时间？内存呢，难道最后要溢出？这是难以置信的。\u003c/p\u003e\n\u003ch2\u003e初探问题\u003c/h2\u003e\n\u003cp\u003e春节期间前有空，上网查了一下方法，\u003ccode\u003ewebpack.optimize.UglifyJsPlugin\u003c/code\u003e 几乎是千夫所指的，自带的代码丑化基本就是鸡肋，用上其他丑化插件，打包时间可以节省上30%，甚至更多，只是 antd-pro 用的是 roadhog.js，是一款接近于 create-react-app 的基础工具，能自己编写的配置参数少之又少，更不要提随意运用 webpack 的插件了。只是想要试探性的玩一下，于是在本地的 node_modules 里面修改了 roadhog 关于 webpack 的 UglifyJsPlugin 插件，结果一试，速度 duang 的一下就上来了。后来由于工作忙就没有怎么 care 构建问题。\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":14,"title":"白帽子讲web安全","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e几个月前碰巧遇到人生第一个安全问题，在负责的输入部分没有做非法字符验证，于是随便写了个\u003ccode\u003ealert('hahaha')\u003c/code\u003e，导致保存后再次查看输入详情时，立马弹出对话框。究其缘由，是前端没有做字符验证，服务端也没有做验证，最后输入端采用jsp的后端渲染方式，于是一点开详情，就爆炸了。春节前有空就看了看《白帽子讲web安全》。\u003c/p\u003e\n\u003ch2\u003eXSS跨站脚本攻击\u003c/h2\u003e\n\u003cp\u003eXSS攻击，通常指黑客通过“HTML注入”篡改网页，插入恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。重点就是\u003cstrong\u003e篡改网页\u003c/strong\u003e。\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":13,"title":"文件的故事","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e项目中遇到的文件下载，上传基本上最常见的事情了。大概半年前，需要实现某表单的查询下载功能，查询还好，只要后端返回数据，我负责展示就好了，但是下载要如何实现呢？用axios的GET请求返回的数据，不忍直视，根本就下载不了。一顿百度谷歌之后，哦，原来这么简单，只要一个\u003ccode\u003ewindow.location.href=url\u003c/code\u003e就搞定了，是不是很简单~\u003c/p\u003e\n\u003ch2\u003e文件下载\u003c/h2\u003e\n\u003cp\u003e后来的文件下载我都统统用这种方式，只是下载提示不够明显，后来改为\u003ccode\u003ewindow.open\u003c/code\u003e打开个新的tag页，然后自动关闭，明显点下载。好像到这里就已经很完美，一切交给浏览器解决。\u003c/p\u003e\n"},{"createTimeEN":"November 12, 2018","id":12,"title":"初识系列：nodejs之stream可读流","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e这是初识系列的第一篇：stream可读流。刚接触stream的时候有点难以理解，在客户端开发，基本接触不到stream，顶多也就是文档下载的时候，后端返回文件流，这个和stream沾边的东西。如此神秘，自然成为了首个研究的对象。nodejs对象里面有可读流，可写流，还有可读可写流，像HTTP响应Response对象就是可读流，而服务端的是可写流，下面介绍一下可读流Readable。\u003c/p\u003e\n\u003ch1\u003e基本\u003c/h1\u003e\n\u003cp\u003e常见用到可读流的情景是用\u003ccode\u003efs.createReadStream(path[, options])\u003c/code\u003e，并通过监听可读流的\u003ccode\u003edata\u003c/code\u003e与\u003ccode\u003eend\u003c/code\u003e事件来操作，或则是用pipe方法将可读流的数据流到可写流里面。\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":11,"title":"Koa初识","content":""},{"createTimeEN":"July 7, 2018","id":10,"title":"初识后端开发 express+MySQL","content":"\u003cblockquote\u003e\n\u003cp\u003e本文大部分内容是基于\u003ca href=\"http://www.alloyteam.com/2015/03/sexpressmysql/\" target=\"_blank\"\u003e初识NodeJS服务端开发（Express+MySQL）\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e本来只是想学习一下MySQL，毕竟隔几天就可以看到隔壁小伙伴在操作数据库有mySQL和Redis，好像还有mongodb？一直挺向往后端的，加上最近想自己打造一个个人博客,从数据库，服务器部署维护，后端nodejs实现集成，最后到前端展示，这些都想一一落实，于是开始数据库的学习。\u003c/p\u003e\n\u003cp\u003e正如本文开头所说的，大部分内容都是基于AlloyTeam的那边篇博客，本来没有必要写的，但是是第一次打通前后端的数据鸿沟，纪念一下，还是发表一下吧。\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":9,"title":"强制转换","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e类型与文法，在两个月以前其实已经看完了，但看完‘this与对象原型’和‘类型与文法’章节后，却自以为早已经掌握，没有什么可以谈的，于是便束之高阁。直到前一阵子，部门分享python基础的时候，提到python没有变量声明，拿来就用。着不是和JS很像？JS为什么没有变量声明呢？记得C语言都用变量声明，为何JS没有呢？变量声明有什么作用？好不好？\u003c/p\u003e\n\u003cp\u003e知乎问题\u003ca href=\"https://www.zhihu.com/question/19883873\" target=\"_blank\"\u003e为什么像 Java、C、C++ 这样的静态语言会比 Python、Ruby 这样的动态语言流行得多？\u003c/a\u003e\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":8,"title":"vuex源码分析","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e前文分析了Vue-router，感觉后劲十足，于是开始分析Vuex。在项目上，Vuex也是常客。它可以很好的管理状态，尤其是跨组件的时候，Vue的单向数据流使得子组件无法修改prop，经常用$emit和$on的话组件是要多难看就多难看。当组件切换，数据需要缓存总不能一直依赖于向上级组件emit传递数据吧？如果要更好的管理状态，Vuex是个很好的选择。Vuex代码量较Vue-router少了很多，而且也没有flow的校验机制，看起来更加习惯了。这里介绍的Vuex版本号为2.4.1。\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":7,"title":"vue-router源码分析","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e用了Vue快一年多了(虽然中间间断好长时间)，就越发的对其周边的生态感兴趣，尤其是对Vue-router和Vuex，Vue-router是单页面应用的核心部件，基本上的路由跳转都依赖它，项目上用的比较多的Vonic也是基于于Vue-router的；而Vuex只是在状态变化较多，需要store的时候才用上。本文先介绍Vue-router(2.7.0)，有时间再介绍Vuex；\u003c/p\u003e\n\u003ch1\u003e从示例开始\u003c/h1\u003e\n\u003cp\u003e下面是官方给出的示例basic，清晰的介绍了VueRouter最基本使用方法：\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":6,"title":"了解Node.js中的网络通信","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e一直想知道Node.js是如何作为一个用js语言写的后端平台。这个设定很是奇怪，前端开始涉足后端了？刚开始用api实现通信的时候，蛮简单的，框架都不用到，简单几句就能实现通信，于是借此机会研究一下Node.js的通信。\u003c/p\u003e\n\u003ch1\u003e从net模块出发\u003c/h1\u003e\n\u003cp\u003e看一个简单的例子\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'http'\u003c/span\u003e).createServer(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    res.end(\u003cspan class=\"hljs-string\"\u003e'hello world'\u003c/span\u003e);\n}).listen(\u003cspan class=\"hljs-number\"\u003e8181\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n"},{"createTimeEN":"July 7, 2018","id":5,"title":"You-Dont-Know-JS之this 与对象原型","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e遥记得以前刚开始写JavaScript的时候，起步就是jQuery，用的也简单，后来想学习原生的JavaScript，刚上来就遇到this的问题，每次都要去看阮老师那篇2010年写的博客，再不就去点开那篇一直珍藏着的\u003ca href=\"http://bonsaiden.github.io/JavaScript-Garden/zh/\" target=\"_blank\"\u003eJavaScript 秘密花园\u003c/a\u003e，每次看完都以为知道，但是后来遇到了总是要再回去一下，直到之前面试，以防万一又看了一遍。。。。。。书中提及的this，在这里更是要总结一下\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":4,"title":"You-Dont-Know-JS之作用域与闭包","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e读的书多了，渐渐也能有自己的体会，书有平庸之作，也有佳作，但有些时候我觉得更多要看人。\n在看了Vue和backbone的源码后，越发感觉自己的代码水平有待提高，但常见的各种动物书都看过了，一时间不知道看啥书好。于是在傻乎逛了一圈后，发现《你不知道的JavaScript》这本书，严格来说是上卷，很早以前就听大名，仿佛和高程三齐名，只是一直以没有时间为理由，没有接触。巧的是在傻乎上发现《你不知道的JavaScript》已经在github上出了\u003ca href=\"https://github.com/JoeHetfield/You-Dont-Know-JS\" target=\"_blank\"\u003e中文版\u003c/a\u003e，而且是全套完整的，幸福来的太突然。细读之，颇有收获，故在此分享。\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":3,"title":"backbone之Events实现","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e记得某次在大神的博客里面讲技术选型，提到团队对Backbone的框架很熟悉，在一次开发的时候选用Backbone源码的一部分，再搭配其他的使用。虽然Backbone现在已经不流行了，但从几年前我就开始听说它的存在了，一直觉得这么神奇的框架肯定很有必要学习，看到大神提到选取Backbone源码的一部分，顿时觉得大神就是大神，对源码运用与此精通。最近有空看Backbone源码，细读时，如啃老牛肉，又硬又难吃，常常看了一部分忘记另外一部分，疼苦不堪，后来结合Backbone的\u003ca href=\"http://www.css88.com/doc/backbone/\" target=\"_blank\"\u003eapi文档\u003c/a\u003e和里面的Todos例子顿时觉得，神清气爽，仿佛任督二脉都打通了，只是看过之后愈发觉得，Backbone框架已经不是前端的弄潮儿，只是接近2000+的源码，里面的MVC思想，值得去研究，而不是天天研究如何运用新框架的api\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":2,"title":"void 0 以及let const var 的理解","content":"\u003ch1\u003evoid 0\u003c/h1\u003e\n\u003cp\u003e最近在backbone的源码(两年前就研究过underscore的源码，现在才看backbone是不是有点那个)，发现里面用到了void 0，这是什么鬼？void居然出现在JavaScript里面，敢情以前用的ES是假的....这么基础的东西，瞟一眼MDN文档，还果然有:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003evoid: 运算符 对给定的表达式进行求值，然后返回 undefined。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eSo, void 0就是返回undefined了，这不是多此一举？直接用undefined来判断，不就完事了，何必用上void 0，这种云里雾里的操作？\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":1,"title":"webpack-dev-middleware主要源码理解","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e每次用Vue-cli的时候，都会觉得配置的nodejs服务器很是让人省心，几个项目下来，都只用关心工程前端部分，用久了便想探其究竟。后来才发现原理用了express框架，代码也挺简单的，但是里面用的一个中间件webpack-dev-middleware，刚开始看的时候却不知有何用处？既然是express框架，又用的是SPA，路由不需要express来分发，那webpack-dev-middleware有何用处？抱着这样的疑问，看源码去吧\u003c/p\u003e\n\u003ch1\u003e思路\u003c/h1\u003e\n\u003cp\u003e一般express中间件的结构如下所示：\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":0,"title":"Vue 0.6.0 早期源码研究","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e相信大家都或多或少接触过Vue，先前就有人介绍学习Vue的源码，提到旧版本的源码行数只不过一千多行，可以一个一个commit学习下去。前段时间为了找下家，一直在用Vue做作品，效率也较以前原生JavaScript要快上许多，后来工作上手了，不禁想看看Vue源码长什么样子的，只是从第一个commit开始读起来较为费时，而Github上面Vue项目能够找到的最早branch是\u003ca href=\"https://github.com/vuejs/vue/tree/0.10\" target=\"_blank\"\u003eVue 0.10\u003c/a\u003e，然而在发布版本里面，可以发现最好早一版本是\u003ca href=\"https://github.com/vuejs/vue/tags?after=v0.7.2\" target=\"_blank\"\u003e0.6.0版本\u003c/a\u003e。本文介绍也是从该本版开始，该版本较0.10的要上少40%左右。\u003c/p\u003e\n"}]}},"page":"/Index/Index","query":{"code":200,"data":[{"createTimeEN":"November 25, 2018","id":33,"title":"对布局和视频加载的想法","content":"\u003cp\u003e最近上线了一个\u003ca href=\"http://www.coloros.com/topic/coloros6.html\" target=\"_blank\"\u003e官网主题页\u003c/a\u003e，也是我的第一个对外页面，嗯，很符合活动页特点，开发周期短，逻辑含量低。但是毕竟以前没有接触过，写下来还是有不少感受的。\u003c/p\u003e\n\u003ch2\u003e布局\u003c/h2\u003e\n\u003cp\u003e布局最常见的方案就是居中布局 + 响应式布局。居中布局可选方案多，为了兼容 ie 9，选取的是 \u003ccode\u003etext-align: center\u003c/code\u003e 的方式；响应式布局为了提高维护性，以 pc 端设计稿的 100px 为 1rem。立马开工，只是没有一会就发现问题了：\u003c/p\u003e\n"},{"createTimeEN":"December 12, 2018","id":32,"title":"React Suspense data fetching 探究","content":"\u003cp\u003e最近 React 16.6 中提出了新组件 Suspense 允许 React 挂起组件渲染直到 IO 的数据返回。这个特性在 JSConf Iceland 中 \u003ca href=\"https://www.youtube.com/watch?v=nLF0n9SACd4\" target=\"_blank\"\u003eBeyond React 16\u003c/a\u003e 里面 Dan 就介绍到了，并在半年后的今天登陆 React 16.6。\u003c/p\u003e\n\u003ch3\u003eSuspense 简单用法\u003c/h3\u003e\n\u003cp\u003e在官网教程里面介绍到 Suspense 与 React.lazy 结合做 \u003ca href=\"https://reactjs.org/docs/code-splitting.html#reactlazy\" target=\"_blank\"\u003eCode-Spliting\u003c/a\u003e ，自然是可以这么用的，只是这更多的是代码分割，除了代码分割以外 IO 的处理，在 Beyond React 16 演讲中还提到了 \u003cstrong\u003edata fetching\u003c/strong\u003e，Dan 的第二个 demo 主要提到的也是 data fetching。下面先看看 Suspense 的一个简单的非代码分割的 demo：\u003c/p\u003e\n"},{"createTimeEN":"October 11, 2018","id":31,"title":"Decorator","content":"\u003ch3\u003e前言\u003c/h3\u003e\n\u003cp\u003eESnext 里面提到的修饰器，在 redux 的推广下，几乎每个工程师都有或多或少的用过，最常见的就是 \u003ccode\u003e@connect\u003c/code\u003e 的形式，而在 Java 领域同样也存在 \u003ccode\u003e@\u003c/code\u003e 这种符号的存在，被称之为注解，而巧的是修饰器同样能实现注解的功能。在看 Java 的注解的时候必然会看到反射这个概念。在阅读下面之前请先看阮老师的文档\u003ca href=\"http://es6.ruanyifeng.com/#docs/decorator\" target=\"_blank\"\u003e修饰器\u003c/a\u003e，再看下文。\u003c/p\u003e\n\u003ch3\u003eBabel 开发环境须知\u003c/h3\u003e\n\u003cp\u003e修饰器 Decorator 是 ES7 里面提出的，在 babel 6 里面需要引入 \u003ccode\u003epreset-stage-2\u003c/code\u003e，并在 .babelrc 中配置 \u003ccode\u003e\u0026quot;presets\u0026quot;: [\u0026quot;env\u0026quot;, \u0026quot;stage-2\u0026quot;]\u003c/code\u003e。到了 babel 7.0.0-beta.54 之前，则是需要 npm 包 \u003ccode\u003e@babel/preset-stage-2\u003c/code\u003e，配置 .babelrc 为  [\u0026quot;@babel/preset-stage-2\u0026quot;, { \u0026quot;decoratorsLegacy\u0026quot;: true }]，默认是关闭的。而 babel 7.0.0-beta.54 之后的版本里面，已经 \u003cstrong\u003e弃用 Stage Preset\u003c/strong\u003e ，所以后面需要安装的版本是 \u003ccode\u003e@babel/plugin-proposal-decorators\u003c/code\u003e 配置为 \u003ccode\u003e[\u0026quot;@babel/plugin-proposal-decorators\u0026quot;, { \u0026quot;legacy\u0026quot;: true }]\u003c/code\u003e，这样可以达到以前的效果，具体看\u003ca href=\"https://github.com/babel/babel/tree/master/packages/babel-preset-stage-0#babelpreset-stage-0\" target=\"_blank\"\u003e官方介绍\u003c/a\u003e，以及\u003ca href=\"https://babeljs.io/docs/en/babel-plugin-proposal-decorators\" target=\"_blank\"\u003e@babel/plugin-proposal-decorators\u003c/a\u003e。目前 babel 7.1.0 已经发布了\u003ca href=\"https://babeljs.io/blog/2018/09/17/decorators\" target=\"_blank\"\u003eTC39 Standards Track Decorators in Babel\u003c/a\u003e。\u003c/p\u003e\n"},{"createTimeEN":"August 4, 2018","id":30,"title":"react之Reconciliation","content":"\u003cp\u003eReact 的特点在于其异步渲染，fiber机制，是其他类 react 框架无法比拟的。前面介绍了些很基本的异步渲染。接下来介绍一下传说中的 diff 算法吧。其实这个在 \u003ca href=\"https://reactjs.org/docs/reconciliation.html\" target=\"_blank\"\u003eReact 官方文档 Reconciliation\u003c/a\u003e 里面早有介绍（advanced guide 里面的内容很多初级 React 工程师应该都没有看过，然而 advanced guide 里面包含了 context、错误边界、HOC、render props 以及 Reconciliation，没有看过的还请多刷几遍）。其中两大基准假设如下\u003c/p\u003e\n"},{"createTimeEN":"July 30, 2018","id":29,"title":"react 开启异步渲染与优先级","content":"\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/react16AsyncFiber.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e在研究时间调度时就有 React 的异步渲染的迹象了，只是在实际应用中却不知道如何开启，如何跟踪，后来看了 \u003ca href=\"https://github.com/koba04/react-fiber-resources\" target=\"_blank\"\u003ereact-fiber-resources\u003c/a\u003e 上面介绍的 \u003cstrong\u003eTry React Fiber asynchronous rendering!\u003c/strong\u003e。其实在 React 的博客 \u003ca href=\"https://reactjs.org/blog/2017/09/26/react-v16.0.html\" target=\"_blank\"\u003eReact v16.0\u003c/a\u003e 发布之际就已经说明了：\u003c/p\u003e\n"},{"createTimeEN":"July 28, 2018","id":28,"title":"react 时间调度","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e继续前面两篇 react 的分析。提到 react 16，除了 fiber 机制之外，还有其调度机制。这里就不得不提 requestIdleCallback 了，react 采用了 requestIdleCallback 的思想来实现调度，为什么说思想呢，因为 requestIdleCallback 是新出的 api，兼容性差，很多现代浏览器都不支持。于是 react 团队就写了一个 ployfill。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/requestIdleCallback-caniuse.PNG\" alt=\"\"\u003e\u003c/p\u003e\n"},{"createTimeEN":"July 15, 2018","id":27,"title":"react 源码下一步","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e前文提到了一个简单的 react 例子，结构如下所示\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eReactDOM.render(\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003eHello World!\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e,\n  \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.getElementById(\u003cspan class=\"hljs-string\"\u003e'container'\u003c/span\u003e)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e只是实在简单呀，缺少 state，缺少状态的变化，于是用另外一个例子来继续研究：\u003c/p\u003e\n"},{"createTimeEN":"November 12, 2018","id":26,"title":"react 源码开始的那一步","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e本来想着学习路径是从 react 周围生态开始的，比如之前的 preact，react-router，再到后面 immutable.js，读懂这些源码，接着可以看 dva，rematch，亦或则是 redux，甚至是 ant-design 都可以看看的，到了最后再吃大餐，react 源码。只是不知道为什么想要挑战一下自己，不想这么循循渐进。想要试试自己的实力。于是便有了这次的 react 源码的阅读。\u003c/p\u003e\n\u003cp\u003e刚开始读的时候觉得看 react 源码是一种享受，就像在读一本小说一样，惊险刺激，停不下来。只是后面到了 fiber 的阶段，就有点懵逼了，这绝对是烧脑侦探片，而我是里面的路人甲，看几行代码都觉得费劲。这个时候遇到了\u003ca href=\"https://zhuanlan.zhihu.com/p/36996225\" target=\"_blank\"\u003e如何阅读大型前端开源项目的源码\u003c/a\u003e，文章写得极好，根据上面的内容开始去看 react 文档里面的 Contribution Guide 里面的指导，随后又读了读 Blog 部分，简直是 amazing，尤其是\u003ca href=\"https://www.youtube.com/watch?v=v6iR3Zk4oDY\" target=\"_blank\"\u003eBeyond React 16 by Dan Abramov\u003c/a\u003e，以及\u003ca href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs\u0026amp;list=PLb0IAmt7-GS3fZ46IGFirdqKTIxlws7e0\u0026amp;index=5\" target=\"_blank\"\u003eA Cartoon Intro to Fiber \u003c/a\u003e。看得内心澎湃，觉得为何自己不能早点入坑呢？随后有看了\u003ca href=\"https://zhuanlan.zhihu.com/p/37095662\" target=\"_blank\"\u003e正妹\u003c/a\u003e，以及\u003ca href=\"https://zhuanlan.zhihu.com/p/37098539\" target=\"_blank\"\u003e方大神\u003c/a\u003e的介绍，顿时有了不少底气。\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":25,"title":"HTTP 2 笔记","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e续网络请求后，学习 HTTP/2。HTTP/2 的主要协议 RFC 7540 出来已经三年多了，HTTP/2 的应用也越来越多。几年前还在为 HTTPS 响应速度慢，能不上 HTTPS 就不上，结果现在基本成为标配了。对于大型系统，HTTP/2 也会是这样，毕竟知乎都是 HTTP 2 了。\u003c/p\u003e\n\u003ch2\u003eHTTP/1.1\u003c/h2\u003e\n\u003cp\u003e从 HTTP/1.1 诞生至今，互联网已经走过了十几个年头，当初的 HTTP/1.1 协议出现了不少缺陷，其中管线化，就是其中一个突出问题。\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/httpInitLink.PNG\" alt=\"\"\u003e\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":24,"title":"网络请求","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e一直好奇网络请求具现出来是什么样子的。从面试官的一个问题，在浏览器输入网址之后，到页面生成，中间会发生什么。为了这个问题，看了《计算机网络:自顶向下》，《图解HTTP》，学习了 node.js 中关于网络部分的源码，结果却还是自认为相差甚远，直到接触了路由表，才开始所有感觉，觉得补上缺失的一脚。\u003c/p\u003e\n\u003ch2\u003e网络结构\u003c/h2\u003e\n\u003cp\u003eOSI 7 层模型定义了一个规范概念，而 TCP/IP 的4 层结构则给出了实现。两者的比较，网上多有资源，这里不做对比了，结合发快递的过程来说说吧：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e第七层，应用层，常见协议 Http、Https、DNS、FTP。作用是为应用程序接口提供网络，直白来讲，就是提供请求/响应数据服务。数据也叫做应用层数据 Application Data；在快递上，就是你自己把要发的快递准备好，包括目的地 url 等。\u003c/li\u003e\n\u003c/ol\u003e\n"},{"createTimeEN":"July 7, 2018","id":23,"title":"翻译 RRB-Trees  Efficient Immutable Vectors","content":"\u003ch3\u003e概论\u003c/h3\u003e\n\u003cp\u003e不可变结构是一种很便利的函数式编程的数据结构，也是现代语言标准库如 Clojure 和 Scala 的一部分。其相同的部分是基于有固定数量的子节点的多阶树，允许快速查询和更新操作。在本文中我们采用了一种新的潜在的 vector 结构 Relaxed Radix Balanced Trees（RRB-Trees）。并展示了这种数据结构在 O(logN) 的时间里进行不可变数据 vector 的串联，插入和分割操作，同时维持着和原始 vector 数据结构的查询、更新和迭代接近的速度。\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":22,"title":"immutable.js 数据结构","content":"\u003ch3\u003e前言\u003c/h3\u003e\n\u003cp\u003e前文《初识immutable》介绍 immutable 的一些基本操作和特色，但是其重点部分\u003cstrong\u003e结构共享\u003c/strong\u003e，即数据结构留在了这里。这不是平时接触到的简单的数组、对象亦或则字典的形式，而是 tree ！日常开发基本就遇不到树结构，再复杂一个字典表就可以搞定了，于是乎 immutable.js 提供了一次很好的学习数据结构，学习算法的体验。\u003c/p\u003e\n\u003ch3\u003e共享结构\u003c/h3\u003e\n\u003cp\u003e共享结构还是比较简单的。对于已有的数据结构，若需要更新其中的某个节点（中间节点或则子叶），并不会把整个数据结构都拷贝一份，再修改该节点并返回新的数据结构。\u003cstrong\u003eimmutable.js 里面会采用路径修改的方式来实现更新。\u003c/strong\u003e\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":21,"title":"初识immutable","content":"\u003ch3\u003e前言\u003c/h3\u003e\n\u003cp\u003eImmutable.js 出来已经有很长一段时间了，只是日常项目中一直用不上。一个是平时没有怎么接触，不了解，另外一个是团队的开发节奏和习惯已经稳定下来了，要改变也不容易。当然了解一下也不差。\u003c/p\u003e\n\u003cp\u003e不可变的数据一旦生成，就无法被改变，这就要求数据可持久化。可是日常中的引用类型的数据，一旦改变了，就改变了，谈什么持久化数据结构呢？\u003c/p\u003e\n\u003ch3\u003e接触immutable\u003c/h3\u003e\n\u003cp\u003e感受一下immutable的不同：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 原本写法：\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e a = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e];\n\u003c/code\u003e\u003c/pre\u003e\n"},{"createTimeEN":"July 7, 2018","id":20,"title":"react-router 4 与 context","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e最近我司要上线一个 Hybird 上的 SPA，17 年年底的时候已经写过 demo 给产品和 leader 看了，近期准备要上线。问题在于，当时准备仓促，又想要玩一玩 react，导致了用的版本是比较成熟的，嗯。。。。意思就是比较老的版本，react-router 是 3.x 版本，而 react 也只是 16.0 而已。对于有追求的我而言，升级势在必行。\u003c/p\u003e\n\u003ch2\u003e问题所在\u003c/h2\u003e\n\u003cp\u003e在 Vue 应用里面用 Vue-router 就是一个 routes 的事情，甚至连 routes 都可以不是嵌套解构，直接一维路由，毕竟业务少。到了之前写的 react 也是采用了这种方式，如下：\u003c/p\u003e\n"},{"createTimeEN":"December 12, 2018","id":19,"title":"preact源码 - 组件与回收机制","content":"\u003ch3\u003e前言\u003c/h3\u003e\n\u003cp\u003e前面介绍到 diff 方法，但是我们只是从简单的例子开始的，并没有用到组件，而组件才是最重要的部分，毕竟一切的一切可以是组件。\u003c/p\u003e\n\u003ch3\u003e组件 Component\u003c/h3\u003e\n\u003cp\u003e先看看 Preact 输出的 Component 长什么样子：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprops, context\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._dirty = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.context = context;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.props = props;\n\u003c/code\u003e\u003c/pre\u003e\n"},{"createTimeEN":"July 7, 2018","id":18,"title":"preact源码 - diff机制","content":"\u003ch3\u003e前言\u003c/h3\u003e\n\u003cp\u003e每次看到有人谈起 React 的 diff 机制的时候，总觉得很厉害的样子，所以自然这里也是立马就想介绍 diff 机制。\u003c/p\u003e\n\u003ch3\u003ediff 机制\u003c/h3\u003e\n\u003cp\u003e以下面为例子来介绍：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { h, render } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'preact'\u003c/span\u003e;\n\nrender((\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"foo\"\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n"},{"createTimeEN":"July 7, 2018","id":17,"title":"preact源码 - VDOM","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e在工作上开始用 React 开发已经有四个多月了，不禁想看看 React 和 Vue 本质上有什么区别。当然一个是 jsx 文件，一个是 vue 文件，两个处理起来肯定是不一样的。想了想以后项目发展越来越大，肯定是要以 React 为主体的，深入了解 React 是必须的，尤其是 React 已经发展到 React 16 了，新特性都不晓得怎么用呢。为了减少初学习 React 源码的陡度，想着还是从 Preact 开始好了，毕竟后者声称兼容 React 而且，关键是体积小！\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":16,"title":"三种常见算法","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e先吐槽。\n金三银四，最近来我司计划招聘两名前端工程师，一名初级，一名中级，结果前来面试的人络绎不绝，让我也当面试官，结果呢。前来的有一两年工作经验的初级工程师，都是渣渣，不是基础差，就是广度不够，连笔试题目都做不出来，尤其是算法题目，简单的排序都做不出来。给我的感觉，连刚参加工作的我都不如。而后面试的两个中级工程师，面试后感觉也就比我差点，工作经验比我长点，可是这个期望薪水，是不是有点高呀。只是排序算法题大多用的是冒泡法，作为工程师不应该开口闭口都是快排吗。嗯，只是忽然想想自己也只是知道快排的思想，具体怎么实现，就懵逼了，于是才有了这篇博客。\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":15,"title":"webpack构建优化","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e项目中经常用 Jenkins 构建项目，只要点击构建，服务端就会按照指令，重新拉取数据构建，这是很好的，只是久而久之发现一个问题：项目的构建时间从之前的飞快，到现在龟速。等待构建开发时间长是一个问题，更重要的是如果项目继续发展壮大呢？现在的 antd-pro 项目也就十来个页面，一点也不多，但是测试服构建起来，时间将近4分钟，特别吃内存。如果以后页面多很多呢？五六十个页面呢？那岂不是要二十来分钟的构建时间？内存呢，难道最后要溢出？这是难以置信的。\u003c/p\u003e\n\u003ch2\u003e初探问题\u003c/h2\u003e\n\u003cp\u003e春节期间前有空，上网查了一下方法，\u003ccode\u003ewebpack.optimize.UglifyJsPlugin\u003c/code\u003e 几乎是千夫所指的，自带的代码丑化基本就是鸡肋，用上其他丑化插件，打包时间可以节省上30%，甚至更多，只是 antd-pro 用的是 roadhog.js，是一款接近于 create-react-app 的基础工具，能自己编写的配置参数少之又少，更不要提随意运用 webpack 的插件了。只是想要试探性的玩一下，于是在本地的 node_modules 里面修改了 roadhog 关于 webpack 的 UglifyJsPlugin 插件，结果一试，速度 duang 的一下就上来了。后来由于工作忙就没有怎么 care 构建问题。\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":14,"title":"白帽子讲web安全","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e几个月前碰巧遇到人生第一个安全问题，在负责的输入部分没有做非法字符验证，于是随便写了个\u003ccode\u003ealert('hahaha')\u003c/code\u003e，导致保存后再次查看输入详情时，立马弹出对话框。究其缘由，是前端没有做字符验证，服务端也没有做验证，最后输入端采用jsp的后端渲染方式，于是一点开详情，就爆炸了。春节前有空就看了看《白帽子讲web安全》。\u003c/p\u003e\n\u003ch2\u003eXSS跨站脚本攻击\u003c/h2\u003e\n\u003cp\u003eXSS攻击，通常指黑客通过“HTML注入”篡改网页，插入恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。重点就是\u003cstrong\u003e篡改网页\u003c/strong\u003e。\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":13,"title":"文件的故事","content":"\u003ch2\u003e前言\u003c/h2\u003e\n\u003cp\u003e项目中遇到的文件下载，上传基本上最常见的事情了。大概半年前，需要实现某表单的查询下载功能，查询还好，只要后端返回数据，我负责展示就好了，但是下载要如何实现呢？用axios的GET请求返回的数据，不忍直视，根本就下载不了。一顿百度谷歌之后，哦，原来这么简单，只要一个\u003ccode\u003ewindow.location.href=url\u003c/code\u003e就搞定了，是不是很简单~\u003c/p\u003e\n\u003ch2\u003e文件下载\u003c/h2\u003e\n\u003cp\u003e后来的文件下载我都统统用这种方式，只是下载提示不够明显，后来改为\u003ccode\u003ewindow.open\u003c/code\u003e打开个新的tag页，然后自动关闭，明显点下载。好像到这里就已经很完美，一切交给浏览器解决。\u003c/p\u003e\n"},{"createTimeEN":"November 12, 2018","id":12,"title":"初识系列：nodejs之stream可读流","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e这是初识系列的第一篇：stream可读流。刚接触stream的时候有点难以理解，在客户端开发，基本接触不到stream，顶多也就是文档下载的时候，后端返回文件流，这个和stream沾边的东西。如此神秘，自然成为了首个研究的对象。nodejs对象里面有可读流，可写流，还有可读可写流，像HTTP响应Response对象就是可读流，而服务端的是可写流，下面介绍一下可读流Readable。\u003c/p\u003e\n\u003ch1\u003e基本\u003c/h1\u003e\n\u003cp\u003e常见用到可读流的情景是用\u003ccode\u003efs.createReadStream(path[, options])\u003c/code\u003e，并通过监听可读流的\u003ccode\u003edata\u003c/code\u003e与\u003ccode\u003eend\u003c/code\u003e事件来操作，或则是用pipe方法将可读流的数据流到可写流里面。\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":11,"title":"Koa初识","content":""},{"createTimeEN":"July 7, 2018","id":10,"title":"初识后端开发 express+MySQL","content":"\u003cblockquote\u003e\n\u003cp\u003e本文大部分内容是基于\u003ca href=\"http://www.alloyteam.com/2015/03/sexpressmysql/\" target=\"_blank\"\u003e初识NodeJS服务端开发（Express+MySQL）\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e本来只是想学习一下MySQL，毕竟隔几天就可以看到隔壁小伙伴在操作数据库有mySQL和Redis，好像还有mongodb？一直挺向往后端的，加上最近想自己打造一个个人博客,从数据库，服务器部署维护，后端nodejs实现集成，最后到前端展示，这些都想一一落实，于是开始数据库的学习。\u003c/p\u003e\n\u003cp\u003e正如本文开头所说的，大部分内容都是基于AlloyTeam的那边篇博客，本来没有必要写的，但是是第一次打通前后端的数据鸿沟，纪念一下，还是发表一下吧。\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":9,"title":"强制转换","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e类型与文法，在两个月以前其实已经看完了，但看完‘this与对象原型’和‘类型与文法’章节后，却自以为早已经掌握，没有什么可以谈的，于是便束之高阁。直到前一阵子，部门分享python基础的时候，提到python没有变量声明，拿来就用。着不是和JS很像？JS为什么没有变量声明呢？记得C语言都用变量声明，为何JS没有呢？变量声明有什么作用？好不好？\u003c/p\u003e\n\u003cp\u003e知乎问题\u003ca href=\"https://www.zhihu.com/question/19883873\" target=\"_blank\"\u003e为什么像 Java、C、C++ 这样的静态语言会比 Python、Ruby 这样的动态语言流行得多？\u003c/a\u003e\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":8,"title":"vuex源码分析","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e前文分析了Vue-router，感觉后劲十足，于是开始分析Vuex。在项目上，Vuex也是常客。它可以很好的管理状态，尤其是跨组件的时候，Vue的单向数据流使得子组件无法修改prop，经常用$emit和$on的话组件是要多难看就多难看。当组件切换，数据需要缓存总不能一直依赖于向上级组件emit传递数据吧？如果要更好的管理状态，Vuex是个很好的选择。Vuex代码量较Vue-router少了很多，而且也没有flow的校验机制，看起来更加习惯了。这里介绍的Vuex版本号为2.4.1。\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":7,"title":"vue-router源码分析","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e用了Vue快一年多了(虽然中间间断好长时间)，就越发的对其周边的生态感兴趣，尤其是对Vue-router和Vuex，Vue-router是单页面应用的核心部件，基本上的路由跳转都依赖它，项目上用的比较多的Vonic也是基于于Vue-router的；而Vuex只是在状态变化较多，需要store的时候才用上。本文先介绍Vue-router(2.7.0)，有时间再介绍Vuex；\u003c/p\u003e\n\u003ch1\u003e从示例开始\u003c/h1\u003e\n\u003cp\u003e下面是官方给出的示例basic，清晰的介绍了VueRouter最基本使用方法：\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":6,"title":"了解Node.js中的网络通信","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e一直想知道Node.js是如何作为一个用js语言写的后端平台。这个设定很是奇怪，前端开始涉足后端了？刚开始用api实现通信的时候，蛮简单的，框架都不用到，简单几句就能实现通信，于是借此机会研究一下Node.js的通信。\u003c/p\u003e\n\u003ch1\u003e从net模块出发\u003c/h1\u003e\n\u003cp\u003e看一个简单的例子\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'http'\u003c/span\u003e).createServer(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    res.end(\u003cspan class=\"hljs-string\"\u003e'hello world'\u003c/span\u003e);\n}).listen(\u003cspan class=\"hljs-number\"\u003e8181\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n"},{"createTimeEN":"July 7, 2018","id":5,"title":"You-Dont-Know-JS之this 与对象原型","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e遥记得以前刚开始写JavaScript的时候，起步就是jQuery，用的也简单，后来想学习原生的JavaScript，刚上来就遇到this的问题，每次都要去看阮老师那篇2010年写的博客，再不就去点开那篇一直珍藏着的\u003ca href=\"http://bonsaiden.github.io/JavaScript-Garden/zh/\" target=\"_blank\"\u003eJavaScript 秘密花园\u003c/a\u003e，每次看完都以为知道，但是后来遇到了总是要再回去一下，直到之前面试，以防万一又看了一遍。。。。。。书中提及的this，在这里更是要总结一下\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":4,"title":"You-Dont-Know-JS之作用域与闭包","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e读的书多了，渐渐也能有自己的体会，书有平庸之作，也有佳作，但有些时候我觉得更多要看人。\n在看了Vue和backbone的源码后，越发感觉自己的代码水平有待提高，但常见的各种动物书都看过了，一时间不知道看啥书好。于是在傻乎逛了一圈后，发现《你不知道的JavaScript》这本书，严格来说是上卷，很早以前就听大名，仿佛和高程三齐名，只是一直以没有时间为理由，没有接触。巧的是在傻乎上发现《你不知道的JavaScript》已经在github上出了\u003ca href=\"https://github.com/JoeHetfield/You-Dont-Know-JS\" target=\"_blank\"\u003e中文版\u003c/a\u003e，而且是全套完整的，幸福来的太突然。细读之，颇有收获，故在此分享。\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":3,"title":"backbone之Events实现","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e记得某次在大神的博客里面讲技术选型，提到团队对Backbone的框架很熟悉，在一次开发的时候选用Backbone源码的一部分，再搭配其他的使用。虽然Backbone现在已经不流行了，但从几年前我就开始听说它的存在了，一直觉得这么神奇的框架肯定很有必要学习，看到大神提到选取Backbone源码的一部分，顿时觉得大神就是大神，对源码运用与此精通。最近有空看Backbone源码，细读时，如啃老牛肉，又硬又难吃，常常看了一部分忘记另外一部分，疼苦不堪，后来结合Backbone的\u003ca href=\"http://www.css88.com/doc/backbone/\" target=\"_blank\"\u003eapi文档\u003c/a\u003e和里面的Todos例子顿时觉得，神清气爽，仿佛任督二脉都打通了，只是看过之后愈发觉得，Backbone框架已经不是前端的弄潮儿，只是接近2000+的源码，里面的MVC思想，值得去研究，而不是天天研究如何运用新框架的api\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":2,"title":"void 0 以及let const var 的理解","content":"\u003ch1\u003evoid 0\u003c/h1\u003e\n\u003cp\u003e最近在backbone的源码(两年前就研究过underscore的源码，现在才看backbone是不是有点那个)，发现里面用到了void 0，这是什么鬼？void居然出现在JavaScript里面，敢情以前用的ES是假的....这么基础的东西，瞟一眼MDN文档，还果然有:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003evoid: 运算符 对给定的表达式进行求值，然后返回 undefined。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eSo, void 0就是返回undefined了，这不是多此一举？直接用undefined来判断，不就完事了，何必用上void 0，这种云里雾里的操作？\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":1,"title":"webpack-dev-middleware主要源码理解","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e每次用Vue-cli的时候，都会觉得配置的nodejs服务器很是让人省心，几个项目下来，都只用关心工程前端部分，用久了便想探其究竟。后来才发现原理用了express框架，代码也挺简单的，但是里面用的一个中间件webpack-dev-middleware，刚开始看的时候却不知有何用处？既然是express框架，又用的是SPA，路由不需要express来分发，那webpack-dev-middleware有何用处？抱着这样的疑问，看源码去吧\u003c/p\u003e\n\u003ch1\u003e思路\u003c/h1\u003e\n\u003cp\u003e一般express中间件的结构如下所示：\u003c/p\u003e\n"},{"createTimeEN":"July 7, 2018","id":0,"title":"Vue 0.6.0 早期源码研究","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e相信大家都或多或少接触过Vue，先前就有人介绍学习Vue的源码，提到旧版本的源码行数只不过一千多行，可以一个一个commit学习下去。前段时间为了找下家，一直在用Vue做作品，效率也较以前原生JavaScript要快上许多，后来工作上手了，不禁想看看Vue源码长什么样子的，只是从第一个commit开始读起来较为费时，而Github上面Vue项目能够找到的最早branch是\u003ca href=\"https://github.com/vuejs/vue/tree/0.10\" target=\"_blank\"\u003eVue 0.10\u003c/a\u003e，然而在发布版本里面，可以发现最好早一版本是\u003ca href=\"https://github.com/vuejs/vue/tags?after=v0.7.2\" target=\"_blank\"\u003e0.6.0版本\u003c/a\u003e。本文介绍也是从该本版开始，该版本较0.10的要上少40%左右。\u003c/p\u003e\n"}]},"buildId":"I9XlxpmvFk~lmulxmmsMh","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Index/Index" src="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/Index/Index.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.ce3e8fb7a689beb447ad.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.8d98f9151bcde6fb2a87.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-45be5a1f94c3fe5df8ee.js" async=""></script></body></html>