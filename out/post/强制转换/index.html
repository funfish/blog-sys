<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">强制转换</title><link rel="preload" href="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.ce3e8fb7a689beb447ad.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.8d98f9151bcde6fb2a87.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-45be5a1f94c3fe5df8ee.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.bb30b296.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___3Hk0c "><a class="logo___1KD30" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___1qXLb" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___3VKNp"><h1 class="postTitle___26vXM">强制转换</h1><span class="postTime___16Ish">July 7, 2018</span></header><article class="postWrapper___3NXol post-article"><div><h1>前言</h1>
<p>类型与文法，在两个月以前其实已经看完了，但看完‘this与对象原型’和‘类型与文法’章节后，却自以为早已经掌握，没有什么可以谈的，于是便束之高阁。直到前一阵子，部门分享python基础的时候，提到python没有变量声明，拿来就用。着不是和JS很像？JS为什么没有变量声明呢？记得C语言都用变量声明，为何JS没有呢？变量声明有什么作用？好不好？</p>
<p>知乎问题<a href="https://www.zhihu.com/question/19883873" target="_blank">为什么像 Java、C、C++ 这样的静态语言会比 Python、Ruby 这样的动态语言流行得多？</a></p>
<p>再结合另外一个知乎问题<a href="https://www.zhihu.com/question/19918532" target="_blank">弱类型、强类型、动态类型、静态类型语言的区别是什么？</a>里面介绍到：</p>
<blockquote>
<p>Program Errors
• trapped errors。导致程序终止执行，如除0，Java中数组越界访问
• untrapped errors。 出错后继续执行，但可能出现任意行为。如C里的缓冲区溢出、Jump到错误地址</p>
<p>Forbidden Behaviours
语言设计时，可以定义一组forbidden behaviors. 它必须包括所有untrapped errors, 但可能包含trapped errors.
Well behaved、ill behaved
• well behaved: 如果程序执行不可能出现forbidden behaviors, 则为well behaved。
• ill behaved: 否则为ill behaved…</p>
<p>强、弱类型
• 强类型strongly typed: 如果一种语言的所有程序都是well behaved——即不可能出现forbidden behaviors，则该语言为strongly typed。
• 弱类型weakly typed: 否则为weakly typed。比如C语言的缓冲区溢出，属于trapped errors，即属于forbidden behaviors..故C是弱类型</p>
<p>动态、静态类型
• 静态类型 statically: 如果在编译时拒绝ill behaved程序，则是statically typed;
• 动态类型dynamiclly: 如果在运行时拒绝ill behaviors, 则是dynamiclly typed。
<img src="https://github.com/funfish/blog/raw/master/images/programType.PNG" alt=""></p>
</blockquote>
<p>可以发现像JS这样的动态语言弱类型，没有如JAVA这样明显的编译过程，只是在浏览器或者Node运行时存在解析过程，并且在解析的时候检查有无forbidden behaviors。这样的动态语言有什么好处了，如部分答主所说的动如脱兔，如同草书般洒脱，不像其他语言一笔一划，讲求中正平稳。看看几年前JavaScript文件，程序如果比较大，几百行JavaScript都可以看得人头晕脑胀，也有没有IDE这样跳转工具，虽然现在有webStorm，对于大规模开发自然是不友好的，这种乱的感觉自然让很多人避开它。
到现在ECMAscript已经发展到ES7甚至ES8了，在Vue-router的开发里面，甚至都用上了Facebook的flow，来验证变量类型，提高代码质量，现在的JS已经是越来越旺盛了。
于是对变量声明的更进一步理解，于是又开始看‘类型与文法’这一章，没想到收获很多</p>
<h1>开始</h1>
<blockquote>
<p>在JavaScript中，变量没有类型 -- 值才有类型。变量可以在任何时候，持有任何值</p>
</blockquote>
<p>这句话深入我心，JS里面有var的变量声明，后面又有let和const。声明的变量可以是任何值，从基本变量到Object都是木有问题的，甚至在非严格模式下，不声明直接使用变量也不会报错，而且变量还可以随意更改，从number变到Object，完全没有问题，那为何要称变量为类型呢？明明说的就是变量背后的值是什么类型；</p>
<h1>强制转换</h1>
<p>falsy列表：</p>
<ol>
<li>undefined</li>
<li>null</li>
<li>false</li>
<li>+0， 0， NaN</li>
<li>''
这些在Boolean强制转换的时候都会变成false，值得注意的是String类型里面仅有唯一一个空字符串('')会被转换为false。
同时，类似的如[], {}以及-1等等的都是true值，这些简单有用的true/false还是值得注意的。</li>
</ol>
<h2>明确的强制转换</h2>
<p>一元操作符'+'能将String明确的转换为number，同样能将Date类型变为number如：</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>( <span class="hljs-string">"Mon, 18 Aug 2014 08:53:06 CDT"</span> );
+d; <span class="hljs-comment">// 1408369986000</span>
</code></pre>
<p>但是通常都不会这么做，没有语义，容易误解，不如常用的'getTime()'好使</p>
<p>需要小心的是parseInt传入非string类型的时候产生的bug。</p>
<h2>隐含的强制转换</h2>
<p>下面的都是是这一章的重点了，明确的强制转换大多好懂，而且不容易犯错。相比之下，隐含的强制转换就深邃的多了。</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>];
<span class="hljs-keyword">var</span> b = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];

a + b; <span class="hljs-comment">// "1,23,4"</span>
</code></pre>
<p>上面例子中当操作数不是number的时候，它们都被强制转换为String类型，我们知道<code>'42' + '1' = '420'</code>通过String来实现字符串拼接，但是Array为什么也会这么做？有深度的内容来了：</p>
<blockquote>
<p>根据ES5语言规范的11.6.1部分，+的算法是（当一个操作数是object值时），如果两个操作数之一已经是一个string，或者下列步骤产生一个string表达形式，+将会进行连接。所以，当+的两个操作数之一收到一个object（包括array）时，它首先在这个值上调用ToPrimitive抽象操作（9.1部分），而它会带着number的上下文环境提示来调用[[DefaultValue]]算法（8.12.8部分）。</p>
</blockquote>
<blockquote>
<p>如果你仔细观察，你会发现这个操作现在和ToNumber抽象操作处理object的过程是一样的（参见早先的“ToNumber”一节）。在array上的valueOf()操作将会在产生一个简单基本类型时失败，于是它退回到一个toString()表现形式。两个array因此分别变成了&quot;1,2&quot;和&quot;3,4&quot;。现在，+就如你通常期望的那样连接这两个string：&quot;1,23,4&quot;。</p>
</blockquote>
<p>这上面两段话以为着什么？说的是当你用object做加法操作的时候，object会调用其valueOf方法并返回基本类型，如果valueOf返回的基本类型失败（如没有valueOf方法或则返回的是object），那么就退回去用toString()方法，如果object没有toString()方法，那就返回错误；当然对象自然都是有toString方法的。
其他的String到number的常见的转换就是如<code>'42' + 2 = 44</code>通过字符串和数字直接相加。</p>
<p>上面提到的都是'+'加法计算，那减法呢？
字符串相加可以理解为拼接的过程，但是相减就完全不一样了，如下：</p>
<pre class="hljs"><code>[<span class="hljs-number">3</span>] + [<span class="hljs-number">1</span>] <span class="hljs-comment">// '31'</span>
[<span class="hljs-number">3</span>] - [<span class="hljs-number">1</span>] <span class="hljs-comment">// 2</span>
</code></pre>
<p>恐怖吧？减法直接将其强制转为String，再由String转换为Number类型。</p>
<h3>||和&amp;&amp;操作符</h3>
<p>||和&amp;&amp;操作符其实没有特别的，只是当你去研究它的时候，又会发现它很特别
在判断的时候如if语言或则是三目判断，常会用到||和&amp;&amp;操作符。但是：</p>
<blockquote>
<p>引用ES5语言规范的11.11部分：
一个&amp;&amp;或||操作符产生的值不见得是Boolean类型。这个产生的值将总是两个操作数表达式其中之一的值。</p>
</blockquote>
<p>||和&amp;&amp;操作符只是意味着选择，而不是其他语言那样的逻辑判断！
想想确实也用过||和&amp;&amp;来做选择，比如以前很常用的：</p>
<pre class="hljs"><code>e = event || <span class="hljs-built_in">window</span>.event
</code></pre>
<p>用来做兼容处理。这里用的就是选择，而常见的<code>cb&amp;&amp;cb()</code>也是做选择。那我们所谓的逻辑判断呢？这个时候用选择的思维考虑一下，马上豁然开朗，逻辑的意思也就是返回最后被选择的数，如果这个数是<code>true</code>那就是真咯。</p>
<h2>宽松等价与严格等价</h2>
<p>提到<code>== 和 ===</code>操作，大多数开发者对前者经常是避而不及，省心的选择就是用后者，做严格的判断，毕竟前者太过花哨了。。。。。。还是先用心了解一下吧:
这里不得不提几条规范：</p>
<blockquote>
<p>4.如果Type(x)是Number而Type(y)是String， 返回比较x == ToNumber(y)的结果。
5.如果Type(x)是String而Type(y)是Number， 返回比较ToNumber(x) == y的结果。
6.如果Type(x)是Boolean， 返回比较 ToNumber(x) == y 的结果。
7.如果Type(y)是Boolean， 返回比较 x == ToNumber(y) 的结果。</p>
</blockquote>
<p>当String类型和Number比较的时候，String类型会被ToNumber为数字进行对比。同样的Boolean类型会被ToNumber，转换为0或者1。于是就有了如下：</p>
<pre class="hljs"><code><span class="hljs-string">'42'</span> == <span class="hljs-literal">false</span> <span class="hljs-comment">// false</span>
<span class="hljs-string">'42'</span> == <span class="hljs-literal">true</span> <span class="hljs-comment">// false</span>
</code></pre>
<p>可以看出'42'既不是0也不1，但是上面表达式却显得42不true也不false。</p>
<blockquote>
<p>2.如果x是null而y是undefined，返回true。
3.如果x是undefined而y是null，返回true。
8.如果Type(x)是一个String或者Number而Type(y)是一个Object， 返回比较 x == ToPrimitive(y) 的结果。
9.如果Type(x)是一个Object而Type(y)是String或者Number， 返回比较 ToPrimitive(x) == y 的结果。</p>
</blockquote>
<p>对于null和undefined自然是自身不true也不false，就等于null或则undefined，这个还是很容易理解的；那Object呢？
前面在'+'加法操作的时候提到过Object的转换问题，能通过valueOf返回基本类型就返回，不能就通过toString()方法，这里也是适用的。
值得一提的是形如<code>{}</code>这样的对象，其toString()之后是<code>[Object Object]</code>而不是<code>'0'</code>，和平时用的<code>Object.prototype.toString.call</code>还是很接近的。
来看看下面例子</p>
<pre class="hljs"><code><span class="hljs-built_in">Number</span>.prototype.valueOf = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
};

<span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>( <span class="hljs-number">2</span> ) == <span class="hljs-number">3</span>;   <span class="hljs-comment">// true</span>
</code></pre>
<p>这种就是业界毒瘤了，希望不要有傻逼这么写。。。。。哈哈哈哈</p>
<h2>抽象关系比较</h2>
<p>前面提到了加法和双等于判断，接下来怎么可以不提到大于小于判断呢？有了前面的基础，对于强制转换还是很容易理解的。看一下例子</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> a = { <span class="hljs-attr">b</span>: <span class="hljs-number">42</span> };
<span class="hljs-keyword">var</span> b = { <span class="hljs-attr">b</span>: <span class="hljs-number">43</span> };

a &lt; b;  <span class="hljs-comment">// false</span>
a &gt; b;  <span class="hljs-comment">// false</span>
a == b;  <span class="hljs-comment">// false</span>

a &lt;= b; <span class="hljs-comment">// true</span>
a &gt;= b; <span class="hljs-comment">// true</span>
</code></pre>
<p>这里Object对象自然都是被强制转换为<code>[object Object]</code>，那肯定是不是大小于关系的，那<code>==</code>呢？<code>[object Object]</code>难道不等于<code>[object Object]</code>？这个时候就不要陷入思维误区了，就像<code>'' == '0'</code>为false一样，明明转换后都是<code>数字0</code>为何不成立？因为他俩都是String，不用强制转换直接对比。同样的Object和Object用<code>==</code>判断自然也不用强制转换。值得一提的是Object只有和自己做<code>==</code>判断的时候才为true。
那后面的小于等于和大于等于呢？妈呀，看着都要乱了，这个要根据语言规范了，谁叫他是老大呢？</p>
<blockquote>
<p>因为语言规范说，对于a &lt;= b，它实际上首先对b &lt; a求值，然后反转那个结果。因为b &lt; a也是false，所以a &lt;= b的结果为true。</p>
</blockquote>
<p>原来是反转。。。。。。JS的逻辑还真会玩</p>
<h1>文法</h1>
<p>语句是有完成值的，比如你打开浏览器的控制台，输入<code>var a = 1</code>回车，这个时候，显示的下一行是<code>undefined</code>，而不是<code>1</code>，但你敲入<code>a</code>会车的时候，才显示<code>1</code>，这里的<code>undefined和1</code>就是语句的完成值。
关于强制转换，一个经常被引用的坑是<code>[] + {}</code>和<code>{} + []</code>，这两个表达式的结果分别是<code>[object Object]</code>和<code>0</code>，因为后面的{}表示的是缺省';'的语句于是变成<code>{}; + []</code>自然是0了。
另外文中还提到结构解析，操作优先级，自动分号(ASI)和错误的问题，这些都是基础部分，这里就不介绍了。</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"July 7, 2018","title":"强制转换","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e类型与文法，在两个月以前其实已经看完了，但看完‘this与对象原型’和‘类型与文法’章节后，却自以为早已经掌握，没有什么可以谈的，于是便束之高阁。直到前一阵子，部门分享python基础的时候，提到python没有变量声明，拿来就用。着不是和JS很像？JS为什么没有变量声明呢？记得C语言都用变量声明，为何JS没有呢？变量声明有什么作用？好不好？\u003c/p\u003e\n\u003cp\u003e知乎问题\u003ca href=\"https://www.zhihu.com/question/19883873\" target=\"_blank\"\u003e为什么像 Java、C、C++ 这样的静态语言会比 Python、Ruby 这样的动态语言流行得多？\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e再结合另外一个知乎问题\u003ca href=\"https://www.zhihu.com/question/19918532\" target=\"_blank\"\u003e弱类型、强类型、动态类型、静态类型语言的区别是什么？\u003c/a\u003e里面介绍到：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eProgram Errors\n• trapped errors。导致程序终止执行，如除0，Java中数组越界访问\n• untrapped errors。 出错后继续执行，但可能出现任意行为。如C里的缓冲区溢出、Jump到错误地址\u003c/p\u003e\n\u003cp\u003eForbidden Behaviours\n语言设计时，可以定义一组forbidden behaviors. 它必须包括所有untrapped errors, 但可能包含trapped errors.\nWell behaved、ill behaved\n• well behaved: 如果程序执行不可能出现forbidden behaviors, 则为well behaved。\n• ill behaved: 否则为ill behaved…\u003c/p\u003e\n\u003cp\u003e强、弱类型\n• 强类型strongly typed: 如果一种语言的所有程序都是well behaved——即不可能出现forbidden behaviors，则该语言为strongly typed。\n• 弱类型weakly typed: 否则为weakly typed。比如C语言的缓冲区溢出，属于trapped errors，即属于forbidden behaviors..故C是弱类型\u003c/p\u003e\n\u003cp\u003e动态、静态类型\n• 静态类型 statically: 如果在编译时拒绝ill behaved程序，则是statically typed;\n• 动态类型dynamiclly: 如果在运行时拒绝ill behaviors, 则是dynamiclly typed。\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/programType.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e可以发现像JS这样的动态语言弱类型，没有如JAVA这样明显的编译过程，只是在浏览器或者Node运行时存在解析过程，并且在解析的时候检查有无forbidden behaviors。这样的动态语言有什么好处了，如部分答主所说的动如脱兔，如同草书般洒脱，不像其他语言一笔一划，讲求中正平稳。看看几年前JavaScript文件，程序如果比较大，几百行JavaScript都可以看得人头晕脑胀，也有没有IDE这样跳转工具，虽然现在有webStorm，对于大规模开发自然是不友好的，这种乱的感觉自然让很多人避开它。\n到现在ECMAscript已经发展到ES7甚至ES8了，在Vue-router的开发里面，甚至都用上了Facebook的flow，来验证变量类型，提高代码质量，现在的JS已经是越来越旺盛了。\n于是对变量声明的更进一步理解，于是又开始看‘类型与文法’这一章，没想到收获很多\u003c/p\u003e\n\u003ch1\u003e开始\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在JavaScript中，变量没有类型 -- 值才有类型。变量可以在任何时候，持有任何值\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这句话深入我心，JS里面有var的变量声明，后面又有let和const。声明的变量可以是任何值，从基本变量到Object都是木有问题的，甚至在非严格模式下，不声明直接使用变量也不会报错，而且变量还可以随意更改，从number变到Object，完全没有问题，那为何要称变量为类型呢？明明说的就是变量背后的值是什么类型；\u003c/p\u003e\n\u003ch1\u003e强制转换\u003c/h1\u003e\n\u003cp\u003efalsy列表：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eundefined\u003c/li\u003e\n\u003cli\u003enull\u003c/li\u003e\n\u003cli\u003efalse\u003c/li\u003e\n\u003cli\u003e+0， 0， NaN\u003c/li\u003e\n\u003cli\u003e''\n这些在Boolean强制转换的时候都会变成false，值得注意的是String类型里面仅有唯一一个空字符串('')会被转换为false。\n同时，类似的如[], {}以及-1等等的都是true值，这些简单有用的true/false还是值得注意的。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e明确的强制转换\u003c/h2\u003e\n\u003cp\u003e一元操作符'+'能将String明确的转换为number，同样能将Date类型变为number如：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e d = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eDate\u003c/span\u003e( \u003cspan class=\"hljs-string\"\u003e\"Mon, 18 Aug 2014 08:53:06 CDT\"\u003c/span\u003e );\n+d; \u003cspan class=\"hljs-comment\"\u003e// 1408369986000\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但是通常都不会这么做，没有语义，容易误解，不如常用的'getTime()'好使\u003c/p\u003e\n\u003cp\u003e需要小心的是parseInt传入非string类型的时候产生的bug。\u003c/p\u003e\n\u003ch2\u003e隐含的强制转换\u003c/h2\u003e\n\u003cp\u003e下面的都是是这一章的重点了，明确的强制转换大多好懂，而且不容易犯错。相比之下，隐含的强制转换就深邃的多了。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e a = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e b = [\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e];\n\na + b; \u003cspan class=\"hljs-comment\"\u003e// \"1,23,4\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面例子中当操作数不是number的时候，它们都被强制转换为String类型，我们知道\u003ccode\u003e'42' + '1' = '420'\u003c/code\u003e通过String来实现字符串拼接，但是Array为什么也会这么做？有深度的内容来了：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e根据ES5语言规范的11.6.1部分，+的算法是（当一个操作数是object值时），如果两个操作数之一已经是一个string，或者下列步骤产生一个string表达形式，+将会进行连接。所以，当+的两个操作数之一收到一个object（包括array）时，它首先在这个值上调用ToPrimitive抽象操作（9.1部分），而它会带着number的上下文环境提示来调用[[DefaultValue]]算法（8.12.8部分）。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e如果你仔细观察，你会发现这个操作现在和ToNumber抽象操作处理object的过程是一样的（参见早先的“ToNumber”一节）。在array上的valueOf()操作将会在产生一个简单基本类型时失败，于是它退回到一个toString()表现形式。两个array因此分别变成了\u0026quot;1,2\u0026quot;和\u0026quot;3,4\u0026quot;。现在，+就如你通常期望的那样连接这两个string：\u0026quot;1,23,4\u0026quot;。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这上面两段话以为着什么？说的是当你用object做加法操作的时候，object会调用其valueOf方法并返回基本类型，如果valueOf返回的基本类型失败（如没有valueOf方法或则返回的是object），那么就退回去用toString()方法，如果object没有toString()方法，那就返回错误；当然对象自然都是有toString方法的。\n其他的String到number的常见的转换就是如\u003ccode\u003e'42' + 2 = 44\u003c/code\u003e通过字符串和数字直接相加。\u003c/p\u003e\n\u003cp\u003e上面提到的都是'+'加法计算，那减法呢？\n字符串相加可以理解为拼接的过程，但是相减就完全不一样了，如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e] + [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] \u003cspan class=\"hljs-comment\"\u003e// '31'\u003c/span\u003e\n[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e] - [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] \u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e恐怖吧？减法直接将其强制转为String，再由String转换为Number类型。\u003c/p\u003e\n\u003ch3\u003e||和\u0026amp;\u0026amp;操作符\u003c/h3\u003e\n\u003cp\u003e||和\u0026amp;\u0026amp;操作符其实没有特别的，只是当你去研究它的时候，又会发现它很特别\n在判断的时候如if语言或则是三目判断，常会用到||和\u0026amp;\u0026amp;操作符。但是：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e引用ES5语言规范的11.11部分：\n一个\u0026amp;\u0026amp;或||操作符产生的值不见得是Boolean类型。这个产生的值将总是两个操作数表达式其中之一的值。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e||和\u0026amp;\u0026amp;操作符只是意味着选择，而不是其他语言那样的逻辑判断！\n想想确实也用过||和\u0026amp;\u0026amp;来做选择，比如以前很常用的：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003ee = event || \u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e.event\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e用来做兼容处理。这里用的就是选择，而常见的\u003ccode\u003ecb\u0026amp;\u0026amp;cb()\u003c/code\u003e也是做选择。那我们所谓的逻辑判断呢？这个时候用选择的思维考虑一下，马上豁然开朗，逻辑的意思也就是返回最后被选择的数，如果这个数是\u003ccode\u003etrue\u003c/code\u003e那就是真咯。\u003c/p\u003e\n\u003ch2\u003e宽松等价与严格等价\u003c/h2\u003e\n\u003cp\u003e提到\u003ccode\u003e== 和 ===\u003c/code\u003e操作，大多数开发者对前者经常是避而不及，省心的选择就是用后者，做严格的判断，毕竟前者太过花哨了。。。。。。还是先用心了解一下吧:\n这里不得不提几条规范：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e4.如果Type(x)是Number而Type(y)是String， 返回比较x == ToNumber(y)的结果。\n5.如果Type(x)是String而Type(y)是Number， 返回比较ToNumber(x) == y的结果。\n6.如果Type(x)是Boolean， 返回比较 ToNumber(x) == y 的结果。\n7.如果Type(y)是Boolean， 返回比较 x == ToNumber(y) 的结果。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e当String类型和Number比较的时候，String类型会被ToNumber为数字进行对比。同样的Boolean类型会被ToNumber，转换为0或者1。于是就有了如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-string\"\u003e'42'\u003c/span\u003e == \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e'42'\u003c/span\u003e == \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看出'42'既不是0也不1，但是上面表达式却显得42不true也不false。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e2.如果x是null而y是undefined，返回true。\n3.如果x是undefined而y是null，返回true。\n8.如果Type(x)是一个String或者Number而Type(y)是一个Object， 返回比较 x == ToPrimitive(y) 的结果。\n9.如果Type(x)是一个Object而Type(y)是String或者Number， 返回比较 ToPrimitive(x) == y 的结果。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e对于null和undefined自然是自身不true也不false，就等于null或则undefined，这个还是很容易理解的；那Object呢？\n前面在'+'加法操作的时候提到过Object的转换问题，能通过valueOf返回基本类型就返回，不能就通过toString()方法，这里也是适用的。\n值得一提的是形如\u003ccode\u003e{}\u003c/code\u003e这样的对象，其toString()之后是\u003ccode\u003e[Object Object]\u003c/code\u003e而不是\u003ccode\u003e'0'\u003c/code\u003e，和平时用的\u003ccode\u003eObject.prototype.toString.call\u003c/code\u003e还是很接近的。\n来看看下面例子\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003eNumber\u003c/span\u003e.prototype.valueOf = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e;\n};\n\n\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eNumber\u003c/span\u003e( \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e ) == \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e;   \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这种就是业界毒瘤了，希望不要有傻逼这么写。。。。。哈哈哈哈\u003c/p\u003e\n\u003ch2\u003e抽象关系比较\u003c/h2\u003e\n\u003cp\u003e前面提到了加法和双等于判断，接下来怎么可以不提到大于小于判断呢？有了前面的基础，对于强制转换还是很容易理解的。看一下例子\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e a = { \u003cspan class=\"hljs-attr\"\u003eb\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e };\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e b = { \u003cspan class=\"hljs-attr\"\u003eb\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e43\u003c/span\u003e };\n\na \u0026lt; b;  \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\na \u0026gt; b;  \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\na == b;  \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\na \u0026lt;= b; \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\na \u0026gt;= b; \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里Object对象自然都是被强制转换为\u003ccode\u003e[object Object]\u003c/code\u003e，那肯定是不是大小于关系的，那\u003ccode\u003e==\u003c/code\u003e呢？\u003ccode\u003e[object Object]\u003c/code\u003e难道不等于\u003ccode\u003e[object Object]\u003c/code\u003e？这个时候就不要陷入思维误区了，就像\u003ccode\u003e'' == '0'\u003c/code\u003e为false一样，明明转换后都是\u003ccode\u003e数字0\u003c/code\u003e为何不成立？因为他俩都是String，不用强制转换直接对比。同样的Object和Object用\u003ccode\u003e==\u003c/code\u003e判断自然也不用强制转换。值得一提的是Object只有和自己做\u003ccode\u003e==\u003c/code\u003e判断的时候才为true。\n那后面的小于等于和大于等于呢？妈呀，看着都要乱了，这个要根据语言规范了，谁叫他是老大呢？\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e因为语言规范说，对于a \u0026lt;= b，它实际上首先对b \u0026lt; a求值，然后反转那个结果。因为b \u0026lt; a也是false，所以a \u0026lt;= b的结果为true。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e原来是反转。。。。。。JS的逻辑还真会玩\u003c/p\u003e\n\u003ch1\u003e文法\u003c/h1\u003e\n\u003cp\u003e语句是有完成值的，比如你打开浏览器的控制台，输入\u003ccode\u003evar a = 1\u003c/code\u003e回车，这个时候，显示的下一行是\u003ccode\u003eundefined\u003c/code\u003e，而不是\u003ccode\u003e1\u003c/code\u003e，但你敲入\u003ccode\u003ea\u003c/code\u003e会车的时候，才显示\u003ccode\u003e1\u003c/code\u003e，这里的\u003ccode\u003eundefined和1\u003c/code\u003e就是语句的完成值。\n关于强制转换，一个经常被引用的坑是\u003ccode\u003e[] + {}\u003c/code\u003e和\u003ccode\u003e{} + []\u003c/code\u003e，这两个表达式的结果分别是\u003ccode\u003e[object Object]\u003c/code\u003e和\u003ccode\u003e0\u003c/code\u003e，因为后面的{}表示的是缺省';'的语句于是变成\u003ccode\u003e{}; + []\u003c/code\u003e自然是0了。\n另外文中还提到结构解析，操作优先级，自动分号(ASI)和错误的问题，这些都是基础部分，这里就不介绍了。\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"July 7, 2018","title":"强制转换","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e类型与文法，在两个月以前其实已经看完了，但看完‘this与对象原型’和‘类型与文法’章节后，却自以为早已经掌握，没有什么可以谈的，于是便束之高阁。直到前一阵子，部门分享python基础的时候，提到python没有变量声明，拿来就用。着不是和JS很像？JS为什么没有变量声明呢？记得C语言都用变量声明，为何JS没有呢？变量声明有什么作用？好不好？\u003c/p\u003e\n\u003cp\u003e知乎问题\u003ca href=\"https://www.zhihu.com/question/19883873\" target=\"_blank\"\u003e为什么像 Java、C、C++ 这样的静态语言会比 Python、Ruby 这样的动态语言流行得多？\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e再结合另外一个知乎问题\u003ca href=\"https://www.zhihu.com/question/19918532\" target=\"_blank\"\u003e弱类型、强类型、动态类型、静态类型语言的区别是什么？\u003c/a\u003e里面介绍到：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eProgram Errors\n• trapped errors。导致程序终止执行，如除0，Java中数组越界访问\n• untrapped errors。 出错后继续执行，但可能出现任意行为。如C里的缓冲区溢出、Jump到错误地址\u003c/p\u003e\n\u003cp\u003eForbidden Behaviours\n语言设计时，可以定义一组forbidden behaviors. 它必须包括所有untrapped errors, 但可能包含trapped errors.\nWell behaved、ill behaved\n• well behaved: 如果程序执行不可能出现forbidden behaviors, 则为well behaved。\n• ill behaved: 否则为ill behaved…\u003c/p\u003e\n\u003cp\u003e强、弱类型\n• 强类型strongly typed: 如果一种语言的所有程序都是well behaved——即不可能出现forbidden behaviors，则该语言为strongly typed。\n• 弱类型weakly typed: 否则为weakly typed。比如C语言的缓冲区溢出，属于trapped errors，即属于forbidden behaviors..故C是弱类型\u003c/p\u003e\n\u003cp\u003e动态、静态类型\n• 静态类型 statically: 如果在编译时拒绝ill behaved程序，则是statically typed;\n• 动态类型dynamiclly: 如果在运行时拒绝ill behaviors, 则是dynamiclly typed。\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/programType.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e可以发现像JS这样的动态语言弱类型，没有如JAVA这样明显的编译过程，只是在浏览器或者Node运行时存在解析过程，并且在解析的时候检查有无forbidden behaviors。这样的动态语言有什么好处了，如部分答主所说的动如脱兔，如同草书般洒脱，不像其他语言一笔一划，讲求中正平稳。看看几年前JavaScript文件，程序如果比较大，几百行JavaScript都可以看得人头晕脑胀，也有没有IDE这样跳转工具，虽然现在有webStorm，对于大规模开发自然是不友好的，这种乱的感觉自然让很多人避开它。\n到现在ECMAscript已经发展到ES7甚至ES8了，在Vue-router的开发里面，甚至都用上了Facebook的flow，来验证变量类型，提高代码质量，现在的JS已经是越来越旺盛了。\n于是对变量声明的更进一步理解，于是又开始看‘类型与文法’这一章，没想到收获很多\u003c/p\u003e\n\u003ch1\u003e开始\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在JavaScript中，变量没有类型 -- 值才有类型。变量可以在任何时候，持有任何值\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这句话深入我心，JS里面有var的变量声明，后面又有let和const。声明的变量可以是任何值，从基本变量到Object都是木有问题的，甚至在非严格模式下，不声明直接使用变量也不会报错，而且变量还可以随意更改，从number变到Object，完全没有问题，那为何要称变量为类型呢？明明说的就是变量背后的值是什么类型；\u003c/p\u003e\n\u003ch1\u003e强制转换\u003c/h1\u003e\n\u003cp\u003efalsy列表：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eundefined\u003c/li\u003e\n\u003cli\u003enull\u003c/li\u003e\n\u003cli\u003efalse\u003c/li\u003e\n\u003cli\u003e+0， 0， NaN\u003c/li\u003e\n\u003cli\u003e''\n这些在Boolean强制转换的时候都会变成false，值得注意的是String类型里面仅有唯一一个空字符串('')会被转换为false。\n同时，类似的如[], {}以及-1等等的都是true值，这些简单有用的true/false还是值得注意的。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e明确的强制转换\u003c/h2\u003e\n\u003cp\u003e一元操作符'+'能将String明确的转换为number，同样能将Date类型变为number如：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e d = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eDate\u003c/span\u003e( \u003cspan class=\"hljs-string\"\u003e\"Mon, 18 Aug 2014 08:53:06 CDT\"\u003c/span\u003e );\n+d; \u003cspan class=\"hljs-comment\"\u003e// 1408369986000\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但是通常都不会这么做，没有语义，容易误解，不如常用的'getTime()'好使\u003c/p\u003e\n\u003cp\u003e需要小心的是parseInt传入非string类型的时候产生的bug。\u003c/p\u003e\n\u003ch2\u003e隐含的强制转换\u003c/h2\u003e\n\u003cp\u003e下面的都是是这一章的重点了，明确的强制转换大多好懂，而且不容易犯错。相比之下，隐含的强制转换就深邃的多了。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e a = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e b = [\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e];\n\na + b; \u003cspan class=\"hljs-comment\"\u003e// \"1,23,4\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面例子中当操作数不是number的时候，它们都被强制转换为String类型，我们知道\u003ccode\u003e'42' + '1' = '420'\u003c/code\u003e通过String来实现字符串拼接，但是Array为什么也会这么做？有深度的内容来了：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e根据ES5语言规范的11.6.1部分，+的算法是（当一个操作数是object值时），如果两个操作数之一已经是一个string，或者下列步骤产生一个string表达形式，+将会进行连接。所以，当+的两个操作数之一收到一个object（包括array）时，它首先在这个值上调用ToPrimitive抽象操作（9.1部分），而它会带着number的上下文环境提示来调用[[DefaultValue]]算法（8.12.8部分）。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e如果你仔细观察，你会发现这个操作现在和ToNumber抽象操作处理object的过程是一样的（参见早先的“ToNumber”一节）。在array上的valueOf()操作将会在产生一个简单基本类型时失败，于是它退回到一个toString()表现形式。两个array因此分别变成了\u0026quot;1,2\u0026quot;和\u0026quot;3,4\u0026quot;。现在，+就如你通常期望的那样连接这两个string：\u0026quot;1,23,4\u0026quot;。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这上面两段话以为着什么？说的是当你用object做加法操作的时候，object会调用其valueOf方法并返回基本类型，如果valueOf返回的基本类型失败（如没有valueOf方法或则返回的是object），那么就退回去用toString()方法，如果object没有toString()方法，那就返回错误；当然对象自然都是有toString方法的。\n其他的String到number的常见的转换就是如\u003ccode\u003e'42' + 2 = 44\u003c/code\u003e通过字符串和数字直接相加。\u003c/p\u003e\n\u003cp\u003e上面提到的都是'+'加法计算，那减法呢？\n字符串相加可以理解为拼接的过程，但是相减就完全不一样了，如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e] + [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] \u003cspan class=\"hljs-comment\"\u003e// '31'\u003c/span\u003e\n[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e] - [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] \u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e恐怖吧？减法直接将其强制转为String，再由String转换为Number类型。\u003c/p\u003e\n\u003ch3\u003e||和\u0026amp;\u0026amp;操作符\u003c/h3\u003e\n\u003cp\u003e||和\u0026amp;\u0026amp;操作符其实没有特别的，只是当你去研究它的时候，又会发现它很特别\n在判断的时候如if语言或则是三目判断，常会用到||和\u0026amp;\u0026amp;操作符。但是：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e引用ES5语言规范的11.11部分：\n一个\u0026amp;\u0026amp;或||操作符产生的值不见得是Boolean类型。这个产生的值将总是两个操作数表达式其中之一的值。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e||和\u0026amp;\u0026amp;操作符只是意味着选择，而不是其他语言那样的逻辑判断！\n想想确实也用过||和\u0026amp;\u0026amp;来做选择，比如以前很常用的：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003ee = event || \u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e.event\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e用来做兼容处理。这里用的就是选择，而常见的\u003ccode\u003ecb\u0026amp;\u0026amp;cb()\u003c/code\u003e也是做选择。那我们所谓的逻辑判断呢？这个时候用选择的思维考虑一下，马上豁然开朗，逻辑的意思也就是返回最后被选择的数，如果这个数是\u003ccode\u003etrue\u003c/code\u003e那就是真咯。\u003c/p\u003e\n\u003ch2\u003e宽松等价与严格等价\u003c/h2\u003e\n\u003cp\u003e提到\u003ccode\u003e== 和 ===\u003c/code\u003e操作，大多数开发者对前者经常是避而不及，省心的选择就是用后者，做严格的判断，毕竟前者太过花哨了。。。。。。还是先用心了解一下吧:\n这里不得不提几条规范：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e4.如果Type(x)是Number而Type(y)是String， 返回比较x == ToNumber(y)的结果。\n5.如果Type(x)是String而Type(y)是Number， 返回比较ToNumber(x) == y的结果。\n6.如果Type(x)是Boolean， 返回比较 ToNumber(x) == y 的结果。\n7.如果Type(y)是Boolean， 返回比较 x == ToNumber(y) 的结果。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e当String类型和Number比较的时候，String类型会被ToNumber为数字进行对比。同样的Boolean类型会被ToNumber，转换为0或者1。于是就有了如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-string\"\u003e'42'\u003c/span\u003e == \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e'42'\u003c/span\u003e == \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看出'42'既不是0也不1，但是上面表达式却显得42不true也不false。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e2.如果x是null而y是undefined，返回true。\n3.如果x是undefined而y是null，返回true。\n8.如果Type(x)是一个String或者Number而Type(y)是一个Object， 返回比较 x == ToPrimitive(y) 的结果。\n9.如果Type(x)是一个Object而Type(y)是String或者Number， 返回比较 ToPrimitive(x) == y 的结果。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e对于null和undefined自然是自身不true也不false，就等于null或则undefined，这个还是很容易理解的；那Object呢？\n前面在'+'加法操作的时候提到过Object的转换问题，能通过valueOf返回基本类型就返回，不能就通过toString()方法，这里也是适用的。\n值得一提的是形如\u003ccode\u003e{}\u003c/code\u003e这样的对象，其toString()之后是\u003ccode\u003e[Object Object]\u003c/code\u003e而不是\u003ccode\u003e'0'\u003c/code\u003e，和平时用的\u003ccode\u003eObject.prototype.toString.call\u003c/code\u003e还是很接近的。\n来看看下面例子\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003eNumber\u003c/span\u003e.prototype.valueOf = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e;\n};\n\n\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eNumber\u003c/span\u003e( \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e ) == \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e;   \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这种就是业界毒瘤了，希望不要有傻逼这么写。。。。。哈哈哈哈\u003c/p\u003e\n\u003ch2\u003e抽象关系比较\u003c/h2\u003e\n\u003cp\u003e前面提到了加法和双等于判断，接下来怎么可以不提到大于小于判断呢？有了前面的基础，对于强制转换还是很容易理解的。看一下例子\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e a = { \u003cspan class=\"hljs-attr\"\u003eb\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e };\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e b = { \u003cspan class=\"hljs-attr\"\u003eb\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e43\u003c/span\u003e };\n\na \u0026lt; b;  \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\na \u0026gt; b;  \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\na == b;  \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\na \u0026lt;= b; \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\na \u0026gt;= b; \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里Object对象自然都是被强制转换为\u003ccode\u003e[object Object]\u003c/code\u003e，那肯定是不是大小于关系的，那\u003ccode\u003e==\u003c/code\u003e呢？\u003ccode\u003e[object Object]\u003c/code\u003e难道不等于\u003ccode\u003e[object Object]\u003c/code\u003e？这个时候就不要陷入思维误区了，就像\u003ccode\u003e'' == '0'\u003c/code\u003e为false一样，明明转换后都是\u003ccode\u003e数字0\u003c/code\u003e为何不成立？因为他俩都是String，不用强制转换直接对比。同样的Object和Object用\u003ccode\u003e==\u003c/code\u003e判断自然也不用强制转换。值得一提的是Object只有和自己做\u003ccode\u003e==\u003c/code\u003e判断的时候才为true。\n那后面的小于等于和大于等于呢？妈呀，看着都要乱了，这个要根据语言规范了，谁叫他是老大呢？\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e因为语言规范说，对于a \u0026lt;= b，它实际上首先对b \u0026lt; a求值，然后反转那个结果。因为b \u0026lt; a也是false，所以a \u0026lt;= b的结果为true。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e原来是反转。。。。。。JS的逻辑还真会玩\u003c/p\u003e\n\u003ch1\u003e文法\u003c/h1\u003e\n\u003cp\u003e语句是有完成值的，比如你打开浏览器的控制台，输入\u003ccode\u003evar a = 1\u003c/code\u003e回车，这个时候，显示的下一行是\u003ccode\u003eundefined\u003c/code\u003e，而不是\u003ccode\u003e1\u003c/code\u003e，但你敲入\u003ccode\u003ea\u003c/code\u003e会车的时候，才显示\u003ccode\u003e1\u003c/code\u003e，这里的\u003ccode\u003eundefined和1\u003c/code\u003e就是语句的完成值。\n关于强制转换，一个经常被引用的坑是\u003ccode\u003e[] + {}\u003c/code\u003e和\u003ccode\u003e{} + []\u003c/code\u003e，这两个表达式的结果分别是\u003ccode\u003e[object Object]\u003c/code\u003e和\u003ccode\u003e0\u003c/code\u003e，因为后面的{}表示的是缺省';'的语句于是变成\u003ccode\u003e{}; + []\u003c/code\u003e自然是0了。\n另外文中还提到结构解析，操作优先级，自动分号(ASI)和错误的问题，这些都是基础部分，这里就不介绍了。\u003c/p\u003e\n"}},"buildId":"I9XlxpmvFk~lmulxmmsMh","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.ce3e8fb7a689beb447ad.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.8d98f9151bcde6fb2a87.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-45be5a1f94c3fe5df8ee.js" async=""></script></body></html>