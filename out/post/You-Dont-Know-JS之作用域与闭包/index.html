<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">You-Dont-Know-JS之作用域与闭包</title><link rel="preload" href="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.491f56ba.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___3Hk0c "><a class="logo___1KD30" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___1qXLb" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___3VKNp"><h1 class="postTitle___26vXM">You-Dont-Know-JS之作用域与闭包</h1><span class="postTime___16Ish">July 7, 2018</span></header><article class="postWrapper___3NXol post-article"><div><h1>前言</h1>
<p>读的书多了，渐渐也能有自己的体会，书有平庸之作，也有佳作，但有些时候我觉得更多要看人。
在看了Vue和backbone的源码后，越发感觉自己的代码水平有待提高，但常见的各种动物书都看过了，一时间不知道看啥书好。于是在傻乎逛了一圈后，发现《你不知道的JavaScript》这本书，严格来说是上卷，很早以前就听大名，仿佛和高程三齐名，只是一直以没有时间为理由，没有接触。巧的是在傻乎上发现《你不知道的JavaScript》已经在github上出了<a href="https://github.com/JoeHetfield/You-Dont-Know-JS" target="_blank">中文版</a>，而且是全套完整的，幸福来的太突然。细读之，颇有收获，故在此分享。</p>
<h1>编译器</h1>
<p>文中一开始就讲到编译器理论，离开大学后就没有接触过这东西，再次看到，觉得很nice；
编译过程通常来说分为三步：1.分词/此法分析，这个有点类似搜索引擎里面的拆字； 2.解析，将步骤一生成的代码片段表示为一个抽象语法树；3.生成代码就是将抽象语法树转化为可执行代码；</p>
<p>正如上文说所，引擎在执行代码前，代码会先经过编译器编译；如<code>var a = 2</code>，编译过程会出现编译器和作用域之间的互动，编译器在遇到var a的时候会通过作用域判断有无该声明，没有就声明一个a变量，有就略过；而代码编译后执行的情况，则是引擎向作用域请求，去寻找a变量，再进行赋值操作；就这样<code>var a = 2</code>被分成两步操作。
看到这里，你大概就发现作用域在里面扮演的中间角色，编译过程中将变量参数创建在作用域内，而执行阶段引擎通过访问作用域得到变量，并进行其他操作；分工是如此的明！！作用域有点像数据库的味道，被互相用来用去。。。。文中还提到了LHS和RHS查询，LHS查询简而言之赋值操作，RHS则是取值操作；如<code>console.log(a)</code>这里面就涉及到两个RHS，console的查找和a的RHS引用。
提到LHS和RHS可以加深我们对编译器，引擎和作用域三者之间关系的理解，书中还有趣的提到三者之间聊天的情况，值得玩味；关于LHS和RHS，还涉及到了引擎抛出的错误<code>ReferenceError</code>和<code>TypeError</code>，前者正如字面解释引用错误，当RHS查询的时候，若在作用域没有发现这个变量，就抛出异常；相同的如果作用域解析成功了，但是进行非法操作，就会<code>TypeError</code>。</p>
<h1>词法作用域，函数与块儿作用域</h1>
<p>在词法作用域里面提到了<code>eval</code>和<code>with</code>这些被好多人提到的黑暗操作，本以为一辈子都见不到了，没想到在自家项目上居然看到有人用。。。立马delete掉；<code>eval</code>这些是很灵活，但是它会大大的影响编译过程中的优化，因为<code>eval</code>这些的出现会导致编译中产生的词法作用域无效：</p>
<blockquote>
<p>但如果 引擎 在代码中发现一个 eval(..) 或 with，它实质上就不得不 假定 自己知道的所有的标识符的位置可能是无效的，因为它不可能在词法分析时就知道你将会向eval(..)传递什么样的代码来修改词法作用域，或者你可能会向with传递的对象有什么样的内容来创建一个新的将被查询的词法作用域。</p>
</blockquote>
<p>IIFE立即调用函数表达式，最开始接触的时候是在看jQuery里面用到的，这样可以把自己声明的变量和外界隔离开来，避免环境污染；let和const带来的块级作用域，自然是无可辩驳的，以前全局作用域和函数作用域，现在已经基本不用var只用let和const了。。。。。var重复声明就直接覆盖，而且变量提升还会带来undefined的覆盖；以下面例子</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> tmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(tmp);
  <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) {
    <span class="hljs-keyword">var</span> tmp = <span class="hljs-string">'hello world'</span>;
  }
}

f(); <span class="hljs-comment">// undefined</span>
</code></pre>
<p>输出结果将会是undefined，而使用块级作用域就很不一样了</p>
<h1>提升，作用域闭包</h1>
<p>变量提升，在之前的博客中也有提到过，书中再次用编译的思想解释。对于变量声明，编译中自然是在的目的之一就是在作用域创建该变量，后面才轮到引擎执行可执行语句，于是产生声明提升，执行的时候才有初始化，正如下面代码</p>
<pre class="hljs"><code>foo(); <span class="hljs-comment">// 不是 ReferenceError， 而是 TypeError!</span>

<span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// ...</span>
};
</code></pre>
<p>提升部分有兴趣可以看看之前一篇博客：<a href="https://github.com/funfish/blog/issues/3" target="_blank">void 0 以及let const var 的理解</a></p>
<p>闭包的概念就有点老生常谈了，如今ES6有了块作用域的概念，一切都好办多了，模块间的import和export语法，也让代码运用更加灵巧，只是结合这本书出版时间，不难发现，在以前这概念可是相当新颖的；</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"July 7, 2018","title":"You-Dont-Know-JS之作用域与闭包","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e读的书多了，渐渐也能有自己的体会，书有平庸之作，也有佳作，但有些时候我觉得更多要看人。\n在看了Vue和backbone的源码后，越发感觉自己的代码水平有待提高，但常见的各种动物书都看过了，一时间不知道看啥书好。于是在傻乎逛了一圈后，发现《你不知道的JavaScript》这本书，严格来说是上卷，很早以前就听大名，仿佛和高程三齐名，只是一直以没有时间为理由，没有接触。巧的是在傻乎上发现《你不知道的JavaScript》已经在github上出了\u003ca href=\"https://github.com/JoeHetfield/You-Dont-Know-JS\" target=\"_blank\"\u003e中文版\u003c/a\u003e，而且是全套完整的，幸福来的太突然。细读之，颇有收获，故在此分享。\u003c/p\u003e\n\u003ch1\u003e编译器\u003c/h1\u003e\n\u003cp\u003e文中一开始就讲到编译器理论，离开大学后就没有接触过这东西，再次看到，觉得很nice；\n编译过程通常来说分为三步：1.分词/此法分析，这个有点类似搜索引擎里面的拆字； 2.解析，将步骤一生成的代码片段表示为一个抽象语法树；3.生成代码就是将抽象语法树转化为可执行代码；\u003c/p\u003e\n\u003cp\u003e正如上文说所，引擎在执行代码前，代码会先经过编译器编译；如\u003ccode\u003evar a = 2\u003c/code\u003e，编译过程会出现编译器和作用域之间的互动，编译器在遇到var a的时候会通过作用域判断有无该声明，没有就声明一个a变量，有就略过；而代码编译后执行的情况，则是引擎向作用域请求，去寻找a变量，再进行赋值操作；就这样\u003ccode\u003evar a = 2\u003c/code\u003e被分成两步操作。\n看到这里，你大概就发现作用域在里面扮演的中间角色，编译过程中将变量参数创建在作用域内，而执行阶段引擎通过访问作用域得到变量，并进行其他操作；分工是如此的明！！作用域有点像数据库的味道，被互相用来用去。。。。文中还提到了LHS和RHS查询，LHS查询简而言之赋值操作，RHS则是取值操作；如\u003ccode\u003econsole.log(a)\u003c/code\u003e这里面就涉及到两个RHS，console的查找和a的RHS引用。\n提到LHS和RHS可以加深我们对编译器，引擎和作用域三者之间关系的理解，书中还有趣的提到三者之间聊天的情况，值得玩味；关于LHS和RHS，还涉及到了引擎抛出的错误\u003ccode\u003eReferenceError\u003c/code\u003e和\u003ccode\u003eTypeError\u003c/code\u003e，前者正如字面解释引用错误，当RHS查询的时候，若在作用域没有发现这个变量，就抛出异常；相同的如果作用域解析成功了，但是进行非法操作，就会\u003ccode\u003eTypeError\u003c/code\u003e。\u003c/p\u003e\n\u003ch1\u003e词法作用域，函数与块儿作用域\u003c/h1\u003e\n\u003cp\u003e在词法作用域里面提到了\u003ccode\u003eeval\u003c/code\u003e和\u003ccode\u003ewith\u003c/code\u003e这些被好多人提到的黑暗操作，本以为一辈子都见不到了，没想到在自家项目上居然看到有人用。。。立马delete掉；\u003ccode\u003eeval\u003c/code\u003e这些是很灵活，但是它会大大的影响编译过程中的优化，因为\u003ccode\u003eeval\u003c/code\u003e这些的出现会导致编译中产生的词法作用域无效：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e但如果 引擎 在代码中发现一个 eval(..) 或 with，它实质上就不得不 假定 自己知道的所有的标识符的位置可能是无效的，因为它不可能在词法分析时就知道你将会向eval(..)传递什么样的代码来修改词法作用域，或者你可能会向with传递的对象有什么样的内容来创建一个新的将被查询的词法作用域。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIIFE立即调用函数表达式，最开始接触的时候是在看jQuery里面用到的，这样可以把自己声明的变量和外界隔离开来，避免环境污染；let和const带来的块级作用域，自然是无可辩驳的，以前全局作用域和函数作用域，现在已经基本不用var只用let和const了。。。。。var重复声明就直接覆盖，而且变量提升还会带来undefined的覆盖；以下面例子\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e tmp = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eDate\u003c/span\u003e();\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ef\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(tmp);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e tmp = \u003cspan class=\"hljs-string\"\u003e'hello world'\u003c/span\u003e;\n  }\n}\n\nf(); \u003cspan class=\"hljs-comment\"\u003e// undefined\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e输出结果将会是undefined，而使用块级作用域就很不一样了\u003c/p\u003e\n\u003ch1\u003e提升，作用域闭包\u003c/h1\u003e\n\u003cp\u003e变量提升，在之前的博客中也有提到过，书中再次用编译的思想解释。对于变量声明，编译中自然是在的目的之一就是在作用域创建该变量，后面才轮到引擎执行可执行语句，于是产生声明提升，执行的时候才有初始化，正如下面代码\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003efoo(); \u003cspan class=\"hljs-comment\"\u003e// 不是 ReferenceError， 而是 TypeError!\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e foo = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e提升部分有兴趣可以看看之前一篇博客：\u003ca href=\"https://github.com/funfish/blog/issues/3\" target=\"_blank\"\u003evoid 0 以及let const var 的理解\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e闭包的概念就有点老生常谈了，如今ES6有了块作用域的概念，一切都好办多了，模块间的import和export语法，也让代码运用更加灵巧，只是结合这本书出版时间，不难发现，在以前这概念可是相当新颖的；\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"July 7, 2018","title":"You-Dont-Know-JS之作用域与闭包","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e读的书多了，渐渐也能有自己的体会，书有平庸之作，也有佳作，但有些时候我觉得更多要看人。\n在看了Vue和backbone的源码后，越发感觉自己的代码水平有待提高，但常见的各种动物书都看过了，一时间不知道看啥书好。于是在傻乎逛了一圈后，发现《你不知道的JavaScript》这本书，严格来说是上卷，很早以前就听大名，仿佛和高程三齐名，只是一直以没有时间为理由，没有接触。巧的是在傻乎上发现《你不知道的JavaScript》已经在github上出了\u003ca href=\"https://github.com/JoeHetfield/You-Dont-Know-JS\" target=\"_blank\"\u003e中文版\u003c/a\u003e，而且是全套完整的，幸福来的太突然。细读之，颇有收获，故在此分享。\u003c/p\u003e\n\u003ch1\u003e编译器\u003c/h1\u003e\n\u003cp\u003e文中一开始就讲到编译器理论，离开大学后就没有接触过这东西，再次看到，觉得很nice；\n编译过程通常来说分为三步：1.分词/此法分析，这个有点类似搜索引擎里面的拆字； 2.解析，将步骤一生成的代码片段表示为一个抽象语法树；3.生成代码就是将抽象语法树转化为可执行代码；\u003c/p\u003e\n\u003cp\u003e正如上文说所，引擎在执行代码前，代码会先经过编译器编译；如\u003ccode\u003evar a = 2\u003c/code\u003e，编译过程会出现编译器和作用域之间的互动，编译器在遇到var a的时候会通过作用域判断有无该声明，没有就声明一个a变量，有就略过；而代码编译后执行的情况，则是引擎向作用域请求，去寻找a变量，再进行赋值操作；就这样\u003ccode\u003evar a = 2\u003c/code\u003e被分成两步操作。\n看到这里，你大概就发现作用域在里面扮演的中间角色，编译过程中将变量参数创建在作用域内，而执行阶段引擎通过访问作用域得到变量，并进行其他操作；分工是如此的明！！作用域有点像数据库的味道，被互相用来用去。。。。文中还提到了LHS和RHS查询，LHS查询简而言之赋值操作，RHS则是取值操作；如\u003ccode\u003econsole.log(a)\u003c/code\u003e这里面就涉及到两个RHS，console的查找和a的RHS引用。\n提到LHS和RHS可以加深我们对编译器，引擎和作用域三者之间关系的理解，书中还有趣的提到三者之间聊天的情况，值得玩味；关于LHS和RHS，还涉及到了引擎抛出的错误\u003ccode\u003eReferenceError\u003c/code\u003e和\u003ccode\u003eTypeError\u003c/code\u003e，前者正如字面解释引用错误，当RHS查询的时候，若在作用域没有发现这个变量，就抛出异常；相同的如果作用域解析成功了，但是进行非法操作，就会\u003ccode\u003eTypeError\u003c/code\u003e。\u003c/p\u003e\n\u003ch1\u003e词法作用域，函数与块儿作用域\u003c/h1\u003e\n\u003cp\u003e在词法作用域里面提到了\u003ccode\u003eeval\u003c/code\u003e和\u003ccode\u003ewith\u003c/code\u003e这些被好多人提到的黑暗操作，本以为一辈子都见不到了，没想到在自家项目上居然看到有人用。。。立马delete掉；\u003ccode\u003eeval\u003c/code\u003e这些是很灵活，但是它会大大的影响编译过程中的优化，因为\u003ccode\u003eeval\u003c/code\u003e这些的出现会导致编译中产生的词法作用域无效：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e但如果 引擎 在代码中发现一个 eval(..) 或 with，它实质上就不得不 假定 自己知道的所有的标识符的位置可能是无效的，因为它不可能在词法分析时就知道你将会向eval(..)传递什么样的代码来修改词法作用域，或者你可能会向with传递的对象有什么样的内容来创建一个新的将被查询的词法作用域。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIIFE立即调用函数表达式，最开始接触的时候是在看jQuery里面用到的，这样可以把自己声明的变量和外界隔离开来，避免环境污染；let和const带来的块级作用域，自然是无可辩驳的，以前全局作用域和函数作用域，现在已经基本不用var只用let和const了。。。。。var重复声明就直接覆盖，而且变量提升还会带来undefined的覆盖；以下面例子\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e tmp = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eDate\u003c/span\u003e();\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ef\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(tmp);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e tmp = \u003cspan class=\"hljs-string\"\u003e'hello world'\u003c/span\u003e;\n  }\n}\n\nf(); \u003cspan class=\"hljs-comment\"\u003e// undefined\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e输出结果将会是undefined，而使用块级作用域就很不一样了\u003c/p\u003e\n\u003ch1\u003e提升，作用域闭包\u003c/h1\u003e\n\u003cp\u003e变量提升，在之前的博客中也有提到过，书中再次用编译的思想解释。对于变量声明，编译中自然是在的目的之一就是在作用域创建该变量，后面才轮到引擎执行可执行语句，于是产生声明提升，执行的时候才有初始化，正如下面代码\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003efoo(); \u003cspan class=\"hljs-comment\"\u003e// 不是 ReferenceError， 而是 TypeError!\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e foo = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e提升部分有兴趣可以看看之前一篇博客：\u003ca href=\"https://github.com/funfish/blog/issues/3\" target=\"_blank\"\u003evoid 0 以及let const var 的理解\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e闭包的概念就有点老生常谈了，如今ES6有了块作用域的概念，一切都好办多了，模块间的import和export语法，也让代码运用更加灵巧，只是结合这本书出版时间，不难发现，在以前这概念可是相当新颖的；\u003c/p\u003e\n"}},"buildId":"IdQI6resUd3YjXidM2HVB","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" async=""></script></body></html>