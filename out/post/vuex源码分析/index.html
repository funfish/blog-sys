<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">vuex源码分析</title><link rel="preload" href="/blog-sys/_next/static/_P3qZyp8~kfTSPLoPskhF/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/_P3qZyp8~kfTSPLoPskhF/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/_P3qZyp8~kfTSPLoPskhF/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.491f56ba.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___3Hk0c "><a class="logo___1KD30" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___1qXLb" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___3VKNp"><h1 class="postTitle___26vXM">vuex源码分析</h1><span class="postTime___16Ish">July 7, 2018</span></header><article class="postWrapper___3NXol post-article"><div><h1>前言</h1>
<p>前文分析了Vue-router，感觉后劲十足，于是开始分析Vuex。在项目上，Vuex也是常客。它可以很好的管理状态，尤其是跨组件的时候，Vue的单向数据流使得子组件无法修改prop，经常用$emit和$on的话组件是要多难看就多难看。当组件切换，数据需要缓存总不能一直依赖于向上级组件emit传递数据吧？如果要更好的管理状态，Vuex是个很好的选择。Vuex代码量较Vue-router少了很多，而且也没有flow的校验机制，看起来更加习惯了。这里介绍的Vuex版本号为2.4.1。</p>
<h1>从示例开始</h1>
<pre class="hljs"><code>Vue.use(Vuex)
<span class="hljs-keyword">const</span> state = {
  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>
}

<span class="hljs-keyword">const</span> mutations = {
  increment (state) {
    state.count++
  },
  decrement (state) {
    state.count--
  }
}

<span class="hljs-keyword">const</span> actions = {
  <span class="hljs-attr">increment</span>: <span class="hljs-function">(<span class="hljs-params">{ commit }</span>) =&gt;</span> commit(<span class="hljs-string">'increment'</span>),
  <span class="hljs-attr">decrement</span>: <span class="hljs-function">(<span class="hljs-params">{ commit }</span>) =&gt;</span> commit(<span class="hljs-string">'decrement'</span>),
}
<span class="hljs-comment">// getters are functions</span>
<span class="hljs-keyword">const</span> getters = {
  <span class="hljs-attr">evenOrOdd</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.count % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? <span class="hljs-string">'even'</span> : <span class="hljs-string">'odd'</span>
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vuex.Store({
  state,
  getters,
  actions,
  mutations,
})
</code></pre>
<p>上面示例基本上包含了最常用的mutations，getters和actions了。可以发现这一切从Vue.use(Vuex)开始的，对Vue.use不熟悉的可以看上一篇的Vuex-router中对Vue.use的介绍。
Vuex中用到了install方法来提供Vuex的使用环境。和Vue-router不同，Vuex的主要代码功能都在store.js文件里面(这对查阅代码友好度明显提到了不少)。install过程里面用到了Vue.mixin，并用到了beforeCreate钩子，使得Vue实例化和组件加载的时候都可以调用到钩子。设计如下：</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> version = <span class="hljs-built_in">Number</span>(Vue.version.split(<span class="hljs-string">'.'</span>)[<span class="hljs-number">0</span>])
<span class="hljs-keyword">if</span> (version &gt;= <span class="hljs-number">2</span>) {
  Vue.mixin({ <span class="hljs-attr">beforeCreate</span>: vuexInit })
} <span class="hljs-keyword">else</span> {
  <span class="hljs-keyword">const</span> _init = Vue.prototype._init
  Vue.prototype._init = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options = {}</span>) </span>{
    options.init = options.init
      ? [vuexInit].concat(options.init)
      : vuexInit
    _init.call(<span class="hljs-keyword">this</span>, options)
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">vuexInit</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> options = <span class="hljs-keyword">this</span>.$options
  <span class="hljs-comment">// store injection</span>
  <span class="hljs-keyword">if</span> (options.store) {
    <span class="hljs-keyword">this</span>.$store = <span class="hljs-keyword">typeof</span> options.store === <span class="hljs-string">'function'</span>
      ? options.store()
      : options.store
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options.parent &amp;&amp; options.parent.$store) {
    <span class="hljs-keyword">this</span>.$store = options.parent.$store
  }
}
</code></pre>
<p>可以看到这里对Vue的版本分别做了处理，本版是2.0.0及以上的都会采用Vue.mixin的方法，而低版本的，则将修改Vue的内部_init方法，来添加$store至根。高级别的版本则采用mixin的方法，同样也是添加<code>this.$store</code>。在Vue-router里面是采用数据劫持的方法，来通知更新，顺便提供this.$router，对于状态管理而言，数据劫持显然是不需要的，仅仅提供入口<code>this.$store</code>就够了，这样为全局提供了访问store对象的方法，可以轻松得使用<code>this.$store.commit, this.$store.state</code>之类的方法。</p>
<h1>Store</h1>
<p>Store.js里面最主要的就是Store类，这个也是之前提到的<code>this.$store</code>对象。先看看constructor方法：
在构造里面先判断有无使用install方法，没有则intall一下，接着是断言有无安装Vue，是否支持Promise和是否是通过new创建Store的实例。另外在install过程里面还有是否重复安装Vuex的断言，这个场景会发生在已经先使用Vuex了，但是没有用<code>Vue.use(Vuex)</code>来显式安装Vuex，如果再加上<code>Vue.use(Vuex)</code>就会有这样的提示，尤其是在开发环境和生产环境配置中。
Store初始化过程，有<code>this._modules = new ModuleCollection(options)</code>，这个_modules就是Store集合的意思了。Vuex有modules的概念，允许对store进行分割形成不同的模块，每个模块都可以有自己的state，getter，mutation和action，甚至还可以嵌套子模块。于是将这些模块包括根模块一起放入modules里面。this._modules的一个重要api就是注册添加一个模块：</p>
<pre class="hljs"><code>register (path, rawModule, runtime = <span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">'production'</span>) {
    assertRawModule(path, rawModule)
  }

  <span class="hljs-keyword">const</span> newModule = <span class="hljs-keyword">new</span> Module(rawModule, runtime)
  <span class="hljs-keyword">if</span> (path.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">this</span>.root = newModule
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">const</span> parent = <span class="hljs-keyword">this</span>.get(path.slice(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>))
    parent.addChild(path[path.length - <span class="hljs-number">1</span>], newModule)
  }

  <span class="hljs-comment">// register nested modules</span>
  <span class="hljs-keyword">if</span> (rawModule.modules) {
    forEachValue(rawModule.modules, (rawChildModule, key) =&gt; {
      <span class="hljs-keyword">this</span>.register(path.concat(key), rawChildModule, runtime)
    })
  }
}
</code></pre>
<p>这里还可以看到this._modules.root就是根模块，并且对于子模块的，还会被添加到父模块parent的_children对象里面；到这里可以发现this.modules.root和原先的store很像，只是单独分离出state，并且将子模块改为了_children关系，并将_rawMoudule赋值为整个传过来模块，同时为this._modules和每个module都添加不少方法，这些方法自然是为后面做准备的。
在谈commit和dispatch方法之前，先看看后面的模块安装和StoreVM的设置</p>
<pre class="hljs"><code>installModule(<span class="hljs-keyword">this</span>, state, [], <span class="hljs-keyword">this</span>._modules.root)
resetStoreVM(<span class="hljs-keyword">this</span>, state)

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">installModule</span> (<span class="hljs-params">store, rootState, path, module, hot</span>) </span>{
  <span class="hljs-keyword">const</span> isRoot = !path.length
  <span class="hljs-keyword">const</span> namespace = store._modules.getNamespace(path)
  <span class="hljs-comment">// 命名空间字典的添加</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">module</span>.namespaced) {
    store._modulesNamespaceMap[namespace] = <span class="hljs-built_in">module</span>
  }
  <span class="hljs-comment">// 设置state</span>
  <span class="hljs-keyword">if</span> (!isRoot &amp;&amp; !hot) {
    <span class="hljs-keyword">const</span> parentState = getNestedState(rootState, path.slice(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>))
    <span class="hljs-keyword">const</span> moduleName = path[path.length - <span class="hljs-number">1</span>]
    store._withCommit(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      Vue.set(parentState, moduleName, <span class="hljs-built_in">module</span>.state)
    })
  }
  <span class="hljs-keyword">const</span> local = <span class="hljs-built_in">module</span>.context = makeLocalContext(store, namespace, path)
  <span class="hljs-built_in">module</span>.forEachMutation(<span class="hljs-function">(<span class="hljs-params">mutation, key</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> namespacedType = namespace + key
    registerMutation(store, namespacedType, mutation, local)
  })
  <span class="hljs-comment">// 下面省略部分是通过module提供的方法分别对action和getter进行registe</span>
  <span class="hljs-comment">// 以及对子模块modules的遍历式得注册mutation/action/getter</span>

  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>对于modules而言，<a href="https://vuex.vuejs.org/zh-cn/modules.html" target="_blank">官方文档</a>有介绍到，模块内部的 action，mutation和getter是注册在全局命名空间的，如果想要独立的空间，比如有命名重复的情况下，可以使用<code>namespaced: true</code>来注册单独的空间；同时访问的时候也也要加上模块的名字，否则否则无法定位到。
接着看state的设置，对于if条件语句，若是子模块并且非hot，会获取子模块的亲父级模块，并通过Vue.set方法将该子模块的state添加到亲父模块state里面，这是响应式的，会被Vue劫持到。后面部分就是对action/getter/mutation的注册添加了，这部分后面在讲。</p>
<p>后面是resetStoreVM：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetStoreVM</span> (<span class="hljs-params">store, state, hot</span>) </span>{
  <span class="hljs-keyword">const</span> oldVm = store._vm
  <span class="hljs-comment">// bind store public getters</span>
  store.getters = {}
  <span class="hljs-keyword">const</span> wrappedGetters = store._wrappedGetters
  <span class="hljs-keyword">const</span> computed = {}
  forEachValue(wrappedGetters, (fn, key) =&gt; {
    <span class="hljs-comment">// use computed to leverage its lazy-caching mechanism</span>
    computed[key] = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> fn(store)
    <span class="hljs-built_in">Object</span>.defineProperty(store.getters, key, {
      <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> store._vm[key],
      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// for local getters</span>
    })
  })
  <span class="hljs-keyword">const</span> silent = Vue.config.silent
  Vue.config.silent = <span class="hljs-literal">true</span>
  store._vm = <span class="hljs-keyword">new</span> Vue({
    <span class="hljs-attr">data</span>: {
      <span class="hljs-attr">$$state</span>: state
    },
    computed
  })
  Vue.config.silent = silent
  <span class="hljs-comment">// enable strict mode for new vm</span>
  <span class="hljs-keyword">if</span> (store.strict) {
    enableStrictMode(store)
  }
  <span class="hljs-comment">// 如果存在oldVM对其进行销毁</span>
  <span class="hljs-comment">// ... </span>
}
</code></pre>
<p>刚看到这里时候可能会惊奇何时来的_vm？事实上这个_vm正是这里的核心，_vm是个Vue实例，并将<code>_vm.data.$$state</code>指向的option中的state。细心的话还可以发现在Store类中，其中的Store.state：如下</p>
<pre class="hljs"><code>get state () {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._vm._data.$$state
}
</code></pre>
<p>state返回的正是<code>_vm.data.$$state</code>，这个也就是平时所用的<code>this.$store.state</code>。观察resetStoreVM还可以发现通过遍历wrappedGetters，来将wrappedGetters中的方法通过_vm.computed的形式添加到<code>store.getters</code>里面，这么复杂的办法有什么好处呢？而且为什么只是专门处理getter，没有对mutation和action进行这样的处理？getter的方法是对state进行处理提取过滤，而computed是依赖于data的，当data更新的时候computed就自动计算，同样这里也是的，当state更新的时候，通过computed的方法，getter不就自动计算更新了吗？只是这样就有点麻烦。。。。。要新建一个Vue实例，关于_vm，更多的可以点<a href="https://github.com/vuejs/vuex/issues/849" target="_blank">这里</a></p>
<h2>commit和dispatch</h2>
<p>在介绍之前先看看前面忽略的，在installModule方法里面对mutation/getter/action等方法的添加机制。
对于registerMutation：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerMutation</span> (<span class="hljs-params">store, type, handler, local</span>) </span>{
  <span class="hljs-comment">// 内部的_mutations[type]保存对应的mutattion方法</span>
  <span class="hljs-keyword">const</span> entry = store._mutations[type] || (store._mutations[type] = [])
  entry.push(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrappedMutationHandler</span> (<span class="hljs-params">payload</span>) </span>{
    <span class="hljs-comment">// 在mutation方法里面传入local.state和payload，</span>
    <span class="hljs-comment">// wrappedMutationHandler只需要payload，符合commit时，仅需传入type和payload</span>
    handler.call(store, local.state, payload)
  })
}
</code></pre>
<p>上面方法添加了store._mutations[type]，而handler传参里面的local.state又是什么呢？回头看可以发现这里调用了makeLocalContext，生产local变量，makeLocalContext代码这里就不贴出来了。local.state就是对应path的state变量，只是是通过数据劫持的方法获得的，代码中说明getters和state对象都必须要懒加载，因为可能被vm更新影响到，这里是不是指_vm重新创建的时候造成的影响呢？由于namespaced的问题，local里面的dispatch和commit都做了特别处理，但是还是使用store的dispatch和commit的方法，只是传参做了修改。
对于registerAction，类似与mutation，采用了store._actions[type]来保存handler数组，但由于action有用于异步的情况，所以若返回的action不是Promise类型，则进行Promise包装。同时action的传参不是local.state，而是传入local的本身的所有字段和store的getters以及state，这也符合action的基本应用。
对于registerGetter，这里比较简单直接采用<code>store._wrappedGetters[type] = handler</code>的形式，而registerMutation是采用数组的形式。所以对于重复名字的getter就会有告警``[vuex] duplicate getter key: ${type}`。</p>
<p>回到commit方法和dispatch，在Store类构造的时候，有如下:</p>
<pre class="hljs"><code><span class="hljs-keyword">this</span>.dispatch = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">boundDispatch</span> (<span class="hljs-params">type, payload</span>) </span>{
  <span class="hljs-keyword">return</span> dispatch.call(store, type, payload)
}
<span class="hljs-keyword">this</span>.commit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">boundCommit</span> (<span class="hljs-params">type, payload, options</span>) </span>{
  <span class="hljs-keyword">return</span> commit.call(store, type, payload, options)
}
</code></pre>
<p>这里面定义commit方法和dispatch方法，这两个就是<code>$store.commit</code>和<code>$store.dispatch</code>，而commit这个方法处理起来也是比较简单，就是将_mutations里面对应方法名都执行一遍，并传递payload进去。同时还将_subscribers里面的函数都遍历执行。_subscribers是通过subscribe这个api添加进来:</p>
<pre class="hljs"><code>subscribe (fn) {
  <span class="hljs-keyword">const</span> subs = <span class="hljs-keyword">this</span>._subscribers
  <span class="hljs-keyword">if</span> (subs.indexOf(fn) &lt; <span class="hljs-number">0</span>) {
    subs.push(fn)
  }
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> i = subs.indexOf(fn)
    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">-1</span>) {
      subs.splice(i, <span class="hljs-number">1</span>)
    }
  }
}
</code></pre>
<p>该方法可以添加订阅函数，每当mutation执行的时候，所有订阅函数都会执行，值得一提的时候在devtool.js文件里面用到了:</p>
<pre class="hljs"><code>store.subscribe(<span class="hljs-function">(<span class="hljs-params">mutation, state</span>) =&gt;</span> {
  devtoolHook.emit(<span class="hljs-string">'vuex:mutation'</span>, mutation, state)
})
</code></pre>
<p>当使用devtoolHook的时候(这个也涉及到Vue官方推荐的浏览器插件工具Vue devtools)能在每个mutation动作结束后，触发vuex:mutation事件，并在devtools插件内打印动作
还可以看出这个subscribe设计很巧妙，subscribe直接运行是添加订阅函数，而其返回函数就是disSubscribe，就是将订阅函数去除掉，由于不常用，所以就没有直接给出api了，厉害的很。</p>
<p>dispatch该动作类似的，也是调用之前存在_actions里的handlers，只是由于handles可能有多个，并且是异步的原因，若是多个的话需要用<code>Promise.all</code>来执行；</p>
<h1>其他Api</h1>
<p>日常用的比较多的是registerModule/unregisterModule，两个过程是类似的，注册新模块的时候需要重新installModule和resetStoreVM，这个时候就会将老的_vm delete掉，重新实例化Vue给到_vm。
mapState/mapMutations/mapGetters/mapActions等api结构类似。以mapState为例子:</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mapState = normalizeNamespace(<span class="hljs-function">(<span class="hljs-params">namespace, states</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> res = {}
  normalizeMap(states).forEach(<span class="hljs-function">(<span class="hljs-params">{ key, val }</span>) =&gt;</span> {
    res[key] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mappedState</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">let</span> state = <span class="hljs-keyword">this</span>.$store.state
      <span class="hljs-keyword">let</span> getters = <span class="hljs-keyword">this</span>.$store.getters
      <span class="hljs-keyword">if</span> (namespace) {
        <span class="hljs-keyword">const</span> <span class="hljs-built_in">module</span> = getModuleByNamespace(<span class="hljs-keyword">this</span>.$store, <span class="hljs-string">'mapState'</span>, namespace)
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">return</span>
        }
        state = <span class="hljs-built_in">module</span>.context.state
        getters = <span class="hljs-built_in">module</span>.context.getters
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'function'</span>
        ? val.call(<span class="hljs-keyword">this</span>, state, getters)
        : state[val]
    }
    <span class="hljs-comment">// mark vuex getter for devtools</span>
    res[key].vuex = <span class="hljs-literal">true</span>
  })
  <span class="hljs-keyword">return</span> res
})
</code></pre>
<p>normalizeNamespace来调整参数，再通过normalizeMap将传入的state调整为<code>{ key, val: key }</code>结构，并根据情况返回。这几个api还是很容易懂的。</p>
<h1>结束</h1>
<p>一周下来写了两篇源码分析，Vuex的代码和Vue-router相比还是很良心的，没有Vue-router里面那么多弯弯绕绕，Vuex简单明了多了。</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"July 7, 2018","title":"vuex源码分析","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e前文分析了Vue-router，感觉后劲十足，于是开始分析Vuex。在项目上，Vuex也是常客。它可以很好的管理状态，尤其是跨组件的时候，Vue的单向数据流使得子组件无法修改prop，经常用$emit和$on的话组件是要多难看就多难看。当组件切换，数据需要缓存总不能一直依赖于向上级组件emit传递数据吧？如果要更好的管理状态，Vuex是个很好的选择。Vuex代码量较Vue-router少了很多，而且也没有flow的校验机制，看起来更加习惯了。这里介绍的Vuex版本号为2.4.1。\u003c/p\u003e\n\u003ch1\u003e从示例开始\u003c/h1\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eVue.use(Vuex)\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e state = {\n  \u003cspan class=\"hljs-attr\"\u003ecount\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e mutations = {\n  increment (state) {\n    state.count++\n  },\n  decrement (state) {\n    state.count--\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e actions = {\n  \u003cspan class=\"hljs-attr\"\u003eincrement\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ commit }\u003c/span\u003e) =\u0026gt;\u003c/span\u003e commit(\u003cspan class=\"hljs-string\"\u003e'increment'\u003c/span\u003e),\n  \u003cspan class=\"hljs-attr\"\u003edecrement\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ commit }\u003c/span\u003e) =\u0026gt;\u003c/span\u003e commit(\u003cspan class=\"hljs-string\"\u003e'decrement'\u003c/span\u003e),\n}\n\u003cspan class=\"hljs-comment\"\u003e// getters are functions\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e getters = {\n  \u003cspan class=\"hljs-attr\"\u003eevenOrOdd\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003estate\u003c/span\u003e =\u0026gt;\u003c/span\u003e state.count % \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e ? \u003cspan class=\"hljs-string\"\u003e'even'\u003c/span\u003e : \u003cspan class=\"hljs-string\"\u003e'odd'\u003c/span\u003e\n}\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Vuex.Store({\n  state,\n  getters,\n  actions,\n  mutations,\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面示例基本上包含了最常用的mutations，getters和actions了。可以发现这一切从Vue.use(Vuex)开始的，对Vue.use不熟悉的可以看上一篇的Vuex-router中对Vue.use的介绍。\nVuex中用到了install方法来提供Vuex的使用环境。和Vue-router不同，Vuex的主要代码功能都在store.js文件里面(这对查阅代码友好度明显提到了不少)。install过程里面用到了Vue.mixin，并用到了beforeCreate钩子，使得Vue实例化和组件加载的时候都可以调用到钩子。设计如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e version = \u003cspan class=\"hljs-built_in\"\u003eNumber\u003c/span\u003e(Vue.version.split(\u003cspan class=\"hljs-string\"\u003e'.'\u003c/span\u003e)[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e])\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (version \u0026gt;= \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) {\n  Vue.mixin({ \u003cspan class=\"hljs-attr\"\u003ebeforeCreate\u003c/span\u003e: vuexInit })\n} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e _init = Vue.prototype._init\n  Vue.prototype._init = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eoptions = {}\u003c/span\u003e) \u003c/span\u003e{\n    options.init = options.init\n      ? [vuexInit].concat(options.init)\n      : vuexInit\n    _init.call(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, options)\n  }\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003evuexInit\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e options = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$options\n  \u003cspan class=\"hljs-comment\"\u003e// store injection\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (options.store) {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$store = \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e options.store === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e\n      ? options.store()\n      : options.store\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (options.parent \u0026amp;\u0026amp; options.parent.$store) {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$store = options.parent.$store\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到这里对Vue的版本分别做了处理，本版是2.0.0及以上的都会采用Vue.mixin的方法，而低版本的，则将修改Vue的内部_init方法，来添加$store至根。高级别的版本则采用mixin的方法，同样也是添加\u003ccode\u003ethis.$store\u003c/code\u003e。在Vue-router里面是采用数据劫持的方法，来通知更新，顺便提供this.$router，对于状态管理而言，数据劫持显然是不需要的，仅仅提供入口\u003ccode\u003ethis.$store\u003c/code\u003e就够了，这样为全局提供了访问store对象的方法，可以轻松得使用\u003ccode\u003ethis.$store.commit, this.$store.state\u003c/code\u003e之类的方法。\u003c/p\u003e\n\u003ch1\u003eStore\u003c/h1\u003e\n\u003cp\u003eStore.js里面最主要的就是Store类，这个也是之前提到的\u003ccode\u003ethis.$store\u003c/code\u003e对象。先看看constructor方法：\n在构造里面先判断有无使用install方法，没有则intall一下，接着是断言有无安装Vue，是否支持Promise和是否是通过new创建Store的实例。另外在install过程里面还有是否重复安装Vuex的断言，这个场景会发生在已经先使用Vuex了，但是没有用\u003ccode\u003eVue.use(Vuex)\u003c/code\u003e来显式安装Vuex，如果再加上\u003ccode\u003eVue.use(Vuex)\u003c/code\u003e就会有这样的提示，尤其是在开发环境和生产环境配置中。\nStore初始化过程，有\u003ccode\u003ethis._modules = new ModuleCollection(options)\u003c/code\u003e，这个_modules就是Store集合的意思了。Vuex有modules的概念，允许对store进行分割形成不同的模块，每个模块都可以有自己的state，getter，mutation和action，甚至还可以嵌套子模块。于是将这些模块包括根模块一起放入modules里面。this._modules的一个重要api就是注册添加一个模块：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eregister (path, rawModule, runtime = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (process.env.NODE_ENV !== \u003cspan class=\"hljs-string\"\u003e'production'\u003c/span\u003e) {\n    assertRawModule(path, rawModule)\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newModule = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Module(rawModule, runtime)\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (path.length === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.root = newModule\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e parent = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.get(path.slice(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e))\n    parent.addChild(path[path.length - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], newModule)\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// register nested modules\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (rawModule.modules) {\n    forEachValue(rawModule.modules, (rawChildModule, key) =\u0026gt; {\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.register(path.concat(key), rawChildModule, runtime)\n    })\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里还可以看到this._modules.root就是根模块，并且对于子模块的，还会被添加到父模块parent的_children对象里面；到这里可以发现this.modules.root和原先的store很像，只是单独分离出state，并且将子模块改为了_children关系，并将_rawMoudule赋值为整个传过来模块，同时为this._modules和每个module都添加不少方法，这些方法自然是为后面做准备的。\n在谈commit和dispatch方法之前，先看看后面的模块安装和StoreVM的设置\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003einstallModule(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, state, [], \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._modules.root)\nresetStoreVM(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, state)\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003einstallModule\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003estore, rootState, path, module, hot\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isRoot = !path.length\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e namespace = store._modules.getNamespace(path)\n  \u003cspan class=\"hljs-comment\"\u003e// 命名空间字典的添加\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.namespaced) {\n    store._modulesNamespaceMap[namespace] = \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 设置state\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isRoot \u0026amp;\u0026amp; !hot) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e parentState = getNestedState(rootState, path.slice(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e))\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e moduleName = path[path.length - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n    store._withCommit(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n      Vue.set(parentState, moduleName, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.state)\n    })\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e local = \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.context = makeLocalContext(store, namespace, path)\n  \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.forEachMutation(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003emutation, key\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e namespacedType = namespace + key\n    registerMutation(store, namespacedType, mutation, local)\n  })\n  \u003cspan class=\"hljs-comment\"\u003e// 下面省略部分是通过module提供的方法分别对action和getter进行registe\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 以及对子模块modules的遍历式得注册mutation/action/getter\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于modules而言，\u003ca href=\"https://vuex.vuejs.org/zh-cn/modules.html\" target=\"_blank\"\u003e官方文档\u003c/a\u003e有介绍到，模块内部的 action，mutation和getter是注册在全局命名空间的，如果想要独立的空间，比如有命名重复的情况下，可以使用\u003ccode\u003enamespaced: true\u003c/code\u003e来注册单独的空间；同时访问的时候也也要加上模块的名字，否则否则无法定位到。\n接着看state的设置，对于if条件语句，若是子模块并且非hot，会获取子模块的亲父级模块，并通过Vue.set方法将该子模块的state添加到亲父模块state里面，这是响应式的，会被Vue劫持到。后面部分就是对action/getter/mutation的注册添加了，这部分后面在讲。\u003c/p\u003e\n\u003cp\u003e后面是resetStoreVM：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eresetStoreVM\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003estore, state, hot\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e oldVm = store._vm\n  \u003cspan class=\"hljs-comment\"\u003e// bind store public getters\u003c/span\u003e\n  store.getters = {}\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e wrappedGetters = store._wrappedGetters\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e computed = {}\n  forEachValue(wrappedGetters, (fn, key) =\u0026gt; {\n    \u003cspan class=\"hljs-comment\"\u003e// use computed to leverage its lazy-caching mechanism\u003c/span\u003e\n    computed[key] = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e fn(store)\n    \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.defineProperty(store.getters, key, {\n      \u003cspan class=\"hljs-attr\"\u003eget\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e store._vm[key],\n      \u003cspan class=\"hljs-attr\"\u003eenumerable\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// for local getters\u003c/span\u003e\n    })\n  })\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e silent = Vue.config.silent\n  Vue.config.silent = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n  store._vm = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Vue({\n    \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003e$$state\u003c/span\u003e: state\n    },\n    computed\n  })\n  Vue.config.silent = silent\n  \u003cspan class=\"hljs-comment\"\u003e// enable strict mode for new vm\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (store.strict) {\n    enableStrictMode(store)\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 如果存在oldVM对其进行销毁\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// ... \u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e刚看到这里时候可能会惊奇何时来的_vm？事实上这个_vm正是这里的核心，_vm是个Vue实例，并将\u003ccode\u003e_vm.data.$$state\u003c/code\u003e指向的option中的state。细心的话还可以发现在Store类中，其中的Store.state：如下\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eget state () {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._vm._data.$$state\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003estate返回的正是\u003ccode\u003e_vm.data.$$state\u003c/code\u003e，这个也就是平时所用的\u003ccode\u003ethis.$store.state\u003c/code\u003e。观察resetStoreVM还可以发现通过遍历wrappedGetters，来将wrappedGetters中的方法通过_vm.computed的形式添加到\u003ccode\u003estore.getters\u003c/code\u003e里面，这么复杂的办法有什么好处呢？而且为什么只是专门处理getter，没有对mutation和action进行这样的处理？getter的方法是对state进行处理提取过滤，而computed是依赖于data的，当data更新的时候computed就自动计算，同样这里也是的，当state更新的时候，通过computed的方法，getter不就自动计算更新了吗？只是这样就有点麻烦。。。。。要新建一个Vue实例，关于_vm，更多的可以点\u003ca href=\"https://github.com/vuejs/vuex/issues/849\" target=\"_blank\"\u003e这里\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003ecommit和dispatch\u003c/h2\u003e\n\u003cp\u003e在介绍之前先看看前面忽略的，在installModule方法里面对mutation/getter/action等方法的添加机制。\n对于registerMutation：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eregisterMutation\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003estore, type, handler, local\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 内部的_mutations[type]保存对应的mutattion方法\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e entry = store._mutations[type] || (store._mutations[type] = [])\n  entry.push(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ewrappedMutationHandler\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003epayload\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e// 在mutation方法里面传入local.state和payload，\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// wrappedMutationHandler只需要payload，符合commit时，仅需传入type和payload\u003c/span\u003e\n    handler.call(store, local.state, payload)\n  })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面方法添加了store._mutations[type]，而handler传参里面的local.state又是什么呢？回头看可以发现这里调用了makeLocalContext，生产local变量，makeLocalContext代码这里就不贴出来了。local.state就是对应path的state变量，只是是通过数据劫持的方法获得的，代码中说明getters和state对象都必须要懒加载，因为可能被vm更新影响到，这里是不是指_vm重新创建的时候造成的影响呢？由于namespaced的问题，local里面的dispatch和commit都做了特别处理，但是还是使用store的dispatch和commit的方法，只是传参做了修改。\n对于registerAction，类似与mutation，采用了store._actions[type]来保存handler数组，但由于action有用于异步的情况，所以若返回的action不是Promise类型，则进行Promise包装。同时action的传参不是local.state，而是传入local的本身的所有字段和store的getters以及state，这也符合action的基本应用。\n对于registerGetter，这里比较简单直接采用\u003ccode\u003estore._wrappedGetters[type] = handler\u003c/code\u003e的形式，而registerMutation是采用数组的形式。所以对于重复名字的getter就会有告警``[vuex] duplicate getter key: ${type}`。\u003c/p\u003e\n\u003cp\u003e回到commit方法和dispatch，在Store类构造的时候，有如下:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.dispatch = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eboundDispatch\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003etype, payload\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e dispatch.call(store, type, payload)\n}\n\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.commit = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eboundCommit\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003etype, payload, options\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e commit.call(store, type, payload, options)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里面定义commit方法和dispatch方法，这两个就是\u003ccode\u003e$store.commit\u003c/code\u003e和\u003ccode\u003e$store.dispatch\u003c/code\u003e，而commit这个方法处理起来也是比较简单，就是将_mutations里面对应方法名都执行一遍，并传递payload进去。同时还将_subscribers里面的函数都遍历执行。_subscribers是通过subscribe这个api添加进来:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003esubscribe (fn) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e subs = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._subscribers\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (subs.indexOf(fn) \u0026lt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    subs.push(fn)\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e i = subs.indexOf(fn)\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (i \u0026gt; \u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e) {\n      subs.splice(i, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e该方法可以添加订阅函数，每当mutation执行的时候，所有订阅函数都会执行，值得一提的时候在devtool.js文件里面用到了:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003estore.subscribe(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003emutation, state\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  devtoolHook.emit(\u003cspan class=\"hljs-string\"\u003e'vuex:mutation'\u003c/span\u003e, mutation, state)\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当使用devtoolHook的时候(这个也涉及到Vue官方推荐的浏览器插件工具Vue devtools)能在每个mutation动作结束后，触发vuex:mutation事件，并在devtools插件内打印动作\n还可以看出这个subscribe设计很巧妙，subscribe直接运行是添加订阅函数，而其返回函数就是disSubscribe，就是将订阅函数去除掉，由于不常用，所以就没有直接给出api了，厉害的很。\u003c/p\u003e\n\u003cp\u003edispatch该动作类似的，也是调用之前存在_actions里的handlers，只是由于handles可能有多个，并且是异步的原因，若是多个的话需要用\u003ccode\u003ePromise.all\u003c/code\u003e来执行；\u003c/p\u003e\n\u003ch1\u003e其他Api\u003c/h1\u003e\n\u003cp\u003e日常用的比较多的是registerModule/unregisterModule，两个过程是类似的，注册新模块的时候需要重新installModule和resetStoreVM，这个时候就会将老的_vm delete掉，重新实例化Vue给到_vm。\nmapState/mapMutations/mapGetters/mapActions等api结构类似。以mapState为例子:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e mapState = normalizeNamespace(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003enamespace, states\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e res = {}\n  normalizeMap(states).forEach(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ key, val }\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    res[key] = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emappedState\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e state = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$store.state\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e getters = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$store.getters\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (namespace) {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e = getModuleByNamespace(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$store, \u003cspan class=\"hljs-string\"\u003e'mapState'\u003c/span\u003e, namespace)\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e) {\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n        }\n        state = \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.context.state\n        getters = \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.context.getters\n      }\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e val === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e\n        ? val.call(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, state, getters)\n        : state[val]\n    }\n    \u003cspan class=\"hljs-comment\"\u003e// mark vuex getter for devtools\u003c/span\u003e\n    res[key].vuex = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n  })\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003enormalizeNamespace来调整参数，再通过normalizeMap将传入的state调整为\u003ccode\u003e{ key, val: key }\u003c/code\u003e结构，并根据情况返回。这几个api还是很容易懂的。\u003c/p\u003e\n\u003ch1\u003e结束\u003c/h1\u003e\n\u003cp\u003e一周下来写了两篇源码分析，Vuex的代码和Vue-router相比还是很良心的，没有Vue-router里面那么多弯弯绕绕，Vuex简单明了多了。\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"July 7, 2018","title":"vuex源码分析","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e前文分析了Vue-router，感觉后劲十足，于是开始分析Vuex。在项目上，Vuex也是常客。它可以很好的管理状态，尤其是跨组件的时候，Vue的单向数据流使得子组件无法修改prop，经常用$emit和$on的话组件是要多难看就多难看。当组件切换，数据需要缓存总不能一直依赖于向上级组件emit传递数据吧？如果要更好的管理状态，Vuex是个很好的选择。Vuex代码量较Vue-router少了很多，而且也没有flow的校验机制，看起来更加习惯了。这里介绍的Vuex版本号为2.4.1。\u003c/p\u003e\n\u003ch1\u003e从示例开始\u003c/h1\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eVue.use(Vuex)\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e state = {\n  \u003cspan class=\"hljs-attr\"\u003ecount\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e mutations = {\n  increment (state) {\n    state.count++\n  },\n  decrement (state) {\n    state.count--\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e actions = {\n  \u003cspan class=\"hljs-attr\"\u003eincrement\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ commit }\u003c/span\u003e) =\u0026gt;\u003c/span\u003e commit(\u003cspan class=\"hljs-string\"\u003e'increment'\u003c/span\u003e),\n  \u003cspan class=\"hljs-attr\"\u003edecrement\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ commit }\u003c/span\u003e) =\u0026gt;\u003c/span\u003e commit(\u003cspan class=\"hljs-string\"\u003e'decrement'\u003c/span\u003e),\n}\n\u003cspan class=\"hljs-comment\"\u003e// getters are functions\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e getters = {\n  \u003cspan class=\"hljs-attr\"\u003eevenOrOdd\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003estate\u003c/span\u003e =\u0026gt;\u003c/span\u003e state.count % \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e ? \u003cspan class=\"hljs-string\"\u003e'even'\u003c/span\u003e : \u003cspan class=\"hljs-string\"\u003e'odd'\u003c/span\u003e\n}\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Vuex.Store({\n  state,\n  getters,\n  actions,\n  mutations,\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面示例基本上包含了最常用的mutations，getters和actions了。可以发现这一切从Vue.use(Vuex)开始的，对Vue.use不熟悉的可以看上一篇的Vuex-router中对Vue.use的介绍。\nVuex中用到了install方法来提供Vuex的使用环境。和Vue-router不同，Vuex的主要代码功能都在store.js文件里面(这对查阅代码友好度明显提到了不少)。install过程里面用到了Vue.mixin，并用到了beforeCreate钩子，使得Vue实例化和组件加载的时候都可以调用到钩子。设计如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e version = \u003cspan class=\"hljs-built_in\"\u003eNumber\u003c/span\u003e(Vue.version.split(\u003cspan class=\"hljs-string\"\u003e'.'\u003c/span\u003e)[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e])\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (version \u0026gt;= \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) {\n  Vue.mixin({ \u003cspan class=\"hljs-attr\"\u003ebeforeCreate\u003c/span\u003e: vuexInit })\n} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e _init = Vue.prototype._init\n  Vue.prototype._init = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eoptions = {}\u003c/span\u003e) \u003c/span\u003e{\n    options.init = options.init\n      ? [vuexInit].concat(options.init)\n      : vuexInit\n    _init.call(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, options)\n  }\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003evuexInit\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e options = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$options\n  \u003cspan class=\"hljs-comment\"\u003e// store injection\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (options.store) {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$store = \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e options.store === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e\n      ? options.store()\n      : options.store\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (options.parent \u0026amp;\u0026amp; options.parent.$store) {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$store = options.parent.$store\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到这里对Vue的版本分别做了处理，本版是2.0.0及以上的都会采用Vue.mixin的方法，而低版本的，则将修改Vue的内部_init方法，来添加$store至根。高级别的版本则采用mixin的方法，同样也是添加\u003ccode\u003ethis.$store\u003c/code\u003e。在Vue-router里面是采用数据劫持的方法，来通知更新，顺便提供this.$router，对于状态管理而言，数据劫持显然是不需要的，仅仅提供入口\u003ccode\u003ethis.$store\u003c/code\u003e就够了，这样为全局提供了访问store对象的方法，可以轻松得使用\u003ccode\u003ethis.$store.commit, this.$store.state\u003c/code\u003e之类的方法。\u003c/p\u003e\n\u003ch1\u003eStore\u003c/h1\u003e\n\u003cp\u003eStore.js里面最主要的就是Store类，这个也是之前提到的\u003ccode\u003ethis.$store\u003c/code\u003e对象。先看看constructor方法：\n在构造里面先判断有无使用install方法，没有则intall一下，接着是断言有无安装Vue，是否支持Promise和是否是通过new创建Store的实例。另外在install过程里面还有是否重复安装Vuex的断言，这个场景会发生在已经先使用Vuex了，但是没有用\u003ccode\u003eVue.use(Vuex)\u003c/code\u003e来显式安装Vuex，如果再加上\u003ccode\u003eVue.use(Vuex)\u003c/code\u003e就会有这样的提示，尤其是在开发环境和生产环境配置中。\nStore初始化过程，有\u003ccode\u003ethis._modules = new ModuleCollection(options)\u003c/code\u003e，这个_modules就是Store集合的意思了。Vuex有modules的概念，允许对store进行分割形成不同的模块，每个模块都可以有自己的state，getter，mutation和action，甚至还可以嵌套子模块。于是将这些模块包括根模块一起放入modules里面。this._modules的一个重要api就是注册添加一个模块：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eregister (path, rawModule, runtime = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (process.env.NODE_ENV !== \u003cspan class=\"hljs-string\"\u003e'production'\u003c/span\u003e) {\n    assertRawModule(path, rawModule)\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newModule = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Module(rawModule, runtime)\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (path.length === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.root = newModule\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e parent = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.get(path.slice(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e))\n    parent.addChild(path[path.length - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], newModule)\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// register nested modules\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (rawModule.modules) {\n    forEachValue(rawModule.modules, (rawChildModule, key) =\u0026gt; {\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.register(path.concat(key), rawChildModule, runtime)\n    })\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里还可以看到this._modules.root就是根模块，并且对于子模块的，还会被添加到父模块parent的_children对象里面；到这里可以发现this.modules.root和原先的store很像，只是单独分离出state，并且将子模块改为了_children关系，并将_rawMoudule赋值为整个传过来模块，同时为this._modules和每个module都添加不少方法，这些方法自然是为后面做准备的。\n在谈commit和dispatch方法之前，先看看后面的模块安装和StoreVM的设置\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003einstallModule(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, state, [], \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._modules.root)\nresetStoreVM(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, state)\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003einstallModule\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003estore, rootState, path, module, hot\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isRoot = !path.length\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e namespace = store._modules.getNamespace(path)\n  \u003cspan class=\"hljs-comment\"\u003e// 命名空间字典的添加\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.namespaced) {\n    store._modulesNamespaceMap[namespace] = \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 设置state\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isRoot \u0026amp;\u0026amp; !hot) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e parentState = getNestedState(rootState, path.slice(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e))\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e moduleName = path[path.length - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n    store._withCommit(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n      Vue.set(parentState, moduleName, \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.state)\n    })\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e local = \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.context = makeLocalContext(store, namespace, path)\n  \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.forEachMutation(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003emutation, key\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e namespacedType = namespace + key\n    registerMutation(store, namespacedType, mutation, local)\n  })\n  \u003cspan class=\"hljs-comment\"\u003e// 下面省略部分是通过module提供的方法分别对action和getter进行registe\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 以及对子模块modules的遍历式得注册mutation/action/getter\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于modules而言，\u003ca href=\"https://vuex.vuejs.org/zh-cn/modules.html\" target=\"_blank\"\u003e官方文档\u003c/a\u003e有介绍到，模块内部的 action，mutation和getter是注册在全局命名空间的，如果想要独立的空间，比如有命名重复的情况下，可以使用\u003ccode\u003enamespaced: true\u003c/code\u003e来注册单独的空间；同时访问的时候也也要加上模块的名字，否则否则无法定位到。\n接着看state的设置，对于if条件语句，若是子模块并且非hot，会获取子模块的亲父级模块，并通过Vue.set方法将该子模块的state添加到亲父模块state里面，这是响应式的，会被Vue劫持到。后面部分就是对action/getter/mutation的注册添加了，这部分后面在讲。\u003c/p\u003e\n\u003cp\u003e后面是resetStoreVM：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eresetStoreVM\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003estore, state, hot\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e oldVm = store._vm\n  \u003cspan class=\"hljs-comment\"\u003e// bind store public getters\u003c/span\u003e\n  store.getters = {}\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e wrappedGetters = store._wrappedGetters\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e computed = {}\n  forEachValue(wrappedGetters, (fn, key) =\u0026gt; {\n    \u003cspan class=\"hljs-comment\"\u003e// use computed to leverage its lazy-caching mechanism\u003c/span\u003e\n    computed[key] = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e fn(store)\n    \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.defineProperty(store.getters, key, {\n      \u003cspan class=\"hljs-attr\"\u003eget\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e store._vm[key],\n      \u003cspan class=\"hljs-attr\"\u003eenumerable\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// for local getters\u003c/span\u003e\n    })\n  })\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e silent = Vue.config.silent\n  Vue.config.silent = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n  store._vm = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Vue({\n    \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003e$$state\u003c/span\u003e: state\n    },\n    computed\n  })\n  Vue.config.silent = silent\n  \u003cspan class=\"hljs-comment\"\u003e// enable strict mode for new vm\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (store.strict) {\n    enableStrictMode(store)\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 如果存在oldVM对其进行销毁\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// ... \u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e刚看到这里时候可能会惊奇何时来的_vm？事实上这个_vm正是这里的核心，_vm是个Vue实例，并将\u003ccode\u003e_vm.data.$$state\u003c/code\u003e指向的option中的state。细心的话还可以发现在Store类中，其中的Store.state：如下\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eget state () {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._vm._data.$$state\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003estate返回的正是\u003ccode\u003e_vm.data.$$state\u003c/code\u003e，这个也就是平时所用的\u003ccode\u003ethis.$store.state\u003c/code\u003e。观察resetStoreVM还可以发现通过遍历wrappedGetters，来将wrappedGetters中的方法通过_vm.computed的形式添加到\u003ccode\u003estore.getters\u003c/code\u003e里面，这么复杂的办法有什么好处呢？而且为什么只是专门处理getter，没有对mutation和action进行这样的处理？getter的方法是对state进行处理提取过滤，而computed是依赖于data的，当data更新的时候computed就自动计算，同样这里也是的，当state更新的时候，通过computed的方法，getter不就自动计算更新了吗？只是这样就有点麻烦。。。。。要新建一个Vue实例，关于_vm，更多的可以点\u003ca href=\"https://github.com/vuejs/vuex/issues/849\" target=\"_blank\"\u003e这里\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003ecommit和dispatch\u003c/h2\u003e\n\u003cp\u003e在介绍之前先看看前面忽略的，在installModule方法里面对mutation/getter/action等方法的添加机制。\n对于registerMutation：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eregisterMutation\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003estore, type, handler, local\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 内部的_mutations[type]保存对应的mutattion方法\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e entry = store._mutations[type] || (store._mutations[type] = [])\n  entry.push(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ewrappedMutationHandler\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003epayload\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e// 在mutation方法里面传入local.state和payload，\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// wrappedMutationHandler只需要payload，符合commit时，仅需传入type和payload\u003c/span\u003e\n    handler.call(store, local.state, payload)\n  })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面方法添加了store._mutations[type]，而handler传参里面的local.state又是什么呢？回头看可以发现这里调用了makeLocalContext，生产local变量，makeLocalContext代码这里就不贴出来了。local.state就是对应path的state变量，只是是通过数据劫持的方法获得的，代码中说明getters和state对象都必须要懒加载，因为可能被vm更新影响到，这里是不是指_vm重新创建的时候造成的影响呢？由于namespaced的问题，local里面的dispatch和commit都做了特别处理，但是还是使用store的dispatch和commit的方法，只是传参做了修改。\n对于registerAction，类似与mutation，采用了store._actions[type]来保存handler数组，但由于action有用于异步的情况，所以若返回的action不是Promise类型，则进行Promise包装。同时action的传参不是local.state，而是传入local的本身的所有字段和store的getters以及state，这也符合action的基本应用。\n对于registerGetter，这里比较简单直接采用\u003ccode\u003estore._wrappedGetters[type] = handler\u003c/code\u003e的形式，而registerMutation是采用数组的形式。所以对于重复名字的getter就会有告警``[vuex] duplicate getter key: ${type}`。\u003c/p\u003e\n\u003cp\u003e回到commit方法和dispatch，在Store类构造的时候，有如下:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.dispatch = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eboundDispatch\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003etype, payload\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e dispatch.call(store, type, payload)\n}\n\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.commit = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eboundCommit\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003etype, payload, options\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e commit.call(store, type, payload, options)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里面定义commit方法和dispatch方法，这两个就是\u003ccode\u003e$store.commit\u003c/code\u003e和\u003ccode\u003e$store.dispatch\u003c/code\u003e，而commit这个方法处理起来也是比较简单，就是将_mutations里面对应方法名都执行一遍，并传递payload进去。同时还将_subscribers里面的函数都遍历执行。_subscribers是通过subscribe这个api添加进来:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003esubscribe (fn) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e subs = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._subscribers\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (subs.indexOf(fn) \u0026lt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    subs.push(fn)\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e i = subs.indexOf(fn)\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (i \u0026gt; \u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e) {\n      subs.splice(i, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e该方法可以添加订阅函数，每当mutation执行的时候，所有订阅函数都会执行，值得一提的时候在devtool.js文件里面用到了:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003estore.subscribe(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003emutation, state\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  devtoolHook.emit(\u003cspan class=\"hljs-string\"\u003e'vuex:mutation'\u003c/span\u003e, mutation, state)\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当使用devtoolHook的时候(这个也涉及到Vue官方推荐的浏览器插件工具Vue devtools)能在每个mutation动作结束后，触发vuex:mutation事件，并在devtools插件内打印动作\n还可以看出这个subscribe设计很巧妙，subscribe直接运行是添加订阅函数，而其返回函数就是disSubscribe，就是将订阅函数去除掉，由于不常用，所以就没有直接给出api了，厉害的很。\u003c/p\u003e\n\u003cp\u003edispatch该动作类似的，也是调用之前存在_actions里的handlers，只是由于handles可能有多个，并且是异步的原因，若是多个的话需要用\u003ccode\u003ePromise.all\u003c/code\u003e来执行；\u003c/p\u003e\n\u003ch1\u003e其他Api\u003c/h1\u003e\n\u003cp\u003e日常用的比较多的是registerModule/unregisterModule，两个过程是类似的，注册新模块的时候需要重新installModule和resetStoreVM，这个时候就会将老的_vm delete掉，重新实例化Vue给到_vm。\nmapState/mapMutations/mapGetters/mapActions等api结构类似。以mapState为例子:\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e mapState = normalizeNamespace(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003enamespace, states\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e res = {}\n  normalizeMap(states).forEach(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ key, val }\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    res[key] = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emappedState\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e state = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$store.state\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e getters = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$store.getters\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (namespace) {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e = getModuleByNamespace(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.$store, \u003cspan class=\"hljs-string\"\u003e'mapState'\u003c/span\u003e, namespace)\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e) {\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n        }\n        state = \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.context.state\n        getters = \u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.context.getters\n      }\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e val === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e\n        ? val.call(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, state, getters)\n        : state[val]\n    }\n    \u003cspan class=\"hljs-comment\"\u003e// mark vuex getter for devtools\u003c/span\u003e\n    res[key].vuex = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n  })\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003enormalizeNamespace来调整参数，再通过normalizeMap将传入的state调整为\u003ccode\u003e{ key, val: key }\u003c/code\u003e结构，并根据情况返回。这几个api还是很容易懂的。\u003c/p\u003e\n\u003ch1\u003e结束\u003c/h1\u003e\n\u003cp\u003e一周下来写了两篇源码分析，Vuex的代码和Vue-router相比还是很良心的，没有Vue-router里面那么多弯弯绕绕，Vuex简单明了多了。\u003c/p\u003e\n"}},"buildId":"_P3qZyp8~kfTSPLoPskhF","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/_P3qZyp8~kfTSPLoPskhF/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/_P3qZyp8~kfTSPLoPskhF/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/_P3qZyp8~kfTSPLoPskhF/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" async=""></script></body></html>