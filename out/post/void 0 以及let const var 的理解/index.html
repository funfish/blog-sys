<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">void 0 以及let const var 的理解</title><link rel="preload" href="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.ce3e8fb7a689beb447ad.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.8d98f9151bcde6fb2a87.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-45be5a1f94c3fe5df8ee.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.bb30b296.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___3Hk0c "><a class="logo___1KD30" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___1qXLb" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___3VKNp"><h1 class="postTitle___26vXM">void 0 以及let const var 的理解</h1><span class="postTime___16Ish">July 7, 2018</span></header><article class="postWrapper___3NXol post-article"><div><h1>void 0</h1>
<p>最近在backbone的源码(两年前就研究过underscore的源码，现在才看backbone是不是有点那个)，发现里面用到了void 0，这是什么鬼？void居然出现在JavaScript里面，敢情以前用的ES是假的....这么基础的东西，瞟一眼MDN文档，还果然有:</p>
<blockquote>
<p>void: 运算符 对给定的表达式进行求值，然后返回 undefined。</p>
</blockquote>
<p>So, void 0就是返回undefined了，这不是多此一举？直接用undefined来判断，不就完事了，何必用上void 0，这种云里雾里的操作？
原来在早期的ECMAscript里面，undefined不是关键字，也就是说undefined是可以被修改的，如</p>
<pre class="hljs"><code>var undefined = 1;
</code></pre>
<p>这样再用undefined判断某个变量，是不是就懵逼了？而void却是关键字，从这个角度出发void 0很有使用的必要，幸好从ES5开始(IE8+)就只把undefined当作一个全局只读的值，不能进行修改，修改了当然就报错咯。
在backbone的issue里面也有人提到了void 0的<a href="https://github.com/jashkenas/backbone/pull/2960" target="_blank">问题</a>，里面提到了void 0的运算速度比undefined更优，只是我在IE9+以上还有chrome上面测得的值都是十分接近的，所以性能不是需要关注，后面还提到void 0的字符要比undefined少，这好处之一，也是为什么我们不用void 1000, void 'hellow world'而是用void 0 的原因，这对主流大型框架还是很有意义的。只是普通的工程就木有必要了</p>
<h1>let，const和var</h1>
<p>上周在chrome的控制台里面无意写了let a = sd，sd是没有声明的变量，所以回车后马上报错，而后面我再次声明let a的时候，又报错显示a已经声明了，于是我再直接在控制台敲 a 回车，结果报错显示a没有声明，这是在赤裸裸的耍我吗？问同事也是一脸懵逼+神奇的样子，后来也就没有管了，毕竟用没有声明过带的变量赋值给其他变量本来就是有问题的，更不要提后面的情况了。
故事应该到这里就截止了，可是昨天，同事给我发了个<a href="https://www.zhihu.com/question/62966713/answer/204487664" target="_blank">链接</a>，这是何其相似，这个实用性不大的问题上，居然还有人花了了两个月的时间，蛋疼的很。于是打开方应杭的介绍(链接在上面自己找)，发现里面的重点在于 Rick Waldron的一段话：</p>
<blockquote>
<p>In JavaScript, all binding declarations are instantiated when control flow enters the scope in which they appear. Legacy var and function declarations allow access to those bindings before the actual declaration, with a &quot;value&quot; of undefined. That legacy behavior is known as &quot;hoisting&quot;. let and const binding declarations are also instantiated when control flow enters the scope in which they appear, with access prevented until the actual declaration is reached; this is called the Temporal Dead Zone. The TDZ exists to prevent the sort of bugs that legacy hoisting can create.</p>
</blockquote>
<p>var的使用存在变量提升，而let/const是不存在变量提升的，控制语句到let/const时，声明会被实例化(instantiated )，但是在执行前禁止访问，不像var和function会先是被赋予undefined，后者称为变量提升，而前者变量提升却是不一样的，也由此生成了死区，就是变量必须在let声明语句后使用；这点其实在阮一峰老师的<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank">ECMAscript 6</a>已经介绍到了，只是没有提及死区形成原因；
回顾前文提到的问题就很简单了，对于let a = sd a变量会在语句执行前实例化，而执行let a = sd的时候，自然报错，同时由于a已经实例化了，不能再次 let a(还得看是什么浏览器。。。。。。)，并且由于a 初始化失败，而在实例化后到初始化这段过程里面，a处于死区中，是无法访问的(acess prevented)，所以不能对a有其他操作。
下文在引用ECMAscript的一段话:</p>
<blockquote>
<p>The variables are created when their containing Lexical Environment is instantiated but may not be accessed in any way until the variable's LexicalBinding is evaluated.
A variable defined by a LexicalBinding with an Initializer is assigned the value of its Initializer's AssignmentExpression when the LexicalBinding is evaluated, not when the variable is created</p>
</blockquote>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"July 7, 2018","title":"void 0 以及let const var 的理解","content":"\u003ch1\u003evoid 0\u003c/h1\u003e\n\u003cp\u003e最近在backbone的源码(两年前就研究过underscore的源码，现在才看backbone是不是有点那个)，发现里面用到了void 0，这是什么鬼？void居然出现在JavaScript里面，敢情以前用的ES是假的....这么基础的东西，瞟一眼MDN文档，还果然有:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003evoid: 运算符 对给定的表达式进行求值，然后返回 undefined。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eSo, void 0就是返回undefined了，这不是多此一举？直接用undefined来判断，不就完事了，何必用上void 0，这种云里雾里的操作？\n原来在早期的ECMAscript里面，undefined不是关键字，也就是说undefined是可以被修改的，如\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003evar undefined = 1;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样再用undefined判断某个变量，是不是就懵逼了？而void却是关键字，从这个角度出发void 0很有使用的必要，幸好从ES5开始(IE8+)就只把undefined当作一个全局只读的值，不能进行修改，修改了当然就报错咯。\n在backbone的issue里面也有人提到了void 0的\u003ca href=\"https://github.com/jashkenas/backbone/pull/2960\" target=\"_blank\"\u003e问题\u003c/a\u003e，里面提到了void 0的运算速度比undefined更优，只是我在IE9+以上还有chrome上面测得的值都是十分接近的，所以性能不是需要关注，后面还提到void 0的字符要比undefined少，这好处之一，也是为什么我们不用void 1000, void 'hellow world'而是用void 0 的原因，这对主流大型框架还是很有意义的。只是普通的工程就木有必要了\u003c/p\u003e\n\u003ch1\u003elet，const和var\u003c/h1\u003e\n\u003cp\u003e上周在chrome的控制台里面无意写了let a = sd，sd是没有声明的变量，所以回车后马上报错，而后面我再次声明let a的时候，又报错显示a已经声明了，于是我再直接在控制台敲 a 回车，结果报错显示a没有声明，这是在赤裸裸的耍我吗？问同事也是一脸懵逼+神奇的样子，后来也就没有管了，毕竟用没有声明过带的变量赋值给其他变量本来就是有问题的，更不要提后面的情况了。\n故事应该到这里就截止了，可是昨天，同事给我发了个\u003ca href=\"https://www.zhihu.com/question/62966713/answer/204487664\" target=\"_blank\"\u003e链接\u003c/a\u003e，这是何其相似，这个实用性不大的问题上，居然还有人花了了两个月的时间，蛋疼的很。于是打开方应杭的介绍(链接在上面自己找)，发现里面的重点在于 Rick Waldron的一段话：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIn JavaScript, all binding declarations are instantiated when control flow enters the scope in which they appear. Legacy var and function declarations allow access to those bindings before the actual declaration, with a \u0026quot;value\u0026quot; of undefined. That legacy behavior is known as \u0026quot;hoisting\u0026quot;. let and const binding declarations are also instantiated when control flow enters the scope in which they appear, with access prevented until the actual declaration is reached; this is called the Temporal Dead Zone. The TDZ exists to prevent the sort of bugs that legacy hoisting can create.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003evar的使用存在变量提升，而let/const是不存在变量提升的，控制语句到let/const时，声明会被实例化(instantiated )，但是在执行前禁止访问，不像var和function会先是被赋予undefined，后者称为变量提升，而前者变量提升却是不一样的，也由此生成了死区，就是变量必须在let声明语句后使用；这点其实在阮一峰老师的\u003ca href=\"http://es6.ruanyifeng.com/#docs/let\" target=\"_blank\"\u003eECMAscript 6\u003c/a\u003e已经介绍到了，只是没有提及死区形成原因；\n回顾前文提到的问题就很简单了，对于let a = sd a变量会在语句执行前实例化，而执行let a = sd的时候，自然报错，同时由于a已经实例化了，不能再次 let a(还得看是什么浏览器。。。。。。)，并且由于a 初始化失败，而在实例化后到初始化这段过程里面，a处于死区中，是无法访问的(acess prevented)，所以不能对a有其他操作。\n下文在引用ECMAscript的一段话:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe variables are created when their containing Lexical Environment is instantiated but may not be accessed in any way until the variable's LexicalBinding is evaluated.\nA variable defined by a LexicalBinding with an Initializer is assigned the value of its Initializer's AssignmentExpression when the LexicalBinding is evaluated, not when the variable is created\u003c/p\u003e\n\u003c/blockquote\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"July 7, 2018","title":"void 0 以及let const var 的理解","content":"\u003ch1\u003evoid 0\u003c/h1\u003e\n\u003cp\u003e最近在backbone的源码(两年前就研究过underscore的源码，现在才看backbone是不是有点那个)，发现里面用到了void 0，这是什么鬼？void居然出现在JavaScript里面，敢情以前用的ES是假的....这么基础的东西，瞟一眼MDN文档，还果然有:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003evoid: 运算符 对给定的表达式进行求值，然后返回 undefined。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eSo, void 0就是返回undefined了，这不是多此一举？直接用undefined来判断，不就完事了，何必用上void 0，这种云里雾里的操作？\n原来在早期的ECMAscript里面，undefined不是关键字，也就是说undefined是可以被修改的，如\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003evar undefined = 1;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样再用undefined判断某个变量，是不是就懵逼了？而void却是关键字，从这个角度出发void 0很有使用的必要，幸好从ES5开始(IE8+)就只把undefined当作一个全局只读的值，不能进行修改，修改了当然就报错咯。\n在backbone的issue里面也有人提到了void 0的\u003ca href=\"https://github.com/jashkenas/backbone/pull/2960\" target=\"_blank\"\u003e问题\u003c/a\u003e，里面提到了void 0的运算速度比undefined更优，只是我在IE9+以上还有chrome上面测得的值都是十分接近的，所以性能不是需要关注，后面还提到void 0的字符要比undefined少，这好处之一，也是为什么我们不用void 1000, void 'hellow world'而是用void 0 的原因，这对主流大型框架还是很有意义的。只是普通的工程就木有必要了\u003c/p\u003e\n\u003ch1\u003elet，const和var\u003c/h1\u003e\n\u003cp\u003e上周在chrome的控制台里面无意写了let a = sd，sd是没有声明的变量，所以回车后马上报错，而后面我再次声明let a的时候，又报错显示a已经声明了，于是我再直接在控制台敲 a 回车，结果报错显示a没有声明，这是在赤裸裸的耍我吗？问同事也是一脸懵逼+神奇的样子，后来也就没有管了，毕竟用没有声明过带的变量赋值给其他变量本来就是有问题的，更不要提后面的情况了。\n故事应该到这里就截止了，可是昨天，同事给我发了个\u003ca href=\"https://www.zhihu.com/question/62966713/answer/204487664\" target=\"_blank\"\u003e链接\u003c/a\u003e，这是何其相似，这个实用性不大的问题上，居然还有人花了了两个月的时间，蛋疼的很。于是打开方应杭的介绍(链接在上面自己找)，发现里面的重点在于 Rick Waldron的一段话：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIn JavaScript, all binding declarations are instantiated when control flow enters the scope in which they appear. Legacy var and function declarations allow access to those bindings before the actual declaration, with a \u0026quot;value\u0026quot; of undefined. That legacy behavior is known as \u0026quot;hoisting\u0026quot;. let and const binding declarations are also instantiated when control flow enters the scope in which they appear, with access prevented until the actual declaration is reached; this is called the Temporal Dead Zone. The TDZ exists to prevent the sort of bugs that legacy hoisting can create.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003evar的使用存在变量提升，而let/const是不存在变量提升的，控制语句到let/const时，声明会被实例化(instantiated )，但是在执行前禁止访问，不像var和function会先是被赋予undefined，后者称为变量提升，而前者变量提升却是不一样的，也由此生成了死区，就是变量必须在let声明语句后使用；这点其实在阮一峰老师的\u003ca href=\"http://es6.ruanyifeng.com/#docs/let\" target=\"_blank\"\u003eECMAscript 6\u003c/a\u003e已经介绍到了，只是没有提及死区形成原因；\n回顾前文提到的问题就很简单了，对于let a = sd a变量会在语句执行前实例化，而执行let a = sd的时候，自然报错，同时由于a已经实例化了，不能再次 let a(还得看是什么浏览器。。。。。。)，并且由于a 初始化失败，而在实例化后到初始化这段过程里面，a处于死区中，是无法访问的(acess prevented)，所以不能对a有其他操作。\n下文在引用ECMAscript的一段话:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe variables are created when their containing Lexical Environment is instantiated but may not be accessed in any way until the variable's LexicalBinding is evaluated.\nA variable defined by a LexicalBinding with an Initializer is assigned the value of its Initializer's AssignmentExpression when the LexicalBinding is evaluated, not when the variable is created\u003c/p\u003e\n\u003c/blockquote\u003e\n"}},"buildId":"I9XlxpmvFk~lmulxmmsMh","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/I9XlxpmvFk~lmulxmmsMh/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.ce3e8fb7a689beb447ad.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.8d98f9151bcde6fb2a87.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-45be5a1f94c3fe5df8ee.js" async=""></script></body></html>