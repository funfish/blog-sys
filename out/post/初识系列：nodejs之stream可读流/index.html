<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">初识系列：nodejs之stream可读流</title><link rel="preload" href="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.491f56ba.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___3Hk0c "><a class="logo___1KD30" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___1qXLb" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___3VKNp"><h1 class="postTitle___26vXM">初识系列：nodejs之stream可读流</h1><span class="postTime___16Ish">November 12, 2018</span></header><article class="postWrapper___3NXol post-article"><div><h1>前言</h1>
<p>这是初识系列的第一篇：stream可读流。刚接触stream的时候有点难以理解，在客户端开发，基本接触不到stream，顶多也就是文档下载的时候，后端返回文件流，这个和stream沾边的东西。如此神秘，自然成为了首个研究的对象。nodejs对象里面有可读流，可写流，还有可读可写流，像HTTP响应Response对象就是可读流，而服务端的是可写流，下面介绍一下可读流Readable。</p>
<h1>基本</h1>
<p>常见用到可读流的情景是用<code>fs.createReadStream(path[, options])</code>，并通过监听可读流的<code>data</code>与<code>end</code>事件来操作，或则是用pipe方法将可读流的数据流到可写流里面。</p>
<p>可读流里面有两个构造函数，一个是Readable，一个是ReadableState。先看看ReadableState的构造函数：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ReadableState</span>(<span class="hljs-params">options, stream</span>) </span>{
  <span class="hljs-comment">// ...省略部分代码</span>
  <span class="hljs-comment">// objectMode 对象流模式，返回的是对象而不是n字节缓存，hwm：高水位标志</span>
  <span class="hljs-keyword">var</span> hwm = options.highWaterMark;
  <span class="hljs-keyword">var</span> defaultHwm = <span class="hljs-keyword">this</span>.objectMode ? <span class="hljs-number">16</span> : <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>;
  <span class="hljs-keyword">this</span>.highWaterMark = hwm || hwm === <span class="hljs-number">0</span> ? hwm : defaultHwm;
  <span class="hljs-keyword">this</span>.highWaterMark = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-keyword">this</span>.highWaterMark);

  <span class="hljs-comment">//BufferList是可读流的缓冲区，其结构类似与C语言的链表，操作比数组快</span>
  <span class="hljs-keyword">this</span>.buffer = <span class="hljs-keyword">new</span> BufferList();
  <span class="hljs-comment">//缓冲区大小长度</span>
  <span class="hljs-keyword">this</span>.length = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// pipes：目标对象流，pipesCount为目标对象流长度</span>
  <span class="hljs-keyword">this</span>.pipes = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>.pipesCount = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// flowing模式标志，ended为可读流结束标志，endEmitted：是否已经触发ended</span>
  <span class="hljs-comment">// reading：是否正在正在调用this._read方法</span>
  <span class="hljs-keyword">this</span>.flowing = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>.ended = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">this</span>.endEmitted = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">this</span>.reading = <span class="hljs-literal">false</span>;
  <span class="hljs-comment">// 异步标志置为true，用来控制'readable'/'data'事件是否立即执行</span>
  <span class="hljs-keyword">this</span>.sync = <span class="hljs-literal">true</span>;
  <span class="hljs-comment">// 是否需要触发readable事件，</span>
  <span class="hljs-keyword">this</span>.needReadable = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">this</span>.emittedReadable = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">this</span>.readableListening = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">this</span>.resumeScheduled = <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">this</span>.destroyed = <span class="hljs-literal">false</span>;

  <span class="hljs-comment">// 目标流不处于drain状态时，等待drain事件的数量；</span>
  <span class="hljs-keyword">this</span>.awaitDrain = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 是否正在读取更多数据，maybeReadMore函数</span>
  <span class="hljs-keyword">this</span>.readingMore = <span class="hljs-literal">false</span>;
  <span class="hljs-comment">//.. 省略编解码相关部分</span>
}
</code></pre>
<p>BufferList，就是读取过程中操作的缓冲池。ReadableState构造函数基本上是用来控制可读流的标志，其中最常见的就是flowing。可读流的工作模式分为flowing模式和pause模式。一般直接使用readable.pipe() 方法来消费流数据，因为它是最简单的一种实现，如果你想要精细控制，那就是通过控制flowing标志以及其他来实现。</p>
<h2>添加chunk</h2>
<p>可读流的数据从哪里来？或许最常见的就是用fs模块来createReadStream，然后直接读取就好了，似乎不涉及到chunk的添加过程。但是createReadStream又是如何创建可读流的呢？到最后还是需要Readable的push这个API，不断地<code>push(chunk)</code>，也就是往缓冲区添加数据。下面介绍一下push方法：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addChunk</span>(<span class="hljs-params">stream, state, chunk, addToFront</span>) </span>{
  <span class="hljs-keyword">if</span> (state.flowing &amp;&amp; state.length === <span class="hljs-number">0</span> &amp;&amp; !state.sync) {
    stream.emit(<span class="hljs-string">'data'</span>, chunk);
    stream.read(<span class="hljs-number">0</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// update the buffer info.</span>
    state.length += state.objectMode ? <span class="hljs-number">1</span> : chunk.length;
    <span class="hljs-keyword">if</span> (addToFront) state.buffer.unshift(chunk);<span class="hljs-keyword">else</span> state.buffer.push(chunk);

    <span class="hljs-keyword">if</span> (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}
</code></pre>
<p>上面是addChunk方法，而Readable的push，会先检查objectMode，若不是objectMode，当压入的数据chunk是一个Buffer, Uint8Array或者string，objectMode就可以是any了，在readableAddChunk函数里面会<code>state.reading = false</code>添加块的过程并不是在执行_read方法。
回到addChunk方法，先看看else语句，可以发现添加chunk只是修改<code>state.length</code>，同时调用push/unshift来把chunk添加到缓冲区里面。并根据情况来触发readable事件。readable事件表明会有新的动态，要么有新的数据，要么到了流的尾部。而前面if语句里面，为flowing模式，并且缓冲区没有数据，且为同步模式下，才会触发data事件，并执行<code>read(0)</code>，<code>read(0)</code>在满足条件的情况下，只是简单触发readable事件而不会读取当前缓冲区，后面会介绍到。addChunk结束部分还调用了<code>maybeReadMore</code>，在read部分会介绍到。</p>
<h2>read</h2>
<p>Readable.prototype.read方法，用于读取缓冲池里面的数据，其开始如下：</p>
<pre class="hljs"><code>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span> &amp;&amp; state.needReadable &amp;&amp; (state.length &gt;= state.highWaterMark || state.ended)) {
    debug(<span class="hljs-string">'read: emitReadable'</span>, state.length, state.ended);
    <span class="hljs-keyword">if</span> (state.length === <span class="hljs-number">0</span> &amp;&amp; state.ended) endReadable(<span class="hljs-keyword">this</span>);<span class="hljs-keyword">else</span> emitReadable(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
</code></pre>
<p>在开始的时候如果<code>n=0</code>，并且符合其他条件，则会执行emitReadable，接着触发readable事件，并返回null，这个时候<code>read(0)</code>并不会触发缓冲区的数据读取，只是简单的触发readable事件，这个实现还是很巧妙的。</p>
<pre class="hljs"><code>  n = howMuchToRead(n, state);
  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span> &amp;&amp; state.ended) {
    <span class="hljs-keyword">if</span> (state.length === <span class="hljs-number">0</span>) endReadable(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">var</span> doRead = state.needReadable;
  debug(<span class="hljs-string">'need readable'</span>, doRead);
  <span class="hljs-comment">// 数据比高水线低，那就需要读</span>
  <span class="hljs-keyword">if</span> (state.length === <span class="hljs-number">0</span> || state.length - n &lt; state.highWaterMark) {
    doRead = <span class="hljs-literal">true</span>;
    debug(<span class="hljs-string">'length less than watermark'</span>, doRead);
  }

  <span class="hljs-keyword">if</span> (state.ended || state.reading) {
    doRead = <span class="hljs-literal">false</span>;
    debug(<span class="hljs-string">'reading or ended'</span>, doRead);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (doRead) {
    debug(<span class="hljs-string">'do read'</span>);
    state.reading = <span class="hljs-literal">true</span>;
    state.sync = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (state.length === <span class="hljs-number">0</span>) state.needReadable = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>._read(state.highWaterMark);
    state.sync = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (!state.reading) n = howMuchToRead(nOrig, state);
  }
</code></pre>
<p>这里面先是重新计算n，
当<code>n===NaN</code>的时候，读取缓冲区的第一个节点或则所有缓冲数据，
当<code>n&lt;=state.length</code>返回n，并且当<code>n&gt;hwm</code>的时候，重新计算高水位，为最小大于n的2^x，
当<code>n&gt;state.length</code>的时候，返回0，并使得<code>state.needReadable=true</code>，
下面则是通过needReadable来判断是否执行_read方法，_read方法是需要自定义实现的，在方法里面手动添加数据到缓冲区里面，以便后面读取数据以及判断缓冲区长度。由于_read可能是同步的方法，修改缓冲区，所以需要重新评估n，以便后面获取数据。
后面部分，获取数据：</p>
<pre class="hljs"><code>  <span class="hljs-keyword">var</span> ret;
  <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) ret = fromList(n, state);<span class="hljs-keyword">else</span> ret = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">if</span> (ret === <span class="hljs-literal">null</span>) {
    state.needReadable = <span class="hljs-literal">true</span>;
    n = <span class="hljs-number">0</span>;
  } <span class="hljs-keyword">else</span> {
    state.length -= n;
  }
  <span class="hljs-keyword">if</span> (state.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span> (!state.ended) state.needReadable = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (nOrig !== n &amp;&amp; state.ended) endReadable(<span class="hljs-keyword">this</span>);
  }
  <span class="hljs-keyword">if</span> (ret !== <span class="hljs-literal">null</span>) <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'data'</span>, ret);

  <span class="hljs-keyword">return</span> ret;
</code></pre>
<p>这一部分就简单了，就是获取数据，设置needReadable，并触发data事件，供可读流监听，操作chunk。</p>
<h3>needReadable的作用</h3>
<p>在read方法里面，needReadable经常被修改为true，这个有什么用呢？
在<code>addChunk</code>里面若执行if语句里面的<code>read(0)</code>，由于需要<code>state.length&gt;=htm</code>是不会触发readable事件的，相反执行else语句，添加chunk之后，就触发readable事件，并将所有的缓冲区数据读出来，相当于把之前的数据，和本次加的数据都读出来了。<code>addChunk</code>的最后面也会通过调用maybeReadMore来执行<code>read(0)</code>，其实现如下：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maybeReadMore</span>(<span class="hljs-params">stream, state</span>) </span>{
  <span class="hljs-keyword">if</span> (!state.readingMore) {
    state.readingMore = <span class="hljs-literal">true</span>;
    processNextTick(maybeReadMore_, stream, state);
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maybeReadMore_</span>(<span class="hljs-params">stream, state</span>) </span>{
  <span class="hljs-keyword">var</span> len = state.length;
  <span class="hljs-keyword">while</span> (!state.reading &amp;&amp; !state.flowing &amp;&amp; !state.ended &amp;&amp; state.length &lt; state.highWaterMark) {
    debug(<span class="hljs-string">'maybeReadMore read 0'</span>);
    stream.read(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (len === state.length)
      <span class="hljs-comment">// didn't get any data, stop spinning.</span>
      <span class="hljs-keyword">break</span>;<span class="hljs-keyword">else</span> len = state.length;
  }
  state.readingMore = <span class="hljs-literal">false</span>;
}
</code></pre>
<p>当添加chunk的时候，若<code>state.lenght&lt;hwm</code>则会执行<code>stream.read(0)</code>，从而肯定会执行_read方法，导致缓冲区增加，直到缓冲区长度超过高水线，同时最后一次调用<code>stream.read(0)</code>，也不会触发readable事件。
另外在<code>Readable.prototype.on</code>函数，readable事件的处理函数里面，异步调用<code>read(0)</code>。
ps：maybeReadMore用了异步调用<code>maybeReadMore_</code>，是为了让本轮循环里面调用的<code>_read</code>执行完先，在<code>_read</code>里面的每个添加chunk的步骤，都会执行maybeReadMore函数，若同步执行<code>maybeReadMore_</code>，缓冲区数据将会远远超标。</p>
<h2>数据读取ended</h2>
<p>当数据读取结束后，要显式的执行<code>push(null)/unshift(null)</code>来调用onEofChunk方法。在onEofChunk里面，会通过emitReadable处理剩余的数据，并设置ended为true。emitReadable方法里面，通过while循环来读取剩余数据，使得state.length为0，并执行endReadable方法。</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">endReadableNT</span>(<span class="hljs-params">state, stream</span>) </span>{
  <span class="hljs-comment">// Check that we didn't get one last unshift.</span>
  <span class="hljs-keyword">if</span> (!state.endEmitted &amp;&amp; state.length === <span class="hljs-number">0</span>) {
    state.endEmitted = <span class="hljs-literal">true</span>;
    stream.readable = <span class="hljs-literal">false</span>;
    stream.emit(<span class="hljs-string">'end'</span>);
  }
}
</code></pre>
<p>endReadable方法异步调用endReadableNT，置readable为false，并触发end事件。这样数据读取就结束了。</p>
<h2>pipe管道</h2>
<p>readable里面的pipe方法，主要部分是事件上的监听，核心部分如下：</p>
<pre class="hljs"><code>  dest.emit(<span class="hljs-string">'pipe'</span>, src);

  <span class="hljs-comment">// start the flow if it hasn't been started already.</span>
  <span class="hljs-keyword">if</span> (!state.flowing) {
    debug(<span class="hljs-string">'pipe resume'</span>);
    src.resume();
  }
</code></pre>
<p>触发pipe事件，同时开启flowing模式，并在结束的时候，会调用cleanup清理掉之前监听的事件。如果在pipe的时候，src又添加数据，而目标文件不处于drain状态，就需要监听drain事件，来单独处理。</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"November 12, 2018","title":"初识系列：nodejs之stream可读流","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e这是初识系列的第一篇：stream可读流。刚接触stream的时候有点难以理解，在客户端开发，基本接触不到stream，顶多也就是文档下载的时候，后端返回文件流，这个和stream沾边的东西。如此神秘，自然成为了首个研究的对象。nodejs对象里面有可读流，可写流，还有可读可写流，像HTTP响应Response对象就是可读流，而服务端的是可写流，下面介绍一下可读流Readable。\u003c/p\u003e\n\u003ch1\u003e基本\u003c/h1\u003e\n\u003cp\u003e常见用到可读流的情景是用\u003ccode\u003efs.createReadStream(path[, options])\u003c/code\u003e，并通过监听可读流的\u003ccode\u003edata\u003c/code\u003e与\u003ccode\u003eend\u003c/code\u003e事件来操作，或则是用pipe方法将可读流的数据流到可写流里面。\u003c/p\u003e\n\u003cp\u003e可读流里面有两个构造函数，一个是Readable，一个是ReadableState。先看看ReadableState的构造函数：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eReadableState\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eoptions, stream\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// ...省略部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// objectMode 对象流模式，返回的是对象而不是n字节缓存，hwm：高水位标志\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e hwm = options.highWaterMark;\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e defaultHwm = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.objectMode ? \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e : \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e1024\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.highWaterMark = hwm || hwm === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e ? hwm : defaultHwm;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.highWaterMark = \u003cspan class=\"hljs-built_in\"\u003eMath\u003c/span\u003e.floor(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.highWaterMark);\n\n  \u003cspan class=\"hljs-comment\"\u003e//BufferList是可读流的缓冲区，其结构类似与C语言的链表，操作比数组快\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.buffer = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e BufferList();\n  \u003cspan class=\"hljs-comment\"\u003e//缓冲区大小长度\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.length = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// pipes：目标对象流，pipesCount为目标对象流长度\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.pipes = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.pipesCount = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// flowing模式标志，ended为可读流结束标志，endEmitted：是否已经触发ended\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// reading：是否正在正在调用this._read方法\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.flowing = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.ended = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.endEmitted = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.reading = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// 异步标志置为true，用来控制'readable'/'data'事件是否立即执行\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.sync = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// 是否需要触发readable事件，\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.needReadable = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.emittedReadable = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.readableListening = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.resumeScheduled = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.destroyed = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e// 目标流不处于drain状态时，等待drain事件的数量；\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.awaitDrain = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// 是否正在读取更多数据，maybeReadMore函数\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.readingMore = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e//.. 省略编解码相关部分\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBufferList，就是读取过程中操作的缓冲池。ReadableState构造函数基本上是用来控制可读流的标志，其中最常见的就是flowing。可读流的工作模式分为flowing模式和pause模式。一般直接使用readable.pipe() 方法来消费流数据，因为它是最简单的一种实现，如果你想要精细控制，那就是通过控制flowing标志以及其他来实现。\u003c/p\u003e\n\u003ch2\u003e添加chunk\u003c/h2\u003e\n\u003cp\u003e可读流的数据从哪里来？或许最常见的就是用fs模块来createReadStream，然后直接读取就好了，似乎不涉及到chunk的添加过程。但是createReadStream又是如何创建可读流的呢？到最后还是需要Readable的push这个API，不断地\u003ccode\u003epush(chunk)\u003c/code\u003e，也就是往缓冲区添加数据。下面介绍一下push方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eaddChunk\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003estream, state, chunk, addToFront\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state.flowing \u0026amp;\u0026amp; state.length === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u0026amp;\u0026amp; !state.sync) {\n    stream.emit(\u003cspan class=\"hljs-string\"\u003e'data'\u003c/span\u003e, chunk);\n    stream.read(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// update the buffer info.\u003c/span\u003e\n    state.length += state.objectMode ? \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e : chunk.length;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (addToFront) state.buffer.unshift(chunk);\u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e state.buffer.push(chunk);\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面是addChunk方法，而Readable的push，会先检查objectMode，若不是objectMode，当压入的数据chunk是一个Buffer, Uint8Array或者string，objectMode就可以是any了，在readableAddChunk函数里面会\u003ccode\u003estate.reading = false\u003c/code\u003e添加块的过程并不是在执行_read方法。\n回到addChunk方法，先看看else语句，可以发现添加chunk只是修改\u003ccode\u003estate.length\u003c/code\u003e，同时调用push/unshift来把chunk添加到缓冲区里面。并根据情况来触发readable事件。readable事件表明会有新的动态，要么有新的数据，要么到了流的尾部。而前面if语句里面，为flowing模式，并且缓冲区没有数据，且为同步模式下，才会触发data事件，并执行\u003ccode\u003eread(0)\u003c/code\u003e，\u003ccode\u003eread(0)\u003c/code\u003e在满足条件的情况下，只是简单触发readable事件而不会读取当前缓冲区，后面会介绍到。addChunk结束部分还调用了\u003ccode\u003emaybeReadMore\u003c/code\u003e，在read部分会介绍到。\u003c/p\u003e\n\u003ch2\u003eread\u003c/h2\u003e\n\u003cp\u003eReadable.prototype.read方法，用于读取缓冲池里面的数据，其开始如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (n === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u0026amp;\u0026amp; state.needReadable \u0026amp;\u0026amp; (state.length \u0026gt;= state.highWaterMark || state.ended)) {\n    debug(\u003cspan class=\"hljs-string\"\u003e'read: emitReadable'\u003c/span\u003e, state.length, state.ended);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state.length === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u0026amp;\u0026amp; state.ended) endReadable(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e);\u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e emitReadable(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在开始的时候如果\u003ccode\u003en=0\u003c/code\u003e，并且符合其他条件，则会执行emitReadable，接着触发readable事件，并返回null，这个时候\u003ccode\u003eread(0)\u003c/code\u003e并不会触发缓冲区的数据读取，只是简单的触发readable事件，这个实现还是很巧妙的。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e  n = howMuchToRead(n, state);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (n === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u0026amp;\u0026amp; state.ended) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state.length === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) endReadable(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e doRead = state.needReadable;\n  debug(\u003cspan class=\"hljs-string\"\u003e'need readable'\u003c/span\u003e, doRead);\n  \u003cspan class=\"hljs-comment\"\u003e// 数据比高水线低，那就需要读\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state.length === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e || state.length - n \u0026lt; state.highWaterMark) {\n    doRead = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    debug(\u003cspan class=\"hljs-string\"\u003e'length less than watermark'\u003c/span\u003e, doRead);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state.ended || state.reading) {\n    doRead = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    debug(\u003cspan class=\"hljs-string\"\u003e'reading or ended'\u003c/span\u003e, doRead);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (doRead) {\n    debug(\u003cspan class=\"hljs-string\"\u003e'do read'\u003c/span\u003e);\n    state.reading = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    state.sync = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state.length === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) state.needReadable = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._read(state.highWaterMark);\n    state.sync = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里面先是重新计算n，\n当\u003ccode\u003en===NaN\u003c/code\u003e的时候，读取缓冲区的第一个节点或则所有缓冲数据，\n当\u003ccode\u003en\u0026lt;=state.length\u003c/code\u003e返回n，并且当\u003ccode\u003en\u0026gt;hwm\u003c/code\u003e的时候，重新计算高水位，为最小大于n的2^x，\n当\u003ccode\u003en\u0026gt;state.length\u003c/code\u003e的时候，返回0，并使得\u003ccode\u003estate.needReadable=true\u003c/code\u003e，\n下面则是通过needReadable来判断是否执行_read方法，_read方法是需要自定义实现的，在方法里面手动添加数据到缓冲区里面，以便后面读取数据以及判断缓冲区长度。由于_read可能是同步的方法，修改缓冲区，所以需要重新评估n，以便后面获取数据。\n后面部分，获取数据：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e ret;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (n \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) ret = fromList(n, state);\u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e ret = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ret === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    state.needReadable = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    n = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    state.length -= n;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state.length === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!state.ended) state.needReadable = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (nOrig !== n \u0026amp;\u0026amp; state.ended) endReadable(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ret !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.emit(\u003cspan class=\"hljs-string\"\u003e'data'\u003c/span\u003e, ret);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e ret;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这一部分就简单了，就是获取数据，设置needReadable，并触发data事件，供可读流监听，操作chunk。\u003c/p\u003e\n\u003ch3\u003eneedReadable的作用\u003c/h3\u003e\n\u003cp\u003e在read方法里面，needReadable经常被修改为true，这个有什么用呢？\n在\u003ccode\u003eaddChunk\u003c/code\u003e里面若执行if语句里面的\u003ccode\u003eread(0)\u003c/code\u003e，由于需要\u003ccode\u003estate.length\u0026gt;=htm\u003c/code\u003e是不会触发readable事件的，相反执行else语句，添加chunk之后，就触发readable事件，并将所有的缓冲区数据读出来，相当于把之前的数据，和本次加的数据都读出来了。\u003ccode\u003eaddChunk\u003c/code\u003e的最后面也会通过调用maybeReadMore来执行\u003ccode\u003eread(0)\u003c/code\u003e，其实现如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emaybeReadMore\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003estream, state\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!state.readingMore) {\n    state.readingMore = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    processNextTick(maybeReadMore_, stream, state);\n  }\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emaybeReadMore_\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003estream, state\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e len = state.length;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (!state.reading \u0026amp;\u0026amp; !state.flowing \u0026amp;\u0026amp; !state.ended \u0026amp;\u0026amp; state.length \u0026lt; state.highWaterMark) {\n    debug(\u003cspan class=\"hljs-string\"\u003e'maybeReadMore read 0'\u003c/span\u003e);\n    stream.read(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (len === state.length)\n      \u003cspan class=\"hljs-comment\"\u003e// didn't get any data, stop spinning.\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e len = state.length;\n  }\n  state.readingMore = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当添加chunk的时候，若\u003ccode\u003estate.lenght\u0026lt;hwm\u003c/code\u003e则会执行\u003ccode\u003estream.read(0)\u003c/code\u003e，从而肯定会执行_read方法，导致缓冲区增加，直到缓冲区长度超过高水线，同时最后一次调用\u003ccode\u003estream.read(0)\u003c/code\u003e，也不会触发readable事件。\n另外在\u003ccode\u003eReadable.prototype.on\u003c/code\u003e函数，readable事件的处理函数里面，异步调用\u003ccode\u003eread(0)\u003c/code\u003e。\nps：maybeReadMore用了异步调用\u003ccode\u003emaybeReadMore_\u003c/code\u003e，是为了让本轮循环里面调用的\u003ccode\u003e_read\u003c/code\u003e执行完先，在\u003ccode\u003e_read\u003c/code\u003e里面的每个添加chunk的步骤，都会执行maybeReadMore函数，若同步执行\u003ccode\u003emaybeReadMore_\u003c/code\u003e，缓冲区数据将会远远超标。\u003c/p\u003e\n\u003ch2\u003e数据读取ended\u003c/h2\u003e\n\u003cp\u003e当数据读取结束后，要显式的执行\u003ccode\u003epush(null)/unshift(null)\u003c/code\u003e来调用onEofChunk方法。在onEofChunk里面，会通过emitReadable处理剩余的数据，并设置ended为true。emitReadable方法里面，通过while循环来读取剩余数据，使得state.length为0，并执行endReadable方法。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eendReadableNT\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003estate, stream\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// Check that we didn't get one last unshift.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!state.endEmitted \u0026amp;\u0026amp; state.length === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    state.endEmitted = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    stream.readable = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    stream.emit(\u003cspan class=\"hljs-string\"\u003e'end'\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eendReadable方法异步调用endReadableNT，置readable为false，并触发end事件。这样数据读取就结束了。\u003c/p\u003e\n\u003ch2\u003epipe管道\u003c/h2\u003e\n\u003cp\u003ereadable里面的pipe方法，主要部分是事件上的监听，核心部分如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e  dest.emit(\u003cspan class=\"hljs-string\"\u003e'pipe'\u003c/span\u003e, src);\n\n  \u003cspan class=\"hljs-comment\"\u003e// start the flow if it hasn't been started already.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!state.flowing) {\n    debug(\u003cspan class=\"hljs-string\"\u003e'pipe resume'\u003c/span\u003e);\n    src.resume();\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e触发pipe事件，同时开启flowing模式，并在结束的时候，会调用cleanup清理掉之前监听的事件。如果在pipe的时候，src又添加数据，而目标文件不处于drain状态，就需要监听drain事件，来单独处理。\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"November 12, 2018","title":"初识系列：nodejs之stream可读流","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e这是初识系列的第一篇：stream可读流。刚接触stream的时候有点难以理解，在客户端开发，基本接触不到stream，顶多也就是文档下载的时候，后端返回文件流，这个和stream沾边的东西。如此神秘，自然成为了首个研究的对象。nodejs对象里面有可读流，可写流，还有可读可写流，像HTTP响应Response对象就是可读流，而服务端的是可写流，下面介绍一下可读流Readable。\u003c/p\u003e\n\u003ch1\u003e基本\u003c/h1\u003e\n\u003cp\u003e常见用到可读流的情景是用\u003ccode\u003efs.createReadStream(path[, options])\u003c/code\u003e，并通过监听可读流的\u003ccode\u003edata\u003c/code\u003e与\u003ccode\u003eend\u003c/code\u003e事件来操作，或则是用pipe方法将可读流的数据流到可写流里面。\u003c/p\u003e\n\u003cp\u003e可读流里面有两个构造函数，一个是Readable，一个是ReadableState。先看看ReadableState的构造函数：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eReadableState\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eoptions, stream\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// ...省略部分代码\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// objectMode 对象流模式，返回的是对象而不是n字节缓存，hwm：高水位标志\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e hwm = options.highWaterMark;\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e defaultHwm = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.objectMode ? \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e : \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e1024\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.highWaterMark = hwm || hwm === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e ? hwm : defaultHwm;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.highWaterMark = \u003cspan class=\"hljs-built_in\"\u003eMath\u003c/span\u003e.floor(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.highWaterMark);\n\n  \u003cspan class=\"hljs-comment\"\u003e//BufferList是可读流的缓冲区，其结构类似与C语言的链表，操作比数组快\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.buffer = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e BufferList();\n  \u003cspan class=\"hljs-comment\"\u003e//缓冲区大小长度\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.length = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// pipes：目标对象流，pipesCount为目标对象流长度\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.pipes = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.pipesCount = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// flowing模式标志，ended为可读流结束标志，endEmitted：是否已经触发ended\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// reading：是否正在正在调用this._read方法\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.flowing = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.ended = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.endEmitted = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.reading = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// 异步标志置为true，用来控制'readable'/'data'事件是否立即执行\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.sync = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// 是否需要触发readable事件，\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.needReadable = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.emittedReadable = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.readableListening = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.resumeScheduled = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.destroyed = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e// 目标流不处于drain状态时，等待drain事件的数量；\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.awaitDrain = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// 是否正在读取更多数据，maybeReadMore函数\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.readingMore = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e//.. 省略编解码相关部分\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBufferList，就是读取过程中操作的缓冲池。ReadableState构造函数基本上是用来控制可读流的标志，其中最常见的就是flowing。可读流的工作模式分为flowing模式和pause模式。一般直接使用readable.pipe() 方法来消费流数据，因为它是最简单的一种实现，如果你想要精细控制，那就是通过控制flowing标志以及其他来实现。\u003c/p\u003e\n\u003ch2\u003e添加chunk\u003c/h2\u003e\n\u003cp\u003e可读流的数据从哪里来？或许最常见的就是用fs模块来createReadStream，然后直接读取就好了，似乎不涉及到chunk的添加过程。但是createReadStream又是如何创建可读流的呢？到最后还是需要Readable的push这个API，不断地\u003ccode\u003epush(chunk)\u003c/code\u003e，也就是往缓冲区添加数据。下面介绍一下push方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eaddChunk\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003estream, state, chunk, addToFront\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state.flowing \u0026amp;\u0026amp; state.length === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u0026amp;\u0026amp; !state.sync) {\n    stream.emit(\u003cspan class=\"hljs-string\"\u003e'data'\u003c/span\u003e, chunk);\n    stream.read(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// update the buffer info.\u003c/span\u003e\n    state.length += state.objectMode ? \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e : chunk.length;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (addToFront) state.buffer.unshift(chunk);\u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e state.buffer.push(chunk);\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面是addChunk方法，而Readable的push，会先检查objectMode，若不是objectMode，当压入的数据chunk是一个Buffer, Uint8Array或者string，objectMode就可以是any了，在readableAddChunk函数里面会\u003ccode\u003estate.reading = false\u003c/code\u003e添加块的过程并不是在执行_read方法。\n回到addChunk方法，先看看else语句，可以发现添加chunk只是修改\u003ccode\u003estate.length\u003c/code\u003e，同时调用push/unshift来把chunk添加到缓冲区里面。并根据情况来触发readable事件。readable事件表明会有新的动态，要么有新的数据，要么到了流的尾部。而前面if语句里面，为flowing模式，并且缓冲区没有数据，且为同步模式下，才会触发data事件，并执行\u003ccode\u003eread(0)\u003c/code\u003e，\u003ccode\u003eread(0)\u003c/code\u003e在满足条件的情况下，只是简单触发readable事件而不会读取当前缓冲区，后面会介绍到。addChunk结束部分还调用了\u003ccode\u003emaybeReadMore\u003c/code\u003e，在read部分会介绍到。\u003c/p\u003e\n\u003ch2\u003eread\u003c/h2\u003e\n\u003cp\u003eReadable.prototype.read方法，用于读取缓冲池里面的数据，其开始如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (n === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u0026amp;\u0026amp; state.needReadable \u0026amp;\u0026amp; (state.length \u0026gt;= state.highWaterMark || state.ended)) {\n    debug(\u003cspan class=\"hljs-string\"\u003e'read: emitReadable'\u003c/span\u003e, state.length, state.ended);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state.length === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u0026amp;\u0026amp; state.ended) endReadable(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e);\u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e emitReadable(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在开始的时候如果\u003ccode\u003en=0\u003c/code\u003e，并且符合其他条件，则会执行emitReadable，接着触发readable事件，并返回null，这个时候\u003ccode\u003eread(0)\u003c/code\u003e并不会触发缓冲区的数据读取，只是简单的触发readable事件，这个实现还是很巧妙的。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e  n = howMuchToRead(n, state);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (n === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u0026amp;\u0026amp; state.ended) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state.length === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) endReadable(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e doRead = state.needReadable;\n  debug(\u003cspan class=\"hljs-string\"\u003e'need readable'\u003c/span\u003e, doRead);\n  \u003cspan class=\"hljs-comment\"\u003e// 数据比高水线低，那就需要读\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state.length === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e || state.length - n \u0026lt; state.highWaterMark) {\n    doRead = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    debug(\u003cspan class=\"hljs-string\"\u003e'length less than watermark'\u003c/span\u003e, doRead);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state.ended || state.reading) {\n    doRead = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    debug(\u003cspan class=\"hljs-string\"\u003e'reading or ended'\u003c/span\u003e, doRead);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (doRead) {\n    debug(\u003cspan class=\"hljs-string\"\u003e'do read'\u003c/span\u003e);\n    state.reading = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    state.sync = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state.length === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) state.needReadable = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._read(state.highWaterMark);\n    state.sync = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里面先是重新计算n，\n当\u003ccode\u003en===NaN\u003c/code\u003e的时候，读取缓冲区的第一个节点或则所有缓冲数据，\n当\u003ccode\u003en\u0026lt;=state.length\u003c/code\u003e返回n，并且当\u003ccode\u003en\u0026gt;hwm\u003c/code\u003e的时候，重新计算高水位，为最小大于n的2^x，\n当\u003ccode\u003en\u0026gt;state.length\u003c/code\u003e的时候，返回0，并使得\u003ccode\u003estate.needReadable=true\u003c/code\u003e，\n下面则是通过needReadable来判断是否执行_read方法，_read方法是需要自定义实现的，在方法里面手动添加数据到缓冲区里面，以便后面读取数据以及判断缓冲区长度。由于_read可能是同步的方法，修改缓冲区，所以需要重新评估n，以便后面获取数据。\n后面部分，获取数据：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e ret;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (n \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) ret = fromList(n, state);\u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e ret = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ret === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    state.needReadable = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    n = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    state.length -= n;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state.length === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!state.ended) state.needReadable = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (nOrig !== n \u0026amp;\u0026amp; state.ended) endReadable(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ret !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.emit(\u003cspan class=\"hljs-string\"\u003e'data'\u003c/span\u003e, ret);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e ret;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这一部分就简单了，就是获取数据，设置needReadable，并触发data事件，供可读流监听，操作chunk。\u003c/p\u003e\n\u003ch3\u003eneedReadable的作用\u003c/h3\u003e\n\u003cp\u003e在read方法里面，needReadable经常被修改为true，这个有什么用呢？\n在\u003ccode\u003eaddChunk\u003c/code\u003e里面若执行if语句里面的\u003ccode\u003eread(0)\u003c/code\u003e，由于需要\u003ccode\u003estate.length\u0026gt;=htm\u003c/code\u003e是不会触发readable事件的，相反执行else语句，添加chunk之后，就触发readable事件，并将所有的缓冲区数据读出来，相当于把之前的数据，和本次加的数据都读出来了。\u003ccode\u003eaddChunk\u003c/code\u003e的最后面也会通过调用maybeReadMore来执行\u003ccode\u003eread(0)\u003c/code\u003e，其实现如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emaybeReadMore\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003estream, state\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!state.readingMore) {\n    state.readingMore = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    processNextTick(maybeReadMore_, stream, state);\n  }\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emaybeReadMore_\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003estream, state\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e len = state.length;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (!state.reading \u0026amp;\u0026amp; !state.flowing \u0026amp;\u0026amp; !state.ended \u0026amp;\u0026amp; state.length \u0026lt; state.highWaterMark) {\n    debug(\u003cspan class=\"hljs-string\"\u003e'maybeReadMore read 0'\u003c/span\u003e);\n    stream.read(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (len === state.length)\n      \u003cspan class=\"hljs-comment\"\u003e// didn't get any data, stop spinning.\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e len = state.length;\n  }\n  state.readingMore = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当添加chunk的时候，若\u003ccode\u003estate.lenght\u0026lt;hwm\u003c/code\u003e则会执行\u003ccode\u003estream.read(0)\u003c/code\u003e，从而肯定会执行_read方法，导致缓冲区增加，直到缓冲区长度超过高水线，同时最后一次调用\u003ccode\u003estream.read(0)\u003c/code\u003e，也不会触发readable事件。\n另外在\u003ccode\u003eReadable.prototype.on\u003c/code\u003e函数，readable事件的处理函数里面，异步调用\u003ccode\u003eread(0)\u003c/code\u003e。\nps：maybeReadMore用了异步调用\u003ccode\u003emaybeReadMore_\u003c/code\u003e，是为了让本轮循环里面调用的\u003ccode\u003e_read\u003c/code\u003e执行完先，在\u003ccode\u003e_read\u003c/code\u003e里面的每个添加chunk的步骤，都会执行maybeReadMore函数，若同步执行\u003ccode\u003emaybeReadMore_\u003c/code\u003e，缓冲区数据将会远远超标。\u003c/p\u003e\n\u003ch2\u003e数据读取ended\u003c/h2\u003e\n\u003cp\u003e当数据读取结束后，要显式的执行\u003ccode\u003epush(null)/unshift(null)\u003c/code\u003e来调用onEofChunk方法。在onEofChunk里面，会通过emitReadable处理剩余的数据，并设置ended为true。emitReadable方法里面，通过while循环来读取剩余数据，使得state.length为0，并执行endReadable方法。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eendReadableNT\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003estate, stream\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// Check that we didn't get one last unshift.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!state.endEmitted \u0026amp;\u0026amp; state.length === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    state.endEmitted = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    stream.readable = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    stream.emit(\u003cspan class=\"hljs-string\"\u003e'end'\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eendReadable方法异步调用endReadableNT，置readable为false，并触发end事件。这样数据读取就结束了。\u003c/p\u003e\n\u003ch2\u003epipe管道\u003c/h2\u003e\n\u003cp\u003ereadable里面的pipe方法，主要部分是事件上的监听，核心部分如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e  dest.emit(\u003cspan class=\"hljs-string\"\u003e'pipe'\u003c/span\u003e, src);\n\n  \u003cspan class=\"hljs-comment\"\u003e// start the flow if it hasn't been started already.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!state.flowing) {\n    debug(\u003cspan class=\"hljs-string\"\u003e'pipe resume'\u003c/span\u003e);\n    src.resume();\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e触发pipe事件，同时开启flowing模式，并在结束的时候，会调用cleanup清理掉之前监听的事件。如果在pipe的时候，src又添加数据，而目标文件不处于drain状态，就需要监听drain事件，来单独处理。\u003c/p\u003e\n"}},"buildId":"IdQI6resUd3YjXidM2HVB","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/IdQI6resUd3YjXidM2HVB/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" async=""></script></body></html>