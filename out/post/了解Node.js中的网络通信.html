<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">了解Node.js中的网络通信</title><link rel="preload" href="/blog-sys/_next/static/sIsd3fYQzJCXbU_Js9qRI/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/sIsd3fYQzJCXbU_Js9qRI/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/sIsd3fYQzJCXbU_Js9qRI/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.491f56ba.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___3Hk0c "><a class="logo___1KD30" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___1qXLb" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___3VKNp"><h1 class="postTitle___26vXM">了解Node.js中的网络通信</h1><span class="postTime___16Ish">July 7, 2018</span></header><article class="postWrapper___3NXol post-article"><div><h1>前言</h1>
<p>一直想知道Node.js是如何作为一个用js语言写的后端平台。这个设定很是奇怪，前端开始涉足后端了？刚开始用api实现通信的时候，蛮简单的，框架都不用到，简单几句就能实现通信，于是借此机会研究一下Node.js的通信。</p>
<h1>从net模块出发</h1>
<p>看一个简单的例子</p>
<pre class="hljs"><code><span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>).createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    res.end(<span class="hljs-string">'hello world'</span>);
}).listen(<span class="hljs-number">8181</span>);
</code></pre>
<p>这里用的是http模块通信，也就是我们最常用的部分，看<a href="https://nodejs.org/dist/latest-v6.x/docs/api/http.html#http_http_createserver_requestlistener" target="_blank">官方文档</a>可以发知道其返回一个http.Server实例，而该实例又继承与net.Server，net.Server的描述是用于创建TCP或者本地服务器，这不正是我们想要的吗？
通过上面例子不难发现，我们主要用到的api的接口是createServer和listen，而首先的是net.Server实例。</p>
<pre class="hljs"><code><span class="hljs-comment">// net.js中</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createServer</span>(<span class="hljs-params">options, connectionListener</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Server(options, connectionListener);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Server</span>(<span class="hljs-params">options, connectionListener</span>) </span>{
  ...
  EventEmitter.call(<span class="hljs-keyword">this</span>);
  ...
    if (<span class="hljs-keyword">typeof</span> connectionListener === <span class="hljs-string">'function'</span>) {
      <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'connection'</span>, connectionListener);
    }
  <span class="hljs-keyword">this</span>._connections = <span class="hljs-number">0</span>;
  ...
  this[async_id_symbol] = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">this</span>._handle = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>._usingWorkers = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">this</span>._workers = [];
  <span class="hljs-keyword">this</span>._unref = <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">this</span>.allowHalfOpen = options.allowHalfOpen || <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">this</span>.pauseOnConnect = !!options.pauseOnConnect;
}
util.inherits(Server, EventEmitter);
</code></pre>
<p>这里可以发现Server实例继承EventEmitter，就像Backbone里面的model等继承Events一样，监听connection事件，并初始化this，net.createServer也是返回Server实例，看来Server很重要。再看看listen</p>
<pre class="hljs"><code>Server.prototype.listen = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>{
  ...
  if (hasCallback) {
    <span class="hljs-keyword">this</span>.once(<span class="hljs-string">'listening'</span>, cb);
  }
  ...
  var backlog;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options.port === <span class="hljs-string">'number'</span> || <span class="hljs-keyword">typeof</span> options.port === <span class="hljs-string">'string'</span>) {
    ...
      <span class="hljs-comment">// 对于listen(port, cb)的情况</span>
      listenInCluster(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, options.port | <span class="hljs-number">0</span>, <span class="hljs-number">4</span>,
                      backlog, <span class="hljs-literal">undefined</span>, options.exclusive);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }
  ...
};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listenInCluster</span>(<span class="hljs-params">server, address, port, addressType,
                         backlog, fd, exclusive</span>) </span>{
  ...
  if (cluster.isMaster || exclusive) {
    server._listen2(address, port, addressType, backlog, fd);
    <span class="hljs-keyword">return</span>; 
  }

  <span class="hljs-keyword">const</span> serverQuery = {
  ...
  };
  ...
  cluster._getServer(server, serverQuery, listenOnMasterHandle);
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listenOnMasterHandle</span>(<span class="hljs-params">err, handle</span>) </span>{
    ...
    server._handle = handle;
    server._listen2(address, port, addressType, backlog, fd);
  }
}
Server.prototype._listen2 = setupListenHandle;  <span class="hljs-comment">// legacy alias</span>
</code></pre>
<p>上面listen方法中有不同的场景判断，上面代码仅仅列出开发中常用的listen(port， cb)的方法。 结合Node.js的document里面的server.listen方法和这里的源码，发现document里面的介绍不就是源码里面的实现吗。。。。listenInCluster方法中通过cluster.isMaster来判断是否是主线程，如果是直接server._listen2，不是的话，还要进行cluster._getServer
而setupListenHandle方法</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setupListenHandle</span>(<span class="hljs-params">address, port, addressType, backlog, fd</span>) </span>{
  ...
    var rval = <span class="hljs-literal">null</span>;
  ...
      rval = createServerHandle(address, port, addressType, fd);
  ...
    this._handle = rval;
  }
  <span class="hljs-keyword">this</span>[async_id_symbol] = getNewAsyncId(<span class="hljs-keyword">this</span>._handle);
  <span class="hljs-keyword">this</span>._handle.onconnection = onconnection;
  <span class="hljs-keyword">this</span>._handle.owner = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">this</span>._handle.listen(backlog || <span class="hljs-number">511</span>);
  ...
  nextTick(<span class="hljs-keyword">this</span>[async_id_symbol], emitListeningNT, <span class="hljs-keyword">this</span>);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createServerHandle</span>(<span class="hljs-params">address, port, addressType, fd</span>) </span>{
  ...
    handle = <span class="hljs-keyword">new</span> TCP();
    isTCP = <span class="hljs-literal">true</span>;

  <span class="hljs-keyword">if</span> (address || port || isTCP) {
    ...
    if (!address) {
      err = handle.bind6(<span class="hljs-string">'::'</span>, port);
      ...
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (addressType === <span class="hljs-number">6</span>) {
      err = handle.bind6(address, port);
    } <span class="hljs-keyword">else</span> {
      err = handle.bind(address, port);
    }
  }
  ...
  return handle;
}
</code></pre>
<p>上面的setupListenHandle经过简化，不难发现最后落脚点在<code>this._handle = new TCP()</code>，而TCP：<code>const TCP = process.binding('tcp_wrap').TCP</code>，this._handle 正是server._handle，在初始化Server实例时候所建立的，process.binding是用来连接Node.js的内建模块，这里要看tcp_wrap.cc文件</p>
<h1>tcp_wrap.cc文件开始的C++和C语言</h1>
<p>tcp_wrap.cc文件里面有这里几个方法,</p>
<pre class="hljs"><code>TCPWrap::TCPWrap(Environment* env, Local&lt;Object&gt; object)
    : ConnectionWrap(env,
                     object,
                     AsyncWrap::PROVIDER_TCPWRAP) {
  <span class="hljs-keyword">int</span> r = uv_tcp_init(env-&gt;event_loop(), &amp;handle_);
  CHECK_EQ(r, <span class="hljs-number">0</span>);  <span class="hljs-comment">// How do we proxy this error up to javascript?</span>
                   <span class="hljs-comment">// Suggestion: uv_tcp_init() returns void.</span>
  UpdateWriteQueueSize();
}
<span class="hljs-keyword">void</span> TCPWrap::Listen(<span class="hljs-keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&amp;wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  <span class="hljs-keyword">int</span> backlog = args[<span class="hljs-number">0</span>]-&gt;Int32Value();
  <span class="hljs-keyword">int</span> err = uv_listen(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uv_stream_t</span>*&gt;(&amp;wrap-&gt;handle_),
                      backlog,
                      OnConnection);
  args.GetReturnValue().Set(err);
}
</code></pre>
<p>TCPWrap方法里面调用了tcp.c里面的方法，建立TCP的句柄，函数形参包括uv_loop_t，uv_tcp_t和flags标识，接着对uv_tcp_t结构体中的各项进行初始设置，并调用uv__handle_init循环；
为什么要提及listen方法？在net.js的setupListenHandle方法里面明确用到了<code>this._handle.listen(backlog || 511)</code>，在stream.c里面的uv_listen方法来监听，根据uv_stream_t结构体的type来判断是否是TCP类型，在tcp.c，uv_tcp_listen中通过uv_tcp_t结构体的flags来判断执行；</p>
<p>在uv.h里面定义了上面的结构体，每个结构体都有自己的成员。刚开始接触的时候，看到这里么就有种越看越乱，越看越多的感觉，这个时候开始知道有libuv；</p>
<h1>libuv为何物</h1>
<p>简单来讲就是跨平台io库，整合了window下的iocp和Linux的epoll，官网上有下图
<img src="https://github.com/funfish/blog/raw/master/images/libuv.PNG" alt=""></p>
<p>在node_maic.cc里面调用了start方法，加载bootstrap_node.js文件，并同时while循环调用uv_run()，uv_run就是libuv事件循环的入口，这个方法的执行如下图
<img src="https://github.com/funfish/blog/raw/master/images/uv_run.PNG" alt="">
其中每一个模块和uv_run中的语句是对应，其中在window里面用<code>(*poll)(loop, timeout)</code>，而unix采用<code>uv__io_poll(loop, timeout)</code>。
上文提到的结构体uv_xx_s/t正是libuv的观察者，其中对应的类型uv_TYPE_t中的type指定了handle的使用目的。 至于具体的机理还是看<a href="http://docs.libuv.org/en/v1.x/#documentation" target="_blank">官方文档好</a>。
看过了文档以及api之后，再去看Node.js里面代码，well， 还是一脸懵逼。。。。</p>
<p>只有硬啃下来，发现就是观察体太过长了，一遍一遍的嵌套宏定义，只是到最后还是没有完全读懂libuv如何实现通信，或许以后有下一篇来阐述libuv吧</p>
<p>参考资料</p>
<ol>
<li><a href="https://cnodejs.org/topic/5716137fe84805cd5410ea21" target="_blank">node源码详解（六） —— 从server.listen 到事件循环</a></li>
<li><a href="http://luohaha.github.io/Chinese-uvbook/source/networking.html" target="_blank">uvbook 中文教程</a></li>
<li><a href="http://zhenhua-lee.github.io/node/socket.html" target="_blank">初步研究node中的网络通信模块</a></li>
<li><a href="https://yjhjstz.gitbooks.io/deep-into-node/" target="_blank">《深入理解Node.js：核心思想与源码分析》</a></li>
</ol>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"July 7, 2018","title":"了解Node.js中的网络通信","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e一直想知道Node.js是如何作为一个用js语言写的后端平台。这个设定很是奇怪，前端开始涉足后端了？刚开始用api实现通信的时候，蛮简单的，框架都不用到，简单几句就能实现通信，于是借此机会研究一下Node.js的通信。\u003c/p\u003e\n\u003ch1\u003e从net模块出发\u003c/h1\u003e\n\u003cp\u003e看一个简单的例子\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'http'\u003c/span\u003e).createServer(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    res.end(\u003cspan class=\"hljs-string\"\u003e'hello world'\u003c/span\u003e);\n}).listen(\u003cspan class=\"hljs-number\"\u003e8181\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里用的是http模块通信，也就是我们最常用的部分，看\u003ca href=\"https://nodejs.org/dist/latest-v6.x/docs/api/http.html#http_http_createserver_requestlistener\" target=\"_blank\"\u003e官方文档\u003c/a\u003e可以发知道其返回一个http.Server实例，而该实例又继承与net.Server，net.Server的描述是用于创建TCP或者本地服务器，这不正是我们想要的吗？\n通过上面例子不难发现，我们主要用到的api的接口是createServer和listen，而首先的是net.Server实例。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// net.js中\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecreateServer\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eoptions, connectionListener\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Server(options, connectionListener);\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eServer\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eoptions, connectionListener\u003c/span\u003e) \u003c/span\u003e{\n  ...\n  EventEmitter.call(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e);\n  ...\n    if (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e connectionListener === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.on(\u003cspan class=\"hljs-string\"\u003e'connection'\u003c/span\u003e, connectionListener);\n    }\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._connections = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  ...\n  this[async_id_symbol] = \u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._handle = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._usingWorkers = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._workers = [];\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._unref = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.allowHalfOpen = options.allowHalfOpen || \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.pauseOnConnect = !!options.pauseOnConnect;\n}\nutil.inherits(Server, EventEmitter);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里可以发现Server实例继承EventEmitter，就像Backbone里面的model等继承Events一样，监听connection事件，并初始化this，net.createServer也是返回Server实例，看来Server很重要。再看看listen\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eServer.prototype.listen = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e...args\u003c/span\u003e) \u003c/span\u003e{\n  ...\n  if (hasCallback) {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.once(\u003cspan class=\"hljs-string\"\u003e'listening'\u003c/span\u003e, cb);\n  }\n  ...\n  var backlog;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e options.port === \u003cspan class=\"hljs-string\"\u003e'number'\u003c/span\u003e || \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e options.port === \u003cspan class=\"hljs-string\"\u003e'string'\u003c/span\u003e) {\n    ...\n      \u003cspan class=\"hljs-comment\"\u003e// 对于listen(port, cb)的情况\u003c/span\u003e\n      listenInCluster(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, options.port | \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\n                      backlog, \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e, options.exclusive);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n  }\n  ...\n};\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003elistenInCluster\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eserver, address, port, addressType,\n                         backlog, fd, exclusive\u003c/span\u003e) \u003c/span\u003e{\n  ...\n  if (cluster.isMaster || exclusive) {\n    server._listen2(address, port, addressType, backlog, fd);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e; \n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e serverQuery = {\n  ...\n  };\n  ...\n  cluster._getServer(server, serverQuery, listenOnMasterHandle);\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003elistenOnMasterHandle\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eerr, handle\u003c/span\u003e) \u003c/span\u003e{\n    ...\n    server._handle = handle;\n    server._listen2(address, port, addressType, backlog, fd);\n  }\n}\nServer.prototype._listen2 = setupListenHandle;  \u003cspan class=\"hljs-comment\"\u003e// legacy alias\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面listen方法中有不同的场景判断，上面代码仅仅列出开发中常用的listen(port， cb)的方法。 结合Node.js的document里面的server.listen方法和这里的源码，发现document里面的介绍不就是源码里面的实现吗。。。。listenInCluster方法中通过cluster.isMaster来判断是否是主线程，如果是直接server._listen2，不是的话，还要进行cluster._getServer\n而setupListenHandle方法\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003esetupListenHandle\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eaddress, port, addressType, backlog, fd\u003c/span\u003e) \u003c/span\u003e{\n  ...\n    var rval = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  ...\n      rval = createServerHandle(address, port, addressType, fd);\n  ...\n    this._handle = rval;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e[async_id_symbol] = getNewAsyncId(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._handle);\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._handle.onconnection = onconnection;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._handle.owner = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e err = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._handle.listen(backlog || \u003cspan class=\"hljs-number\"\u003e511\u003c/span\u003e);\n  ...\n  nextTick(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e[async_id_symbol], emitListeningNT, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e);\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecreateServerHandle\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eaddress, port, addressType, fd\u003c/span\u003e) \u003c/span\u003e{\n  ...\n    handle = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e TCP();\n    isTCP = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (address || port || isTCP) {\n    ...\n    if (!address) {\n      err = handle.bind6(\u003cspan class=\"hljs-string\"\u003e'::'\u003c/span\u003e, port);\n      ...\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (addressType === \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e) {\n      err = handle.bind6(address, port);\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      err = handle.bind(address, port);\n    }\n  }\n  ...\n  return handle;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面的setupListenHandle经过简化，不难发现最后落脚点在\u003ccode\u003ethis._handle = new TCP()\u003c/code\u003e，而TCP：\u003ccode\u003econst TCP = process.binding('tcp_wrap').TCP\u003c/code\u003e，this._handle 正是server._handle，在初始化Server实例时候所建立的，process.binding是用来连接Node.js的内建模块，这里要看tcp_wrap.cc文件\u003c/p\u003e\n\u003ch1\u003etcp_wrap.cc文件开始的C++和C语言\u003c/h1\u003e\n\u003cp\u003etcp_wrap.cc文件里面有这里几个方法,\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eTCPWrap::TCPWrap(Environment* env, Local\u0026lt;Object\u0026gt; object)\n    : ConnectionWrap(env,\n                     object,\n                     AsyncWrap::PROVIDER_TCPWRAP) {\n  \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e r = uv_tcp_init(env-\u0026gt;event_loop(), \u0026amp;handle_);\n  CHECK_EQ(r, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);  \u003cspan class=\"hljs-comment\"\u003e// How do we proxy this error up to javascript?\u003c/span\u003e\n                   \u003cspan class=\"hljs-comment\"\u003e// Suggestion: uv_tcp_init() returns void.\u003c/span\u003e\n  UpdateWriteQueueSize();\n}\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e TCPWrap::Listen(\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e FunctionCallbackInfo\u0026lt;Value\u0026gt;\u0026amp; args) {\n  TCPWrap* wrap;\n  ASSIGN_OR_RETURN_UNWRAP(\u0026amp;wrap,\n                          args.Holder(),\n                          args.GetReturnValue().Set(UV_EBADF));\n  \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e backlog = args[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]-\u0026gt;Int32Value();\n  \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e err = uv_listen(\u003cspan class=\"hljs-keyword\"\u003ereinterpret_cast\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-keyword\"\u003euv_stream_t\u003c/span\u003e*\u0026gt;(\u0026amp;wrap-\u0026gt;handle_),\n                      backlog,\n                      OnConnection);\n  args.GetReturnValue().Set(err);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTCPWrap方法里面调用了tcp.c里面的方法，建立TCP的句柄，函数形参包括uv_loop_t，uv_tcp_t和flags标识，接着对uv_tcp_t结构体中的各项进行初始设置，并调用uv__handle_init循环；\n为什么要提及listen方法？在net.js的setupListenHandle方法里面明确用到了\u003ccode\u003ethis._handle.listen(backlog || 511)\u003c/code\u003e，在stream.c里面的uv_listen方法来监听，根据uv_stream_t结构体的type来判断是否是TCP类型，在tcp.c，uv_tcp_listen中通过uv_tcp_t结构体的flags来判断执行；\u003c/p\u003e\n\u003cp\u003e在uv.h里面定义了上面的结构体，每个结构体都有自己的成员。刚开始接触的时候，看到这里么就有种越看越乱，越看越多的感觉，这个时候开始知道有libuv；\u003c/p\u003e\n\u003ch1\u003elibuv为何物\u003c/h1\u003e\n\u003cp\u003e简单来讲就是跨平台io库，整合了window下的iocp和Linux的epoll，官网上有下图\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/libuv.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e在node_maic.cc里面调用了start方法，加载bootstrap_node.js文件，并同时while循环调用uv_run()，uv_run就是libuv事件循环的入口，这个方法的执行如下图\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/uv_run.PNG\" alt=\"\"\u003e\n其中每一个模块和uv_run中的语句是对应，其中在window里面用\u003ccode\u003e(*poll)(loop, timeout)\u003c/code\u003e，而unix采用\u003ccode\u003euv__io_poll(loop, timeout)\u003c/code\u003e。\n上文提到的结构体uv_xx_s/t正是libuv的观察者，其中对应的类型uv_TYPE_t中的type指定了handle的使用目的。 至于具体的机理还是看\u003ca href=\"http://docs.libuv.org/en/v1.x/#documentation\" target=\"_blank\"\u003e官方文档好\u003c/a\u003e。\n看过了文档以及api之后，再去看Node.js里面代码，well， 还是一脸懵逼。。。。\u003c/p\u003e\n\u003cp\u003e只有硬啃下来，发现就是观察体太过长了，一遍一遍的嵌套宏定义，只是到最后还是没有完全读懂libuv如何实现通信，或许以后有下一篇来阐述libuv吧\u003c/p\u003e\n\u003cp\u003e参考资料\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://cnodejs.org/topic/5716137fe84805cd5410ea21\" target=\"_blank\"\u003enode源码详解（六） —— 从server.listen 到事件循环\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://luohaha.github.io/Chinese-uvbook/source/networking.html\" target=\"_blank\"\u003euvbook 中文教程\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://zhenhua-lee.github.io/node/socket.html\" target=\"_blank\"\u003e初步研究node中的网络通信模块\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://yjhjstz.gitbooks.io/deep-into-node/\" target=\"_blank\"\u003e《深入理解Node.js：核心思想与源码分析》\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"July 7, 2018","title":"了解Node.js中的网络通信","content":"\u003ch1\u003e前言\u003c/h1\u003e\n\u003cp\u003e一直想知道Node.js是如何作为一个用js语言写的后端平台。这个设定很是奇怪，前端开始涉足后端了？刚开始用api实现通信的时候，蛮简单的，框架都不用到，简单几句就能实现通信，于是借此机会研究一下Node.js的通信。\u003c/p\u003e\n\u003ch1\u003e从net模块出发\u003c/h1\u003e\n\u003cp\u003e看一个简单的例子\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'http'\u003c/span\u003e).createServer(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    res.end(\u003cspan class=\"hljs-string\"\u003e'hello world'\u003c/span\u003e);\n}).listen(\u003cspan class=\"hljs-number\"\u003e8181\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里用的是http模块通信，也就是我们最常用的部分，看\u003ca href=\"https://nodejs.org/dist/latest-v6.x/docs/api/http.html#http_http_createserver_requestlistener\" target=\"_blank\"\u003e官方文档\u003c/a\u003e可以发知道其返回一个http.Server实例，而该实例又继承与net.Server，net.Server的描述是用于创建TCP或者本地服务器，这不正是我们想要的吗？\n通过上面例子不难发现，我们主要用到的api的接口是createServer和listen，而首先的是net.Server实例。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// net.js中\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecreateServer\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eoptions, connectionListener\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Server(options, connectionListener);\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eServer\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eoptions, connectionListener\u003c/span\u003e) \u003c/span\u003e{\n  ...\n  EventEmitter.call(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e);\n  ...\n    if (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e connectionListener === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.on(\u003cspan class=\"hljs-string\"\u003e'connection'\u003c/span\u003e, connectionListener);\n    }\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._connections = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  ...\n  this[async_id_symbol] = \u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._handle = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._usingWorkers = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._workers = [];\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._unref = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.allowHalfOpen = options.allowHalfOpen || \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.pauseOnConnect = !!options.pauseOnConnect;\n}\nutil.inherits(Server, EventEmitter);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里可以发现Server实例继承EventEmitter，就像Backbone里面的model等继承Events一样，监听connection事件，并初始化this，net.createServer也是返回Server实例，看来Server很重要。再看看listen\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eServer.prototype.listen = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e...args\u003c/span\u003e) \u003c/span\u003e{\n  ...\n  if (hasCallback) {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.once(\u003cspan class=\"hljs-string\"\u003e'listening'\u003c/span\u003e, cb);\n  }\n  ...\n  var backlog;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e options.port === \u003cspan class=\"hljs-string\"\u003e'number'\u003c/span\u003e || \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e options.port === \u003cspan class=\"hljs-string\"\u003e'string'\u003c/span\u003e) {\n    ...\n      \u003cspan class=\"hljs-comment\"\u003e// 对于listen(port, cb)的情况\u003c/span\u003e\n      listenInCluster(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, options.port | \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\n                      backlog, \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e, options.exclusive);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n  }\n  ...\n};\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003elistenInCluster\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eserver, address, port, addressType,\n                         backlog, fd, exclusive\u003c/span\u003e) \u003c/span\u003e{\n  ...\n  if (cluster.isMaster || exclusive) {\n    server._listen2(address, port, addressType, backlog, fd);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e; \n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e serverQuery = {\n  ...\n  };\n  ...\n  cluster._getServer(server, serverQuery, listenOnMasterHandle);\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003elistenOnMasterHandle\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eerr, handle\u003c/span\u003e) \u003c/span\u003e{\n    ...\n    server._handle = handle;\n    server._listen2(address, port, addressType, backlog, fd);\n  }\n}\nServer.prototype._listen2 = setupListenHandle;  \u003cspan class=\"hljs-comment\"\u003e// legacy alias\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面listen方法中有不同的场景判断，上面代码仅仅列出开发中常用的listen(port， cb)的方法。 结合Node.js的document里面的server.listen方法和这里的源码，发现document里面的介绍不就是源码里面的实现吗。。。。listenInCluster方法中通过cluster.isMaster来判断是否是主线程，如果是直接server._listen2，不是的话，还要进行cluster._getServer\n而setupListenHandle方法\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003esetupListenHandle\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eaddress, port, addressType, backlog, fd\u003c/span\u003e) \u003c/span\u003e{\n  ...\n    var rval = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  ...\n      rval = createServerHandle(address, port, addressType, fd);\n  ...\n    this._handle = rval;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e[async_id_symbol] = getNewAsyncId(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._handle);\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._handle.onconnection = onconnection;\n  \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._handle.owner = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e err = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._handle.listen(backlog || \u003cspan class=\"hljs-number\"\u003e511\u003c/span\u003e);\n  ...\n  nextTick(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e[async_id_symbol], emitListeningNT, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e);\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecreateServerHandle\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eaddress, port, addressType, fd\u003c/span\u003e) \u003c/span\u003e{\n  ...\n    handle = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e TCP();\n    isTCP = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (address || port || isTCP) {\n    ...\n    if (!address) {\n      err = handle.bind6(\u003cspan class=\"hljs-string\"\u003e'::'\u003c/span\u003e, port);\n      ...\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (addressType === \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e) {\n      err = handle.bind6(address, port);\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      err = handle.bind(address, port);\n    }\n  }\n  ...\n  return handle;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面的setupListenHandle经过简化，不难发现最后落脚点在\u003ccode\u003ethis._handle = new TCP()\u003c/code\u003e，而TCP：\u003ccode\u003econst TCP = process.binding('tcp_wrap').TCP\u003c/code\u003e，this._handle 正是server._handle，在初始化Server实例时候所建立的，process.binding是用来连接Node.js的内建模块，这里要看tcp_wrap.cc文件\u003c/p\u003e\n\u003ch1\u003etcp_wrap.cc文件开始的C++和C语言\u003c/h1\u003e\n\u003cp\u003etcp_wrap.cc文件里面有这里几个方法,\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eTCPWrap::TCPWrap(Environment* env, Local\u0026lt;Object\u0026gt; object)\n    : ConnectionWrap(env,\n                     object,\n                     AsyncWrap::PROVIDER_TCPWRAP) {\n  \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e r = uv_tcp_init(env-\u0026gt;event_loop(), \u0026amp;handle_);\n  CHECK_EQ(r, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);  \u003cspan class=\"hljs-comment\"\u003e// How do we proxy this error up to javascript?\u003c/span\u003e\n                   \u003cspan class=\"hljs-comment\"\u003e// Suggestion: uv_tcp_init() returns void.\u003c/span\u003e\n  UpdateWriteQueueSize();\n}\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e TCPWrap::Listen(\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e FunctionCallbackInfo\u0026lt;Value\u0026gt;\u0026amp; args) {\n  TCPWrap* wrap;\n  ASSIGN_OR_RETURN_UNWRAP(\u0026amp;wrap,\n                          args.Holder(),\n                          args.GetReturnValue().Set(UV_EBADF));\n  \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e backlog = args[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]-\u0026gt;Int32Value();\n  \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e err = uv_listen(\u003cspan class=\"hljs-keyword\"\u003ereinterpret_cast\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-keyword\"\u003euv_stream_t\u003c/span\u003e*\u0026gt;(\u0026amp;wrap-\u0026gt;handle_),\n                      backlog,\n                      OnConnection);\n  args.GetReturnValue().Set(err);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTCPWrap方法里面调用了tcp.c里面的方法，建立TCP的句柄，函数形参包括uv_loop_t，uv_tcp_t和flags标识，接着对uv_tcp_t结构体中的各项进行初始设置，并调用uv__handle_init循环；\n为什么要提及listen方法？在net.js的setupListenHandle方法里面明确用到了\u003ccode\u003ethis._handle.listen(backlog || 511)\u003c/code\u003e，在stream.c里面的uv_listen方法来监听，根据uv_stream_t结构体的type来判断是否是TCP类型，在tcp.c，uv_tcp_listen中通过uv_tcp_t结构体的flags来判断执行；\u003c/p\u003e\n\u003cp\u003e在uv.h里面定义了上面的结构体，每个结构体都有自己的成员。刚开始接触的时候，看到这里么就有种越看越乱，越看越多的感觉，这个时候开始知道有libuv；\u003c/p\u003e\n\u003ch1\u003elibuv为何物\u003c/h1\u003e\n\u003cp\u003e简单来讲就是跨平台io库，整合了window下的iocp和Linux的epoll，官网上有下图\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/libuv.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e在node_maic.cc里面调用了start方法，加载bootstrap_node.js文件，并同时while循环调用uv_run()，uv_run就是libuv事件循环的入口，这个方法的执行如下图\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/uv_run.PNG\" alt=\"\"\u003e\n其中每一个模块和uv_run中的语句是对应，其中在window里面用\u003ccode\u003e(*poll)(loop, timeout)\u003c/code\u003e，而unix采用\u003ccode\u003euv__io_poll(loop, timeout)\u003c/code\u003e。\n上文提到的结构体uv_xx_s/t正是libuv的观察者，其中对应的类型uv_TYPE_t中的type指定了handle的使用目的。 至于具体的机理还是看\u003ca href=\"http://docs.libuv.org/en/v1.x/#documentation\" target=\"_blank\"\u003e官方文档好\u003c/a\u003e。\n看过了文档以及api之后，再去看Node.js里面代码，well， 还是一脸懵逼。。。。\u003c/p\u003e\n\u003cp\u003e只有硬啃下来，发现就是观察体太过长了，一遍一遍的嵌套宏定义，只是到最后还是没有完全读懂libuv如何实现通信，或许以后有下一篇来阐述libuv吧\u003c/p\u003e\n\u003cp\u003e参考资料\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://cnodejs.org/topic/5716137fe84805cd5410ea21\" target=\"_blank\"\u003enode源码详解（六） —— 从server.listen 到事件循环\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://luohaha.github.io/Chinese-uvbook/source/networking.html\" target=\"_blank\"\u003euvbook 中文教程\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://zhenhua-lee.github.io/node/socket.html\" target=\"_blank\"\u003e初步研究node中的网络通信模块\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://yjhjstz.gitbooks.io/deep-into-node/\" target=\"_blank\"\u003e《深入理解Node.js：核心思想与源码分析》\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n"}},"buildId":"sIsd3fYQzJCXbU_Js9qRI","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/sIsd3fYQzJCXbU_Js9qRI/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/sIsd3fYQzJCXbU_Js9qRI/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/sIsd3fYQzJCXbU_Js9qRI/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" async=""></script></body></html>