<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">react 开启异步渲染与优先级</title><link rel="preload" href="/blog-sys/_next/static/_P3qZyp8~kfTSPLoPskhF/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/_P3qZyp8~kfTSPLoPskhF/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/_P3qZyp8~kfTSPLoPskhF/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.491f56ba.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/blog-sys/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___3Hk0c hasBannerImg___86Yg8"><a class="logo___1KD30" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___1qXLb" href="/blog-sys/">Home</a></li></ul></nav><header style="background-image:url(https://github.com/funfish/blog/raw/master/images/react16AsyncFiber.PNG);background-size:contain" class="banner___2FJmA"><div class="mask___1Eks5"></div><div class="postTitleWrap___1QiCz"><h1 class="postTitle___26vXM">react 开启异步渲染与优先级</h1><p>July 30, 2018</p></div></header><article class="postWrapper___3NXol post-article"><div><p>在研究时间调度时就有 React 的异步渲染的迹象了，只是在实际应用中却不知道如何开启，如何跟踪，后来看了 <a href="https://github.com/koba04/react-fiber-resources" target="_blank">react-fiber-resources</a> 上面介绍的 <strong>Try React Fiber asynchronous rendering!</strong>。其实在 React 的博客 <a href="https://reactjs.org/blog/2017/09/26/react-v16.0.html" target="_blank">React v16.0</a> 发布之际就已经说明了：</p>
<blockquote>
<p>We think async rendering is a big deal, and represents the future of React. To make migration to v16.0 as smooth as possible, we’re not enabling any async features yet, but we’re excited to start rolling them out in the coming months. Stay tuned!</p>
</blockquote>
<p>直到现在本文研究的版本 16.4.1，异步渲染 async rendering 仍然没有正式推出，其中日常开发中可以看到 <code>ReactDOM.render(element, container)</code> 模式采用的就是 legacyCreateRootFromDOMContainer 这类方式，在生成 root 的时候直接将 root.current 的 mode 赋值为 0，也就是常见的同步的方式。fiber 的模式 mode 有以下类型：</p>
<pre class="hljs"><code><span class="hljs-comment">// ReactTypeOfMode.js</span>
<span class="hljs-keyword">const</span> NoContext = <span class="hljs-number">0b000</span>;
<span class="hljs-keyword">const</span> AsyncMode = <span class="hljs-number">0b001</span>;
<span class="hljs-keyword">const</span> StrictMode = <span class="hljs-number">0b010</span>;
<span class="hljs-keyword">const</span> ProfileMode = <span class="hljs-number">0b100</span>;
</code></pre>
<p>StrictMode/ProfileMode 在源码中似乎是用于开发中的，于是看这里的 AsyncMode 模式，也就是异步模式。只是通过官网教程介绍的方式是无法开启异步模式，还没有大规模的推广，现在日常开发用的 React 基本上还是同步模式 sync，也就是上面的 NoContext。</p>
<p>那如何开始异步模式呢？在上文链接中有介绍到。可以通过以下方式：</p>
<pre class="hljs"><code><span class="hljs-comment">// 较于之前的方式，将 container 与 element 分开。通过 unstable_createRoot </span>
<span class="hljs-comment">// 创建异步的 fiber。</span>
<span class="hljs-keyword">const</span> root = ReactDOM.unstable_createRoot(container);
root.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>);
</span></code></pre>
<p>unstable_createRoot 的方式和先前一样，创建根部 root，即是 ReactRoot 对象，当前 current fiber 为异步模式，mode 为 3 即 <code>AsyncMode|StrictMode</code>。再进行 rendering 渲染。</p>
<h2>expirationTime</h2>
<p>在早期的 React 版本里面采用了优先级的 Priority 模式，如下：</p>
<pre class="hljs"><code><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">NoWork</span>: <span class="hljs-number">0</span>,              <span class="hljs-comment">// No work is pending.</span>
  SynchronousPriority: <span class="hljs-number">1</span>, <span class="hljs-comment">// For controlled text inputs. Synchronous side-effects.</span>
  AnimationPriority: <span class="hljs-number">2</span>,   <span class="hljs-comment">// Needs to complete before the next frame.</span>
  HighPriority: <span class="hljs-number">3</span>,        <span class="hljs-comment">// Interaction that needs to complete pretty soon to feel responsive.</span>
  LowPriority: <span class="hljs-number">4</span>,         <span class="hljs-comment">// Data fetching, or result from updating stores.</span>
  OffscreenPriority: <span class="hljs-number">5</span>,   <span class="hljs-comment">// Won't be visible but do the work in case it becomes visible.</span>
};
</code></pre>
<p>到了该版本 React 16.4.1，采用的则是 fiber.mode 以及 expirationTime 相继结合来实现异步以及优先级的。已经没有上面这些标志的存在了。通过统一的参数 expirationTime 来表示优先级。分为两种情况：</p>
<ol>
<li>expirationTime 为 1，就是同步模式，也就类似于 React 16 之前的 stack 情况，程序会按照顺序执行下去，直到结束；</li>
<li>expirationTime 不为 1 的时候，则其值越低，优先级越高。rootExpirationTime 不为 1 的时候会启动异步模式。</li>
</ol>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeExpirationForFiber</span>(<span class="hljs-params">currentTime: ExpirationTime, fiber: Fiber</span>) </span>{
  <span class="hljs-keyword">let</span> expirationTime;
  <span class="hljs-keyword">if</span> (expirationContext !== NoWork) {
    expirationTime = expirationContext;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isWorking) {
    <span class="hljs-keyword">if</span> (isCommitting) {
      <span class="hljs-comment">// 在 commit 阶段更新任务，需要给予同步优先级</span>
      expirationTime = Sync;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 渲染阶段则设置为渲染结束后的下次时间</span>
      expirationTime = nextRenderExpirationTime;
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 非执行阶段，根据 fiber.mode来设置 expirationTime。</span>
    <span class="hljs-keyword">if</span> (fiber.mode &amp; AsyncMode) {
      <span class="hljs-comment">// 异步模式下</span>
      <span class="hljs-keyword">if</span> (isBatchingInteractiveUpdates) {
        expirationTime = computeInteractiveExpiration(currentTime);
      } <span class="hljs-keyword">else</span> {
        expirationTime = computeAsyncExpiration(currentTime);
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 同步模式下</span>
      expirationTime = Sync;
    }
  }
  <span class="hljs-comment">// ...省略交互相关部分</span>
  <span class="hljs-keyword">return</span> expirationTime;
}
</code></pre>
<p>如果 <code>fiber.mode === AsyncMode</code>，则 expirationTime 为大于 1 的值，同步则为 1，当然同步是优先级最高的，异步具有 LowPriority。前面博客都是同步模式下研究的。对于异步时间的计算，按照 当前时间为基准，250ms 为一个单元。两个异步 fiber 计算 expirationTime 的时候，如果当前时间 <code>currentTime/25</code> 为相同整数，则这两个异步 fiber 具有相同的优先级。</p>
<p>render/reconciliation 阶段的从深调用栈返回处理交互事件，也和时间的计算有关系。在上文中提到，在 workLoop 中通过计算 deadline.timeRemaining() 来判断是否还剩余时间，这个也就是 requestIdleCallback 的用法。但是有一点不同，在 performWork 里面，也就是即将进入 performWorkOnRoot 之前有：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performWork</span>(<span class="hljs-params">minExpirationTime, dl</span>) </span>{
  <span class="hljs-comment">//...省略部分</span>
  <span class="hljs-keyword">if</span>(dl !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">while</span> (
      nextFlushedRoot !== <span class="hljs-literal">null</span> &amp;&amp;
      nextFlushedExpirationTime !== NoWork &amp;&amp;
      (minExpirationTime === NoWork ||
        minExpirationTime &gt;= nextFlushedExpirationTime) &amp;&amp;
      (!deadlineDidExpire ||
        recalculateCurrentTime() &gt;= nextFlushedExpirationTime)
    ) {
      recalculateCurrentTime();
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, <span class="hljs-literal">true</span>);
      findHighestPriorityRoot();
    }
  }
  <span class="hljs-comment">// 省略部分</span>
}
</code></pre>
<p>由前文可知当没有剩余时间的时候会终结 workLoop 循环，同时令 <code>deadlineDidExpire = true</code>，只是如果这样还是不足以使得 performWork 里面的循环为 false，必须要 <code>recalculateCurrentTime() &gt;= nextFlushedExpirationTime</code>。recalculateCurrentTime 计算的是当前时间，nextFlushedExpirationTime 则是 root.expirationTime，初看的时候会自然的认为后者肯定是更小的，但是恰恰相反。<strong>异步的 expirationTime 是以 5000ms 为基数， 250ms 为单位计算的</strong>。所以只有当超出时间过长，比如五六秒，才会变为立刻执行的情况。在之前的小版本里面，基本是只要是剩余时间不足就立刻中断，没有和 nextFlushedExpirationTime 比较的过程。</p>
<p>前面的 expirationContext 涉及到 ReactDOM 的另一个异步更新的 API，如下：</p>
<pre class="hljs"><code>ReactDOM.unstable_deferredUpdates(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>. container);
  // or
  instance.setState(() =&gt; newState);
}); 
</span></code></pre>
<p>与 unstable_createRoot 一开始就创建异步模式的 fiber 不同，unstable_deferredUpdates 会修改 expirationContext 生成异步的 expirationTime 达到延迟更新的目的，</p>
<h2>优先级</h2>
<p>当 <code>expirationTime !== SYNC</code> 时候，fiber 就具有不同的优先级，有优先级的前提是异步。异步模式是通过时间调度方式实现的，具体看前文 <a href="https://github.com/funfish/blog/blob/master/30.%20react%20%E6%97%B6%E9%97%B4%E8%B0%83%E5%BA%A6.md" target="_blank">react 时间调度</a>。那优先级是定义好了，但是如何保证高优先级的先执行呢？</p>
<p>在 renderRoot 的时侯，会有 <code>nextRenderExpirationTime = root.nextExpirationTimeToWorkOn</code>，所以当初次构建 workInProgress Tree 的时候所有的 fiber 也就是 expirationTime 都是一致，哪怕是异步组件 React.unstable_AsyncMode。生产的 expriationTime 是一样的，但是若中途出现优先级更高的事件，导致基准的 expriationTime 改变又如何？</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beginWork</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
  <span class="hljs-keyword">if</span> (
    workInProgress.expirationTime === NoWork ||
    workInProgress.expirationTime &gt; renderExpirationTime
  ) {
    <span class="hljs-keyword">return</span> bailoutOnLowPriority(current, workInProgress);
  }
  <span class="hljs-comment">// ...省略后面 switch (workInProgress.tag) 的情况</span>
}
</code></pre>
<p>在 beginWork 就比较当前 fiber.expirationTime 和 renderExpirationTime 关系。renderExpirationTime 即是 nextRenderExpirationTime，是下次要渲染的时长，高于它，则该 fiber 将不会在该阶段中渲染。这种情况会发生在异步渲染里面，还在渲染阶段的时候，插入低优先级的的事件，这个时候将会产生更低优先级的 fiber，本轮 commit 结束后，会在下一次渲染阶段再做安排。</p>
<h3>update 的优先级</h3>
<p>在 fiber 里面有任务队列 updateQueue，该队列维护的是传参 element，是个链表结构，节点为 update。通过 update.nextEffect 来指向下一个节点。而这里的每个节点，则是需要更新的 element。update 结构如下：</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createUpdate</span>(<span class="hljs-params">expirationTime: ExpirationTime</span>): <span class="hljs-title">Update</span>&lt;*&gt; </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">expirationTime</span>: expirationTime,
    <span class="hljs-attr">tag</span>: UpdateState,
    <span class="hljs-attr">payload</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">callback</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">nextEffect</span>: <span class="hljs-literal">null</span>,
  };
}
</code></pre>
<p>expirationTime 是对应该节点的优先级。fiber 有优先级，这个 update 也有优先级，这个在 ReactUpdateQueue.js 开头的注释有介绍到：</p>
<ol>
<li>updates 的排序不是基于优先级的，而是基于插入顺序。</li>
<li>渲染阶段的时候，只有高优先级的 update 才会被被用到。</li>
</ol>
<p>以前版本里面，对 update 的处理是采用 insert 方式的，即是高优先级的会插入到低优先级 update 前面。而今则是通过 expirationTime 区分。</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processUpdateQueue</span>(<span class="hljs-params">workInProgress, queue, props, instance, renderExpirationTime</span>)</span>{
  <span class="hljs-comment">// ...省略部分</span>
  <span class="hljs-keyword">let</span> update = queue.firstUpdate;
  <span class="hljs-keyword">let</span> resultState = newBaseState;
  <span class="hljs-keyword">while</span> (update !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">const</span> updateExpirationTime = update.expirationTime;
    <span class="hljs-keyword">if</span> (updateExpirationTime &gt; renderExpirationTime) {
      <span class="hljs-comment">// This update does not have sufficient priority. Skip it.</span>
      <span class="hljs-keyword">if</span> (newFirstUpdate === <span class="hljs-literal">null</span>) {
        newFirstUpdate = update;
        newBaseState = resultState;
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// This update does have sufficient priority. Process it and compute</span>
      <span class="hljs-comment">// a new result.</span>
      <span class="hljs-comment">// ..,省略</span>
    }
  }
  <span class="hljs-comment">// ..,省略</span>
}
</code></pre>
<p>可以看出只有小于或者等于 renderExpirationTime 的才会被采用，你没有看错是小于或者等于，而不仅仅是小于。因为同优先级的 update 是会被采用的，这个 bug 已经在 <a href="https://github.com/facebook/react/pull/13071" target="_blank">Always batch updates of like priority within the same event</a> 被修复了，well，同时也修改和很多地方，最大的是 requestCurrentTime 取代了 recalculateCurrentTime。
没有被采用的 update 最怎么样呢？通过 newFirstUpdate 保留到 updateQueue 里的 firstUpdate 了。下次渲染的时候，才会被用到。</p>
<h2>总结</h2>
<p>异步渲染里面，除了 ReactDOM.unstable_createRoot/ReactDOM.unstable_deferredUpdates 以外，还有 React.unstable_AsyncMode 的方式创建异步组件，React.Timeout 这样的 TimeoutComponent 组件。只是目前关于异步，优先级，React 本身还在一直更新中，指不定有不少的坑，当然都冠以 unstable 的名号了，谁用谁负责，就像 UNSAFE_componentWillReceiveProps 之类的。期待未来 React 异步渲染正式推出那天。期待下图：
<img src="https://github.com/funfish/blog/raw/master/images/react16AsyncFiber.PNG" alt=""></p>
<p>优先级里面还有更多的是生成 workInprogress tree 的时候也会设置，包括是否是 offscreen/hidden，这里就不做研究了。</p>
<h2>参考</h2>
<ol>
<li><a href="https://medium.com/@_cybai/%E7%BF%BB%E8%AD%AF-react-fiber-%E7%8F%BE%E7%8B%80%E7%A2%BA%E8%AA%8D-fd3808072279" target="_blank">[翻譯] React Fiber 現狀確認</a></li>
<li><a href="https://github.com/koba04/react-fiber-resources" target="_blank">react-fiber-resources</a> 里面的资源都灰常好！如这篇 <a href="https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec" target="_blank">Build your own React Fiber</a>，还有视频系列。</li>
<li><a href="https://gist.github.com/acdlite/f31becd03e2f5feb9b4b22267a58bc1f" target="_blank">coordinating-async-react</a></li>
</ol>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"July 30, 2018","title":"react 开启异步渲染与优先级","bannerUrl":"https://github.com/funfish/blog/raw/master/images/react16AsyncFiber.PNG","content":"\u003cp\u003e在研究时间调度时就有 React 的异步渲染的迹象了，只是在实际应用中却不知道如何开启，如何跟踪，后来看了 \u003ca href=\"https://github.com/koba04/react-fiber-resources\" target=\"_blank\"\u003ereact-fiber-resources\u003c/a\u003e 上面介绍的 \u003cstrong\u003eTry React Fiber asynchronous rendering!\u003c/strong\u003e。其实在 React 的博客 \u003ca href=\"https://reactjs.org/blog/2017/09/26/react-v16.0.html\" target=\"_blank\"\u003eReact v16.0\u003c/a\u003e 发布之际就已经说明了：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWe think async rendering is a big deal, and represents the future of React. To make migration to v16.0 as smooth as possible, we’re not enabling any async features yet, but we’re excited to start rolling them out in the coming months. Stay tuned!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e直到现在本文研究的版本 16.4.1，异步渲染 async rendering 仍然没有正式推出，其中日常开发中可以看到 \u003ccode\u003eReactDOM.render(element, container)\u003c/code\u003e 模式采用的就是 legacyCreateRootFromDOMContainer 这类方式，在生成 root 的时候直接将 root.current 的 mode 赋值为 0，也就是常见的同步的方式。fiber 的模式 mode 有以下类型：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// ReactTypeOfMode.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e NoContext = \u003cspan class=\"hljs-number\"\u003e0b000\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e AsyncMode = \u003cspan class=\"hljs-number\"\u003e0b001\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e StrictMode = \u003cspan class=\"hljs-number\"\u003e0b010\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ProfileMode = \u003cspan class=\"hljs-number\"\u003e0b100\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eStrictMode/ProfileMode 在源码中似乎是用于开发中的，于是看这里的 AsyncMode 模式，也就是异步模式。只是通过官网教程介绍的方式是无法开启异步模式，还没有大规模的推广，现在日常开发用的 React 基本上还是同步模式 sync，也就是上面的 NoContext。\u003c/p\u003e\n\u003cp\u003e那如何开始异步模式呢？在上文链接中有介绍到。可以通过以下方式：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 较于之前的方式，将 container 与 element 分开。通过 unstable_createRoot \u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 创建异步的 fiber。\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e root = ReactDOM.unstable_createRoot(container);\nroot.render(\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eApp\u003c/span\u003e /\u0026gt;\u003c/span\u003e);\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eunstable_createRoot 的方式和先前一样，创建根部 root，即是 ReactRoot 对象，当前 current fiber 为异步模式，mode 为 3 即 \u003ccode\u003eAsyncMode|StrictMode\u003c/code\u003e。再进行 rendering 渲染。\u003c/p\u003e\n\u003ch2\u003eexpirationTime\u003c/h2\u003e\n\u003cp\u003e在早期的 React 版本里面采用了优先级的 Priority 模式，如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = {\n  \u003cspan class=\"hljs-attr\"\u003eNoWork\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,              \u003cspan class=\"hljs-comment\"\u003e// No work is pending.\u003c/span\u003e\n  SynchronousPriority: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// For controlled text inputs. Synchronous side-effects.\u003c/span\u003e\n  AnimationPriority: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,   \u003cspan class=\"hljs-comment\"\u003e// Needs to complete before the next frame.\u003c/span\u003e\n  HighPriority: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,        \u003cspan class=\"hljs-comment\"\u003e// Interaction that needs to complete pretty soon to feel responsive.\u003c/span\u003e\n  LowPriority: \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,         \u003cspan class=\"hljs-comment\"\u003e// Data fetching, or result from updating stores.\u003c/span\u003e\n  OffscreenPriority: \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,   \u003cspan class=\"hljs-comment\"\u003e// Won't be visible but do the work in case it becomes visible.\u003c/span\u003e\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e到了该版本 React 16.4.1，采用的则是 fiber.mode 以及 expirationTime 相继结合来实现异步以及优先级的。已经没有上面这些标志的存在了。通过统一的参数 expirationTime 来表示优先级。分为两种情况：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eexpirationTime 为 1，就是同步模式，也就类似于 React 16 之前的 stack 情况，程序会按照顺序执行下去，直到结束；\u003c/li\u003e\n\u003cli\u003eexpirationTime 不为 1 的时候，则其值越低，优先级越高。rootExpirationTime 不为 1 的时候会启动异步模式。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecomputeExpirationForFiber\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrentTime: ExpirationTime, fiber: Fiber\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e expirationTime;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (expirationContext !== NoWork) {\n    expirationTime = expirationContext;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isWorking) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isCommitting) {\n      \u003cspan class=\"hljs-comment\"\u003e// 在 commit 阶段更新任务，需要给予同步优先级\u003c/span\u003e\n      expirationTime = Sync;\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// 渲染阶段则设置为渲染结束后的下次时间\u003c/span\u003e\n      expirationTime = nextRenderExpirationTime;\n    }\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 非执行阶段，根据 fiber.mode来设置 expirationTime。\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (fiber.mode \u0026amp; AsyncMode) {\n      \u003cspan class=\"hljs-comment\"\u003e// 异步模式下\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isBatchingInteractiveUpdates) {\n        expirationTime = computeInteractiveExpiration(currentTime);\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        expirationTime = computeAsyncExpiration(currentTime);\n      }\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// 同步模式下\u003c/span\u003e\n      expirationTime = Sync;\n    }\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// ...省略交互相关部分\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e expirationTime;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果 \u003ccode\u003efiber.mode === AsyncMode\u003c/code\u003e，则 expirationTime 为大于 1 的值，同步则为 1，当然同步是优先级最高的，异步具有 LowPriority。前面博客都是同步模式下研究的。对于异步时间的计算，按照 当前时间为基准，250ms 为一个单元。两个异步 fiber 计算 expirationTime 的时候，如果当前时间 \u003ccode\u003ecurrentTime/25\u003c/code\u003e 为相同整数，则这两个异步 fiber 具有相同的优先级。\u003c/p\u003e\n\u003cp\u003erender/reconciliation 阶段的从深调用栈返回处理交互事件，也和时间的计算有关系。在上文中提到，在 workLoop 中通过计算 deadline.timeRemaining() 来判断是否还剩余时间，这个也就是 requestIdleCallback 的用法。但是有一点不同，在 performWork 里面，也就是即将进入 performWorkOnRoot 之前有：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eperformWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eminExpirationTime, dl\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e//...省略部分\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(dl !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (\n      nextFlushedRoot !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026amp;\u0026amp;\n      nextFlushedExpirationTime !== NoWork \u0026amp;\u0026amp;\n      (minExpirationTime === NoWork ||\n        minExpirationTime \u0026gt;= nextFlushedExpirationTime) \u0026amp;\u0026amp;\n      (!deadlineDidExpire ||\n        recalculateCurrentTime() \u0026gt;= nextFlushedExpirationTime)\n    ) {\n      recalculateCurrentTime();\n      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n      findHighestPriorityRoot();\n    }\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 省略部分\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e由前文可知当没有剩余时间的时候会终结 workLoop 循环，同时令 \u003ccode\u003edeadlineDidExpire = true\u003c/code\u003e，只是如果这样还是不足以使得 performWork 里面的循环为 false，必须要 \u003ccode\u003erecalculateCurrentTime() \u0026gt;= nextFlushedExpirationTime\u003c/code\u003e。recalculateCurrentTime 计算的是当前时间，nextFlushedExpirationTime 则是 root.expirationTime，初看的时候会自然的认为后者肯定是更小的，但是恰恰相反。\u003cstrong\u003e异步的 expirationTime 是以 5000ms 为基数， 250ms 为单位计算的\u003c/strong\u003e。所以只有当超出时间过长，比如五六秒，才会变为立刻执行的情况。在之前的小版本里面，基本是只要是剩余时间不足就立刻中断，没有和 nextFlushedExpirationTime 比较的过程。\u003c/p\u003e\n\u003cp\u003e前面的 expirationContext 涉及到 ReactDOM 的另一个异步更新的 API，如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eReactDOM.unstable_deferredUpdates(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n  ReactDOM.render(\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eApp\u003c/span\u003e /\u0026gt;\u003c/span\u003e. container);\n  // or\n  instance.setState(() =\u0026gt; newState);\n}); \n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e与 unstable_createRoot 一开始就创建异步模式的 fiber 不同，unstable_deferredUpdates 会修改 expirationContext 生成异步的 expirationTime 达到延迟更新的目的，\u003c/p\u003e\n\u003ch2\u003e优先级\u003c/h2\u003e\n\u003cp\u003e当 \u003ccode\u003eexpirationTime !== SYNC\u003c/code\u003e 时候，fiber 就具有不同的优先级，有优先级的前提是异步。异步模式是通过时间调度方式实现的，具体看前文 \u003ca href=\"https://github.com/funfish/blog/blob/master/30.%20react%20%E6%97%B6%E9%97%B4%E8%B0%83%E5%BA%A6.md\" target=\"_blank\"\u003ereact 时间调度\u003c/a\u003e。那优先级是定义好了，但是如何保证高优先级的先执行呢？\u003c/p\u003e\n\u003cp\u003e在 renderRoot 的时侯，会有 \u003ccode\u003enextRenderExpirationTime = root.nextExpirationTimeToWorkOn\u003c/code\u003e，所以当初次构建 workInProgress Tree 的时候所有的 fiber 也就是 expirationTime 都是一致，哪怕是异步组件 React.unstable_AsyncMode。生产的 expriationTime 是一样的，但是若中途出现优先级更高的事件，导致基准的 expriationTime 改变又如何？\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ebeginWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, workInProgress, renderExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n    workInProgress.expirationTime === NoWork ||\n    workInProgress.expirationTime \u0026gt; renderExpirationTime\n  ) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e bailoutOnLowPriority(current, workInProgress);\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// ...省略后面 switch (workInProgress.tag) 的情况\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 beginWork 就比较当前 fiber.expirationTime 和 renderExpirationTime 关系。renderExpirationTime 即是 nextRenderExpirationTime，是下次要渲染的时长，高于它，则该 fiber 将不会在该阶段中渲染。这种情况会发生在异步渲染里面，还在渲染阶段的时候，插入低优先级的的事件，这个时候将会产生更低优先级的 fiber，本轮 commit 结束后，会在下一次渲染阶段再做安排。\u003c/p\u003e\n\u003ch3\u003eupdate 的优先级\u003c/h3\u003e\n\u003cp\u003e在 fiber 里面有任务队列 updateQueue，该队列维护的是传参 element，是个链表结构，节点为 update。通过 update.nextEffect 来指向下一个节点。而这里的每个节点，则是需要更新的 element。update 结构如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecreateUpdate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eexpirationTime: ExpirationTime\u003c/span\u003e): \u003cspan class=\"hljs-title\"\u003eUpdate\u003c/span\u003e\u0026lt;*\u0026gt; \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eexpirationTime\u003c/span\u003e: expirationTime,\n    \u003cspan class=\"hljs-attr\"\u003etag\u003c/span\u003e: UpdateState,\n    \u003cspan class=\"hljs-attr\"\u003epayload\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ecallback\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003enextEffect\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eexpirationTime 是对应该节点的优先级。fiber 有优先级，这个 update 也有优先级，这个在 ReactUpdateQueue.js 开头的注释有介绍到：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eupdates 的排序不是基于优先级的，而是基于插入顺序。\u003c/li\u003e\n\u003cli\u003e渲染阶段的时候，只有高优先级的 update 才会被被用到。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e以前版本里面，对 update 的处理是采用 insert 方式的，即是高优先级的会插入到低优先级 update 前面。而今则是通过 expirationTime 区分。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eprocessUpdateQueue\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eworkInProgress, queue, props, instance, renderExpirationTime\u003c/span\u003e)\u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// ...省略部分\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e update = queue.firstUpdate;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e resultState = newBaseState;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (update !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e updateExpirationTime = update.expirationTime;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (updateExpirationTime \u0026gt; renderExpirationTime) {\n      \u003cspan class=\"hljs-comment\"\u003e// This update does not have sufficient priority. Skip it.\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (newFirstUpdate === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n        newFirstUpdate = update;\n        newBaseState = resultState;\n      }\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// This update does have sufficient priority. Process it and compute\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e// a new result.\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e// ..,省略\u003c/span\u003e\n    }\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// ..,省略\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看出只有小于或者等于 renderExpirationTime 的才会被采用，你没有看错是小于或者等于，而不仅仅是小于。因为同优先级的 update 是会被采用的，这个 bug 已经在 \u003ca href=\"https://github.com/facebook/react/pull/13071\" target=\"_blank\"\u003eAlways batch updates of like priority within the same event\u003c/a\u003e 被修复了，well，同时也修改和很多地方，最大的是 requestCurrentTime 取代了 recalculateCurrentTime。\n没有被采用的 update 最怎么样呢？通过 newFirstUpdate 保留到 updateQueue 里的 firstUpdate 了。下次渲染的时候，才会被用到。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e异步渲染里面，除了 ReactDOM.unstable_createRoot/ReactDOM.unstable_deferredUpdates 以外，还有 React.unstable_AsyncMode 的方式创建异步组件，React.Timeout 这样的 TimeoutComponent 组件。只是目前关于异步，优先级，React 本身还在一直更新中，指不定有不少的坑，当然都冠以 unstable 的名号了，谁用谁负责，就像 UNSAFE_componentWillReceiveProps 之类的。期待未来 React 异步渲染正式推出那天。期待下图：\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/react16AsyncFiber.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e优先级里面还有更多的是生成 workInprogress tree 的时候也会设置，包括是否是 offscreen/hidden，这里就不做研究了。\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://medium.com/@_cybai/%E7%BF%BB%E8%AD%AF-react-fiber-%E7%8F%BE%E7%8B%80%E7%A2%BA%E8%AA%8D-fd3808072279\" target=\"_blank\"\u003e[翻譯] React Fiber 現狀確認\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/koba04/react-fiber-resources\" target=\"_blank\"\u003ereact-fiber-resources\u003c/a\u003e 里面的资源都灰常好！如这篇 \u003ca href=\"https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec\" target=\"_blank\"\u003eBuild your own React Fiber\u003c/a\u003e，还有视频系列。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://gist.github.com/acdlite/f31becd03e2f5feb9b4b22267a58bc1f\" target=\"_blank\"\u003ecoordinating-async-react\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"July 30, 2018","title":"react 开启异步渲染与优先级","bannerUrl":"https://github.com/funfish/blog/raw/master/images/react16AsyncFiber.PNG","content":"\u003cp\u003e在研究时间调度时就有 React 的异步渲染的迹象了，只是在实际应用中却不知道如何开启，如何跟踪，后来看了 \u003ca href=\"https://github.com/koba04/react-fiber-resources\" target=\"_blank\"\u003ereact-fiber-resources\u003c/a\u003e 上面介绍的 \u003cstrong\u003eTry React Fiber asynchronous rendering!\u003c/strong\u003e。其实在 React 的博客 \u003ca href=\"https://reactjs.org/blog/2017/09/26/react-v16.0.html\" target=\"_blank\"\u003eReact v16.0\u003c/a\u003e 发布之际就已经说明了：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWe think async rendering is a big deal, and represents the future of React. To make migration to v16.0 as smooth as possible, we’re not enabling any async features yet, but we’re excited to start rolling them out in the coming months. Stay tuned!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e直到现在本文研究的版本 16.4.1，异步渲染 async rendering 仍然没有正式推出，其中日常开发中可以看到 \u003ccode\u003eReactDOM.render(element, container)\u003c/code\u003e 模式采用的就是 legacyCreateRootFromDOMContainer 这类方式，在生成 root 的时候直接将 root.current 的 mode 赋值为 0，也就是常见的同步的方式。fiber 的模式 mode 有以下类型：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// ReactTypeOfMode.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e NoContext = \u003cspan class=\"hljs-number\"\u003e0b000\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e AsyncMode = \u003cspan class=\"hljs-number\"\u003e0b001\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e StrictMode = \u003cspan class=\"hljs-number\"\u003e0b010\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ProfileMode = \u003cspan class=\"hljs-number\"\u003e0b100\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eStrictMode/ProfileMode 在源码中似乎是用于开发中的，于是看这里的 AsyncMode 模式，也就是异步模式。只是通过官网教程介绍的方式是无法开启异步模式，还没有大规模的推广，现在日常开发用的 React 基本上还是同步模式 sync，也就是上面的 NoContext。\u003c/p\u003e\n\u003cp\u003e那如何开始异步模式呢？在上文链接中有介绍到。可以通过以下方式：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 较于之前的方式，将 container 与 element 分开。通过 unstable_createRoot \u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 创建异步的 fiber。\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e root = ReactDOM.unstable_createRoot(container);\nroot.render(\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eApp\u003c/span\u003e /\u0026gt;\u003c/span\u003e);\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eunstable_createRoot 的方式和先前一样，创建根部 root，即是 ReactRoot 对象，当前 current fiber 为异步模式，mode 为 3 即 \u003ccode\u003eAsyncMode|StrictMode\u003c/code\u003e。再进行 rendering 渲染。\u003c/p\u003e\n\u003ch2\u003eexpirationTime\u003c/h2\u003e\n\u003cp\u003e在早期的 React 版本里面采用了优先级的 Priority 模式，如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = {\n  \u003cspan class=\"hljs-attr\"\u003eNoWork\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,              \u003cspan class=\"hljs-comment\"\u003e// No work is pending.\u003c/span\u003e\n  SynchronousPriority: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// For controlled text inputs. Synchronous side-effects.\u003c/span\u003e\n  AnimationPriority: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,   \u003cspan class=\"hljs-comment\"\u003e// Needs to complete before the next frame.\u003c/span\u003e\n  HighPriority: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,        \u003cspan class=\"hljs-comment\"\u003e// Interaction that needs to complete pretty soon to feel responsive.\u003c/span\u003e\n  LowPriority: \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,         \u003cspan class=\"hljs-comment\"\u003e// Data fetching, or result from updating stores.\u003c/span\u003e\n  OffscreenPriority: \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,   \u003cspan class=\"hljs-comment\"\u003e// Won't be visible but do the work in case it becomes visible.\u003c/span\u003e\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e到了该版本 React 16.4.1，采用的则是 fiber.mode 以及 expirationTime 相继结合来实现异步以及优先级的。已经没有上面这些标志的存在了。通过统一的参数 expirationTime 来表示优先级。分为两种情况：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eexpirationTime 为 1，就是同步模式，也就类似于 React 16 之前的 stack 情况，程序会按照顺序执行下去，直到结束；\u003c/li\u003e\n\u003cli\u003eexpirationTime 不为 1 的时候，则其值越低，优先级越高。rootExpirationTime 不为 1 的时候会启动异步模式。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecomputeExpirationForFiber\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrentTime: ExpirationTime, fiber: Fiber\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e expirationTime;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (expirationContext !== NoWork) {\n    expirationTime = expirationContext;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isWorking) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isCommitting) {\n      \u003cspan class=\"hljs-comment\"\u003e// 在 commit 阶段更新任务，需要给予同步优先级\u003c/span\u003e\n      expirationTime = Sync;\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// 渲染阶段则设置为渲染结束后的下次时间\u003c/span\u003e\n      expirationTime = nextRenderExpirationTime;\n    }\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 非执行阶段，根据 fiber.mode来设置 expirationTime。\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (fiber.mode \u0026amp; AsyncMode) {\n      \u003cspan class=\"hljs-comment\"\u003e// 异步模式下\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isBatchingInteractiveUpdates) {\n        expirationTime = computeInteractiveExpiration(currentTime);\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        expirationTime = computeAsyncExpiration(currentTime);\n      }\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// 同步模式下\u003c/span\u003e\n      expirationTime = Sync;\n    }\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// ...省略交互相关部分\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e expirationTime;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果 \u003ccode\u003efiber.mode === AsyncMode\u003c/code\u003e，则 expirationTime 为大于 1 的值，同步则为 1，当然同步是优先级最高的，异步具有 LowPriority。前面博客都是同步模式下研究的。对于异步时间的计算，按照 当前时间为基准，250ms 为一个单元。两个异步 fiber 计算 expirationTime 的时候，如果当前时间 \u003ccode\u003ecurrentTime/25\u003c/code\u003e 为相同整数，则这两个异步 fiber 具有相同的优先级。\u003c/p\u003e\n\u003cp\u003erender/reconciliation 阶段的从深调用栈返回处理交互事件，也和时间的计算有关系。在上文中提到，在 workLoop 中通过计算 deadline.timeRemaining() 来判断是否还剩余时间，这个也就是 requestIdleCallback 的用法。但是有一点不同，在 performWork 里面，也就是即将进入 performWorkOnRoot 之前有：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eperformWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eminExpirationTime, dl\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e//...省略部分\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(dl !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (\n      nextFlushedRoot !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026amp;\u0026amp;\n      nextFlushedExpirationTime !== NoWork \u0026amp;\u0026amp;\n      (minExpirationTime === NoWork ||\n        minExpirationTime \u0026gt;= nextFlushedExpirationTime) \u0026amp;\u0026amp;\n      (!deadlineDidExpire ||\n        recalculateCurrentTime() \u0026gt;= nextFlushedExpirationTime)\n    ) {\n      recalculateCurrentTime();\n      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n      findHighestPriorityRoot();\n    }\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 省略部分\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e由前文可知当没有剩余时间的时候会终结 workLoop 循环，同时令 \u003ccode\u003edeadlineDidExpire = true\u003c/code\u003e，只是如果这样还是不足以使得 performWork 里面的循环为 false，必须要 \u003ccode\u003erecalculateCurrentTime() \u0026gt;= nextFlushedExpirationTime\u003c/code\u003e。recalculateCurrentTime 计算的是当前时间，nextFlushedExpirationTime 则是 root.expirationTime，初看的时候会自然的认为后者肯定是更小的，但是恰恰相反。\u003cstrong\u003e异步的 expirationTime 是以 5000ms 为基数， 250ms 为单位计算的\u003c/strong\u003e。所以只有当超出时间过长，比如五六秒，才会变为立刻执行的情况。在之前的小版本里面，基本是只要是剩余时间不足就立刻中断，没有和 nextFlushedExpirationTime 比较的过程。\u003c/p\u003e\n\u003cp\u003e前面的 expirationContext 涉及到 ReactDOM 的另一个异步更新的 API，如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eReactDOM.unstable_deferredUpdates(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n  ReactDOM.render(\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eApp\u003c/span\u003e /\u0026gt;\u003c/span\u003e. container);\n  // or\n  instance.setState(() =\u0026gt; newState);\n}); \n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e与 unstable_createRoot 一开始就创建异步模式的 fiber 不同，unstable_deferredUpdates 会修改 expirationContext 生成异步的 expirationTime 达到延迟更新的目的，\u003c/p\u003e\n\u003ch2\u003e优先级\u003c/h2\u003e\n\u003cp\u003e当 \u003ccode\u003eexpirationTime !== SYNC\u003c/code\u003e 时候，fiber 就具有不同的优先级，有优先级的前提是异步。异步模式是通过时间调度方式实现的，具体看前文 \u003ca href=\"https://github.com/funfish/blog/blob/master/30.%20react%20%E6%97%B6%E9%97%B4%E8%B0%83%E5%BA%A6.md\" target=\"_blank\"\u003ereact 时间调度\u003c/a\u003e。那优先级是定义好了，但是如何保证高优先级的先执行呢？\u003c/p\u003e\n\u003cp\u003e在 renderRoot 的时侯，会有 \u003ccode\u003enextRenderExpirationTime = root.nextExpirationTimeToWorkOn\u003c/code\u003e，所以当初次构建 workInProgress Tree 的时候所有的 fiber 也就是 expirationTime 都是一致，哪怕是异步组件 React.unstable_AsyncMode。生产的 expriationTime 是一样的，但是若中途出现优先级更高的事件，导致基准的 expriationTime 改变又如何？\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ebeginWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecurrent, workInProgress, renderExpirationTime\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n    workInProgress.expirationTime === NoWork ||\n    workInProgress.expirationTime \u0026gt; renderExpirationTime\n  ) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e bailoutOnLowPriority(current, workInProgress);\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// ...省略后面 switch (workInProgress.tag) 的情况\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 beginWork 就比较当前 fiber.expirationTime 和 renderExpirationTime 关系。renderExpirationTime 即是 nextRenderExpirationTime，是下次要渲染的时长，高于它，则该 fiber 将不会在该阶段中渲染。这种情况会发生在异步渲染里面，还在渲染阶段的时候，插入低优先级的的事件，这个时候将会产生更低优先级的 fiber，本轮 commit 结束后，会在下一次渲染阶段再做安排。\u003c/p\u003e\n\u003ch3\u003eupdate 的优先级\u003c/h3\u003e\n\u003cp\u003e在 fiber 里面有任务队列 updateQueue，该队列维护的是传参 element，是个链表结构，节点为 update。通过 update.nextEffect 来指向下一个节点。而这里的每个节点，则是需要更新的 element。update 结构如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecreateUpdate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eexpirationTime: ExpirationTime\u003c/span\u003e): \u003cspan class=\"hljs-title\"\u003eUpdate\u003c/span\u003e\u0026lt;*\u0026gt; \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eexpirationTime\u003c/span\u003e: expirationTime,\n    \u003cspan class=\"hljs-attr\"\u003etag\u003c/span\u003e: UpdateState,\n    \u003cspan class=\"hljs-attr\"\u003epayload\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ecallback\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003enextEffect\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eexpirationTime 是对应该节点的优先级。fiber 有优先级，这个 update 也有优先级，这个在 ReactUpdateQueue.js 开头的注释有介绍到：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eupdates 的排序不是基于优先级的，而是基于插入顺序。\u003c/li\u003e\n\u003cli\u003e渲染阶段的时候，只有高优先级的 update 才会被被用到。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e以前版本里面，对 update 的处理是采用 insert 方式的，即是高优先级的会插入到低优先级 update 前面。而今则是通过 expirationTime 区分。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eprocessUpdateQueue\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eworkInProgress, queue, props, instance, renderExpirationTime\u003c/span\u003e)\u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// ...省略部分\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e update = queue.firstUpdate;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e resultState = newBaseState;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (update !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e updateExpirationTime = update.expirationTime;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (updateExpirationTime \u0026gt; renderExpirationTime) {\n      \u003cspan class=\"hljs-comment\"\u003e// This update does not have sufficient priority. Skip it.\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (newFirstUpdate === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n        newFirstUpdate = update;\n        newBaseState = resultState;\n      }\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// This update does have sufficient priority. Process it and compute\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e// a new result.\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e// ..,省略\u003c/span\u003e\n    }\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// ..,省略\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看出只有小于或者等于 renderExpirationTime 的才会被采用，你没有看错是小于或者等于，而不仅仅是小于。因为同优先级的 update 是会被采用的，这个 bug 已经在 \u003ca href=\"https://github.com/facebook/react/pull/13071\" target=\"_blank\"\u003eAlways batch updates of like priority within the same event\u003c/a\u003e 被修复了，well，同时也修改和很多地方，最大的是 requestCurrentTime 取代了 recalculateCurrentTime。\n没有被采用的 update 最怎么样呢？通过 newFirstUpdate 保留到 updateQueue 里的 firstUpdate 了。下次渲染的时候，才会被用到。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e异步渲染里面，除了 ReactDOM.unstable_createRoot/ReactDOM.unstable_deferredUpdates 以外，还有 React.unstable_AsyncMode 的方式创建异步组件，React.Timeout 这样的 TimeoutComponent 组件。只是目前关于异步，优先级，React 本身还在一直更新中，指不定有不少的坑，当然都冠以 unstable 的名号了，谁用谁负责，就像 UNSAFE_componentWillReceiveProps 之类的。期待未来 React 异步渲染正式推出那天。期待下图：\n\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/react16AsyncFiber.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e优先级里面还有更多的是生成 workInprogress tree 的时候也会设置，包括是否是 offscreen/hidden，这里就不做研究了。\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://medium.com/@_cybai/%E7%BF%BB%E8%AD%AF-react-fiber-%E7%8F%BE%E7%8B%80%E7%A2%BA%E8%AA%8D-fd3808072279\" target=\"_blank\"\u003e[翻譯] React Fiber 現狀確認\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/koba04/react-fiber-resources\" target=\"_blank\"\u003ereact-fiber-resources\u003c/a\u003e 里面的资源都灰常好！如这篇 \u003ca href=\"https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec\" target=\"_blank\"\u003eBuild your own React Fiber\u003c/a\u003e，还有视频系列。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://gist.github.com/acdlite/f31becd03e2f5feb9b4b22267a58bc1f\" target=\"_blank\"\u003ecoordinating-async-react\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n"}},"buildId":"_P3qZyp8~kfTSPLoPskhF","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/_P3qZyp8~kfTSPLoPskhF/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/_P3qZyp8~kfTSPLoPskhF/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/_P3qZyp8~kfTSPLoPskhF/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" async=""></script></body></html>