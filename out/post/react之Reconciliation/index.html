<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">react之Reconciliation</title><link rel="preload" href="/blog-sys/_next/static/ZS9D2ZWqQsj~9BxQGiyVr/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/ZS9D2ZWqQsj~9BxQGiyVr/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/ZS9D2ZWqQsj~9BxQGiyVr/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.491f56ba.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___3Hk0c "><a class="logo___1KD30" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___1qXLb" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___3VKNp"><h1 class="postTitle___26vXM">react之Reconciliation</h1><span class="postTime___16Ish">August 4, 2018</span></header><article class="postWrapper___3NXol post-article"><div><p>React 的特点在于其异步渲染，fiber机制，是其他类 react 框架无法比拟的。前面介绍了些很基本的异步渲染。接下来介绍一下传说中的 diff 算法吧。其实这个在 <a href="https://reactjs.org/docs/reconciliation.html" target="_blank">React 官方文档 Reconciliation</a> 里面早有介绍（advanced guide 里面的内容很多初级 React 工程师应该都没有看过，然而 advanced guide 里面包含了 context、错误边界、HOC、render props 以及 Reconciliation，没有看过的还请多刷几遍）。其中两大基准假设如下</p>
<ol>
<li>Two elements of different types will produce different trees.</li>
<li>The developer can hint at which child elements may be stable across different renders with a key prop.</li>
</ol>
<p>这两个准则很好的优化树的对比算法，遇到不同类型的元素自然是会生成不一样的树，而通过 key 这个 react 特性的属性可以来判断新旧元素是否是相似的，来减少优化步骤。</p>
<h2>reconcileChildFibers</h2>
<p>diff 的过程其实就是 reconciliation 的过程，在生成 workInProgress tree 的时候，新 fiber 的生成就取决于老 fiber 与相关 props。</p>
<p>元素的更新都需要有对应的子 fiber。下面以 fiber.tag 为 HostComponent 来举例子，HostComponent 指的就是一般的 'div' 'span' 等等常见的 HTML 标签。生成/更新子 fiber 的方式如下：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileChildFibers</span>(<span class="hljs-params">
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  newChild: any,
  expirationTime: ExpirationTime,
</span>): <span class="hljs-title">Fiber</span> | <span class="hljs-title">null</span> </span>{
  <span class="hljs-keyword">const</span> isUnkeyedTopLevelFragment =
    <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'object'</span> &amp;&amp;
    newChild !== <span class="hljs-literal">null</span> &amp;&amp;
    newChild.type === REACT_FRAGMENT_TYPE &amp;&amp;
    newChild.key === <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">if</span> (isUnkeyedTopLevelFragment) {
    newChild = newChild.props.children;
  }
  <span class="hljs-comment">// 新child是否为非空对象，</span>
  <span class="hljs-keyword">const</span> isObject = <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'object'</span> &amp;&amp; newChild !== <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (isObject) {
    <span class="hljs-comment">// 对于非空对象的情况</span>
    <span class="hljs-keyword">switch</span> (newChild.$$<span class="hljs-keyword">typeof</span>) {
      <span class="hljs-keyword">case</span> REACT_ELEMENT_TYPE:
        <span class="hljs-comment">// 普通的 div/span 等元素其 $$typeof 都是 REACT_ELEMENT_TYPE</span>
        <span class="hljs-keyword">return</span> placeSingleChild(
          reconcileSingleElement(
            returnFiber,
            currentFirstChild,
            newChild,
            expirationTime,
          ),
        );
      <span class="hljs-keyword">case</span> REACT_PORTAL_TYPE:
        <span class="hljs-comment">// react 新API portal 组件</span>
        <span class="hljs-keyword">return</span> placeSingleChild(
          reconcileSinglePortal(
            returnFiber,
            currentFirstChild,
            newChild,
            expirationTime,
          ),
        );
    }
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'number'</span>) {
    <span class="hljs-comment">// 如果child是文本或者数字，就直接替换就好了，fiber都不用生成</span>
    <span class="hljs-keyword">return</span> placeSingleChild(
      reconcileSingleTextNode(
        returnFiber,
        currentFirstChild,
        <span class="hljs-string">''</span> + newChild,
        expirationTime,
      ),
    );
  }

  <span class="hljs-keyword">if</span> (isArray(newChild)) {
    <span class="hljs-comment">// 对于数组的情况， react 新支持的 &lt;&gt;&lt;/&gt; 等方式，元素包含多子元素也是数组</span>
    <span class="hljs-keyword">return</span> reconcileChildrenArray(
      returnFiber,
      currentFirstChild,
      newChild,
      expirationTime,
    );
  }

  <span class="hljs-keyword">if</span> (getIteratorFn(newChild)) {
    <span class="hljs-comment">// 需要迭代，这里先不管。</span>
    <span class="hljs-keyword">return</span> reconcileChildrenIterator(
      returnFiber,
      currentFirstChild,
      newChild,
      expirationTime,
    );
  }

  <span class="hljs-keyword">if</span> (isObject) {
    throwOnInvalidObjectType(returnFiber, newChild);
  }
  <span class="hljs-comment">// 省略部分抛错提示处理</span>
  <span class="hljs-comment">// 剩下的都当作空处理，也就是 delete 掉</span>
  <span class="hljs-keyword">return</span> deleteRemainingChildren(returnFiber, currentFirstChild);
}
</code></pre>
<p>分类处理 newChild，并生成不同的 fiber。child 包括以前不兼容的 array 的形式。对于 HostComponent 而言，其 newChild 是 jsx 解析后的对象，type 为盒子类型，props 为其属性，包括 children，子元素。前面只是分类处理，而 reconcileSingleElement 才是生成 diff 的关键。</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileSingleElement</span>(<span class="hljs-params">
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  element: ReactElement,
  expirationTime: ExpirationTime,
</span>): <span class="hljs-title">Fiber</span> </span>{
  <span class="hljs-keyword">const</span> key = element.key;
  <span class="hljs-keyword">let</span> child = currentFirstChild;
  <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">if</span> (child.key === key) {
      <span class="hljs-comment">// newChild 的 key 是否和 currrent 的 child.key 一样？</span>
      <span class="hljs-keyword">if</span> (
        child.tag === Fragment
          ? element.type === REACT_FRAGMENT_TYPE
          : child.type === element.type
      ) {
        <span class="hljs-comment">// key 一样外，type 必须也是一样的哦。</span>
        deleteRemainingChildren(returnFiber, child.sibling);
        <span class="hljs-keyword">const</span> existing = useFiber(
          child,
          element.type === REACT_FRAGMENT_TYPE
            ? element.props.children
            : element.props,
          expirationTime,
        );
        existing.ref = coerceRef(returnFiber, child, element);
        existing.return = returnFiber;
        <span class="hljs-keyword">return</span> existing;
      } <span class="hljs-keyword">else</span> {
        deleteRemainingChildren(returnFiber, child);
        <span class="hljs-keyword">break</span>;
      }
    } <span class="hljs-keyword">else</span> {
      deleteChild(returnFiber, child);
    }
    child = child.sibling;
  }
  <span class="hljs-keyword">const</span> created = createFiberFromElement(
    element,
    returnFiber.mode,
    expirationTime,
  );
  created.ref = coerceRef(returnFiber, currentFirstChild, element);
  created.return = returnFiber;
  <span class="hljs-keyword">return</span> created;
}
</code></pre>
<p>从 current 里面找到对应的 key，也就是老元素的 key，如果新老元素的 key，以及 type 是一样的，则认为是同一个元素发生更新，这个时候会直接创建和之前一样的 fiber，包括 stateNode 实例也是一样的，其 alternate 则为 current。只是会传入新的 props，给到生成的 fiber。对比先后生成情况可以发现：</p>
<ol>
<li>处理 newChild 的时候，可以直接复用之前 current.alternate，修改其 pendingProps 以及 effect list 就可以了，而不是新建一个 fiber。同时可以直接复用 stateNode，只要后面再做更新处理就好，远比新生成 stateNode，开销要小。</li>
<li>对于更新的当前 fiber，由于存在 alternate。所以沿着 workInProgress tree 的子级时候，就可能存在 current.child 和新生成 fiber 的 newChild 做对比，又是一个 diff 的过程了。反之，如果一开始不配，直接生成新的 fiber，则下轮的时候，没有对应的 current，又是生成新的 fiber，其开销要比 diff 多很多。</li>
<li>节省内存不会反复创建 fiber。</li>
</ol>
<p>可以看到这里符合上面的两个基本点，相同类型的 type 才复用 fiber，否则，删除掉，并重新创建 fiber。而对于单元素而言，相同 type 还是不够的，必须相同 key，值得一提的是，没有设置 key 的时候，key 为 null，所以还是相同 key 值。但是对于复杂情况，如多元素 key 的判断，则要依赖于数组，也就是 reconcileChildrenArray 方法。</p>
<h3>reconcileChildrenArray</h3>
<p>对于有 key 的情况，按照官网介绍的 <a href="https://reactjs.org/docs/reconciliation.html#keys" target="_blank">reconciliation keys</a>。通过设置 key 可以有效的保留之前元素，而不是每次都去对比考虑新建/修改一个元素。但是 key 的分布可以是散列，没有规律的。react 又要如何识别呢？通过建立一个 map 的结构就可以快速识别。</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapRemainingChildren</span>(<span class="hljs-params">
  returnFiber: Fiber,
  currentFirstChild: Fiber,
</span>): <span class="hljs-title">Map</span>&lt;<span class="hljs-title">string</span> | <span class="hljs-title">number</span>, <span class="hljs-title">Fiber</span>&gt; </span>{
  <span class="hljs-keyword">const</span> existingChildren: <span class="hljs-built_in">Map</span>&lt;string | number, Fiber&gt; = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

  <span class="hljs-keyword">let</span> existingChild = currentFirstChild;
  <span class="hljs-keyword">while</span> (existingChild !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">if</span> (existingChild.key !== <span class="hljs-literal">null</span>) {
      existingChildren.set(existingChild.key, existingChild);
    } <span class="hljs-keyword">else</span> {
      existingChildren.set(existingChild.index, existingChild);
    }
    existingChild = existingChild.sibling;
  }
  <span class="hljs-keyword">return</span> existingChildren;
}
</code></pre>
<p>这里将以前的 old fiber 通过建立 Map 的方式，搭建一个字典对象，当新元素需要对比的时候，先瞅一瞅 existingChildren 里面有没有对应的 key，当然 type 也必须要是一样的。另外除了 key 之外，children 里面的排序也很重要。当没有 key 的时候，existingChildren 的键名将会是 index。在处理 key 的时候也是要小心不和 index 混淆了。创建 fiber 的时候，每个 fiber 都有 index 字段。数组的 children 转为 fiber 的时候，元素在 children 里面的顺序就是其 index。所以对于数组的情况，如果没有设置 key，通过 index 字段，react 也可以识别是不是同一个 fiber 的更新，但是 index 是有序的，这也照就很多不变，插入删除一个都会导致后面的全部更新。key 的设置还是很重要的。</p>
<p>react 里面对于数组元素，例如通过 map 遍历返回的，都是要有 key 的标识，这样可以提高下次渲染的重用，提高其性能。</p>
<p>在 preact 里面也是类似的。将所有 old 元素循环下来，通过 keyed 保存对应的 key 和 child，在对新的元素做 key 判断，从而找到对应的元素。</p>
<h2>completeWork</h2>
<p>这里会对上面 fiber 的 stateNode 更新，和之前。<a href="https://github.com/funfish/blog/blob/master/29.%20react%20%E6%BA%90%E7%A0%81%E4%B8%8B%E4%B8%80%E6%AD%A5.md" target="_blank">react 源码下一步</a> 里面的 diff 属性就有介绍到。前文是 diff fiber，这里是 diff stateNode。</p>
<p>到最后就是 commitRoot 里的三大循环了。</p>
<h2>effectList</h2>
<p>在 fiber 的 completeUnitOfWork 里面会收集所有的有 side-effect 的 fiber，将其通过 nextEffect 字段联系起来，成为一个单向的链表。其顺序是先子节点后父节点，只有有 side-effect 的节点才会被添加进来。也就是是说如果父节点 fiber 没有 side-effect，就是没有变动的话，是不会出现在 effectList 链表里面。</p>
<p><img src="https://github.com/funfish/blog/raw/master/images/effectList.PNG" alt=""></p>
<p>A是祖节点，B/C 为父节点，D/E/F 为子节点，蓝色线为父子关系，绿色线为 effectList 关系。当 D/E/F 有变化，而 B/C 没有变化的时候，形成的 effectList 如左图所示，这里 A.firstEffect 为 F，A.lastEffect 为 D，D/E/F 形成 nextEffct 关系。于是 commit 阶段的时候，只是对 D/E/F 做处理，而 B/C 是没有的。也是优化更新，实现局部更新的方式。</p>
<p>对于右图，则是当 B 也发生变化的时候，这个时候 A.lastEffect 为 B，D.nextEffect 为 B。父节点是在子节点之后出现的。通过这样的 effectList 的构建，形成单向的链表，而不是多层次的递归。</p>
<h2>总结</h2>
<p>React 的 diff 算法里面体现更多的是复用的概念，往往更新只是一小部分的，但是 react 的循环却是从头到尾一直进行的。<strong>通过两棵新老 fiber tree 的对比，可以有效避免创建多余的 fiber，提高其性能</strong>。对于日常开发的我们更重要的是牢记开头说的两点</p>
<ol>
<li>Two elements of different types will produce different trees.</li>
<li>The developer can hint at which child elements may be stable across different renders with a key prop.</li>
</ol>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"August 4, 2018","title":"react之Reconciliation","content":"\u003cp\u003eReact 的特点在于其异步渲染，fiber机制，是其他类 react 框架无法比拟的。前面介绍了些很基本的异步渲染。接下来介绍一下传说中的 diff 算法吧。其实这个在 \u003ca href=\"https://reactjs.org/docs/reconciliation.html\" target=\"_blank\"\u003eReact 官方文档 Reconciliation\u003c/a\u003e 里面早有介绍（advanced guide 里面的内容很多初级 React 工程师应该都没有看过，然而 advanced guide 里面包含了 context、错误边界、HOC、render props 以及 Reconciliation，没有看过的还请多刷几遍）。其中两大基准假设如下\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eTwo elements of different types will produce different trees.\u003c/li\u003e\n\u003cli\u003eThe developer can hint at which child elements may be stable across different renders with a key prop.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这两个准则很好的优化树的对比算法，遇到不同类型的元素自然是会生成不一样的树，而通过 key 这个 react 特性的属性可以来判断新旧元素是否是相似的，来减少优化步骤。\u003c/p\u003e\n\u003ch2\u003ereconcileChildFibers\u003c/h2\u003e\n\u003cp\u003ediff 的过程其实就是 reconciliation 的过程，在生成 workInProgress tree 的时候，新 fiber 的生成就取决于老 fiber 与相关 props。\u003c/p\u003e\n\u003cp\u003e元素的更新都需要有对应的子 fiber。下面以 fiber.tag 为 HostComponent 来举例子，HostComponent 指的就是一般的 'div' 'span' 等等常见的 HTML 标签。生成/更新子 fiber 的方式如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ereconcileChildFibers\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  newChild: any,\n  expirationTime: ExpirationTime,\n\u003c/span\u003e): \u003cspan class=\"hljs-title\"\u003eFiber\u003c/span\u003e | \u003cspan class=\"hljs-title\"\u003enull\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isUnkeyedTopLevelFragment =\n    \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e newChild === \u003cspan class=\"hljs-string\"\u003e'object'\u003c/span\u003e \u0026amp;\u0026amp;\n    newChild !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026amp;\u0026amp;\n    newChild.type === REACT_FRAGMENT_TYPE \u0026amp;\u0026amp;\n    newChild.key === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isUnkeyedTopLevelFragment) {\n    newChild = newChild.props.children;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 新child是否为非空对象，\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isObject = \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e newChild === \u003cspan class=\"hljs-string\"\u003e'object'\u003c/span\u003e \u0026amp;\u0026amp; newChild !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isObject) {\n    \u003cspan class=\"hljs-comment\"\u003e// 对于非空对象的情况\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (newChild.$$\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e REACT_ELEMENT_TYPE:\n        \u003cspan class=\"hljs-comment\"\u003e// 普通的 div/span 等元素其 $$typeof 都是 REACT_ELEMENT_TYPE\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e placeSingleChild(\n          reconcileSingleElement(\n            returnFiber,\n            currentFirstChild,\n            newChild,\n            expirationTime,\n          ),\n        );\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e REACT_PORTAL_TYPE:\n        \u003cspan class=\"hljs-comment\"\u003e// react 新API portal 组件\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e placeSingleChild(\n          reconcileSinglePortal(\n            returnFiber,\n            currentFirstChild,\n            newChild,\n            expirationTime,\n          ),\n        );\n    }\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e newChild === \u003cspan class=\"hljs-string\"\u003e'string'\u003c/span\u003e || \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e newChild === \u003cspan class=\"hljs-string\"\u003e'number'\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 如果child是文本或者数字，就直接替换就好了，fiber都不用生成\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e placeSingleChild(\n      reconcileSingleTextNode(\n        returnFiber,\n        currentFirstChild,\n        \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e + newChild,\n        expirationTime,\n      ),\n    );\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isArray(newChild)) {\n    \u003cspan class=\"hljs-comment\"\u003e// 对于数组的情况， react 新支持的 \u0026lt;\u0026gt;\u0026lt;/\u0026gt; 等方式，元素包含多子元素也是数组\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e reconcileChildrenArray(\n      returnFiber,\n      currentFirstChild,\n      newChild,\n      expirationTime,\n    );\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (getIteratorFn(newChild)) {\n    \u003cspan class=\"hljs-comment\"\u003e// 需要迭代，这里先不管。\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e reconcileChildrenIterator(\n      returnFiber,\n      currentFirstChild,\n      newChild,\n      expirationTime,\n    );\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isObject) {\n    throwOnInvalidObjectType(returnFiber, newChild);\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 省略部分抛错提示处理\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 剩下的都当作空处理，也就是 delete 掉\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e deleteRemainingChildren(returnFiber, currentFirstChild);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e分类处理 newChild，并生成不同的 fiber。child 包括以前不兼容的 array 的形式。对于 HostComponent 而言，其 newChild 是 jsx 解析后的对象，type 为盒子类型，props 为其属性，包括 children，子元素。前面只是分类处理，而 reconcileSingleElement 才是生成 diff 的关键。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ereconcileSingleElement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  element: ReactElement,\n  expirationTime: ExpirationTime,\n\u003c/span\u003e): \u003cspan class=\"hljs-title\"\u003eFiber\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e key = element.key;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e child = currentFirstChild;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (child !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (child.key === key) {\n      \u003cspan class=\"hljs-comment\"\u003e// newChild 的 key 是否和 currrent 的 child.key 一样？\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n        child.tag === Fragment\n          ? element.type === REACT_FRAGMENT_TYPE\n          : child.type === element.type\n      ) {\n        \u003cspan class=\"hljs-comment\"\u003e// key 一样外，type 必须也是一样的哦。\u003c/span\u003e\n        deleteRemainingChildren(returnFiber, child.sibling);\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e existing = useFiber(\n          child,\n          element.type === REACT_FRAGMENT_TYPE\n            ? element.props.children\n            : element.props,\n          expirationTime,\n        );\n        existing.ref = coerceRef(returnFiber, child, element);\n        existing.return = returnFiber;\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e existing;\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        deleteRemainingChildren(returnFiber, child);\n        \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n      }\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      deleteChild(returnFiber, child);\n    }\n    child = child.sibling;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e created = createFiberFromElement(\n    element,\n    returnFiber.mode,\n    expirationTime,\n  );\n  created.ref = coerceRef(returnFiber, currentFirstChild, element);\n  created.return = returnFiber;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e created;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e从 current 里面找到对应的 key，也就是老元素的 key，如果新老元素的 key，以及 type 是一样的，则认为是同一个元素发生更新，这个时候会直接创建和之前一样的 fiber，包括 stateNode 实例也是一样的，其 alternate 则为 current。只是会传入新的 props，给到生成的 fiber。对比先后生成情况可以发现：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e处理 newChild 的时候，可以直接复用之前 current.alternate，修改其 pendingProps 以及 effect list 就可以了，而不是新建一个 fiber。同时可以直接复用 stateNode，只要后面再做更新处理就好，远比新生成 stateNode，开销要小。\u003c/li\u003e\n\u003cli\u003e对于更新的当前 fiber，由于存在 alternate。所以沿着 workInProgress tree 的子级时候，就可能存在 current.child 和新生成 fiber 的 newChild 做对比，又是一个 diff 的过程了。反之，如果一开始不配，直接生成新的 fiber，则下轮的时候，没有对应的 current，又是生成新的 fiber，其开销要比 diff 多很多。\u003c/li\u003e\n\u003cli\u003e节省内存不会反复创建 fiber。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e可以看到这里符合上面的两个基本点，相同类型的 type 才复用 fiber，否则，删除掉，并重新创建 fiber。而对于单元素而言，相同 type 还是不够的，必须相同 key，值得一提的是，没有设置 key 的时候，key 为 null，所以还是相同 key 值。但是对于复杂情况，如多元素 key 的判断，则要依赖于数组，也就是 reconcileChildrenArray 方法。\u003c/p\u003e\n\u003ch3\u003ereconcileChildrenArray\u003c/h3\u003e\n\u003cp\u003e对于有 key 的情况，按照官网介绍的 \u003ca href=\"https://reactjs.org/docs/reconciliation.html#keys\" target=\"_blank\"\u003ereconciliation keys\u003c/a\u003e。通过设置 key 可以有效的保留之前元素，而不是每次都去对比考虑新建/修改一个元素。但是 key 的分布可以是散列，没有规律的。react 又要如何识别呢？通过建立一个 map 的结构就可以快速识别。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emapRemainingChildren\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n  returnFiber: Fiber,\n  currentFirstChild: Fiber,\n\u003c/span\u003e): \u003cspan class=\"hljs-title\"\u003eMap\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-title\"\u003estring\u003c/span\u003e | \u003cspan class=\"hljs-title\"\u003enumber\u003c/span\u003e, \u003cspan class=\"hljs-title\"\u003eFiber\u003c/span\u003e\u0026gt; \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e existingChildren: \u003cspan class=\"hljs-built_in\"\u003eMap\u003c/span\u003e\u0026lt;string | number, Fiber\u0026gt; = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eMap\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e existingChild = currentFirstChild;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (existingChild !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (existingChild.key !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n      existingChildren.set(existingChild.key, existingChild);\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      existingChildren.set(existingChild.index, existingChild);\n    }\n    existingChild = existingChild.sibling;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e existingChildren;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里将以前的 old fiber 通过建立 Map 的方式，搭建一个字典对象，当新元素需要对比的时候，先瞅一瞅 existingChildren 里面有没有对应的 key，当然 type 也必须要是一样的。另外除了 key 之外，children 里面的排序也很重要。当没有 key 的时候，existingChildren 的键名将会是 index。在处理 key 的时候也是要小心不和 index 混淆了。创建 fiber 的时候，每个 fiber 都有 index 字段。数组的 children 转为 fiber 的时候，元素在 children 里面的顺序就是其 index。所以对于数组的情况，如果没有设置 key，通过 index 字段，react 也可以识别是不是同一个 fiber 的更新，但是 index 是有序的，这也照就很多不变，插入删除一个都会导致后面的全部更新。key 的设置还是很重要的。\u003c/p\u003e\n\u003cp\u003ereact 里面对于数组元素，例如通过 map 遍历返回的，都是要有 key 的标识，这样可以提高下次渲染的重用，提高其性能。\u003c/p\u003e\n\u003cp\u003e在 preact 里面也是类似的。将所有 old 元素循环下来，通过 keyed 保存对应的 key 和 child，在对新的元素做 key 判断，从而找到对应的元素。\u003c/p\u003e\n\u003ch2\u003ecompleteWork\u003c/h2\u003e\n\u003cp\u003e这里会对上面 fiber 的 stateNode 更新，和之前。\u003ca href=\"https://github.com/funfish/blog/blob/master/29.%20react%20%E6%BA%90%E7%A0%81%E4%B8%8B%E4%B8%80%E6%AD%A5.md\" target=\"_blank\"\u003ereact 源码下一步\u003c/a\u003e 里面的 diff 属性就有介绍到。前文是 diff fiber，这里是 diff stateNode。\u003c/p\u003e\n\u003cp\u003e到最后就是 commitRoot 里的三大循环了。\u003c/p\u003e\n\u003ch2\u003eeffectList\u003c/h2\u003e\n\u003cp\u003e在 fiber 的 completeUnitOfWork 里面会收集所有的有 side-effect 的 fiber，将其通过 nextEffect 字段联系起来，成为一个单向的链表。其顺序是先子节点后父节点，只有有 side-effect 的节点才会被添加进来。也就是是说如果父节点 fiber 没有 side-effect，就是没有变动的话，是不会出现在 effectList 链表里面。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/effectList.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eA是祖节点，B/C 为父节点，D/E/F 为子节点，蓝色线为父子关系，绿色线为 effectList 关系。当 D/E/F 有变化，而 B/C 没有变化的时候，形成的 effectList 如左图所示，这里 A.firstEffect 为 F，A.lastEffect 为 D，D/E/F 形成 nextEffct 关系。于是 commit 阶段的时候，只是对 D/E/F 做处理，而 B/C 是没有的。也是优化更新，实现局部更新的方式。\u003c/p\u003e\n\u003cp\u003e对于右图，则是当 B 也发生变化的时候，这个时候 A.lastEffect 为 B，D.nextEffect 为 B。父节点是在子节点之后出现的。通过这样的 effectList 的构建，形成单向的链表，而不是多层次的递归。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003eReact 的 diff 算法里面体现更多的是复用的概念，往往更新只是一小部分的，但是 react 的循环却是从头到尾一直进行的。\u003cstrong\u003e通过两棵新老 fiber tree 的对比，可以有效避免创建多余的 fiber，提高其性能\u003c/strong\u003e。对于日常开发的我们更重要的是牢记开头说的两点\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eTwo elements of different types will produce different trees.\u003c/li\u003e\n\u003cli\u003eThe developer can hint at which child elements may be stable across different renders with a key prop.\u003c/li\u003e\n\u003c/ol\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"August 4, 2018","title":"react之Reconciliation","content":"\u003cp\u003eReact 的特点在于其异步渲染，fiber机制，是其他类 react 框架无法比拟的。前面介绍了些很基本的异步渲染。接下来介绍一下传说中的 diff 算法吧。其实这个在 \u003ca href=\"https://reactjs.org/docs/reconciliation.html\" target=\"_blank\"\u003eReact 官方文档 Reconciliation\u003c/a\u003e 里面早有介绍（advanced guide 里面的内容很多初级 React 工程师应该都没有看过，然而 advanced guide 里面包含了 context、错误边界、HOC、render props 以及 Reconciliation，没有看过的还请多刷几遍）。其中两大基准假设如下\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eTwo elements of different types will produce different trees.\u003c/li\u003e\n\u003cli\u003eThe developer can hint at which child elements may be stable across different renders with a key prop.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这两个准则很好的优化树的对比算法，遇到不同类型的元素自然是会生成不一样的树，而通过 key 这个 react 特性的属性可以来判断新旧元素是否是相似的，来减少优化步骤。\u003c/p\u003e\n\u003ch2\u003ereconcileChildFibers\u003c/h2\u003e\n\u003cp\u003ediff 的过程其实就是 reconciliation 的过程，在生成 workInProgress tree 的时候，新 fiber 的生成就取决于老 fiber 与相关 props。\u003c/p\u003e\n\u003cp\u003e元素的更新都需要有对应的子 fiber。下面以 fiber.tag 为 HostComponent 来举例子，HostComponent 指的就是一般的 'div' 'span' 等等常见的 HTML 标签。生成/更新子 fiber 的方式如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ereconcileChildFibers\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  newChild: any,\n  expirationTime: ExpirationTime,\n\u003c/span\u003e): \u003cspan class=\"hljs-title\"\u003eFiber\u003c/span\u003e | \u003cspan class=\"hljs-title\"\u003enull\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isUnkeyedTopLevelFragment =\n    \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e newChild === \u003cspan class=\"hljs-string\"\u003e'object'\u003c/span\u003e \u0026amp;\u0026amp;\n    newChild !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026amp;\u0026amp;\n    newChild.type === REACT_FRAGMENT_TYPE \u0026amp;\u0026amp;\n    newChild.key === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isUnkeyedTopLevelFragment) {\n    newChild = newChild.props.children;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 新child是否为非空对象，\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isObject = \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e newChild === \u003cspan class=\"hljs-string\"\u003e'object'\u003c/span\u003e \u0026amp;\u0026amp; newChild !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isObject) {\n    \u003cspan class=\"hljs-comment\"\u003e// 对于非空对象的情况\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (newChild.$$\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e REACT_ELEMENT_TYPE:\n        \u003cspan class=\"hljs-comment\"\u003e// 普通的 div/span 等元素其 $$typeof 都是 REACT_ELEMENT_TYPE\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e placeSingleChild(\n          reconcileSingleElement(\n            returnFiber,\n            currentFirstChild,\n            newChild,\n            expirationTime,\n          ),\n        );\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e REACT_PORTAL_TYPE:\n        \u003cspan class=\"hljs-comment\"\u003e// react 新API portal 组件\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e placeSingleChild(\n          reconcileSinglePortal(\n            returnFiber,\n            currentFirstChild,\n            newChild,\n            expirationTime,\n          ),\n        );\n    }\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e newChild === \u003cspan class=\"hljs-string\"\u003e'string'\u003c/span\u003e || \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e newChild === \u003cspan class=\"hljs-string\"\u003e'number'\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 如果child是文本或者数字，就直接替换就好了，fiber都不用生成\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e placeSingleChild(\n      reconcileSingleTextNode(\n        returnFiber,\n        currentFirstChild,\n        \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e + newChild,\n        expirationTime,\n      ),\n    );\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isArray(newChild)) {\n    \u003cspan class=\"hljs-comment\"\u003e// 对于数组的情况， react 新支持的 \u0026lt;\u0026gt;\u0026lt;/\u0026gt; 等方式，元素包含多子元素也是数组\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e reconcileChildrenArray(\n      returnFiber,\n      currentFirstChild,\n      newChild,\n      expirationTime,\n    );\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (getIteratorFn(newChild)) {\n    \u003cspan class=\"hljs-comment\"\u003e// 需要迭代，这里先不管。\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e reconcileChildrenIterator(\n      returnFiber,\n      currentFirstChild,\n      newChild,\n      expirationTime,\n    );\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isObject) {\n    throwOnInvalidObjectType(returnFiber, newChild);\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// 省略部分抛错提示处理\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 剩下的都当作空处理，也就是 delete 掉\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e deleteRemainingChildren(returnFiber, currentFirstChild);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e分类处理 newChild，并生成不同的 fiber。child 包括以前不兼容的 array 的形式。对于 HostComponent 而言，其 newChild 是 jsx 解析后的对象，type 为盒子类型，props 为其属性，包括 children，子元素。前面只是分类处理，而 reconcileSingleElement 才是生成 diff 的关键。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ereconcileSingleElement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  element: ReactElement,\n  expirationTime: ExpirationTime,\n\u003c/span\u003e): \u003cspan class=\"hljs-title\"\u003eFiber\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e key = element.key;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e child = currentFirstChild;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (child !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (child.key === key) {\n      \u003cspan class=\"hljs-comment\"\u003e// newChild 的 key 是否和 currrent 的 child.key 一样？\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n        child.tag === Fragment\n          ? element.type === REACT_FRAGMENT_TYPE\n          : child.type === element.type\n      ) {\n        \u003cspan class=\"hljs-comment\"\u003e// key 一样外，type 必须也是一样的哦。\u003c/span\u003e\n        deleteRemainingChildren(returnFiber, child.sibling);\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e existing = useFiber(\n          child,\n          element.type === REACT_FRAGMENT_TYPE\n            ? element.props.children\n            : element.props,\n          expirationTime,\n        );\n        existing.ref = coerceRef(returnFiber, child, element);\n        existing.return = returnFiber;\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e existing;\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        deleteRemainingChildren(returnFiber, child);\n        \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n      }\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      deleteChild(returnFiber, child);\n    }\n    child = child.sibling;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e created = createFiberFromElement(\n    element,\n    returnFiber.mode,\n    expirationTime,\n  );\n  created.ref = coerceRef(returnFiber, currentFirstChild, element);\n  created.return = returnFiber;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e created;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e从 current 里面找到对应的 key，也就是老元素的 key，如果新老元素的 key，以及 type 是一样的，则认为是同一个元素发生更新，这个时候会直接创建和之前一样的 fiber，包括 stateNode 实例也是一样的，其 alternate 则为 current。只是会传入新的 props，给到生成的 fiber。对比先后生成情况可以发现：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e处理 newChild 的时候，可以直接复用之前 current.alternate，修改其 pendingProps 以及 effect list 就可以了，而不是新建一个 fiber。同时可以直接复用 stateNode，只要后面再做更新处理就好，远比新生成 stateNode，开销要小。\u003c/li\u003e\n\u003cli\u003e对于更新的当前 fiber，由于存在 alternate。所以沿着 workInProgress tree 的子级时候，就可能存在 current.child 和新生成 fiber 的 newChild 做对比，又是一个 diff 的过程了。反之，如果一开始不配，直接生成新的 fiber，则下轮的时候，没有对应的 current，又是生成新的 fiber，其开销要比 diff 多很多。\u003c/li\u003e\n\u003cli\u003e节省内存不会反复创建 fiber。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e可以看到这里符合上面的两个基本点，相同类型的 type 才复用 fiber，否则，删除掉，并重新创建 fiber。而对于单元素而言，相同 type 还是不够的，必须相同 key，值得一提的是，没有设置 key 的时候，key 为 null，所以还是相同 key 值。但是对于复杂情况，如多元素 key 的判断，则要依赖于数组，也就是 reconcileChildrenArray 方法。\u003c/p\u003e\n\u003ch3\u003ereconcileChildrenArray\u003c/h3\u003e\n\u003cp\u003e对于有 key 的情况，按照官网介绍的 \u003ca href=\"https://reactjs.org/docs/reconciliation.html#keys\" target=\"_blank\"\u003ereconciliation keys\u003c/a\u003e。通过设置 key 可以有效的保留之前元素，而不是每次都去对比考虑新建/修改一个元素。但是 key 的分布可以是散列，没有规律的。react 又要如何识别呢？通过建立一个 map 的结构就可以快速识别。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emapRemainingChildren\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n  returnFiber: Fiber,\n  currentFirstChild: Fiber,\n\u003c/span\u003e): \u003cspan class=\"hljs-title\"\u003eMap\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-title\"\u003estring\u003c/span\u003e | \u003cspan class=\"hljs-title\"\u003enumber\u003c/span\u003e, \u003cspan class=\"hljs-title\"\u003eFiber\u003c/span\u003e\u0026gt; \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e existingChildren: \u003cspan class=\"hljs-built_in\"\u003eMap\u003c/span\u003e\u0026lt;string | number, Fiber\u0026gt; = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eMap\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e existingChild = currentFirstChild;\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (existingChild !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (existingChild.key !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n      existingChildren.set(existingChild.key, existingChild);\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      existingChildren.set(existingChild.index, existingChild);\n    }\n    existingChild = existingChild.sibling;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e existingChildren;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里将以前的 old fiber 通过建立 Map 的方式，搭建一个字典对象，当新元素需要对比的时候，先瞅一瞅 existingChildren 里面有没有对应的 key，当然 type 也必须要是一样的。另外除了 key 之外，children 里面的排序也很重要。当没有 key 的时候，existingChildren 的键名将会是 index。在处理 key 的时候也是要小心不和 index 混淆了。创建 fiber 的时候，每个 fiber 都有 index 字段。数组的 children 转为 fiber 的时候，元素在 children 里面的顺序就是其 index。所以对于数组的情况，如果没有设置 key，通过 index 字段，react 也可以识别是不是同一个 fiber 的更新，但是 index 是有序的，这也照就很多不变，插入删除一个都会导致后面的全部更新。key 的设置还是很重要的。\u003c/p\u003e\n\u003cp\u003ereact 里面对于数组元素，例如通过 map 遍历返回的，都是要有 key 的标识，这样可以提高下次渲染的重用，提高其性能。\u003c/p\u003e\n\u003cp\u003e在 preact 里面也是类似的。将所有 old 元素循环下来，通过 keyed 保存对应的 key 和 child，在对新的元素做 key 判断，从而找到对应的元素。\u003c/p\u003e\n\u003ch2\u003ecompleteWork\u003c/h2\u003e\n\u003cp\u003e这里会对上面 fiber 的 stateNode 更新，和之前。\u003ca href=\"https://github.com/funfish/blog/blob/master/29.%20react%20%E6%BA%90%E7%A0%81%E4%B8%8B%E4%B8%80%E6%AD%A5.md\" target=\"_blank\"\u003ereact 源码下一步\u003c/a\u003e 里面的 diff 属性就有介绍到。前文是 diff fiber，这里是 diff stateNode。\u003c/p\u003e\n\u003cp\u003e到最后就是 commitRoot 里的三大循环了。\u003c/p\u003e\n\u003ch2\u003eeffectList\u003c/h2\u003e\n\u003cp\u003e在 fiber 的 completeUnitOfWork 里面会收集所有的有 side-effect 的 fiber，将其通过 nextEffect 字段联系起来，成为一个单向的链表。其顺序是先子节点后父节点，只有有 side-effect 的节点才会被添加进来。也就是是说如果父节点 fiber 没有 side-effect，就是没有变动的话，是不会出现在 effectList 链表里面。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/funfish/blog/raw/master/images/effectList.PNG\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eA是祖节点，B/C 为父节点，D/E/F 为子节点，蓝色线为父子关系，绿色线为 effectList 关系。当 D/E/F 有变化，而 B/C 没有变化的时候，形成的 effectList 如左图所示，这里 A.firstEffect 为 F，A.lastEffect 为 D，D/E/F 形成 nextEffct 关系。于是 commit 阶段的时候，只是对 D/E/F 做处理，而 B/C 是没有的。也是优化更新，实现局部更新的方式。\u003c/p\u003e\n\u003cp\u003e对于右图，则是当 B 也发生变化的时候，这个时候 A.lastEffect 为 B，D.nextEffect 为 B。父节点是在子节点之后出现的。通过这样的 effectList 的构建，形成单向的链表，而不是多层次的递归。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003eReact 的 diff 算法里面体现更多的是复用的概念，往往更新只是一小部分的，但是 react 的循环却是从头到尾一直进行的。\u003cstrong\u003e通过两棵新老 fiber tree 的对比，可以有效避免创建多余的 fiber，提高其性能\u003c/strong\u003e。对于日常开发的我们更重要的是牢记开头说的两点\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eTwo elements of different types will produce different trees.\u003c/li\u003e\n\u003cli\u003eThe developer can hint at which child elements may be stable across different renders with a key prop.\u003c/li\u003e\n\u003c/ol\u003e\n"}},"buildId":"ZS9D2ZWqQsj~9BxQGiyVr","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/ZS9D2ZWqQsj~9BxQGiyVr/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/ZS9D2ZWqQsj~9BxQGiyVr/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/ZS9D2ZWqQsj~9BxQGiyVr/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" async=""></script></body></html>