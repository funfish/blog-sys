<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><title class="next-head">Decorator</title><link rel="preload" href="/blog-sys/_next/static/ZS9D2ZWqQsj~9BxQGiyVr/pages/Post/Post.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/ZS9D2ZWqQsj~9BxQGiyVr/pages/_app.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/ZS9D2ZWqQsj~9BxQGiyVr/pages/_error.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" as="script"/><link rel="preload" href="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" as="script"/><link rel="stylesheet" href="/blog-sys/_next/static/css/styles.491f56ba.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="user-scalable=0, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"/><meta name="theme-color" content="yellowgreen"/><meta name="description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><link rel="icon" sizes="192x192" href="/static/touch-icon.png"/><link rel="apple-touch-icon" href="/static/touch-icon.png"/><link rel="icon" href="/static/avatar.jpg"/><meta property="og:title" content="funfish的博客"/><meta property="og:description" content="这是funfish的博客，funfish立志成为一名高级前端工程师"/><meta property="og:image" content=""/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/></head><body><div id="__next"><nav class="nav___3Hk0c "><a class="logo___1KD30" href="/blog-sys/">Funfish Blog</a><ul><li><a class="link___1qXLb" href="/blog-sys/">Home</a></li></ul></nav><header class="bannerWithoutImg___3VKNp"><h1 class="postTitle___26vXM">Decorator</h1><span class="postTime___16Ish">October 11, 2018</span></header><article class="postWrapper___3NXol post-article"><div><h3>前言</h3>
<p>ESnext 里面提到的修饰器，在 redux 的推广下，几乎每个工程师都有或多或少的用过，最常见的就是 <code>@connect</code> 的形式，而在 Java 领域同样也存在 <code>@</code> 这种符号的存在，被称之为注解，而巧的是修饰器同样能实现注解的功能。在看 Java 的注解的时候必然会看到反射这个概念。在阅读下面之前请先看阮老师的文档<a href="http://es6.ruanyifeng.com/#docs/decorator" target="_blank">修饰器</a>，再看下文。</p>
<h3>Babel 开发环境须知</h3>
<p>修饰器 Decorator 是 ES7 里面提出的，在 babel 6 里面需要引入 <code>preset-stage-2</code>，并在 .babelrc 中配置 <code>&quot;presets&quot;: [&quot;env&quot;, &quot;stage-2&quot;]</code>。到了 babel 7.0.0-beta.54 之前，则是需要 npm 包 <code>@babel/preset-stage-2</code>，配置 .babelrc 为  [&quot;@babel/preset-stage-2&quot;, { &quot;decoratorsLegacy&quot;: true }]，默认是关闭的。而 babel 7.0.0-beta.54 之后的版本里面，已经 <strong>弃用 Stage Preset</strong> ，所以后面需要安装的版本是 <code>@babel/plugin-proposal-decorators</code> 配置为 <code>[&quot;@babel/plugin-proposal-decorators&quot;, { &quot;legacy&quot;: true }]</code>，这样可以达到以前的效果，具体看<a href="https://github.com/babel/babel/tree/master/packages/babel-preset-stage-0#babelpreset-stage-0" target="_blank">官方介绍</a>，以及<a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators" target="_blank">@babel/plugin-proposal-decorators</a>。目前 babel 7.1.0 已经发布了<a href="https://babeljs.io/blog/2018/09/17/decorators" target="_blank">TC39 Standards Track Decorators in Babel</a>。</p>
<h3>java 中的注解和反射</h3>
<p>在 Java 里面注解是元数据，相当于是提供元素的配置信息，也就是额外的数据，比如最常见的 <code>@Override @RequestMapping</code> 这些。而在 ES 里面修饰器则更强大的多，是对类进行处理封装的改变，也可以不使用 <code>@</code> 符号进行描述，但是这样就失去其便捷性、直观性了。ESnext 中关于 Decorator 的<a href="https://github.com/tc39/proposal-decorators" target="_blank">提案</a>中提到修饰器不仅仅是可以用来修饰类，更包括了字段、getter、setter 和 方法。</p>
<p>先来看看 Java 中的注解是什么用法：</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
  ...
  <span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span>
}
</span></code></pre>
<p>通过 Test 注解，来添加额外的信息，本身是没有什么作用的，需要工具支持才可以用，而这个工具就是反射了。反射有什么作用呢？<strong>反射可以在运行时获得程序或程序集中每一个类型的成员和成员的信息</strong> 。如果结合上注解，那就是 <strong>可以在运行时通过反射的方式取出方法的注解</strong> ，从而实现额外的功能。反射里面主要用到下面四个类：</p>
<ol>
<li>java.lang.Class 类对象；</li>
<li>java.lang.reflect.Constructor 构造器对象 有 <code>public Constructor[] getConstructors()</code> 方式；</li>
<li>java.lang.reflect.Method 方法对象，有 <code>public Method[] getMethods()</code> 等；</li>
<li>java.lang.reflect.Field 属性对象，有 <code>public Field[] getFields()</code> 等；</li>
</ol>
<p>可以看看下面示例了解一下反射：</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (Method m : obj.getClass().getMethods()) {
  Test t = m.getAnnotation(Test.class);
  <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) {
    <span class="hljs-comment">// 对符合要求的 m 做处理</span>
  }
}
</code></pre>
<p>反射的存在使得注解变得灵动起来。注解除了是 JDK 或者 Spring 里面提供的外，还可以自己定义注解，形如下面的 <code>@Override</code> 注解：</p>
<pre class="hljs"><code><span class="hljs-meta">@Target</span>({ElementType.METHOD})
<span class="hljs-meta">@Retention</span>(RetentionPolicy.SOURCE)
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override {
}
</code></pre>
<h3>ES 中的修饰器</h3>
<p>ES 中对类的修饰器，更像是给类加个包装，对这个类进行操作。这里可以看看 react-redux 里面的 connect 的实现：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connectAdvanced</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapWithConnect</span>(<span class="hljs-params">WrappedComponent</span>) </span>{
    <span class="hljs-comment">// ...</span>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connect</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
      <span class="hljs-comment">// ...</span>
      render() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.error) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.state.error
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> createElement(WrappedComponent, <span class="hljs-keyword">this</span>.addExtraProps(<span class="hljs-keyword">this</span>.state.props))
        }  
      }
    }
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">return</span> hoistStatics(Connect, WrappedComponent)
  }
}

<span class="hljs-comment">// 使用方式</span>
@connect(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> ({
  <span class="hljs-attr">global</span>: state.global
}))
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WrappedComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PureComponent</span> </span>{}
</code></pre>
<p>如上所示的，通过 <code>@connect</code>，对 WrappedComponent 修饰，在 Connect 中实现一套更新 store 的逻辑，最后通过 <code>setState</code> 来触发，使得传入 WrappedComponent 的 props 发生更新，并注入 dispath 等等方法，最后达到传递状态的作用。
而上面的这一切的功能只要用一个 <code>@connect</code> 就可以办到，和 Java 的注解不同，这里不需要反射来实现其功能。</p>
<p>对类/方法修饰还可以看看方正大神的(egg-blueprint)[https://github.com/Foveluy/egg-blueprint/blob/master/lib/index.js]，是一个 egg.js 为插件，采用修饰器的方式，实现了类似于 Spring 中 <code>@RequestMapping</code> 的方式。</p>
<p>对于一些 java 中常见的注解，如 <code>@override @readonly</code> 等等，在 ES 里面也有同样的实现！比如常用的 <a href="https://github.com/jayphelps/core-decorators" target="_blank">core-decorators</a> 和 <a href="https://github.com/steelsojka/lodash-decorators" target="_blank">lodash-decorators</a> 库。</p>
<p>比如 <code>@readonly</code> 的实现：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readonly</span>(<span class="hljs-params">target, name, descriptor</span>)</span>{
  descriptor.writable = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">return</span> descriptor;
}
</code></pre>
<p>如果说对类的修饰是外在包装一层，那么对方法的修饰，由于 descriptor 的存在，则更像是修饰器。方法的修饰里面传入的参数中，包含了 descriptor 描述对象。这个在 <code>Object.defineProperty</code> 中应该是再熟悉不过的了。通过 descriptor 可以实现非常多的功能。</p>
<p>对于类的属性同样也能采用修饰器的方式，类似于方法，但是其 descriptor 属性描述符里面只能用 initializer 来替代之前的 value。</p>
<p>另外 ESnext 里面也可以通过 <code>#</code> 来定义私有变量，就如同 java 的修饰符 private。</p>
<p>只是对于私有方法和私有变量而言，其 descriptor 属性描述符里面 <code>writable enumerable configurable</code> 均为 false，同样的私有变量的描述对象只能用 initializer 来替代的 value。其他静态方法/变量等可以看看<a href="https://github.com/tc39/proposal-decorators/blob/master/TAXONOMY.md" target="_blank">文档</a>。</p>
<h3>总结</h3>
<p>由于对 java 的理解尚浅，本文也是做个简单的对比。ES 中的修饰器随着新特性的出现，也会被更多人所使用。</p>
</div></article></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"createTimeEN":"October 11, 2018","title":"Decorator","content":"\u003ch3\u003e前言\u003c/h3\u003e\n\u003cp\u003eESnext 里面提到的修饰器，在 redux 的推广下，几乎每个工程师都有或多或少的用过，最常见的就是 \u003ccode\u003e@connect\u003c/code\u003e 的形式，而在 Java 领域同样也存在 \u003ccode\u003e@\u003c/code\u003e 这种符号的存在，被称之为注解，而巧的是修饰器同样能实现注解的功能。在看 Java 的注解的时候必然会看到反射这个概念。在阅读下面之前请先看阮老师的文档\u003ca href=\"http://es6.ruanyifeng.com/#docs/decorator\" target=\"_blank\"\u003e修饰器\u003c/a\u003e，再看下文。\u003c/p\u003e\n\u003ch3\u003eBabel 开发环境须知\u003c/h3\u003e\n\u003cp\u003e修饰器 Decorator 是 ES7 里面提出的，在 babel 6 里面需要引入 \u003ccode\u003epreset-stage-2\u003c/code\u003e，并在 .babelrc 中配置 \u003ccode\u003e\u0026quot;presets\u0026quot;: [\u0026quot;env\u0026quot;, \u0026quot;stage-2\u0026quot;]\u003c/code\u003e。到了 babel 7.0.0-beta.54 之前，则是需要 npm 包 \u003ccode\u003e@babel/preset-stage-2\u003c/code\u003e，配置 .babelrc 为  [\u0026quot;@babel/preset-stage-2\u0026quot;, { \u0026quot;decoratorsLegacy\u0026quot;: true }]，默认是关闭的。而 babel 7.0.0-beta.54 之后的版本里面，已经 \u003cstrong\u003e弃用 Stage Preset\u003c/strong\u003e ，所以后面需要安装的版本是 \u003ccode\u003e@babel/plugin-proposal-decorators\u003c/code\u003e 配置为 \u003ccode\u003e[\u0026quot;@babel/plugin-proposal-decorators\u0026quot;, { \u0026quot;legacy\u0026quot;: true }]\u003c/code\u003e，这样可以达到以前的效果，具体看\u003ca href=\"https://github.com/babel/babel/tree/master/packages/babel-preset-stage-0#babelpreset-stage-0\" target=\"_blank\"\u003e官方介绍\u003c/a\u003e，以及\u003ca href=\"https://babeljs.io/docs/en/babel-plugin-proposal-decorators\" target=\"_blank\"\u003e@babel/plugin-proposal-decorators\u003c/a\u003e。目前 babel 7.1.0 已经发布了\u003ca href=\"https://babeljs.io/blog/2018/09/17/decorators\" target=\"_blank\"\u003eTC39 Standards Track Decorators in Babel\u003c/a\u003e。\u003c/p\u003e\n\u003ch3\u003ejava 中的注解和反射\u003c/h3\u003e\n\u003cp\u003e在 Java 里面注解是元数据，相当于是提供元素的配置信息，也就是额外的数据，比如最常见的 \u003ccode\u003e@Override @RequestMapping\u003c/code\u003e 这些。而在 ES 里面修饰器则更强大的多，是对类进行处理封装的改变，也可以不使用 \u003ccode\u003e@\u003c/code\u003e 符号进行描述，但是这样就失去其便捷性、直观性了。ESnext 中关于 Decorator 的\u003ca href=\"https://github.com/tc39/proposal-decorators\" target=\"_blank\"\u003e提案\u003c/a\u003e中提到修饰器不仅仅是可以用来修饰类，更包括了字段、getter、setter 和 方法。\u003c/p\u003e\n\u003cp\u003e先来看看 Java 中的注解是什么用法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eMyClass\u003c/span\u003e \u003c/span\u003e{\n  ...\n  \u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003egetName\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\n}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过 Test 注解，来添加额外的信息，本身是没有什么作用的，需要工具支持才可以用，而这个工具就是反射了。反射有什么作用呢？\u003cstrong\u003e反射可以在运行时获得程序或程序集中每一个类型的成员和成员的信息\u003c/strong\u003e 。如果结合上注解，那就是 \u003cstrong\u003e可以在运行时通过反射的方式取出方法的注解\u003c/strong\u003e ，从而实现额外的功能。反射里面主要用到下面四个类：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ejava.lang.Class 类对象；\u003c/li\u003e\n\u003cli\u003ejava.lang.reflect.Constructor 构造器对象 有 \u003ccode\u003epublic Constructor[] getConstructors()\u003c/code\u003e 方式；\u003c/li\u003e\n\u003cli\u003ejava.lang.reflect.Method 方法对象，有 \u003ccode\u003epublic Method[] getMethods()\u003c/code\u003e 等；\u003c/li\u003e\n\u003cli\u003ejava.lang.reflect.Field 属性对象，有 \u003ccode\u003epublic Field[] getFields()\u003c/code\u003e 等；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e可以看看下面示例了解一下反射：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (Method m : obj.getClass().getMethods()) {\n  Test t = m.getAnnotation(Test.class);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (t != \u003cspan class=\"hljs-keyword\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 对符合要求的 m 做处理\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e反射的存在使得注解变得灵动起来。注解除了是 JDK 或者 Spring 里面提供的外，还可以自己定义注解，形如下面的 \u003ccode\u003e@Override\u003c/code\u003e 注解：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-meta\"\u003e@Target\u003c/span\u003e({ElementType.METHOD})\n\u003cspan class=\"hljs-meta\"\u003e@Retention\u003c/span\u003e(RetentionPolicy.SOURCE)\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-meta\"\u003e@interface\u003c/span\u003e Override {\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eES 中的修饰器\u003c/h3\u003e\n\u003cp\u003eES 中对类的修饰器，更像是给类加个包装，对这个类进行操作。这里可以看看 react-redux 里面的 connect 的实现：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003econnectAdvanced\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ewrapWithConnect\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eWrappedComponent\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n    \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eConnect\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eComponent\u003c/span\u003e \u003c/span\u003e{\n      \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n      render() {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state.error) {\n          \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state.error\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e createElement(WrappedComponent, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.addExtraProps(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state.props))\n        }  \n      }\n    }\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e hoistStatics(Connect, WrappedComponent)\n  }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 使用方式\u003c/span\u003e\n@connect(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003estate\u003c/span\u003e =\u0026gt;\u003c/span\u003e ({\n  \u003cspan class=\"hljs-attr\"\u003eglobal\u003c/span\u003e: state.global\n}))\n\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eWrappedComponent\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ePureComponent\u003c/span\u003e \u003c/span\u003e{}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如上所示的，通过 \u003ccode\u003e@connect\u003c/code\u003e，对 WrappedComponent 修饰，在 Connect 中实现一套更新 store 的逻辑，最后通过 \u003ccode\u003esetState\u003c/code\u003e 来触发，使得传入 WrappedComponent 的 props 发生更新，并注入 dispath 等等方法，最后达到传递状态的作用。\n而上面的这一切的功能只要用一个 \u003ccode\u003e@connect\u003c/code\u003e 就可以办到，和 Java 的注解不同，这里不需要反射来实现其功能。\u003c/p\u003e\n\u003cp\u003e对类/方法修饰还可以看看方正大神的(egg-blueprint)[https://github.com/Foveluy/egg-blueprint/blob/master/lib/index.js]，是一个 egg.js 为插件，采用修饰器的方式，实现了类似于 Spring 中 \u003ccode\u003e@RequestMapping\u003c/code\u003e 的方式。\u003c/p\u003e\n\u003cp\u003e对于一些 java 中常见的注解，如 \u003ccode\u003e@override @readonly\u003c/code\u003e 等等，在 ES 里面也有同样的实现！比如常用的 \u003ca href=\"https://github.com/jayphelps/core-decorators\" target=\"_blank\"\u003ecore-decorators\u003c/a\u003e 和 \u003ca href=\"https://github.com/steelsojka/lodash-decorators\" target=\"_blank\"\u003elodash-decorators\u003c/a\u003e 库。\u003c/p\u003e\n\u003cp\u003e比如 \u003ccode\u003e@readonly\u003c/code\u003e 的实现：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ereadonly\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etarget, name, descriptor\u003c/span\u003e)\u003c/span\u003e{\n  descriptor.writable = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e descriptor;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果说对类的修饰是外在包装一层，那么对方法的修饰，由于 descriptor 的存在，则更像是修饰器。方法的修饰里面传入的参数中，包含了 descriptor 描述对象。这个在 \u003ccode\u003eObject.defineProperty\u003c/code\u003e 中应该是再熟悉不过的了。通过 descriptor 可以实现非常多的功能。\u003c/p\u003e\n\u003cp\u003e对于类的属性同样也能采用修饰器的方式，类似于方法，但是其 descriptor 属性描述符里面只能用 initializer 来替代之前的 value。\u003c/p\u003e\n\u003cp\u003e另外 ESnext 里面也可以通过 \u003ccode\u003e#\u003c/code\u003e 来定义私有变量，就如同 java 的修饰符 private。\u003c/p\u003e\n\u003cp\u003e只是对于私有方法和私有变量而言，其 descriptor 属性描述符里面 \u003ccode\u003ewritable enumerable configurable\u003c/code\u003e 均为 false，同样的私有变量的描述对象只能用 initializer 来替代的 value。其他静态方法/变量等可以看看\u003ca href=\"https://github.com/tc39/proposal-decorators/blob/master/TAXONOMY.md\" target=\"_blank\"\u003e文档\u003c/a\u003e。\u003c/p\u003e\n\u003ch3\u003e总结\u003c/h3\u003e\n\u003cp\u003e由于对 java 的理解尚浅，本文也是做个简单的对比。ES 中的修饰器随着新特性的出现，也会被更多人所使用。\u003c/p\u003e\n"}},"page":"/Post/Post","query":{"code":200,"data":{"createTimeEN":"October 11, 2018","title":"Decorator","content":"\u003ch3\u003e前言\u003c/h3\u003e\n\u003cp\u003eESnext 里面提到的修饰器，在 redux 的推广下，几乎每个工程师都有或多或少的用过，最常见的就是 \u003ccode\u003e@connect\u003c/code\u003e 的形式，而在 Java 领域同样也存在 \u003ccode\u003e@\u003c/code\u003e 这种符号的存在，被称之为注解，而巧的是修饰器同样能实现注解的功能。在看 Java 的注解的时候必然会看到反射这个概念。在阅读下面之前请先看阮老师的文档\u003ca href=\"http://es6.ruanyifeng.com/#docs/decorator\" target=\"_blank\"\u003e修饰器\u003c/a\u003e，再看下文。\u003c/p\u003e\n\u003ch3\u003eBabel 开发环境须知\u003c/h3\u003e\n\u003cp\u003e修饰器 Decorator 是 ES7 里面提出的，在 babel 6 里面需要引入 \u003ccode\u003epreset-stage-2\u003c/code\u003e，并在 .babelrc 中配置 \u003ccode\u003e\u0026quot;presets\u0026quot;: [\u0026quot;env\u0026quot;, \u0026quot;stage-2\u0026quot;]\u003c/code\u003e。到了 babel 7.0.0-beta.54 之前，则是需要 npm 包 \u003ccode\u003e@babel/preset-stage-2\u003c/code\u003e，配置 .babelrc 为  [\u0026quot;@babel/preset-stage-2\u0026quot;, { \u0026quot;decoratorsLegacy\u0026quot;: true }]，默认是关闭的。而 babel 7.0.0-beta.54 之后的版本里面，已经 \u003cstrong\u003e弃用 Stage Preset\u003c/strong\u003e ，所以后面需要安装的版本是 \u003ccode\u003e@babel/plugin-proposal-decorators\u003c/code\u003e 配置为 \u003ccode\u003e[\u0026quot;@babel/plugin-proposal-decorators\u0026quot;, { \u0026quot;legacy\u0026quot;: true }]\u003c/code\u003e，这样可以达到以前的效果，具体看\u003ca href=\"https://github.com/babel/babel/tree/master/packages/babel-preset-stage-0#babelpreset-stage-0\" target=\"_blank\"\u003e官方介绍\u003c/a\u003e，以及\u003ca href=\"https://babeljs.io/docs/en/babel-plugin-proposal-decorators\" target=\"_blank\"\u003e@babel/plugin-proposal-decorators\u003c/a\u003e。目前 babel 7.1.0 已经发布了\u003ca href=\"https://babeljs.io/blog/2018/09/17/decorators\" target=\"_blank\"\u003eTC39 Standards Track Decorators in Babel\u003c/a\u003e。\u003c/p\u003e\n\u003ch3\u003ejava 中的注解和反射\u003c/h3\u003e\n\u003cp\u003e在 Java 里面注解是元数据，相当于是提供元素的配置信息，也就是额外的数据，比如最常见的 \u003ccode\u003e@Override @RequestMapping\u003c/code\u003e 这些。而在 ES 里面修饰器则更强大的多，是对类进行处理封装的改变，也可以不使用 \u003ccode\u003e@\u003c/code\u003e 符号进行描述，但是这样就失去其便捷性、直观性了。ESnext 中关于 Decorator 的\u003ca href=\"https://github.com/tc39/proposal-decorators\" target=\"_blank\"\u003e提案\u003c/a\u003e中提到修饰器不仅仅是可以用来修饰类，更包括了字段、getter、setter 和 方法。\u003c/p\u003e\n\u003cp\u003e先来看看 Java 中的注解是什么用法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eMyClass\u003c/span\u003e \u003c/span\u003e{\n  ...\n  \u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003egetName\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\n}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过 Test 注解，来添加额外的信息，本身是没有什么作用的，需要工具支持才可以用，而这个工具就是反射了。反射有什么作用呢？\u003cstrong\u003e反射可以在运行时获得程序或程序集中每一个类型的成员和成员的信息\u003c/strong\u003e 。如果结合上注解，那就是 \u003cstrong\u003e可以在运行时通过反射的方式取出方法的注解\u003c/strong\u003e ，从而实现额外的功能。反射里面主要用到下面四个类：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ejava.lang.Class 类对象；\u003c/li\u003e\n\u003cli\u003ejava.lang.reflect.Constructor 构造器对象 有 \u003ccode\u003epublic Constructor[] getConstructors()\u003c/code\u003e 方式；\u003c/li\u003e\n\u003cli\u003ejava.lang.reflect.Method 方法对象，有 \u003ccode\u003epublic Method[] getMethods()\u003c/code\u003e 等；\u003c/li\u003e\n\u003cli\u003ejava.lang.reflect.Field 属性对象，有 \u003ccode\u003epublic Field[] getFields()\u003c/code\u003e 等；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e可以看看下面示例了解一下反射：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (Method m : obj.getClass().getMethods()) {\n  Test t = m.getAnnotation(Test.class);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (t != \u003cspan class=\"hljs-keyword\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 对符合要求的 m 做处理\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e反射的存在使得注解变得灵动起来。注解除了是 JDK 或者 Spring 里面提供的外，还可以自己定义注解，形如下面的 \u003ccode\u003e@Override\u003c/code\u003e 注解：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-meta\"\u003e@Target\u003c/span\u003e({ElementType.METHOD})\n\u003cspan class=\"hljs-meta\"\u003e@Retention\u003c/span\u003e(RetentionPolicy.SOURCE)\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-meta\"\u003e@interface\u003c/span\u003e Override {\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eES 中的修饰器\u003c/h3\u003e\n\u003cp\u003eES 中对类的修饰器，更像是给类加个包装，对这个类进行操作。这里可以看看 react-redux 里面的 connect 的实现：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003econnectAdvanced\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ewrapWithConnect\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eWrappedComponent\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n    \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eConnect\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eComponent\u003c/span\u003e \u003c/span\u003e{\n      \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n      render() {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state.error) {\n          \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state.error\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e createElement(WrappedComponent, \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.addExtraProps(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.state.props))\n        }  \n      }\n    }\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e hoistStatics(Connect, WrappedComponent)\n  }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 使用方式\u003c/span\u003e\n@connect(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003estate\u003c/span\u003e =\u0026gt;\u003c/span\u003e ({\n  \u003cspan class=\"hljs-attr\"\u003eglobal\u003c/span\u003e: state.global\n}))\n\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eWrappedComponent\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ePureComponent\u003c/span\u003e \u003c/span\u003e{}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如上所示的，通过 \u003ccode\u003e@connect\u003c/code\u003e，对 WrappedComponent 修饰，在 Connect 中实现一套更新 store 的逻辑，最后通过 \u003ccode\u003esetState\u003c/code\u003e 来触发，使得传入 WrappedComponent 的 props 发生更新，并注入 dispath 等等方法，最后达到传递状态的作用。\n而上面的这一切的功能只要用一个 \u003ccode\u003e@connect\u003c/code\u003e 就可以办到，和 Java 的注解不同，这里不需要反射来实现其功能。\u003c/p\u003e\n\u003cp\u003e对类/方法修饰还可以看看方正大神的(egg-blueprint)[https://github.com/Foveluy/egg-blueprint/blob/master/lib/index.js]，是一个 egg.js 为插件，采用修饰器的方式，实现了类似于 Spring 中 \u003ccode\u003e@RequestMapping\u003c/code\u003e 的方式。\u003c/p\u003e\n\u003cp\u003e对于一些 java 中常见的注解，如 \u003ccode\u003e@override @readonly\u003c/code\u003e 等等，在 ES 里面也有同样的实现！比如常用的 \u003ca href=\"https://github.com/jayphelps/core-decorators\" target=\"_blank\"\u003ecore-decorators\u003c/a\u003e 和 \u003ca href=\"https://github.com/steelsojka/lodash-decorators\" target=\"_blank\"\u003elodash-decorators\u003c/a\u003e 库。\u003c/p\u003e\n\u003cp\u003e比如 \u003ccode\u003e@readonly\u003c/code\u003e 的实现：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ereadonly\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etarget, name, descriptor\u003c/span\u003e)\u003c/span\u003e{\n  descriptor.writable = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e descriptor;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果说对类的修饰是外在包装一层，那么对方法的修饰，由于 descriptor 的存在，则更像是修饰器。方法的修饰里面传入的参数中，包含了 descriptor 描述对象。这个在 \u003ccode\u003eObject.defineProperty\u003c/code\u003e 中应该是再熟悉不过的了。通过 descriptor 可以实现非常多的功能。\u003c/p\u003e\n\u003cp\u003e对于类的属性同样也能采用修饰器的方式，类似于方法，但是其 descriptor 属性描述符里面只能用 initializer 来替代之前的 value。\u003c/p\u003e\n\u003cp\u003e另外 ESnext 里面也可以通过 \u003ccode\u003e#\u003c/code\u003e 来定义私有变量，就如同 java 的修饰符 private。\u003c/p\u003e\n\u003cp\u003e只是对于私有方法和私有变量而言，其 descriptor 属性描述符里面 \u003ccode\u003ewritable enumerable configurable\u003c/code\u003e 均为 false，同样的私有变量的描述对象只能用 initializer 来替代的 value。其他静态方法/变量等可以看看\u003ca href=\"https://github.com/tc39/proposal-decorators/blob/master/TAXONOMY.md\" target=\"_blank\"\u003e文档\u003c/a\u003e。\u003c/p\u003e\n\u003ch3\u003e总结\u003c/h3\u003e\n\u003cp\u003e由于对 java 的理解尚浅，本文也是做个简单的对比。ES 中的修饰器随着新特性的出现，也会被更多人所使用。\u003c/p\u003e\n"}},"buildId":"ZS9D2ZWqQsj~9BxQGiyVr","assetPrefix":"/blog-sys","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/Post/Post" src="/blog-sys/_next/static/ZS9D2ZWqQsj~9BxQGiyVr/pages/Post/Post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog-sys/_next/static/ZS9D2ZWqQsj~9BxQGiyVr/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog-sys/_next/static/ZS9D2ZWqQsj~9BxQGiyVr/pages/_error.js"></script><script src="/blog-sys/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/blog-sys/_next/static/chunks/commons.28b647a963f3c76114f7.js" async=""></script><script src="/blog-sys/_next/static/chunks/styles.c9977e80c1b7548ec4f2.js" async=""></script><script src="/blog-sys/_next/static/runtime/main-83d67440b882eeb37951.js" async=""></script></body></html>